
ET024006DHU_EXAMPLE1.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000a9d8  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000ca00  8000ca00  0000ce00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00022ec4  8000cc00  8000cc00  0000d000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .lalign       00000004  8002fac4  8002fac4  0002fec4  2**0
                  ALLOC
  6 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  7 .data         00000530  00000008  8002fac8  00030008  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .bss          00000b38  00000538  00000538  00000000  2**2
                  ALLOC
  9 .heap         0000df90  00001070  00001070  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  00030538  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 00001648  00000000  00000000  00030568  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 0000344c  00000000  00000000  00031bb0  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   00030a63  00000000  00000000  00034ffc  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 00006f1c  00000000  00000000  00065a5f  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   00014b95  00000000  00000000  0006c97b  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00003a80  00000000  00000000  00081510  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    00007544  00000000  00000000  00084f90  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    0000f3ad  00000000  00000000  0008c4d4  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_macinfo 0167be21  00000000  00000000  0009b881  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 21 .debug_ranges 00001948  00000000  00000000  017176a8  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	fe cf b4 b4 	sub	pc,pc,-19276

80000004 <_trampoline>:
80000004:	e0 8f 10 00 	bral	80002004 <program_start>
	...

80002004 <program_start>:
  rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002004:	fe cf d4 b8 	sub	pc,pc,-11080

Disassembly of section .text:

80002008 <sd_mmc_spi_get_capacity>:
80002008:	d4 01       	pushm	lr
8000200a:	4c 18       	lddpc	r8,8000210c <sd_mmc_spi_get_capacity+0x104>
  uint8_t  read_bl_len;
  uint8_t  erase_grp_size;
  uint8_t  erase_grp_mult;

  // extract variables from CSD array
  read_bl_len = csd[5] & 0x0F;
8000200c:	11 db       	ld.ub	r11,r8[0x5]
  if (card_type == SD_CARD_2_SDHC) {
8000200e:	4c 18       	lddpc	r8,80002110 <sd_mmc_spi_get_capacity+0x108>
80002010:	11 8a       	ld.ub	r10,r8[0x0]
80002012:	30 38       	mov	r8,3
80002014:	f0 0a 18 00 	cp.b	r10,r8
80002018:	c2 71       	brne	80002066 <sd_mmc_spi_get_capacity+0x5e>
    c_size = ((csd[7] & 0x3F) << 16) | (csd[8] << 8) | csd[9];
8000201a:	4b d8       	lddpc	r8,8000210c <sd_mmc_spi_get_capacity+0x104>
8000201c:	f1 3a 00 08 	ld.ub	r10,r8[8]
80002020:	f1 39 00 09 	ld.ub	r9,r8[9]
80002024:	f3 ea 10 89 	or	r9,r9,r10<<0x8
80002028:	11 fa       	ld.ub	r10,r8[0x7]
8000202a:	f5 da c0 06 	bfextu	r10,r10,0x0,0x6
8000202e:	f3 ea 11 0a 	or	r10,r9,r10<<0x10
    ++c_size;
80002032:	2f fa       	sub	r10,-1
    capacity = (uint64_t)c_size << 19;
80002034:	f4 0b 16 0d 	lsr	r11,r10,0xd
80002038:	16 99       	mov	r9,r11
8000203a:	f4 08 15 13 	lsl	r8,r10,0x13
8000203e:	4b 6a       	lddpc	r10,80002114 <sd_mmc_spi_get_capacity+0x10c>
80002040:	f4 e9 00 00 	st.d	r10[0],r8
    capacity_mult = (c_size >> 13) & 0x01FF;
80002044:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80002048:	4b 48       	lddpc	r8,80002118 <sd_mmc_spi_get_capacity+0x110>
8000204a:	b0 0b       	st.h	r8[0x0],r11
    sd_mmc_spi_last_block_address = (capacity >> 9) + (capacity_mult << 23) - 1;
8000204c:	f4 ea 00 00 	ld.d	r10,r10[0]
80002050:	90 09       	ld.sh	r9,r8[0x0]
80002052:	f4 08 16 09 	lsr	r8,r10,0x9
80002056:	f1 eb 11 78 	or	r8,r8,r11<<0x17
8000205a:	20 18       	sub	r8,1
8000205c:	b7 79       	lsl	r9,0x17
8000205e:	12 08       	add	r8,r9
80002060:	4a f9       	lddpc	r9,8000211c <sd_mmc_spi_get_capacity+0x114>
80002062:	93 08       	st.w	r9[0x0],r8
80002064:	c4 28       	rjmp	800020e8 <sd_mmc_spi_get_capacity+0xe0>
  } else {
    c_size      = ((csd[6] & 0x03) << 10) + (csd[7] << 2) + ((csd[8] & 0xC0) >> 6);
    c_size_mult = ((csd[9] & 0x03) << 1) + ((csd[10] & 0x80) >> 7);
80002066:	4a a8       	lddpc	r8,8000210c <sd_mmc_spi_get_capacity+0x104>
80002068:	f1 3c 00 0a 	ld.ub	r12,r8[10]
    sd_mmc_spi_last_block_address = ((uint32_t)(c_size + 1) * (uint32_t)((1 << (c_size_mult + 2)))) - 1;
8000206c:	f1 39 00 08 	ld.ub	r9,r8[8]
80002070:	a7 89       	lsr	r9,0x6
80002072:	11 fe       	ld.ub	lr,r8[0x7]
80002074:	f2 0e 00 29 	add	r9,r9,lr<<0x2
80002078:	11 ee       	ld.ub	lr,r8[0x6]
8000207a:	fd de c0 02 	bfextu	lr,lr,0x0,0x2
8000207e:	ab 6e       	lsl	lr,0xa
80002080:	1c 09       	add	r9,lr
80002082:	2f f9       	sub	r9,-1
80002084:	f1 38 00 09 	ld.ub	r8,r8[9]
80002088:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000208c:	f8 0e 16 07 	lsr	lr,r12,0x7
80002090:	fc 08 00 18 	add	r8,lr,r8<<0x1
80002094:	2f e8       	sub	r8,-2
80002096:	f2 08 09 49 	lsl	r9,r9,r8
8000209a:	20 19       	sub	r9,1
8000209c:	4a 08       	lddpc	r8,8000211c <sd_mmc_spi_get_capacity+0x114>
8000209e:	91 09       	st.w	r8[0x0],r9
    capacity = (1 << read_bl_len) * (sd_mmc_spi_last_block_address + 1);
800020a0:	70 0e       	ld.w	lr,r8[0x0]
800020a2:	f7 db c0 04 	bfextu	r11,r11,0x0,0x4
800020a6:	2f fe       	sub	lr,-1
800020a8:	fc 0b 09 48 	lsl	r8,lr,r11
800020ac:	30 09       	mov	r9,0
800020ae:	49 ae       	lddpc	lr,80002114 <sd_mmc_spi_get_capacity+0x10c>
800020b0:	fc e9 00 00 	st.d	lr[0],r8
    capacity_mult = 0;
800020b4:	49 98       	lddpc	r8,80002118 <sd_mmc_spi_get_capacity+0x110>
800020b6:	b0 09       	st.h	r8[0x0],r9
    if (read_bl_len > 9) {  // 9 means 2^9 = 512b
800020b8:	30 98       	mov	r8,9
800020ba:	f0 0b 18 00 	cp.b	r11,r8
800020be:	e0 88 00 08 	brls	800020ce <sd_mmc_spi_get_capacity+0xc6>
      sd_mmc_spi_last_block_address <<= (read_bl_len - 9);
800020c2:	49 78       	lddpc	r8,8000211c <sd_mmc_spi_get_capacity+0x114>
800020c4:	70 09       	ld.w	r9,r8[0x0]
800020c6:	20 9b       	sub	r11,9
800020c8:	f2 0b 09 4b 	lsl	r11,r9,r11
800020cc:	91 0b       	st.w	r8[0x0],r11
    }
  }
  if (card_type == MMC_CARD)
800020ce:	58 0a       	cp.w	r10,0
800020d0:	c0 c1       	brne	800020e8 <sd_mmc_spi_get_capacity+0xe0>
  {
    erase_grp_size = ((csd[10] & 0x7C) >> 2);
800020d2:	f1 dc c0 45 	bfextu	r8,r12,0x2,0x5
    erase_grp_mult = ((csd[10] & 0x03) << 3) | ((csd[11] & 0xE0) >> 5);
800020d6:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
800020da:	48 d9       	lddpc	r9,8000210c <sd_mmc_spi_get_capacity+0x104>
800020dc:	f3 39 00 0b 	ld.ub	r9,r9[11]
800020e0:	a3 7c       	lsl	r12,0x3
800020e2:	f9 e9 12 59 	or	r9,r12,r9>>0x5
800020e6:	c0 c8       	rjmp	800020fe <sd_mmc_spi_get_capacity+0xf6>
  }
  else
  {
    erase_grp_size = ((csd[10] & 0x3F) << 1) + ((csd[11] & 0x80) >> 7);
800020e8:	48 9a       	lddpc	r10,8000210c <sd_mmc_spi_get_capacity+0x104>
800020ea:	f5 39 00 0a 	ld.ub	r9,r10[10]
800020ee:	f3 d9 c0 06 	bfextu	r9,r9,0x0,0x6
800020f2:	f5 38 00 0b 	ld.ub	r8,r10[11]
800020f6:	a7 98       	lsr	r8,0x7
800020f8:	f0 09 00 18 	add	r8,r8,r9<<0x1
800020fc:	30 09       	mov	r9,0
    erase_grp_mult = 0;
  }
  erase_group_size = (erase_grp_size + 1) * (erase_grp_mult + 1);
800020fe:	2f f9       	sub	r9,-1
80002100:	2f f8       	sub	r8,-1
80002102:	b1 39       	mul	r9,r8
80002104:	48 78       	lddpc	r8,80002120 <sd_mmc_spi_get_capacity+0x118>
80002106:	b0 09       	st.h	r8[0x0],r9
}
80002108:	d8 02       	popm	pc
8000210a:	00 00       	add	r0,r0
8000210c:	00 00       	add	r0,r0
8000210e:	0a 24       	rsub	r4,r5
80002110:	00 00       	add	r0,r0
80002112:	0a 22       	rsub	r2,r5
80002114:	00 00       	add	r0,r0
80002116:	0a 10       	sub	r0,r5
80002118:	00 00       	add	r0,r0
8000211a:	0a 18       	sub	r8,r5
8000211c:	00 00       	add	r0,r0
8000211e:	0a 1c       	sub	r12,r5
80002120:	00 00       	add	r0,r0
80002122:	0a 1a       	sub	r10,r5

80002124 <sd_mmc_spi_write_close>:
//! page programming.
//!
void sd_mmc_spi_write_close (void)
{

}
80002124:	5e fc       	retal	r12
80002126:	d7 03       	nop

80002128 <sd_mmc_spi_send_and_read>:
//! @param  data_to_send   byte to send over SPI
//!
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
80002128:	d4 01       	pushm	lr
8000212a:	20 1d       	sub	sp,4
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8000212c:	18 9b       	mov	r11,r12
8000212e:	fe 7c 24 00 	mov	r12,-56320
80002132:	f0 1f 00 09 	mcall	80002154 <sd_mmc_spi_send_and_read+0x2c>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80002136:	fa cb ff fe 	sub	r11,sp,-2
8000213a:	fe 7c 24 00 	mov	r12,-56320
8000213e:	f0 1f 00 07 	mcall	80002158 <sd_mmc_spi_send_and_read+0x30>
80002142:	58 1c       	cp.w	r12,1
80002144:	c0 41       	brne	8000214c <sd_mmc_spi_send_and_read+0x24>
80002146:	e0 6c 00 ff 	mov	r12,255
8000214a:	c0 28       	rjmp	8000214e <sd_mmc_spi_send_and_read+0x26>
     return 0xFF;
   return data_read;
8000214c:	1b bc       	ld.ub	r12,sp[0x3]
}
8000214e:	2f fd       	sub	sp,-4
80002150:	d8 02       	popm	pc
80002152:	00 00       	add	r0,r0
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	2d 2e       	sub	lr,-46
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	2d 4a       	sub	r10,-44

8000215c <sd_mmc_spi_wait_not_busy>:
//! @brief This function waits until the SD/MMC is not busy.
//!
//! @return bit
//!          true when card is not busy
bool sd_mmc_spi_wait_not_busy(void)
{
8000215c:	d4 21       	pushm	r4-r7,lr
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
8000215e:	30 1b       	mov	r11,1
80002160:	fe 7c 24 00 	mov	r12,-56320
80002164:	f0 1f 00 10 	mcall	800021a4 <sd_mmc_spi_wait_not_busy+0x48>
80002168:	30 07       	mov	r7,0
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
8000216a:	e0 65 00 ff 	mov	r5,255
8000216e:	48 f4       	lddpc	r4,800021a8 <sd_mmc_spi_wait_not_busy+0x4c>
80002170:	3f f6       	mov	r6,-1
80002172:	c0 b8       	rjmp	80002188 <sd_mmc_spi_wait_not_busy+0x2c>
  {
    retry++;
80002174:	2f f7       	sub	r7,-1
    if (retry == 200000)
80002176:	e2 57 0d 40 	cp.w	r7,200000
8000217a:	c0 71       	brne	80002188 <sd_mmc_spi_wait_not_busy+0x2c>
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
8000217c:	30 1b       	mov	r11,1
8000217e:	fe 7c 24 00 	mov	r12,-56320
80002182:	f0 1f 00 0b 	mcall	800021ac <sd_mmc_spi_wait_not_busy+0x50>
80002186:	d8 2a       	popm	r4-r7,pc,r12=0
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
80002188:	0a 9c       	mov	r12,r5
8000218a:	f0 1f 00 0a 	mcall	800021b0 <sd_mmc_spi_wait_not_busy+0x54>
8000218e:	a8 8c       	st.b	r4[0x0],r12
80002190:	ec 0c 18 00 	cp.b	r12,r6
80002194:	cf 01       	brne	80002174 <sd_mmc_spi_wait_not_busy+0x18>
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
      return false;
    }
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80002196:	30 1b       	mov	r11,1
80002198:	fe 7c 24 00 	mov	r12,-56320
8000219c:	f0 1f 00 04 	mcall	800021ac <sd_mmc_spi_wait_not_busy+0x50>
800021a0:	da 2a       	popm	r4-r7,pc,r12=1
800021a2:	00 00       	add	r0,r0
800021a4:	80 00       	ld.sh	r0,r0[0x0]
800021a6:	2b fc       	sub	r12,-65
800021a8:	00 00       	add	r0,r0
800021aa:	0a 34       	cp.w	r4,r5
800021ac:	80 00       	ld.sh	r0,r0[0x0]
800021ae:	2c 48       	sub	r8,-60
800021b0:	80 00       	ld.sh	r0,r0[0x0]
800021b2:	21 28       	sub	r8,18

800021b4 <sd_mmc_spi_write_open>:
//! @param  pos   Sector address
//!
//! @return bit
//!   The open succeeded      -> true
bool sd_mmc_spi_write_open (uint32_t pos)
{
800021b4:	d4 01       	pushm	lr
  // Set the global memory ptr at a Byte address.
  gl_ptr_mem = (uint64_t)pos << 9; // gl_ptr_mem = pos * 512
800021b6:	48 58       	lddpc	r8,800021c8 <sd_mmc_spi_write_open+0x14>
800021b8:	f8 09 16 17 	lsr	r9,r12,0x17
800021bc:	91 09       	st.w	r8[0x0],r9
800021be:	a9 7c       	lsl	r12,0x9
800021c0:	91 1c       	st.w	r8[0x4],r12

  // wait for MMC not busy
  return sd_mmc_spi_wait_not_busy();
800021c2:	f0 1f 00 03 	mcall	800021cc <sd_mmc_spi_write_open+0x18>
}
800021c6:	d8 02       	popm	pc
800021c8:	00 00       	add	r0,r0
800021ca:	05 38       	ld.ub	r8,r2++
800021cc:	80 00       	ld.sh	r0,r0[0x0]
800021ce:	21 5c       	sub	r12,21

800021d0 <sd_mmc_spi_read_close>:

//!
//! @brief This function unselects the current SD_MMC memory.
//!
bool sd_mmc_spi_read_close (void)
{
800021d0:	d4 01       	pushm	lr
  if (false == sd_mmc_spi_wait_not_busy())
800021d2:	f0 1f 00 02 	mcall	800021d8 <sd_mmc_spi_read_close+0x8>
    return false;
  return true;
}
800021d6:	d8 02       	popm	pc
800021d8:	80 00       	ld.sh	r0,r0[0x0]
800021da:	21 5c       	sub	r12,21

800021dc <sd_mmc_spi_read_open>:
//! @param  pos   Sector address
//!
//! @return bit
//!   The open succeeded      -> true
bool sd_mmc_spi_read_open (uint32_t pos)
{
800021dc:	d4 01       	pushm	lr
  // Set the global memory ptr at a Byte address.
  gl_ptr_mem = (uint64_t)pos << 9;        // gl_ptr_mem = pos * 512
800021de:	48 58       	lddpc	r8,800021f0 <sd_mmc_spi_read_open+0x14>
800021e0:	f8 09 16 17 	lsr	r9,r12,0x17
800021e4:	91 09       	st.w	r8[0x0],r9
800021e6:	a9 7c       	lsl	r12,0x9
800021e8:	91 1c       	st.w	r8[0x4],r12

  // wait for MMC not busy
  return sd_mmc_spi_wait_not_busy();
800021ea:	f0 1f 00 03 	mcall	800021f4 <sd_mmc_spi_read_open+0x18>
}
800021ee:	d8 02       	popm	pc
800021f0:	00 00       	add	r0,r0
800021f2:	05 38       	ld.ub	r8,r2++
800021f4:	80 00       	ld.sh	r0,r0[0x0]
800021f6:	21 5c       	sub	r12,21

800021f8 <sd_mmc_spi_command>:
//! @param  arg       argument of the command
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF time out error)
uint8_t sd_mmc_spi_command(uint8_t command, uint32_t arg)
{
800021f8:	eb cd 40 f8 	pushm	r3-r7,lr
800021fc:	18 96       	mov	r6,r12
800021fe:	16 97       	mov	r7,r11
  uint8_t retry;

  spi_write(SD_MMC_SPI, 0xFF);            // write dummy byte
80002200:	e0 6b 00 ff 	mov	r11,255
80002204:	fe 7c 24 00 	mov	r12,-56320
80002208:	f0 1f 00 2b 	mcall	800022b4 <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, command | 0x40);  // send command
8000220c:	0c 9b       	mov	r11,r6
8000220e:	a7 ab       	sbr	r11,0x6
80002210:	5c 5b       	castu.b	r11
80002212:	fe 7c 24 00 	mov	r12,-56320
80002216:	f0 1f 00 28 	mcall	800022b4 <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, arg>>24);         // send parameter
8000221a:	ee 0b 16 18 	lsr	r11,r7,0x18
8000221e:	fe 7c 24 00 	mov	r12,-56320
80002222:	f0 1f 00 25 	mcall	800022b4 <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, arg>>16);
80002226:	ee 0b 16 10 	lsr	r11,r7,0x10
8000222a:	fe 7c 24 00 	mov	r12,-56320
8000222e:	f0 1f 00 22 	mcall	800022b4 <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, arg>>8 );
80002232:	f7 d7 c1 10 	bfextu	r11,r7,0x8,0x10
80002236:	fe 7c 24 00 	mov	r12,-56320
8000223a:	f0 1f 00 1f 	mcall	800022b4 <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, arg    );
8000223e:	0e 9b       	mov	r11,r7
80002240:	5c 7b       	castu.h	r11
80002242:	fe 7c 24 00 	mov	r12,-56320
80002246:	f0 1f 00 1c 	mcall	800022b4 <sd_mmc_spi_command+0xbc>
  switch(command)
8000224a:	30 08       	mov	r8,0
8000224c:	f0 06 18 00 	cp.b	r6,r8
80002250:	c0 60       	breq	8000225c <sd_mmc_spi_command+0x64>
80002252:	30 88       	mov	r8,8
80002254:	f0 06 18 00 	cp.b	r6,r8
80002258:	c1 01       	brne	80002278 <sd_mmc_spi_command+0x80>
8000225a:	c0 88       	rjmp	8000226a <sd_mmc_spi_command+0x72>
  {
      case MMC_GO_IDLE_STATE:
         spi_write(SD_MMC_SPI, 0x95);
8000225c:	e0 6b 00 95 	mov	r11,149
80002260:	fe 7c 24 00 	mov	r12,-56320
80002264:	f0 1f 00 14 	mcall	800022b4 <sd_mmc_spi_command+0xbc>
         break;
80002268:	c0 e8       	rjmp	80002284 <sd_mmc_spi_command+0x8c>
      case MMC_SEND_IF_COND:
         spi_write(SD_MMC_SPI, 0x87);
8000226a:	e0 6b 00 87 	mov	r11,135
8000226e:	fe 7c 24 00 	mov	r12,-56320
80002272:	f0 1f 00 11 	mcall	800022b4 <sd_mmc_spi_command+0xbc>
         break;
80002276:	c0 78       	rjmp	80002284 <sd_mmc_spi_command+0x8c>
      default:
         spi_write(SD_MMC_SPI, 0xff);
80002278:	e0 6b 00 ff 	mov	r11,255
8000227c:	fe 7c 24 00 	mov	r12,-56320
80002280:	f0 1f 00 0d 	mcall	800022b4 <sd_mmc_spi_command+0xbc>

  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
80002284:	3f f9       	mov	r9,-1
80002286:	48 d8       	lddpc	r8,800022b8 <sd_mmc_spi_command+0xc0>
80002288:	b0 89       	st.b	r8[0x0],r9
8000228a:	30 07       	mov	r7,0
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
8000228c:	e0 64 00 ff 	mov	r4,255
80002290:	10 93       	mov	r3,r8
80002292:	12 96       	mov	r6,r9
  {
    retry++;
    if(retry > 10) break;
80002294:	30 b5       	mov	r5,11
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80002296:	c0 68       	rjmp	800022a2 <sd_mmc_spi_command+0xaa>
  {
    retry++;
80002298:	2f f7       	sub	r7,-1
8000229a:	5c 57       	castu.b	r7
    if(retry > 10) break;
8000229c:	ea 07 18 00 	cp.b	r7,r5
800022a0:	c0 80       	breq	800022b0 <sd_mmc_spi_command+0xb8>
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
800022a2:	08 9c       	mov	r12,r4
800022a4:	f0 1f 00 06 	mcall	800022bc <sd_mmc_spi_command+0xc4>
800022a8:	a6 8c       	st.b	r3[0x0],r12
800022aa:	ec 0c 18 00 	cp.b	r12,r6
800022ae:	cf 50       	breq	80002298 <sd_mmc_spi_command+0xa0>
  {
    retry++;
    if(retry > 10) break;
  }
  return r1;
}
800022b0:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800022b4:	80 00       	ld.sh	r0,r0[0x0]
800022b6:	2d 2e       	sub	lr,-46
800022b8:	00 00       	add	r0,r0
800022ba:	0a 34       	cp.w	r4,r5
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	21 28       	sub	r8,18

800022c0 <sd_mmc_spi_send_command>:
//! @param  arg       argument of the command
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
800022c0:	eb cd 40 c0 	pushm	r6-r7,lr
800022c4:	18 97       	mov	r7,r12
800022c6:	16 96       	mov	r6,r11
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
800022c8:	30 1b       	mov	r11,1
800022ca:	fe 7c 24 00 	mov	r12,-56320
800022ce:	f0 1f 00 09 	mcall	800022f0 <sd_mmc_spi_send_command+0x30>
  r1 = sd_mmc_spi_command(command, arg);
800022d2:	0c 9b       	mov	r11,r6
800022d4:	0e 9c       	mov	r12,r7
800022d6:	f0 1f 00 08 	mcall	800022f4 <sd_mmc_spi_send_command+0x34>
800022da:	48 87       	lddpc	r7,800022f8 <sd_mmc_spi_send_command+0x38>
800022dc:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800022de:	30 1b       	mov	r11,1
800022e0:	fe 7c 24 00 	mov	r12,-56320
800022e4:	f0 1f 00 06 	mcall	800022fc <sd_mmc_spi_send_command+0x3c>
  return r1;
}
800022e8:	0f 8c       	ld.ub	r12,r7[0x0]
800022ea:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800022ee:	00 00       	add	r0,r0
800022f0:	80 00       	ld.sh	r0,r0[0x0]
800022f2:	2b fc       	sub	r12,-65
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	21 f8       	sub	r8,31
800022f8:	00 00       	add	r0,r0
800022fa:	0a 34       	cp.w	r4,r5
800022fc:	80 00       	ld.sh	r0,r0[0x0]
800022fe:	2c 48       	sub	r8,-60

80002300 <sd_mmc_spi_check_presence>:
//!
//! @return bit
//!   The memory is present (true)
//!   The memory does not respond (disconnected) (false)
bool sd_mmc_spi_check_presence(void)
{
80002300:	eb cd 40 fe 	pushm	r1-r7,lr
  uint16_t retry;

  retry = 0;
  if (sd_mmc_spi_init_done == false)
80002304:	49 a8       	lddpc	r8,8000236c <sd_mmc_spi_check_presence+0x6c>
80002306:	11 89       	ld.ub	r9,r8[0x0]
80002308:	30 08       	mov	r8,0
8000230a:	f0 09 18 00 	cp.b	r9,r8
8000230e:	c1 f1       	brne	8000234c <sd_mmc_spi_check_presence+0x4c>
80002310:	30 07       	mov	r7,0
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
80002312:	0e 94       	mov	r4,r7
80002314:	49 73       	lddpc	r3,80002370 <sd_mmc_spi_check_presence+0x70>
80002316:	30 16       	mov	r6,1
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80002318:	e0 62 00 ff 	mov	r2,255
8000231c:	fe 71 24 00 	mov	r1,-56320
      retry++;
      if (retry > 10)
80002320:	30 b5       	mov	r5,11
80002322:	c0 c8       	rjmp	8000233a <sd_mmc_spi_check_presence+0x3a>
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80002324:	04 9b       	mov	r11,r2
80002326:	02 9c       	mov	r12,r1
80002328:	f0 1f 00 13 	mcall	80002374 <sd_mmc_spi_check_presence+0x74>
      retry++;
8000232c:	2f f7       	sub	r7,-1
8000232e:	5c 87       	casts.h	r7
      if (retry > 10)
80002330:	ea 07 19 00 	cp.h	r7,r5
80002334:	c0 31       	brne	8000233a <sd_mmc_spi_check_presence+0x3a>
80002336:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
8000233a:	08 9b       	mov	r11,r4
8000233c:	08 9c       	mov	r12,r4
8000233e:	f0 1f 00 0f 	mcall	80002378 <sd_mmc_spi_check_presence+0x78>
80002342:	a6 8c       	st.b	r3[0x0],r12
80002344:	ec 0c 18 00 	cp.b	r12,r6
80002348:	ce e1       	brne	80002324 <sd_mmc_spi_check_presence+0x24>
8000234a:	c0 e8       	rjmp	80002366 <sd_mmc_spi_check_presence+0x66>
    return true;
  }
  else
  {
    // If memory already initialized, send a CRC command (CMD59) (supported only if card is initialized)
    if ((r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0)) == 0x00)
8000234c:	30 0b       	mov	r11,0
8000234e:	33 bc       	mov	r12,59
80002350:	f0 1f 00 0a 	mcall	80002378 <sd_mmc_spi_check_presence+0x78>
80002354:	48 78       	lddpc	r8,80002370 <sd_mmc_spi_check_presence+0x70>
80002356:	b0 8c       	st.b	r8[0x0],r12
80002358:	58 0c       	cp.w	r12,0
8000235a:	c0 60       	breq	80002366 <sd_mmc_spi_check_presence+0x66>
      return true;
    sd_mmc_spi_init_done = false;
8000235c:	30 09       	mov	r9,0
8000235e:	48 48       	lddpc	r8,8000236c <sd_mmc_spi_check_presence+0x6c>
80002360:	b0 89       	st.b	r8[0x0],r9
80002362:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
    return false;
80002366:	e3 cf 90 fe 	ldm	sp++,r1-r7,pc,r12=1
8000236a:	00 00       	add	r0,r0
8000236c:	00 00       	add	r0,r0
8000236e:	05 54       	ld.sh	r4,--r2
80002370:	00 00       	add	r0,r0
80002372:	0a 34       	cp.w	r4,r5
80002374:	80 00       	ld.sh	r0,r0[0x0]
80002376:	2d 2e       	sub	lr,-46
80002378:	80 00       	ld.sh	r0,r0[0x0]
8000237a:	22 c0       	sub	r0,44

8000237c <sd_mmc_spi_write_sector_from_ram>:
//! @return bit
//!   The write succeeded   -> true
//!   The write failed      -> false
//!
bool sd_mmc_spi_write_sector_from_ram(const void *ram)
{
8000237c:	eb cd 40 e0 	pushm	r5-r7,lr
80002380:	18 97       	mov	r7,r12
  const uint8_t *_ram = ram;
  uint16_t i;

  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
80002382:	f0 1f 00 4e 	mcall	800024b8 <sd_mmc_spi_write_sector_from_ram+0x13c>
80002386:	e0 80 00 96 	breq	800024b2 <sd_mmc_spi_write_sector_from_ram+0x136>
    return false;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000238a:	30 1b       	mov	r11,1
8000238c:	fe 7c 24 00 	mov	r12,-56320
80002390:	f0 1f 00 4b 	mcall	800024bc <sd_mmc_spi_write_sector_from_ram+0x140>

  // issue command
  if(card_type == SD_CARD_2_SDHC) {
80002394:	4c b8       	lddpc	r8,800024c0 <sd_mmc_spi_write_sector_from_ram+0x144>
80002396:	11 89       	ld.ub	r9,r8[0x0]
80002398:	30 38       	mov	r8,3
8000239a:	f0 09 18 00 	cp.b	r9,r8
8000239e:	c0 d1       	brne	800023b8 <sd_mmc_spi_write_sector_from_ram+0x3c>
    r1 = sd_mmc_spi_command(MMC_WRITE_BLOCK, gl_ptr_mem>>9);
800023a0:	4c 98       	lddpc	r8,800024c4 <sd_mmc_spi_write_sector_from_ram+0x148>
800023a2:	70 0b       	ld.w	r11,r8[0x0]
800023a4:	70 18       	ld.w	r8,r8[0x4]
800023a6:	a9 98       	lsr	r8,0x9
800023a8:	f1 eb 11 7b 	or	r11,r8,r11<<0x17
800023ac:	31 8c       	mov	r12,24
800023ae:	f0 1f 00 47 	mcall	800024c8 <sd_mmc_spi_write_sector_from_ram+0x14c>
800023b2:	4c 78       	lddpc	r8,800024cc <sd_mmc_spi_write_sector_from_ram+0x150>
800023b4:	b0 8c       	st.b	r8[0x0],r12
800023b6:	c0 88       	rjmp	800023c6 <sd_mmc_spi_write_sector_from_ram+0x4a>
  } else {
    r1 = sd_mmc_spi_command(MMC_WRITE_BLOCK, gl_ptr_mem);
800023b8:	4c 38       	lddpc	r8,800024c4 <sd_mmc_spi_write_sector_from_ram+0x148>
800023ba:	70 1b       	ld.w	r11,r8[0x4]
800023bc:	31 8c       	mov	r12,24
800023be:	f0 1f 00 43 	mcall	800024c8 <sd_mmc_spi_write_sector_from_ram+0x14c>
800023c2:	4c 38       	lddpc	r8,800024cc <sd_mmc_spi_write_sector_from_ram+0x150>
800023c4:	b0 8c       	st.b	r8[0x0],r12
  }

  // check for valid response
  if(r1 != 0x00)
800023c6:	4c 28       	lddpc	r8,800024cc <sd_mmc_spi_write_sector_from_ram+0x150>
800023c8:	11 89       	ld.ub	r9,r8[0x0]
800023ca:	30 08       	mov	r8,0
800023cc:	f0 09 18 00 	cp.b	r9,r8
800023d0:	c0 80       	breq	800023e0 <sd_mmc_spi_write_sector_from_ram+0x64>
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
800023d2:	30 1b       	mov	r11,1
800023d4:	fe 7c 24 00 	mov	r12,-56320
800023d8:	f0 1f 00 3e 	mcall	800024d0 <sd_mmc_spi_write_sector_from_ram+0x154>
800023dc:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
    return false;
  }
  // send dummy
  spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction
800023e0:	e0 6b 00 ff 	mov	r11,255
800023e4:	fe 7c 24 00 	mov	r12,-56320
800023e8:	f0 1f 00 3b 	mcall	800024d4 <sd_mmc_spi_write_sector_from_ram+0x158>

  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
800023ec:	e0 6b 00 fe 	mov	r11,254
800023f0:	fe 7c 24 00 	mov	r12,-56320
800023f4:	f0 1f 00 38 	mcall	800024d4 <sd_mmc_spi_write_sector_from_ram+0x158>
//!
//! @return bit
//!   The write succeeded   -> true
//!   The write failed      -> false
//!
bool sd_mmc_spi_write_sector_from_ram(const void *ram)
800023f8:	ee c6 fe 00 	sub	r6,r7,-512
  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
  // write data
  for(i=0;i<MMC_SECTOR_SIZE;i++)
  {
    spi_write(SD_MMC_SPI,*_ram++);
800023fc:	fe 75 24 00 	mov	r5,-56320
80002400:	0f 3b       	ld.ub	r11,r7++
80002402:	0a 9c       	mov	r12,r5
80002404:	f0 1f 00 34 	mcall	800024d4 <sd_mmc_spi_write_sector_from_ram+0x158>
  spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction

  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
  // write data
  for(i=0;i<MMC_SECTOR_SIZE;i++)
80002408:	0c 37       	cp.w	r7,r6
8000240a:	cf b1       	brne	80002400 <sd_mmc_spi_write_sector_from_ram+0x84>
  {
    spi_write(SD_MMC_SPI,*_ram++);
  }

  spi_write(SD_MMC_SPI,0xFF);    // send CRC (field required but value ignored)
8000240c:	e0 6b 00 ff 	mov	r11,255
80002410:	fe 7c 24 00 	mov	r12,-56320
80002414:	f0 1f 00 30 	mcall	800024d4 <sd_mmc_spi_write_sector_from_ram+0x158>
  spi_write(SD_MMC_SPI,0xFF);
80002418:	e0 6b 00 ff 	mov	r11,255
8000241c:	fe 7c 24 00 	mov	r12,-56320
80002420:	f0 1f 00 2d 	mcall	800024d4 <sd_mmc_spi_write_sector_from_ram+0x158>

  // read data response token
  r1 = sd_mmc_spi_send_and_read(0xFF);
80002424:	e0 6c 00 ff 	mov	r12,255
80002428:	f0 1f 00 2c 	mcall	800024d8 <sd_mmc_spi_write_sector_from_ram+0x15c>
8000242c:	4a 88       	lddpc	r8,800024cc <sd_mmc_spi_write_sector_from_ram+0x150>
8000242e:	b0 8c       	st.b	r8[0x0],r12
  if( (r1&MMC_DR_MASK) != MMC_DR_ACCEPT)
80002430:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80002434:	58 5c       	cp.w	r12,5
80002436:	c1 40       	breq	8000245e <sd_mmc_spi_write_sector_from_ram+0xe2>
  {
    spi_write(SD_MMC_SPI,0xFF);    // send dummy bytes
80002438:	e0 6b 00 ff 	mov	r11,255
8000243c:	fe 7c 24 00 	mov	r12,-56320
80002440:	f0 1f 00 25 	mcall	800024d4 <sd_mmc_spi_write_sector_from_ram+0x158>
    spi_write(SD_MMC_SPI,0xFF);
80002444:	e0 6b 00 ff 	mov	r11,255
80002448:	fe 7c 24 00 	mov	r12,-56320
8000244c:	f0 1f 00 22 	mcall	800024d4 <sd_mmc_spi_write_sector_from_ram+0x158>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80002450:	30 1b       	mov	r11,1
80002452:	fe 7c 24 00 	mov	r12,-56320
80002456:	f0 1f 00 1f 	mcall	800024d0 <sd_mmc_spi_write_sector_from_ram+0x154>
8000245a:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
    return false;         // return ERROR byte
  }

  spi_write(SD_MMC_SPI,0xFF);    // send dummy bytes
8000245e:	e0 6b 00 ff 	mov	r11,255
80002462:	fe 7c 24 00 	mov	r12,-56320
80002466:	f0 1f 00 1c 	mcall	800024d4 <sd_mmc_spi_write_sector_from_ram+0x158>
  spi_write(SD_MMC_SPI,0xFF);
8000246a:	e0 6b 00 ff 	mov	r11,255
8000246e:	fe 7c 24 00 	mov	r12,-56320
80002472:	f0 1f 00 19 	mcall	800024d4 <sd_mmc_spi_write_sector_from_ram+0x158>

  // release chip select
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002476:	30 1b       	mov	r11,1
80002478:	fe 7c 24 00 	mov	r12,-56320
8000247c:	f0 1f 00 15 	mcall	800024d0 <sd_mmc_spi_write_sector_from_ram+0x154>
  gl_ptr_mem += 512;        // Update the memory pointer.
80002480:	49 18       	lddpc	r8,800024c4 <sd_mmc_spi_write_sector_from_ram+0x148>
80002482:	f0 e6 00 00 	ld.d	r6,r8[0]
80002486:	e0 6a 02 00 	mov	r10,512
8000248a:	30 0b       	mov	r11,0
8000248c:	ec 0a 00 0a 	add	r10,r6,r10
80002490:	ee 0b 00 4b 	adc	r11,r7,r11
80002494:	f0 eb 00 00 	st.d	r8[0],r10
80002498:	30 07       	mov	r7,0
  // wait card not busy after last programming operation
  i=0;
  while (false == sd_mmc_spi_wait_not_busy())
  {
    i++;
    if (i == 10)
8000249a:	30 a6       	mov	r6,10
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
  gl_ptr_mem += 512;        // Update the memory pointer.

  // wait card not busy after last programming operation
  i=0;
  while (false == sd_mmc_spi_wait_not_busy())
8000249c:	c0 68       	rjmp	800024a8 <sd_mmc_spi_write_sector_from_ram+0x12c>
  {
    i++;
8000249e:	2f f7       	sub	r7,-1
800024a0:	5c 87       	casts.h	r7
    if (i == 10)
800024a2:	ec 07 19 00 	cp.h	r7,r6
800024a6:	c0 60       	breq	800024b2 <sd_mmc_spi_write_sector_from_ram+0x136>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
  gl_ptr_mem += 512;        // Update the memory pointer.

  // wait card not busy after last programming operation
  i=0;
  while (false == sd_mmc_spi_wait_not_busy())
800024a8:	f0 1f 00 04 	mcall	800024b8 <sd_mmc_spi_write_sector_from_ram+0x13c>
800024ac:	cf 90       	breq	8000249e <sd_mmc_spi_write_sector_from_ram+0x122>
800024ae:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
800024b2:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
800024b6:	00 00       	add	r0,r0
800024b8:	80 00       	ld.sh	r0,r0[0x0]
800024ba:	21 5c       	sub	r12,21
800024bc:	80 00       	ld.sh	r0,r0[0x0]
800024be:	2b fc       	sub	r12,-65
800024c0:	00 00       	add	r0,r0
800024c2:	0a 22       	rsub	r2,r5
800024c4:	00 00       	add	r0,r0
800024c6:	05 38       	ld.ub	r8,r2++
800024c8:	80 00       	ld.sh	r0,r0[0x0]
800024ca:	21 f8       	sub	r8,31
800024cc:	00 00       	add	r0,r0
800024ce:	0a 34       	cp.w	r4,r5
800024d0:	80 00       	ld.sh	r0,r0[0x0]
800024d2:	2c 48       	sub	r8,-60
800024d4:	80 00       	ld.sh	r0,r0[0x0]
800024d6:	2d 2e       	sub	lr,-46
800024d8:	80 00       	ld.sh	r0,r0[0x0]
800024da:	21 28       	sub	r8,18

800024dc <sd_mmc_spi_check_hc>:
//!           SD_CARD      Detected card is SD
//!           ERROR


int sd_mmc_spi_check_hc(void)
{
800024dc:	eb cd 40 c0 	pushm	r6-r7,lr
  unsigned char hc_bit;
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
800024e0:	f0 1f 00 1c 	mcall	80002550 <sd_mmc_spi_check_hc+0x74>
800024e4:	c0 31       	brne	800024ea <sd_mmc_spi_check_hc+0xe>
800024e6:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
    return SD_FAILURE;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
800024ea:	30 1b       	mov	r11,1
800024ec:	fe 7c 24 00 	mov	r12,-56320
800024f0:	f0 1f 00 19 	mcall	80002554 <sd_mmc_spi_check_hc+0x78>
  r1 = sd_mmc_spi_command(SD_READ_OCR, 0);
800024f4:	30 0b       	mov	r11,0
800024f6:	33 ac       	mov	r12,58
800024f8:	f0 1f 00 18 	mcall	80002558 <sd_mmc_spi_check_hc+0x7c>
800024fc:	49 88       	lddpc	r8,8000255c <sd_mmc_spi_check_hc+0x80>
800024fe:	b0 8c       	st.b	r8[0x0],r12
  // check for valid response
  if(r1 != 0) {
80002500:	58 0c       	cp.w	r12,0
80002502:	c0 80       	breq	80002512 <sd_mmc_spi_check_hc+0x36>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002504:	30 1b       	mov	r11,1
80002506:	fe 7c 24 00 	mov	r12,-56320
8000250a:	f0 1f 00 16 	mcall	80002560 <sd_mmc_spi_check_hc+0x84>
8000250e:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
    return SD_FAILURE;
  }
  hc_bit = sd_mmc_spi_send_and_read(0xFF);
80002512:	e0 6c 00 ff 	mov	r12,255
80002516:	f0 1f 00 14 	mcall	80002564 <sd_mmc_spi_check_hc+0x88>
8000251a:	18 96       	mov	r6,r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
8000251c:	e0 6c 00 ff 	mov	r12,255
80002520:	f0 1f 00 11 	mcall	80002564 <sd_mmc_spi_check_hc+0x88>
80002524:	48 e7       	lddpc	r7,8000255c <sd_mmc_spi_check_hc+0x80>
80002526:	ae 8c       	st.b	r7[0x0],r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
80002528:	e0 6c 00 ff 	mov	r12,255
8000252c:	f0 1f 00 0e 	mcall	80002564 <sd_mmc_spi_check_hc+0x88>
80002530:	ae 8c       	st.b	r7[0x0],r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
80002532:	e0 6c 00 ff 	mov	r12,255
80002536:	f0 1f 00 0c 	mcall	80002564 <sd_mmc_spi_check_hc+0x88>
8000253a:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000253c:	30 1b       	mov	r11,1
8000253e:	fe 7c 24 00 	mov	r12,-56320
80002542:	f0 1f 00 08 	mcall	80002560 <sd_mmc_spi_check_hc+0x84>
80002546:	f9 d6 c0 c1 	bfextu	r12,r6,0x6,0x1
  if(hc_bit & 0x40) {
      return SDHC_CARD;
  }
  return 0;
}
8000254a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000254e:	00 00       	add	r0,r0
80002550:	80 00       	ld.sh	r0,r0[0x0]
80002552:	21 5c       	sub	r12,21
80002554:	80 00       	ld.sh	r0,r0[0x0]
80002556:	2b fc       	sub	r12,-65
80002558:	80 00       	ld.sh	r0,r0[0x0]
8000255a:	21 f8       	sub	r8,31
8000255c:	00 00       	add	r0,r0
8000255e:	0a 34       	cp.w	r4,r5
80002560:	80 00       	ld.sh	r0,r0[0x0]
80002562:	2c 48       	sub	r8,-60
80002564:	80 00       	ld.sh	r0,r0[0x0]
80002566:	21 28       	sub	r8,18

80002568 <sd_mmc_spi_get_if>:
//!                true
//!                SD_MMC


int sd_mmc_spi_get_if(void)
{
80002568:	eb cd 40 80 	pushm	r7,lr
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
8000256c:	f0 1f 00 27 	mcall	80002608 <sd_mmc_spi_get_if+0xa0>
80002570:	c0 31       	brne	80002576 <sd_mmc_spi_get_if+0xe>
80002572:	e3 cf c0 80 	ldm	sp++,r7,pc,r12=-1
    return SD_FAILURE;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80002576:	30 1b       	mov	r11,1
80002578:	fe 7c 24 00 	mov	r12,-56320
8000257c:	f0 1f 00 24 	mcall	8000260c <sd_mmc_spi_get_if+0xa4>
  r1 = sd_mmc_spi_command(MMC_SEND_IF_COND, 0x000001AA);
80002580:	e0 6b 01 aa 	mov	r11,426
80002584:	30 8c       	mov	r12,8
80002586:	f0 1f 00 23 	mcall	80002610 <sd_mmc_spi_get_if+0xa8>
8000258a:	4a 38       	lddpc	r8,80002614 <sd_mmc_spi_get_if+0xac>
8000258c:	b0 8c       	st.b	r8[0x0],r12
  // check for valid response
  if((r1 & MMC_R1_ILLEGAL_COM) != 0) {
8000258e:	e2 1c 00 04 	andl	r12,0x4,COH
80002592:	c0 80       	breq	800025a2 <sd_mmc_spi_get_if+0x3a>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002594:	30 1b       	mov	r11,1
80002596:	fe 7c 24 00 	mov	r12,-56320
8000259a:	f0 1f 00 20 	mcall	80002618 <sd_mmc_spi_get_if+0xb0>
8000259e:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
    return SD_MMC;
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
800025a2:	e0 6c 00 ff 	mov	r12,255
800025a6:	f0 1f 00 1e 	mcall	8000261c <sd_mmc_spi_get_if+0xb4>
800025aa:	49 b7       	lddpc	r7,80002614 <sd_mmc_spi_get_if+0xac>
800025ac:	ae 8c       	st.b	r7[0x0],r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
800025ae:	e0 6c 00 ff 	mov	r12,255
800025b2:	f0 1f 00 1b 	mcall	8000261c <sd_mmc_spi_get_if+0xb4>
800025b6:	ae 8c       	st.b	r7[0x0],r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
800025b8:	e0 6c 00 ff 	mov	r12,255
800025bc:	f0 1f 00 18 	mcall	8000261c <sd_mmc_spi_get_if+0xb4>
800025c0:	ae 8c       	st.b	r7[0x0],r12
  if((r1 & 0x01) == 0) {
800025c2:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
800025c6:	c0 81       	brne	800025d6 <sd_mmc_spi_get_if+0x6e>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800025c8:	30 1b       	mov	r11,1
800025ca:	fe 7c 24 00 	mov	r12,-56320
800025ce:	f0 1f 00 13 	mcall	80002618 <sd_mmc_spi_get_if+0xb0>
800025d2:	e3 cf c0 80 	ldm	sp++,r7,pc,r12=-1
    return SD_FAILURE;
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
800025d6:	e0 6c 00 ff 	mov	r12,255
800025da:	f0 1f 00 11 	mcall	8000261c <sd_mmc_spi_get_if+0xb4>
800025de:	48 e8       	lddpc	r8,80002614 <sd_mmc_spi_get_if+0xac>
800025e0:	b0 8c       	st.b	r8[0x0],r12
  if(r1 != 0xaa) {
800025e2:	3a a8       	mov	r8,-86
800025e4:	f0 0c 18 00 	cp.b	r12,r8
800025e8:	c0 80       	breq	800025f8 <sd_mmc_spi_get_if+0x90>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800025ea:	30 1b       	mov	r11,1
800025ec:	fe 7c 24 00 	mov	r12,-56320
800025f0:	f0 1f 00 0a 	mcall	80002618 <sd_mmc_spi_get_if+0xb0>
800025f4:	e3 cf c0 80 	ldm	sp++,r7,pc,r12=-1
    return SD_FAILURE; /* wrong test pattern */
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800025f8:	30 1b       	mov	r11,1
800025fa:	fe 7c 24 00 	mov	r12,-56320
800025fe:	f0 1f 00 07 	mcall	80002618 <sd_mmc_spi_get_if+0xb0>
80002602:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
80002606:	00 00       	add	r0,r0
80002608:	80 00       	ld.sh	r0,r0[0x0]
8000260a:	21 5c       	sub	r12,21
8000260c:	80 00       	ld.sh	r0,r0[0x0]
8000260e:	2b fc       	sub	r12,-65
80002610:	80 00       	ld.sh	r0,r0[0x0]
80002612:	21 f8       	sub	r8,31
80002614:	00 00       	add	r0,r0
80002616:	0a 34       	cp.w	r4,r5
80002618:	80 00       	ld.sh	r0,r0[0x0]
8000261a:	2c 48       	sub	r8,-60
8000261c:	80 00       	ld.sh	r0,r0[0x0]
8000261e:	21 28       	sub	r8,18

80002620 <sd_mmc_spi_read_sector_to_ram>:
//! @return bit
//!   The read succeeded   -> true
//!   The read failed (bad address, etc.)  -> false
//!/
bool sd_mmc_spi_read_sector_to_ram(void *ram)
{
80002620:	eb cd 40 f8 	pushm	r3-r7,lr
80002624:	20 1d       	sub	sp,4
80002626:	18 93       	mov	r3,r12
  uint8_t *_ram = ram;
  uint16_t  i;
  uint16_t  read_time_out;
  unsigned short data_read;
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
80002628:	f0 1f 00 4d 	mcall	8000275c <sd_mmc_spi_read_sector_to_ram+0x13c>
8000262c:	e0 80 00 94 	breq	80002754 <sd_mmc_spi_read_sector_to_ram+0x134>
    return false;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80002630:	30 1b       	mov	r11,1
80002632:	fe 7c 24 00 	mov	r12,-56320
80002636:	f0 1f 00 4b 	mcall	80002760 <sd_mmc_spi_read_sector_to_ram+0x140>

  // issue command
  if(card_type == SD_CARD_2_SDHC) {
8000263a:	4c b8       	lddpc	r8,80002764 <sd_mmc_spi_read_sector_to_ram+0x144>
8000263c:	11 89       	ld.ub	r9,r8[0x0]
8000263e:	30 38       	mov	r8,3
80002640:	f0 09 18 00 	cp.b	r9,r8
80002644:	c0 d1       	brne	8000265e <sd_mmc_spi_read_sector_to_ram+0x3e>
    r1 = sd_mmc_spi_command(MMC_READ_SINGLE_BLOCK, gl_ptr_mem>>9);
80002646:	4c 98       	lddpc	r8,80002768 <sd_mmc_spi_read_sector_to_ram+0x148>
80002648:	70 0b       	ld.w	r11,r8[0x0]
8000264a:	70 18       	ld.w	r8,r8[0x4]
8000264c:	a9 98       	lsr	r8,0x9
8000264e:	f1 eb 11 7b 	or	r11,r8,r11<<0x17
80002652:	31 1c       	mov	r12,17
80002654:	f0 1f 00 46 	mcall	8000276c <sd_mmc_spi_read_sector_to_ram+0x14c>
80002658:	4c 68       	lddpc	r8,80002770 <sd_mmc_spi_read_sector_to_ram+0x150>
8000265a:	b0 8c       	st.b	r8[0x0],r12
8000265c:	c0 88       	rjmp	8000266c <sd_mmc_spi_read_sector_to_ram+0x4c>
  } else {
    r1 = sd_mmc_spi_command(MMC_READ_SINGLE_BLOCK, gl_ptr_mem);
8000265e:	4c 38       	lddpc	r8,80002768 <sd_mmc_spi_read_sector_to_ram+0x148>
80002660:	70 1b       	ld.w	r11,r8[0x4]
80002662:	31 1c       	mov	r12,17
80002664:	f0 1f 00 42 	mcall	8000276c <sd_mmc_spi_read_sector_to_ram+0x14c>
80002668:	4c 28       	lddpc	r8,80002770 <sd_mmc_spi_read_sector_to_ram+0x150>
8000266a:	b0 8c       	st.b	r8[0x0],r12
  }

  // check for valid response
  if (r1 != 0x00)
8000266c:	4c 18       	lddpc	r8,80002770 <sd_mmc_spi_read_sector_to_ram+0x150>
8000266e:	11 89       	ld.ub	r9,r8[0x0]
80002670:	30 08       	mov	r8,0
80002672:	f0 09 18 00 	cp.b	r9,r8
80002676:	c1 20       	breq	8000269a <sd_mmc_spi_read_sector_to_ram+0x7a>
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002678:	30 1b       	mov	r11,1
8000267a:	fe 7c 24 00 	mov	r12,-56320
8000267e:	f0 1f 00 3e 	mcall	80002774 <sd_mmc_spi_read_sector_to_ram+0x154>
80002682:	30 0c       	mov	r12,0
    return false;
80002684:	c6 88       	rjmp	80002754 <sd_mmc_spi_read_sector_to_ram+0x134>

  // wait for token (may be a datablock start token OR a data error token !)
  read_time_out = 30000;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
  {
     read_time_out--;
80002686:	20 17       	sub	r7,1
80002688:	5c 87       	casts.h	r7
     if (read_time_out == 0)   // TIME-OUT
8000268a:	c0 e1       	brne	800026a6 <sd_mmc_spi_read_sector_to_ram+0x86>
     {
       spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS); // unselect SD_MMC_SPI
8000268c:	30 1b       	mov	r11,1
8000268e:	fe 7c 24 00 	mov	r12,-56320
80002692:	f0 1f 00 39 	mcall	80002774 <sd_mmc_spi_read_sector_to_ram+0x154>
80002696:	30 0c       	mov	r12,0
       return false;
80002698:	c5 e8       	rjmp	80002754 <sd_mmc_spi_read_sector_to_ram+0x134>
8000269a:	e0 67 75 30 	mov	r7,30000
    return false;
  }

  // wait for token (may be a datablock start token OR a data error token !)
  read_time_out = 30000;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
8000269e:	e0 65 00 ff 	mov	r5,255
800026a2:	4b 44       	lddpc	r4,80002770 <sd_mmc_spi_read_sector_to_ram+0x150>
800026a4:	3f f6       	mov	r6,-1
800026a6:	0a 9c       	mov	r12,r5
800026a8:	f0 1f 00 34 	mcall	80002778 <sd_mmc_spi_read_sector_to_ram+0x158>
800026ac:	a8 8c       	st.b	r4[0x0],r12
800026ae:	ec 0c 18 00 	cp.b	r12,r6
800026b2:	ce a0       	breq	80002686 <sd_mmc_spi_read_sector_to_ram+0x66>
       return false;
     }
  }

  // check token
  if (r1 != MMC_STARTBLOCK_READ)
800026b4:	3f e8       	mov	r8,-2
800026b6:	f0 0c 18 00 	cp.b	r12,r8
800026ba:	c0 e0       	breq	800026d6 <sd_mmc_spi_read_sector_to_ram+0xb6>
  {
    spi_write(SD_MMC_SPI,0xFF);
800026bc:	e0 6b 00 ff 	mov	r11,255
800026c0:	fe 7c 24 00 	mov	r12,-56320
800026c4:	f0 1f 00 2e 	mcall	8000277c <sd_mmc_spi_read_sector_to_ram+0x15c>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800026c8:	30 1b       	mov	r11,1
800026ca:	fe 7c 24 00 	mov	r12,-56320
800026ce:	f0 1f 00 2a 	mcall	80002774 <sd_mmc_spi_read_sector_to_ram+0x154>
800026d2:	30 0c       	mov	r12,0
    return false;
800026d4:	c4 08       	rjmp	80002754 <sd_mmc_spi_read_sector_to_ram+0x134>
//!   The read succeeded   -> true
//!   The read failed (bad address, etc.)  -> false
//!/
bool sd_mmc_spi_read_sector_to_ram(void *ram)
{
  uint8_t *_ram = ram;
800026d6:	06 97       	mov	r7,r3
//!
//! @return bit
//!   The read succeeded   -> true
//!   The read failed (bad address, etc.)  -> false
//!/
bool sd_mmc_spi_read_sector_to_ram(void *ram)
800026d8:	e6 c5 fe 00 	sub	r5,r3,-512
  }

  // store datablock
  for(i=0;i<MMC_SECTOR_SIZE;i++)
  {
    spi_write(SD_MMC_SPI,0xFF);
800026dc:	e0 64 00 ff 	mov	r4,255
800026e0:	fe 76 24 00 	mov	r6,-56320
    spi_read(SD_MMC_SPI,&data_read);
800026e4:	fa c3 ff fe 	sub	r3,sp,-2
  }

  // store datablock
  for(i=0;i<MMC_SECTOR_SIZE;i++)
  {
    spi_write(SD_MMC_SPI,0xFF);
800026e8:	08 9b       	mov	r11,r4
800026ea:	0c 9c       	mov	r12,r6
800026ec:	f0 1f 00 24 	mcall	8000277c <sd_mmc_spi_read_sector_to_ram+0x15c>
    spi_read(SD_MMC_SPI,&data_read);
800026f0:	06 9b       	mov	r11,r3
800026f2:	0c 9c       	mov	r12,r6
800026f4:	f0 1f 00 23 	mcall	80002780 <sd_mmc_spi_read_sector_to_ram+0x160>
    *_ram++=data_read;
800026f8:	9a 18       	ld.sh	r8,sp[0x2]
800026fa:	0e c8       	st.b	r7++,r8
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return false;
  }

  // store datablock
  for(i=0;i<MMC_SECTOR_SIZE;i++)
800026fc:	0a 37       	cp.w	r7,r5
800026fe:	cf 51       	brne	800026e8 <sd_mmc_spi_read_sector_to_ram+0xc8>
  {
    spi_write(SD_MMC_SPI,0xFF);
    spi_read(SD_MMC_SPI,&data_read);
    *_ram++=data_read;
  }
  gl_ptr_mem += 512;     // Update the memory pointer.
80002700:	49 a8       	lddpc	r8,80002768 <sd_mmc_spi_read_sector_to_ram+0x148>
80002702:	f0 e6 00 00 	ld.d	r6,r8[0]
80002706:	e0 6a 02 00 	mov	r10,512
8000270a:	30 0b       	mov	r11,0
8000270c:	ec 0a 00 0a 	add	r10,r6,r10
80002710:	ee 0b 00 4b 	adc	r11,r7,r11
80002714:	f0 eb 00 00 	st.d	r8[0],r10

  // load 16-bit CRC (ignored)
  spi_write(SD_MMC_SPI,0xFF);
80002718:	e0 6b 00 ff 	mov	r11,255
8000271c:	fe 7c 24 00 	mov	r12,-56320
80002720:	f0 1f 00 17 	mcall	8000277c <sd_mmc_spi_read_sector_to_ram+0x15c>
  spi_write(SD_MMC_SPI,0xFF);
80002724:	e0 6b 00 ff 	mov	r11,255
80002728:	fe 7c 24 00 	mov	r12,-56320
8000272c:	f0 1f 00 14 	mcall	8000277c <sd_mmc_spi_read_sector_to_ram+0x15c>

  // continue delivering some clock cycles
  spi_write(SD_MMC_SPI,0xFF);
80002730:	e0 6b 00 ff 	mov	r11,255
80002734:	fe 7c 24 00 	mov	r12,-56320
80002738:	f0 1f 00 11 	mcall	8000277c <sd_mmc_spi_read_sector_to_ram+0x15c>
  spi_write(SD_MMC_SPI,0xFF);
8000273c:	e0 6b 00 ff 	mov	r11,255
80002740:	fe 7c 24 00 	mov	r12,-56320
80002744:	f0 1f 00 0e 	mcall	8000277c <sd_mmc_spi_read_sector_to_ram+0x15c>

  // release chip select
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002748:	30 1b       	mov	r11,1
8000274a:	fe 7c 24 00 	mov	r12,-56320
8000274e:	f0 1f 00 0a 	mcall	80002774 <sd_mmc_spi_read_sector_to_ram+0x154>
80002752:	30 1c       	mov	r12,1

  return true;   // Read done.
}
80002754:	2f fd       	sub	sp,-4
80002756:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000275a:	00 00       	add	r0,r0
8000275c:	80 00       	ld.sh	r0,r0[0x0]
8000275e:	21 5c       	sub	r12,21
80002760:	80 00       	ld.sh	r0,r0[0x0]
80002762:	2b fc       	sub	r12,-65
80002764:	00 00       	add	r0,r0
80002766:	0a 22       	rsub	r2,r5
80002768:	00 00       	add	r0,r0
8000276a:	05 38       	ld.ub	r8,r2++
8000276c:	80 00       	ld.sh	r0,r0[0x0]
8000276e:	21 f8       	sub	r8,31
80002770:	00 00       	add	r0,r0
80002772:	0a 34       	cp.w	r4,r5
80002774:	80 00       	ld.sh	r0,r0[0x0]
80002776:	2c 48       	sub	r8,-60
80002778:	80 00       	ld.sh	r0,r0[0x0]
8000277a:	21 28       	sub	r8,18
8000277c:	80 00       	ld.sh	r0,r0[0x0]
8000277e:	2d 2e       	sub	lr,-46
80002780:	80 00       	ld.sh	r0,r0[0x0]
80002782:	2d 4a       	sub	r10,-44

80002784 <sd_mmc_spi_get_csd>:
//! @param  buffer to fill
//!
//! @return bit
//!         true / false
bool sd_mmc_spi_get_csd(uint8_t *buffer)
{
80002784:	eb cd 40 fc 	pushm	r2-r7,lr
80002788:	20 1d       	sub	sp,4
8000278a:	18 92       	mov	r2,r12
uint8_t retry;
unsigned short data_read;
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
8000278c:	f0 1f 00 32 	mcall	80002854 <sd_mmc_spi_get_csd+0xd0>
80002790:	c5 f0       	breq	8000284e <sd_mmc_spi_get_csd+0xca>
    return false;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80002792:	30 1b       	mov	r11,1
80002794:	fe 7c 24 00 	mov	r12,-56320
80002798:	f0 1f 00 30 	mcall	80002858 <sd_mmc_spi_get_csd+0xd4>
  // issue command
  r1 = sd_mmc_spi_command(MMC_SEND_CSD, 0);
8000279c:	30 0b       	mov	r11,0
8000279e:	30 9c       	mov	r12,9
800027a0:	f0 1f 00 2f 	mcall	8000285c <sd_mmc_spi_get_csd+0xd8>
800027a4:	4a f8       	lddpc	r8,80002860 <sd_mmc_spi_get_csd+0xdc>
800027a6:	b0 8c       	st.b	r8[0x0],r12
  // check for valid response
  if(r1 != 0x00)
800027a8:	58 0c       	cp.w	r12,0
800027aa:	c0 81       	brne	800027ba <sd_mmc_spi_get_csd+0x36>
800027ac:	30 07       	mov	r7,0
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
800027ae:	e0 64 00 ff 	mov	r4,255
800027b2:	10 93       	mov	r3,r8
800027b4:	3f e6       	mov	r6,-2
  {
    if (retry > 8)
800027b6:	30 95       	mov	r5,9
800027b8:	c1 78       	rjmp	800027e6 <sd_mmc_spi_get_csd+0x62>
  // issue command
  r1 = sd_mmc_spi_command(MMC_SEND_CSD, 0);
  // check for valid response
  if(r1 != 0x00)
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800027ba:	30 1b       	mov	r11,1
800027bc:	fe 7c 24 00 	mov	r12,-56320
800027c0:	f0 1f 00 29 	mcall	80002864 <sd_mmc_spi_get_csd+0xe0>
    sd_mmc_spi_init_done = false;
800027c4:	30 09       	mov	r9,0
800027c6:	4a 98       	lddpc	r8,80002868 <sd_mmc_spi_get_csd+0xe4>
800027c8:	b0 89       	st.b	r8[0x0],r9
800027ca:	30 0c       	mov	r12,0
    return false;
800027cc:	c4 18       	rjmp	8000284e <sd_mmc_spi_get_csd+0xca>
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
  {
    if (retry > 8)
800027ce:	ea 07 18 00 	cp.b	r7,r5
800027d2:	c0 81       	brne	800027e2 <sd_mmc_spi_get_csd+0x5e>
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800027d4:	30 1b       	mov	r11,1
800027d6:	fe 7c 24 00 	mov	r12,-56320
800027da:	f0 1f 00 23 	mcall	80002864 <sd_mmc_spi_get_csd+0xe0>
800027de:	30 0c       	mov	r12,0
      return false;
800027e0:	c3 78       	rjmp	8000284e <sd_mmc_spi_get_csd+0xca>
    }
    retry++;
800027e2:	2f f7       	sub	r7,-1
800027e4:	5c 57       	castu.b	r7
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
800027e6:	08 9c       	mov	r12,r4
800027e8:	f0 1f 00 21 	mcall	8000286c <sd_mmc_spi_get_csd+0xe8>
800027ec:	a6 8c       	st.b	r3[0x0],r12
800027ee:	ec 0c 18 00 	cp.b	r12,r6
800027f2:	ce e1       	brne	800027ce <sd_mmc_spi_get_csd+0x4a>
800027f4:	30 07       	mov	r7,0
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
800027f6:	e0 65 00 ff 	mov	r5,255
800027fa:	fe 76 24 00 	mov	r6,-56320
   spi_read(SD_MMC_SPI,&data_read);
800027fe:	fa c4 ff fe 	sub	r4,sp,-2
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80002802:	0a 9b       	mov	r11,r5
80002804:	0c 9c       	mov	r12,r6
80002806:	f0 1f 00 1b 	mcall	80002870 <sd_mmc_spi_get_csd+0xec>
   spi_read(SD_MMC_SPI,&data_read);
8000280a:	08 9b       	mov	r11,r4
8000280c:	0c 9c       	mov	r12,r6
8000280e:	f0 1f 00 1a 	mcall	80002874 <sd_mmc_spi_get_csd+0xf0>
    buffer[retry] = data_read;
80002812:	9a 18       	ld.sh	r8,sp[0x2]
80002814:	e4 07 0b 08 	st.b	r2[r7],r8
80002818:	2f f7       	sub	r7,-1
      return false;
    }
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
8000281a:	59 07       	cp.w	r7,16
8000281c:	cf 31       	brne	80002802 <sd_mmc_spi_get_csd+0x7e>
  {
   spi_write(SD_MMC_SPI,0xFF);
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
  }
   spi_write(SD_MMC_SPI,0xFF);   // load CRC (not used)
8000281e:	e0 6b 00 ff 	mov	r11,255
80002822:	fe 7c 24 00 	mov	r12,-56320
80002826:	f0 1f 00 13 	mcall	80002870 <sd_mmc_spi_get_csd+0xec>
   spi_write(SD_MMC_SPI,0xFF);
8000282a:	e0 6b 00 ff 	mov	r11,255
8000282e:	fe 7c 24 00 	mov	r12,-56320
80002832:	f0 1f 00 10 	mcall	80002870 <sd_mmc_spi_get_csd+0xec>
   spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction
80002836:	e0 6b 00 ff 	mov	r11,255
8000283a:	fe 7c 24 00 	mov	r12,-56320
8000283e:	f0 1f 00 0d 	mcall	80002870 <sd_mmc_spi_get_csd+0xec>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002842:	30 1b       	mov	r11,1
80002844:	fe 7c 24 00 	mov	r12,-56320
80002848:	f0 1f 00 07 	mcall	80002864 <sd_mmc_spi_get_csd+0xe0>
8000284c:	30 1c       	mov	r12,1
  return true;
}
8000284e:	2f fd       	sub	sp,-4
80002850:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002854:	80 00       	ld.sh	r0,r0[0x0]
80002856:	21 5c       	sub	r12,21
80002858:	80 00       	ld.sh	r0,r0[0x0]
8000285a:	2b fc       	sub	r12,-65
8000285c:	80 00       	ld.sh	r0,r0[0x0]
8000285e:	21 f8       	sub	r8,31
80002860:	00 00       	add	r0,r0
80002862:	0a 34       	cp.w	r4,r5
80002864:	80 00       	ld.sh	r0,r0[0x0]
80002866:	2c 48       	sub	r8,-60
80002868:	00 00       	add	r0,r0
8000286a:	05 54       	ld.sh	r4,--r2
8000286c:	80 00       	ld.sh	r0,r0[0x0]
8000286e:	21 28       	sub	r8,18
80002870:	80 00       	ld.sh	r0,r0[0x0]
80002872:	2d 2e       	sub	lr,-46
80002874:	80 00       	ld.sh	r0,r0[0x0]
80002876:	2d 4a       	sub	r10,-44

80002878 <sd_mmc_spi_internal_init>:
//!
//!
//! @return bit
//!   The memory is ready     -> true (always)
bool sd_mmc_spi_internal_init(void)
{
80002878:	d4 31       	pushm	r0-r7,lr
  uint16_t retry;
  int i;
  int if_cond;

  // Start at low frequency
  sd_mmc_opt.baudrate = 400000;
8000287a:	fe fb 02 66 	ld.w	r11,pc[614]
8000287e:	e6 68 1a 80 	mov	r8,400000
80002882:	97 18       	st.w	r11[0x4],r8
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);
80002884:	fe f8 02 60 	ld.w	r8,pc[608]
80002888:	70 0a       	ld.w	r10,r8[0x0]
8000288a:	fe 7c 24 00 	mov	r12,-56320
8000288e:	f0 1f 00 97 	mcall	80002ae8 <sd_mmc_spi_internal_init+0x270>

  /* card needs 74 cycles minimum to start up */
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80002892:	30 1b       	mov	r11,1
80002894:	fe 7c 24 00 	mov	r12,-56320
80002898:	f0 1f 00 95 	mcall	80002aec <sd_mmc_spi_internal_init+0x274>
8000289c:	30 07       	mov	r7,0
  for(i = 0; i < 10; ++i) {
    spi_write(SD_MMC_SPI,0xFF);
8000289e:	e0 66 00 ff 	mov	r6,255
800028a2:	fe 75 24 00 	mov	r5,-56320
800028a6:	0c 9b       	mov	r11,r6
800028a8:	0a 9c       	mov	r12,r5
800028aa:	f0 1f 00 92 	mcall	80002af0 <sd_mmc_spi_internal_init+0x278>
  sd_mmc_opt.baudrate = 400000;
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);

  /* card needs 74 cycles minimum to start up */
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  for(i = 0; i < 10; ++i) {
800028ae:	2f f7       	sub	r7,-1
800028b0:	58 a7       	cp.w	r7,10
800028b2:	cf a1       	brne	800028a6 <sd_mmc_spi_internal_init+0x2e>
    spi_write(SD_MMC_SPI,0xFF);
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800028b4:	30 1b       	mov	r11,1
800028b6:	fe 7c 24 00 	mov	r12,-56320
800028ba:	f0 1f 00 8f 	mcall	80002af4 <sd_mmc_spi_internal_init+0x27c>

  // RESET THE MEMORY CARD
  sd_mmc_spi_init_done = false;
800028be:	30 08       	mov	r8,0
800028c0:	fe f9 02 38 	ld.w	r9,pc[568]
800028c4:	b2 88       	st.b	r9[0x0],r8
  card_type = MMC_CARD;
800028c6:	fe f9 02 36 	ld.w	r9,pc[566]
800028ca:	b2 88       	st.b	r9[0x0],r8
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
800028cc:	30 0b       	mov	r11,0
800028ce:	16 9c       	mov	r12,r11
800028d0:	f0 1f 00 8c 	mcall	80002b00 <sd_mmc_spi_internal_init+0x288>
800028d4:	fe f8 02 30 	ld.w	r8,pc[560]
800028d8:	b0 8c       	st.b	r8[0x0],r12
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800028da:	e0 6b 00 ff 	mov	r11,255
800028de:	fe 7c 24 00 	mov	r12,-56320
800028e2:	f0 1f 00 84 	mcall	80002af0 <sd_mmc_spi_internal_init+0x278>
800028e6:	30 17       	mov	r7,1
    // do retry counter
    retry++;
    if(retry > 100)
      return false;
  }
  while(r1 != 0x01);   // check memory enters idle_state
800028e8:	fe f6 02 1c 	ld.w	r6,pc[540]
800028ec:	30 15       	mov	r5,1
  card_type = MMC_CARD;
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
800028ee:	30 03       	mov	r3,0
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800028f0:	e0 62 00 ff 	mov	r2,255
800028f4:	fe 71 24 00 	mov	r1,-56320
    // do retry counter
    retry++;
    if(retry > 100)
800028f8:	36 54       	mov	r4,101
800028fa:	c1 08       	rjmp	8000291a <sd_mmc_spi_internal_init+0xa2>
  card_type = MMC_CARD;
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
800028fc:	06 9b       	mov	r11,r3
800028fe:	06 9c       	mov	r12,r3
80002900:	f0 1f 00 80 	mcall	80002b00 <sd_mmc_spi_internal_init+0x288>
80002904:	ac 8c       	st.b	r6[0x0],r12
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80002906:	04 9b       	mov	r11,r2
80002908:	02 9c       	mov	r12,r1
8000290a:	f0 1f 00 7a 	mcall	80002af0 <sd_mmc_spi_internal_init+0x278>
    // do retry counter
    retry++;
8000290e:	2f f7       	sub	r7,-1
80002910:	5c 87       	casts.h	r7
    if(retry > 100)
80002912:	e8 07 19 00 	cp.h	r7,r4
80002916:	e0 80 00 e4 	breq	80002ade <sd_mmc_spi_internal_init+0x266>
      return false;
  }
  while(r1 != 0x01);   // check memory enters idle_state
8000291a:	0d 88       	ld.ub	r8,r6[0x0]
8000291c:	ea 08 18 00 	cp.b	r8,r5
80002920:	ce e1       	brne	800028fc <sd_mmc_spi_internal_init+0x84>

  if_cond = sd_mmc_spi_get_if();
80002922:	f0 1f 00 7a 	mcall	80002b08 <sd_mmc_spi_internal_init+0x290>
  if(if_cond == -1) {
80002926:	5b fc       	cp.w	r12,-1
80002928:	e0 80 00 db 	breq	80002ade <sd_mmc_spi_internal_init+0x266>
      return false; // card is bad
  } else if (if_cond == 1) {
8000292c:	58 1c       	cp.w	r12,1
8000292e:	c0 51       	brne	80002938 <sd_mmc_spi_internal_init+0xc0>
      card_type = SD_CARD_2;
80002930:	30 29       	mov	r9,2
80002932:	4f 38       	lddpc	r8,80002afc <sd_mmc_spi_internal_init+0x284>
80002934:	b0 89       	st.b	r8[0x0],r9
80002936:	c4 c8       	rjmp	800029ce <sd_mmc_spi_internal_init+0x156>
  } else {
    // IDENTIFICATION OF THE CARD TYPE (SD or MMC)
    // Both cards will accept CMD55 command but only the SD card will respond to ACMD41
    r1 = sd_mmc_spi_send_command(SD_APP_CMD55,0);
80002938:	30 0b       	mov	r11,0
8000293a:	33 7c       	mov	r12,55
8000293c:	f0 1f 00 71 	mcall	80002b00 <sd_mmc_spi_internal_init+0x288>
80002940:	4f 17       	lddpc	r7,80002b04 <sd_mmc_spi_internal_init+0x28c>
80002942:	ae 8c       	st.b	r7[0x0],r12
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte
80002944:	e0 6b 00 ff 	mov	r11,255
80002948:	fe 7c 24 00 	mov	r12,-56320
8000294c:	f0 1f 00 69 	mcall	80002af0 <sd_mmc_spi_internal_init+0x278>

    r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0);
80002950:	30 0b       	mov	r11,0
80002952:	32 9c       	mov	r12,41
80002954:	f0 1f 00 6b 	mcall	80002b00 <sd_mmc_spi_internal_init+0x288>
80002958:	ae 8c       	st.b	r7[0x0],r12
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte
8000295a:	e0 6b 00 ff 	mov	r11,255
8000295e:	fe 7c 24 00 	mov	r12,-56320
80002962:	f0 1f 00 64 	mcall	80002af0 <sd_mmc_spi_internal_init+0x278>

    if ((r1&0xFE) == 0) {   // ignore "in_idle_state" flag bit
80002966:	0f 88       	ld.ub	r8,r7[0x0]
80002968:	e2 18 00 fe 	andl	r8,0xfe,COH
8000296c:	c0 51       	brne	80002976 <sd_mmc_spi_internal_init+0xfe>
      card_type = SD_CARD;    // card has accepted the command, this is a SD card
8000296e:	30 19       	mov	r9,1
80002970:	4e 38       	lddpc	r8,80002afc <sd_mmc_spi_internal_init+0x284>
80002972:	b0 89       	st.b	r8[0x0],r9
80002974:	c2 d8       	rjmp	800029ce <sd_mmc_spi_internal_init+0x156>
    } else {
      card_type = MMC_CARD;   // card has not responded, this is a MMC card
80002976:	30 09       	mov	r9,0
80002978:	4e 18       	lddpc	r8,80002afc <sd_mmc_spi_internal_init+0x284>
8000297a:	b0 89       	st.b	r8[0x0],r9
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
8000297c:	30 0b       	mov	r11,0
8000297e:	16 9c       	mov	r12,r11
80002980:	f0 1f 00 60 	mcall	80002b00 <sd_mmc_spi_internal_init+0x288>
80002984:	4e 08       	lddpc	r8,80002b04 <sd_mmc_spi_internal_init+0x28c>
80002986:	b0 8c       	st.b	r8[0x0],r12
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80002988:	e0 6b 00 ff 	mov	r11,255
8000298c:	fe 7c 24 00 	mov	r12,-56320
80002990:	f0 1f 00 58 	mcall	80002af0 <sd_mmc_spi_internal_init+0x278>
80002994:	30 17       	mov	r7,1
        // do retry counter
        retry++;
        if(retry > 100)
          return false;
      }
      while(r1 != 0x01);   // check memory enters idle_state
80002996:	4d c6       	lddpc	r6,80002b04 <sd_mmc_spi_internal_init+0x28c>
80002998:	30 15       	mov	r5,1
      card_type = MMC_CARD;   // card has not responded, this is a MMC card
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
8000299a:	30 03       	mov	r3,0
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000299c:	e0 62 00 ff 	mov	r2,255
800029a0:	fe 71 24 00 	mov	r1,-56320
        // do retry counter
        retry++;
        if(retry > 100)
800029a4:	36 54       	mov	r4,101
800029a6:	c1 08       	rjmp	800029c6 <sd_mmc_spi_internal_init+0x14e>
      card_type = MMC_CARD;   // card has not responded, this is a MMC card
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
800029a8:	06 9b       	mov	r11,r3
800029aa:	06 9c       	mov	r12,r3
800029ac:	f0 1f 00 55 	mcall	80002b00 <sd_mmc_spi_internal_init+0x288>
800029b0:	ac 8c       	st.b	r6[0x0],r12
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800029b2:	04 9b       	mov	r11,r2
800029b4:	02 9c       	mov	r12,r1
800029b6:	f0 1f 00 4f 	mcall	80002af0 <sd_mmc_spi_internal_init+0x278>
        // do retry counter
        retry++;
800029ba:	2f f7       	sub	r7,-1
800029bc:	5c 87       	casts.h	r7
        if(retry > 100)
800029be:	e8 07 19 00 	cp.h	r7,r4
800029c2:	e0 80 00 8e 	breq	80002ade <sd_mmc_spi_internal_init+0x266>
          return false;
      }
      while(r1 != 0x01);   // check memory enters idle_state
800029c6:	0d 88       	ld.ub	r8,r6[0x0]
800029c8:	ea 08 18 00 	cp.b	r8,r5
800029cc:	ce e1       	brne	800029a8 <sd_mmc_spi_internal_init+0x130>
800029ce:	30 07       	mov	r7,0

  // CONTINUE INTERNAL INITIALIZATION OF THE CARD
  // Continue sending CMD1 while memory card is in idle state
  retry = 0;
  do {
    switch(card_type) {
800029d0:	4c b4       	lddpc	r4,80002afc <sd_mmc_spi_internal_init+0x284>
800029d2:	30 15       	mov	r5,1
    case MMC_CARD:
      r1 = sd_mmc_spi_send_command(MMC_SEND_OP_COND, 0);
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
      break;
    case SD_CARD:
      sd_mmc_spi_send_command(SD_APP_CMD55,0);
800029d4:	0e 93       	mov	r3,r7
800029d6:	33 70       	mov	r0,55
      r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0);
800029d8:	4c b6       	lddpc	r6,80002b04 <sd_mmc_spi_internal_init+0x28c>
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800029da:	e0 62 00 ff 	mov	r2,255
800029de:	fe 71 24 00 	mov	r1,-56320

  // CONTINUE INTERNAL INITIALIZATION OF THE CARD
  // Continue sending CMD1 while memory card is in idle state
  retry = 0;
  do {
    switch(card_type) {
800029e2:	09 88       	ld.ub	r8,r4[0x0]
800029e4:	ea 08 18 00 	cp.b	r8,r5
800029e8:	c1 10       	breq	80002a0a <sd_mmc_spi_internal_init+0x192>
800029ea:	c0 63       	brcs	800029f6 <sd_mmc_spi_internal_init+0x17e>
800029ec:	30 29       	mov	r9,2
800029ee:	f2 08 18 00 	cp.b	r8,r9
800029f2:	c2 81       	brne	80002a42 <sd_mmc_spi_internal_init+0x1ca>
800029f4:	c1 98       	rjmp	80002a26 <sd_mmc_spi_internal_init+0x1ae>
    case MMC_CARD:
      r1 = sd_mmc_spi_send_command(MMC_SEND_OP_COND, 0);
800029f6:	06 9b       	mov	r11,r3
800029f8:	30 1c       	mov	r12,1
800029fa:	f0 1f 00 42 	mcall	80002b00 <sd_mmc_spi_internal_init+0x288>
800029fe:	ac 8c       	st.b	r6[0x0],r12
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80002a00:	04 9b       	mov	r11,r2
80002a02:	02 9c       	mov	r12,r1
80002a04:	f0 1f 00 3b 	mcall	80002af0 <sd_mmc_spi_internal_init+0x278>
      break;
80002a08:	c1 d8       	rjmp	80002a42 <sd_mmc_spi_internal_init+0x1ca>
    case SD_CARD:
      sd_mmc_spi_send_command(SD_APP_CMD55,0);
80002a0a:	06 9b       	mov	r11,r3
80002a0c:	00 9c       	mov	r12,r0
80002a0e:	f0 1f 00 3d 	mcall	80002b00 <sd_mmc_spi_internal_init+0x288>
      r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0);
80002a12:	06 9b       	mov	r11,r3
80002a14:	32 9c       	mov	r12,41
80002a16:	f0 1f 00 3b 	mcall	80002b00 <sd_mmc_spi_internal_init+0x288>
80002a1a:	ac 8c       	st.b	r6[0x0],r12
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80002a1c:	04 9b       	mov	r11,r2
80002a1e:	02 9c       	mov	r12,r1
80002a20:	f0 1f 00 34 	mcall	80002af0 <sd_mmc_spi_internal_init+0x278>
      break;
80002a24:	c0 f8       	rjmp	80002a42 <sd_mmc_spi_internal_init+0x1ca>
    case SD_CARD_2:
      // set high capacity bit mask
      sd_mmc_spi_send_command(SD_APP_CMD55,0);
80002a26:	06 9b       	mov	r11,r3
80002a28:	00 9c       	mov	r12,r0
80002a2a:	f0 1f 00 36 	mcall	80002b00 <sd_mmc_spi_internal_init+0x288>
      r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0x40000000);
80002a2e:	fc 1b 40 00 	movh	r11,0x4000
80002a32:	32 9c       	mov	r12,41
80002a34:	f0 1f 00 33 	mcall	80002b00 <sd_mmc_spi_internal_init+0x288>
80002a38:	ac 8c       	st.b	r6[0x0],r12
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80002a3a:	04 9b       	mov	r11,r2
80002a3c:	02 9c       	mov	r12,r1
80002a3e:	f0 1f 00 2d 	mcall	80002af0 <sd_mmc_spi_internal_init+0x278>
      break;
    }
     // do retry counter
     retry++;
80002a42:	2f f7       	sub	r7,-1
80002a44:	5c 87       	casts.h	r7
     if(retry == 50000)    // measured approx. 500 on several cards
80002a46:	fe 78 c3 50 	mov	r8,-15536
80002a4a:	f0 07 19 00 	cp.h	r7,r8
80002a4e:	c4 80       	breq	80002ade <sd_mmc_spi_internal_init+0x266>
        return false;
  } while (r1);
80002a50:	0d 89       	ld.ub	r9,r6[0x0]
80002a52:	30 08       	mov	r8,0
80002a54:	f0 09 18 00 	cp.b	r9,r8
80002a58:	cc 51       	brne	800029e2 <sd_mmc_spi_internal_init+0x16a>

  // CHECK FOR SDHC
  if(card_type == SD_CARD_2) {
80002a5a:	4a 98       	lddpc	r8,80002afc <sd_mmc_spi_internal_init+0x284>
80002a5c:	11 89       	ld.ub	r9,r8[0x0]
80002a5e:	30 28       	mov	r8,2
80002a60:	f0 09 18 00 	cp.b	r9,r8
80002a64:	c0 a1       	brne	80002a78 <sd_mmc_spi_internal_init+0x200>
    if_cond = sd_mmc_spi_check_hc();
80002a66:	f0 1f 00 2a 	mcall	80002b0c <sd_mmc_spi_internal_init+0x294>
    if (if_cond == -1) {
80002a6a:	5b fc       	cp.w	r12,-1
80002a6c:	c3 90       	breq	80002ade <sd_mmc_spi_internal_init+0x266>
      return false;
    } else if (if_cond == 1){
80002a6e:	58 1c       	cp.w	r12,1
80002a70:	c0 41       	brne	80002a78 <sd_mmc_spi_internal_init+0x200>
          card_type = SD_CARD_2_SDHC;
80002a72:	30 39       	mov	r9,3
80002a74:	4a 28       	lddpc	r8,80002afc <sd_mmc_spi_internal_init+0x284>
80002a76:	b0 89       	st.b	r8[0x0],r9
      }
  }

  // DISABLE CRC TO SIMPLIFY AND SPEED UP COMMUNICATIONS
  r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0);  // disable CRC (should be already initialized on SPI init)
80002a78:	30 0b       	mov	r11,0
80002a7a:	33 bc       	mov	r12,59
80002a7c:	f0 1f 00 21 	mcall	80002b00 <sd_mmc_spi_internal_init+0x288>
80002a80:	4a 17       	lddpc	r7,80002b04 <sd_mmc_spi_internal_init+0x28c>
80002a82:	ae 8c       	st.b	r7[0x0],r12
  spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80002a84:	e0 6b 00 ff 	mov	r11,255
80002a88:	fe 7c 24 00 	mov	r12,-56320
80002a8c:	f0 1f 00 19 	mcall	80002af0 <sd_mmc_spi_internal_init+0x278>

  // SET BLOCK LENGTH TO 512 BYTES
  r1 = sd_mmc_spi_send_command(MMC_SET_BLOCKLEN, 512);
80002a90:	e0 6b 02 00 	mov	r11,512
80002a94:	31 0c       	mov	r12,16
80002a96:	f0 1f 00 1b 	mcall	80002b00 <sd_mmc_spi_internal_init+0x288>
80002a9a:	ae 8c       	st.b	r7[0x0],r12
  spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80002a9c:	e0 6b 00 ff 	mov	r11,255
80002aa0:	fe 7c 24 00 	mov	r12,-56320
80002aa4:	f0 1f 00 13 	mcall	80002af0 <sd_mmc_spi_internal_init+0x278>
  if (r1 != 0x00)
80002aa8:	0f 89       	ld.ub	r9,r7[0x0]
80002aaa:	30 08       	mov	r8,0
80002aac:	f0 09 18 00 	cp.b	r9,r8
80002ab0:	c1 71       	brne	80002ade <sd_mmc_spi_internal_init+0x266>
    return false;    // card unsupported if block length of 512b is not accepted

  // GET CARD SPECIFIC DATA
  if (false ==  sd_mmc_spi_get_csd(csd))
80002ab2:	49 8c       	lddpc	r12,80002b10 <sd_mmc_spi_internal_init+0x298>
80002ab4:	f0 1f 00 18 	mcall	80002b14 <sd_mmc_spi_internal_init+0x29c>
80002ab8:	c1 30       	breq	80002ade <sd_mmc_spi_internal_init+0x266>
    return false;

  // GET CARD CAPACITY and NUMBER OF SECTORS
  sd_mmc_spi_get_capacity();
80002aba:	f0 1f 00 18 	mcall	80002b18 <sd_mmc_spi_internal_init+0x2a0>
#if (defined SD_MMC_READ_CID) && (SD_MMC_READ_CID == true)
  if (false ==  sd_mmc_spi_get_cid(cid))
    return false;
#endif

  sd_mmc_spi_init_done = true;
80002abe:	30 19       	mov	r9,1
80002ac0:	48 e8       	lddpc	r8,80002af8 <sd_mmc_spi_internal_init+0x280>
80002ac2:	b0 89       	st.b	r8[0x0],r9

  // Set SPI Speed to MAX
  sd_mmc_opt.baudrate = SD_MMC_SPI_MASTER_SPEED;
80002ac4:	48 7b       	lddpc	r11,80002ae0 <sd_mmc_spi_internal_init+0x268>
80002ac6:	e0 68 1b 00 	mov	r8,6912
80002aca:	ea 18 00 b7 	orh	r8,0xb7
80002ace:	97 18       	st.w	r11[0x4],r8
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);
80002ad0:	48 58       	lddpc	r8,80002ae4 <sd_mmc_spi_internal_init+0x26c>
80002ad2:	70 0a       	ld.w	r10,r8[0x0]
80002ad4:	fe 7c 24 00 	mov	r12,-56320
80002ad8:	f0 1f 00 04 	mcall	80002ae8 <sd_mmc_spi_internal_init+0x270>
80002adc:	da 3a       	popm	r0-r7,pc,r12=1
  return true;
80002ade:	d8 3a       	popm	r0-r7,pc,r12=0
80002ae0:	00 00       	add	r0,r0
80002ae2:	05 40       	ld.w	r0,--r2
80002ae4:	00 00       	add	r0,r0
80002ae6:	05 50       	ld.sh	r0,--r2
80002ae8:	80 00       	ld.sh	r0,r0[0x0]
80002aea:	2c 70       	sub	r0,-57
80002aec:	80 00       	ld.sh	r0,r0[0x0]
80002aee:	2b fc       	sub	r12,-65
80002af0:	80 00       	ld.sh	r0,r0[0x0]
80002af2:	2d 2e       	sub	lr,-46
80002af4:	80 00       	ld.sh	r0,r0[0x0]
80002af6:	2c 48       	sub	r8,-60
80002af8:	00 00       	add	r0,r0
80002afa:	05 54       	ld.sh	r4,--r2
80002afc:	00 00       	add	r0,r0
80002afe:	0a 22       	rsub	r2,r5
80002b00:	80 00       	ld.sh	r0,r0[0x0]
80002b02:	22 c0       	sub	r0,44
80002b04:	00 00       	add	r0,r0
80002b06:	0a 34       	cp.w	r4,r5
80002b08:	80 00       	ld.sh	r0,r0[0x0]
80002b0a:	25 68       	sub	r8,86
80002b0c:	80 00       	ld.sh	r0,r0[0x0]
80002b0e:	24 dc       	sub	r12,77
80002b10:	00 00       	add	r0,r0
80002b12:	0a 24       	rsub	r4,r5
80002b14:	80 00       	ld.sh	r0,r0[0x0]
80002b16:	27 84       	sub	r4,120
80002b18:	80 00       	ld.sh	r0,r0[0x0]
80002b1a:	20 08       	sub	r8,0

80002b1c <sd_mmc_spi_mem_check>:
//!
//! @return bit
//!   The memory is ready     -> true
//!   The memory check failed -> false
bool sd_mmc_spi_mem_check(void)
{
80002b1c:	d4 01       	pushm	lr
  if (sd_mmc_spi_check_presence())
80002b1e:	f0 1f 00 07 	mcall	80002b38 <sd_mmc_spi_mem_check+0x1c>
80002b22:	c0 a0       	breq	80002b36 <sd_mmc_spi_mem_check+0x1a>
  {
    if (sd_mmc_spi_init_done == false)
80002b24:	48 68       	lddpc	r8,80002b3c <sd_mmc_spi_mem_check+0x20>
80002b26:	11 89       	ld.ub	r9,r8[0x0]
80002b28:	30 08       	mov	r8,0
80002b2a:	f0 09 18 00 	cp.b	r9,r8
80002b2e:	c0 20       	breq	80002b32 <sd_mmc_spi_mem_check+0x16>
80002b30:	da 0a       	popm	pc,r12=1
    {
      return sd_mmc_spi_internal_init();
80002b32:	f0 1f 00 04 	mcall	80002b40 <sd_mmc_spi_mem_check+0x24>
    }
    else
      return true;
  }
  return false;
}
80002b36:	d8 02       	popm	pc
80002b38:	80 00       	ld.sh	r0,r0[0x0]
80002b3a:	23 00       	sub	r0,48
80002b3c:	00 00       	add	r0,r0
80002b3e:	05 54       	ld.sh	r4,--r2
80002b40:	80 00       	ld.sh	r0,r0[0x0]
80002b42:	28 78       	sub	r8,-121

80002b44 <sd_mmc_spi_init>:
//!
//!
//! @return bit
//!   The memory is ready     -> true (always)
bool sd_mmc_spi_init(spi_options_t spiOptions, unsigned int pba_hz)
{
80002b44:	eb cd 40 10 	pushm	r4,lr
80002b48:	fa c4 ff f8 	sub	r4,sp,-8
  // Keep SPI options internally
  sd_mmc_pba_hz = pba_hz;
80002b4c:	48 88       	lddpc	r8,80002b6c <sd_mmc_spi_init+0x28>
80002b4e:	91 0c       	st.w	r8[0x0],r12
  memcpy( &sd_mmc_opt, &spiOptions, sizeof(spi_options_t) );
80002b50:	48 88       	lddpc	r8,80002b70 <sd_mmc_spi_init+0x2c>
80002b52:	e8 ea 00 00 	ld.d	r10,r4[0]
80002b56:	f0 eb 00 00 	st.d	r8[0],r10
80002b5a:	e8 ea 00 08 	ld.d	r10,r4[8]
80002b5e:	f0 eb 00 08 	st.d	r8[8],r10

  // Initialize the SD/MMC controller.
  return sd_mmc_spi_internal_init();
80002b62:	f0 1f 00 05 	mcall	80002b74 <sd_mmc_spi_init+0x30>
}
80002b66:	e3 cd 80 10 	ldm	sp++,r4,pc
80002b6a:	00 00       	add	r0,r0
80002b6c:	00 00       	add	r0,r0
80002b6e:	05 50       	ld.sh	r0,--r2
80002b70:	00 00       	add	r0,r0
80002b72:	05 40       	ld.w	r0,--r2
80002b74:	80 00       	ld.sh	r0,r0[0x0]
80002b76:	28 78       	sub	r8,-121

80002b78 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80002b78:	f8 c8 00 01 	sub	r8,r12,1
80002b7c:	f0 0b 00 0b 	add	r11,r8,r11
80002b80:	f6 0c 0d 0a 	divu	r10,r11,r12
80002b84:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
80002b86:	f4 c8 00 01 	sub	r8,r10,1
80002b8a:	e0 48 00 fe 	cp.w	r8,254
80002b8e:	e0 88 00 03 	brls	80002b94 <getBaudDiv+0x1c>
80002b92:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
80002b94:	5c 8c       	casts.h	r12
}
80002b96:	5e fc       	retal	r12

80002b98 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
80002b98:	f7 39 00 0d 	ld.ub	r9,r11[13]
80002b9c:	30 18       	mov	r8,1
80002b9e:	f0 09 18 00 	cp.b	r9,r8
80002ba2:	e0 88 00 04 	brls	80002baa <spi_initMaster+0x12>
80002ba6:	30 2c       	mov	r12,2
80002ba8:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
80002baa:	e0 68 00 80 	mov	r8,128
80002bae:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80002bb0:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
80002bb2:	30 19       	mov	r9,1
80002bb4:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
80002bb8:	f7 39 00 0d 	ld.ub	r9,r11[13]
80002bbc:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80002bc0:	30 09       	mov	r9,0
80002bc2:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80002bc6:	30 fa       	mov	r10,15
80002bc8:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
80002bcc:	99 18       	st.w	r12[0x4],r8
80002bce:	5e f9       	retal	r9

80002bd0 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80002bd0:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80002bd2:	30 18       	mov	r8,1
80002bd4:	f0 0b 18 00 	cp.b	r11,r8
80002bd8:	5f be       	srhi	lr
80002bda:	f0 0a 18 00 	cp.b	r10,r8
80002bde:	5f b8       	srhi	r8
80002be0:	fd e8 10 08 	or	r8,lr,r8
80002be4:	c0 30       	breq	80002bea <spi_selectionMode+0x1a>
80002be6:	30 2c       	mov	r12,2
80002be8:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
80002bea:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80002bec:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80002bf0:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80002bf4:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80002bf8:	99 18       	st.w	r12[0x4],r8
80002bfa:	d8 0a       	popm	pc,r12=0

80002bfc <spi_selectChip>:
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80002bfc:	78 18       	ld.w	r8,r12[0x4]
80002bfe:	ea 18 00 0f 	orh	r8,0xf
80002c02:	99 18       	st.w	r12[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80002c04:	78 18       	ld.w	r8,r12[0x4]
80002c06:	e2 18 00 04 	andl	r8,0x4,COH
80002c0a:	c0 f0       	breq	80002c28 <spi_selectChip+0x2c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80002c0c:	30 e8       	mov	r8,14
80002c0e:	f0 0b 18 00 	cp.b	r11,r8
80002c12:	e0 8b 00 19 	brhi	80002c44 <spi_selectChip+0x48>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80002c16:	78 18       	ld.w	r8,r12[0x4]
80002c18:	b1 6b       	lsl	r11,0x10
80002c1a:	ea 1b ff f0 	orh	r11,0xfff0
80002c1e:	e8 1b ff ff 	orl	r11,0xffff
80002c22:	10 6b       	and	r11,r8
80002c24:	99 1b       	st.w	r12[0x4],r11
80002c26:	5e fd       	retal	0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80002c28:	30 38       	mov	r8,3
80002c2a:	f0 0b 18 00 	cp.b	r11,r8
80002c2e:	e0 8b 00 0b 	brhi	80002c44 <spi_selectChip+0x48>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80002c32:	78 18       	ld.w	r8,r12[0x4]
80002c34:	2f 0b       	sub	r11,-16
80002c36:	30 19       	mov	r9,1
80002c38:	f2 0b 09 4b 	lsl	r11,r9,r11
80002c3c:	5c db       	com	r11
80002c3e:	10 6b       	and	r11,r8
80002c40:	99 1b       	st.w	r12[0x4],r11
80002c42:	5e fd       	retal	0
80002c44:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80002c46:	5e fc       	retal	r12

80002c48 <spi_unselectChip>:

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80002c48:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80002c4c:	c0 58       	rjmp	80002c56 <spi_unselectChip+0xe>
		if (!timeout--) {
80002c4e:	58 08       	cp.w	r8,0
80002c50:	c0 21       	brne	80002c54 <spi_unselectChip+0xc>
80002c52:	5e ff       	retal	1
80002c54:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80002c56:	78 49       	ld.w	r9,r12[0x10]
80002c58:	e2 19 02 00 	andl	r9,0x200,COH
80002c5c:	cf 90       	breq	80002c4e <spi_unselectChip+0x6>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80002c5e:	78 18       	ld.w	r8,r12[0x4]
80002c60:	ea 18 00 0f 	orh	r8,0xf
80002c64:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80002c66:	fc 18 01 00 	movh	r8,0x100
80002c6a:	99 08       	st.w	r12[0x0],r8
80002c6c:	5e fd       	retal	0
80002c6e:	d7 03       	nop

80002c70 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80002c70:	eb cd 40 f8 	pushm	r3-r7,lr
80002c74:	18 95       	mov	r5,r12
80002c76:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80002c78:	f7 36 00 0c 	ld.ub	r6,r11[12]
80002c7c:	30 38       	mov	r8,3
80002c7e:	f0 06 18 00 	cp.b	r6,r8
80002c82:	e0 8b 00 4d 	brhi	80002d1c <spi_setupChipReg+0xac>
			options->stay_act > 1 ||
80002c86:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80002c8a:	30 18       	mov	r8,1
80002c8c:	f0 04 18 00 	cp.b	r4,r8
80002c90:	e0 8b 00 46 	brhi	80002d1c <spi_setupChipReg+0xac>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80002c94:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80002c98:	30 78       	mov	r8,7
80002c9a:	f0 03 18 00 	cp.b	r3,r8
80002c9e:	e0 88 00 3f 	brls	80002d1c <spi_setupChipReg+0xac>
80002ca2:	31 08       	mov	r8,16
80002ca4:	f0 03 18 00 	cp.b	r3,r8
80002ca8:	e0 8b 00 3a 	brhi	80002d1c <spi_setupChipReg+0xac>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80002cac:	14 9b       	mov	r11,r10
80002cae:	6e 1c       	ld.w	r12,r7[0x4]
80002cb0:	f0 1f 00 1d 	mcall	80002d24 <spi_setupChipReg+0xb4>

	if (baudDiv < 0) {
80002cb4:	c3 45       	brlt	80002d1c <spi_setupChipReg+0xac>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
80002cb6:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80002cb8:	ec 09 16 01 	lsr	r9,r6,0x1
80002cbc:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80002cc0:	ec 16 00 01 	eorl	r6,0x1
80002cc4:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80002cc8:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
80002ccc:	20 83       	sub	r3,8
80002cce:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
80002cd2:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80002cd6:	ef 39 00 09 	ld.ub	r9,r7[9]
80002cda:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80002cde:	ef 39 00 0a 	ld.ub	r9,r7[10]
80002ce2:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
80002ce6:	0f 89       	ld.ub	r9,r7[0x0]
80002ce8:	30 1a       	mov	r10,1
80002cea:	f4 09 18 00 	cp.b	r9,r10
80002cee:	c0 e0       	breq	80002d0a <spi_setupChipReg+0x9a>
80002cf0:	c0 a3       	brcs	80002d04 <spi_setupChipReg+0x94>
80002cf2:	30 2a       	mov	r10,2
80002cf4:	f4 09 18 00 	cp.b	r9,r10
80002cf8:	c0 c0       	breq	80002d10 <spi_setupChipReg+0xa0>
80002cfa:	30 3a       	mov	r10,3
80002cfc:	f4 09 18 00 	cp.b	r9,r10
80002d00:	c0 e1       	brne	80002d1c <spi_setupChipReg+0xac>
80002d02:	c0 a8       	rjmp	80002d16 <spi_setupChipReg+0xa6>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80002d04:	8b c8       	st.w	r5[0x30],r8
80002d06:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
		break;

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80002d0a:	8b d8       	st.w	r5[0x34],r8
80002d0c:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
		break;

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80002d10:	8b e8       	st.w	r5[0x38],r8
80002d12:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
		break;

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80002d16:	8b f8       	st.w	r5[0x3c],r8
80002d18:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
		break;
80002d1c:	30 2c       	mov	r12,2
		}
	}
#endif

	return SPI_OK;
}
80002d1e:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002d22:	00 00       	add	r0,r0
80002d24:	80 00       	ld.sh	r0,r0[0x0]
80002d26:	2b 78       	sub	r8,-73

80002d28 <spi_enable>:

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80002d28:	30 18       	mov	r8,1
80002d2a:	99 08       	st.w	r12[0x0],r8
}
80002d2c:	5e fc       	retal	r12

80002d2e <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80002d2e:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80002d32:	c0 58       	rjmp	80002d3c <spi_write+0xe>
		if (!timeout--) {
80002d34:	58 08       	cp.w	r8,0
80002d36:	c0 21       	brne	80002d3a <spi_write+0xc>
80002d38:	5e ff       	retal	1
80002d3a:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80002d3c:	78 49       	ld.w	r9,r12[0x10]
80002d3e:	e2 19 00 02 	andl	r9,0x2,COH
80002d42:	cf 90       	breq	80002d34 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80002d44:	5c 7b       	castu.h	r11
80002d46:	99 3b       	st.w	r12[0xc],r11
80002d48:	5e fd       	retal	0

80002d4a <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80002d4a:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80002d4e:	c0 58       	rjmp	80002d58 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80002d50:	58 08       	cp.w	r8,0
80002d52:	c0 21       	brne	80002d56 <spi_read+0xc>
80002d54:	5e ff       	retal	1
80002d56:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80002d58:	78 49       	ld.w	r9,r12[0x10]
80002d5a:	e2 19 02 01 	andl	r9,0x201,COH
80002d5e:	e0 49 02 01 	cp.w	r9,513
80002d62:	cf 71       	brne	80002d50 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80002d64:	78 28       	ld.w	r8,r12[0x8]
80002d66:	b6 08       	st.h	r11[0x0],r8
80002d68:	5e fd       	retal	0
80002d6a:	d7 03       	nop

80002d6c <tpa6130_abdac_tx_pdca_int_handler>:
  .output_impedance    = TPA6130_OUTPUT_IMPEDANCE_DEFAULT,
  .i2c_address_version = TPA6130_I2C_ADDRESS_VERSION_DEFAULT,
};

ISR(tpa6130_abdac_tx_pdca_int_handler, TPA6130_ABDAC_PDCA_IRQ_GROUP, TPA6130_ABDAC_PDCA_INT_LEVEL)
{
80002d6c:	d4 01       	pushm	lr
  if (pdca_get_transfer_status(TPA6130_ABDAC_PDCA_CHANNEL) & PDCA_TRANSFER_COMPLETE)
80002d6e:	30 0c       	mov	r12,0
80002d70:	f0 1f 00 13 	mcall	80002dbc <tpa6130_abdac_tx_pdca_int_handler+0x50>
80002d74:	e2 1c 00 02 	andl	r12,0x2,COH
80002d78:	c0 d0       	breq	80002d92 <tpa6130_abdac_tx_pdca_int_handler+0x26>
  {
    pdca_disable_interrupt_transfer_complete(TPA6130_ABDAC_PDCA_CHANNEL);
80002d7a:	30 0c       	mov	r12,0
80002d7c:	f0 1f 00 11 	mcall	80002dc0 <tpa6130_abdac_tx_pdca_int_handler+0x54>
    if (tpa6130_output_param.callback_opt & AUDIO_DAC_OUT_OF_SAMPLE_CB)
80002d80:	49 18       	lddpc	r8,80002dc4 <tpa6130_abdac_tx_pdca_int_handler+0x58>
80002d82:	70 28       	ld.w	r8,r8[0x8]
80002d84:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002d88:	c0 50       	breq	80002d92 <tpa6130_abdac_tx_pdca_int_handler+0x26>
      tpa6130_output_param.callback(AUDIO_DAC_OUT_OF_SAMPLE_CB);
80002d8a:	48 f8       	lddpc	r8,80002dc4 <tpa6130_abdac_tx_pdca_int_handler+0x58>
80002d8c:	70 18       	ld.w	r8,r8[0x4]
80002d8e:	30 1c       	mov	r12,1
80002d90:	5d 18       	icall	r8
  }

  if (pdca_get_transfer_status(TPA6130_ABDAC_PDCA_CHANNEL) & PDCA_TRANSFER_COUNTER_RELOAD_IS_ZERO)
80002d92:	30 0c       	mov	r12,0
80002d94:	f0 1f 00 0a 	mcall	80002dbc <tpa6130_abdac_tx_pdca_int_handler+0x50>
80002d98:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002d9c:	c0 d0       	breq	80002db6 <tpa6130_abdac_tx_pdca_int_handler+0x4a>
  {
    pdca_disable_interrupt_reload_counter_zero(TPA6130_ABDAC_PDCA_CHANNEL);
80002d9e:	30 0c       	mov	r12,0
80002da0:	f0 1f 00 0a 	mcall	80002dc8 <tpa6130_abdac_tx_pdca_int_handler+0x5c>
    if (tpa6130_output_param.callback_opt & AUDIO_DAC_RELOAD_CB)
80002da4:	48 88       	lddpc	r8,80002dc4 <tpa6130_abdac_tx_pdca_int_handler+0x58>
80002da6:	70 28       	ld.w	r8,r8[0x8]
80002da8:	e2 18 00 02 	andl	r8,0x2,COH
80002dac:	c0 50       	breq	80002db6 <tpa6130_abdac_tx_pdca_int_handler+0x4a>
      tpa6130_output_param.callback(AUDIO_DAC_RELOAD_CB);
80002dae:	48 68       	lddpc	r8,80002dc4 <tpa6130_abdac_tx_pdca_int_handler+0x58>
80002db0:	70 18       	ld.w	r8,r8[0x4]
80002db2:	30 2c       	mov	r12,2
80002db4:	5d 18       	icall	r8
  }
}
80002db6:	d4 02       	popm	lr
80002db8:	d6 03       	rete
80002dba:	00 00       	add	r0,r0
80002dbc:	80 00       	ld.sh	r0,r0[0x0]
80002dbe:	42 78       	lddsp	r8,sp[0x9c]
80002dc0:	80 00       	ld.sh	r0,r0[0x0]
80002dc2:	42 b0       	lddsp	r0,sp[0xac]
80002dc4:	00 00       	add	r0,r0
80002dc6:	05 58       	ld.sh	r8,--r2
80002dc8:	80 00       	ld.sh	r0,r0[0x0]
80002dca:	42 88       	lddsp	r8,sp[0xa0]

80002dcc <tpa6130_write_data>:
 *  \param reg Register index. Use the defines in this file.
 *  \param data Register data. Macros from this file can be used
 *  to ease writing to the bitfields.
 */
static void tpa6130_write_data(uint8_t reg, uint8_t data)
{
80002dcc:	d4 21       	pushm	r4-r7,lr
80002dce:	20 6d       	sub	sp,24
80002dd0:	18 94       	mov	r4,r12
80002dd2:	16 95       	mov	r5,r11
  uint16_t message = (reg << 8) | data;
80002dd4:	f7 ec 10 88 	or	r8,r11,r12<<0x8
80002dd8:	fb 58 00 16 	st.h	sp[22],r8
  {
    .chip = TPA6130_TWI_ADDRESS,
    .addr_length = 0,//AVR32_TWI_MMR_IADRSZ_NO_ADDR,
    .buffer = &message,
    .length = sizeof(message)
  };
80002ddc:	30 08       	mov	r8,0
80002dde:	30 09       	mov	r9,0
80002de0:	fa e9 00 00 	st.d	sp[0],r8
80002de4:	fa e9 00 08 	st.d	sp[8],r8
80002de8:	36 08       	mov	r8,96
80002dea:	ba 88       	st.b	sp[0x0],r8
80002dec:	fa c8 ff ea 	sub	r8,sp,-22
80002df0:	50 38       	stdsp	sp[0xc],r8
80002df2:	30 28       	mov	r8,2
80002df4:	50 48       	stdsp	sp[0x10],r8

  do
  {
     twi_status=twi_master_write(TPA6130_TWI, &twi_package);
80002df6:	1a 96       	mov	r6,sp
80002df8:	fe 77 2c 00 	mov	r7,-54272
80002dfc:	1a 9b       	mov	r11,sp
80002dfe:	0e 9c       	mov	r12,r7
80002e00:	f0 1f 00 05 	mcall	80002e14 <tpa6130_write_data+0x48>
  }
  while( twi_status != TWI_SUCCESS );
80002e04:	cf c1       	brne	80002dfc <tpa6130_write_data+0x30>

  /* Save write value to shadow registers */
  *(((uint8_t *) &tpa6130_shadow_regs) + reg - 1) = data;
80002e06:	48 58       	lddpc	r8,80002e18 <tpa6130_write_data+0x4c>
80002e08:	f0 04 00 04 	add	r4,r8,r4
80002e0c:	e9 65 ff ff 	st.b	r4[-1],r5
}
80002e10:	2f ad       	sub	sp,-24
80002e12:	d8 22       	popm	r4-r7,pc
80002e14:	80 00       	ld.sh	r0,r0[0x0]
80002e16:	46 cc       	lddsp	r12,sp[0x1b0]
80002e18:	00 00       	add	r0,r0
80002e1a:	00 08       	add	r8,r0

80002e1c <tpa6130_set_volume>:
 *  it to max.
 *  A volume of 0 will mute both channels. Any other value will unmute
 *  them.
 */
void tpa6130_set_volume(int8_t volume)
{
80002e1c:	d4 01       	pushm	lr
  int8_t new_volume = volume;

  if(volume > TPA6130_VOL_MAX)
80002e1e:	33 f8       	mov	r8,63
80002e20:	f0 0c 18 00 	cp.b	r12,r8
80002e24:	e0 8a 00 04 	brle	80002e2c <tpa6130_set_volume+0x10>
80002e28:	33 fb       	mov	r11,63
80002e2a:	c0 b8       	rjmp	80002e40 <tpa6130_set_volume+0x24>
  {
    new_volume = TPA6130_VOL_MAX;
  }
  else if(volume <= TPA6130_VOL_MIN )
80002e2c:	30 08       	mov	r8,0
80002e2e:	f0 0c 18 00 	cp.b	r12,r8
80002e32:	e0 89 00 05 	brgt	80002e3c <tpa6130_set_volume+0x20>
80002e36:	e0 6b 00 c0 	mov	r11,192
80002e3a:	c0 38       	rjmp	80002e40 <tpa6130_set_volume+0x24>
80002e3c:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
  {
    // MUTE Left and Right;
    new_volume = MUTE_L|MUTE_R;
  }

  tpa6130_write_data(TPA6130_VOLUME_AND_MUTE, new_volume );
80002e40:	30 2c       	mov	r12,2
80002e42:	f0 1f 00 02 	mcall	80002e48 <tpa6130_set_volume+0x2c>
}
80002e46:	d8 02       	popm	pc
80002e48:	80 00       	ld.sh	r0,r0[0x0]
80002e4a:	2d cc       	sub	r12,-36

80002e4c <tpa6130_dac_output>:
 * which contain two (16-bit) samples, one for each channel.
 *
 * \note The DACs must have been started beforehand.
 */
bool tpa6130_dac_output(void *sample_buffer, size_t sample_length)
{
80002e4c:	eb cd 40 c0 	pushm	r6-r7,lr
80002e50:	18 96       	mov	r6,r12
80002e52:	16 97       	mov	r7,r11
  //int global_interrupt_enabled;

  /*Wait until the PDCA loads the reload value to its transfer
   * counter register(TCRR=0). Then we are ready to set up a new
   * transfer */
  if(!(pdca_get_transfer_status(TPA6130_ABDAC_PDCA_CHANNEL) &
80002e54:	30 0c       	mov	r12,0
80002e56:	f0 1f 00 11 	mcall	80002e98 <tpa6130_dac_output+0x4c>
80002e5a:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002e5e:	c1 b0       	breq	80002e94 <tpa6130_dac_output+0x48>
  {
    return false;
  }

  /* Nothing to do if we get no data. */
  if(sample_length)
80002e60:	58 07       	cp.w	r7,0
80002e62:	c1 80       	breq	80002e92 <tpa6130_dac_output+0x46>
    //if((global_interrupt_enabled = cpu_irq_is_enabled()))
    //  cpu_irq_disable();

    /*FIXME This assumes a stereo 16-bit sample size */
    // one sample here consists of 2x16-bit (16-bit stereo)
    pdca_reload_channel(TPA6130_ABDAC_PDCA_CHANNEL,
80002e64:	0e 9a       	mov	r10,r7
80002e66:	0c 9b       	mov	r11,r6
80002e68:	30 0c       	mov	r12,0
80002e6a:	f0 1f 00 0d 	mcall	80002e9c <tpa6130_dac_output+0x50>
    //if(global_interrupt_enabled)
    //  cpu_irq_enable();

    /*TODO enable transfer complete interrupt
     * Is it possible to move this to setup or other places?*/
    if(tpa6130_output_param.callback_opt & AUDIO_DAC_OUT_OF_SAMPLE_CB)
80002e6e:	48 d8       	lddpc	r8,80002ea0 <tpa6130_dac_output+0x54>
80002e70:	70 28       	ld.w	r8,r8[0x8]
80002e72:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002e76:	c0 40       	breq	80002e7e <tpa6130_dac_output+0x32>
      pdca_enable_interrupt_transfer_complete(TPA6130_ABDAC_PDCA_CHANNEL);
80002e78:	30 0c       	mov	r12,0
80002e7a:	f0 1f 00 0b 	mcall	80002ea4 <tpa6130_dac_output+0x58>
    if (tpa6130_output_param.callback_opt & AUDIO_DAC_RELOAD_CB)
80002e7e:	48 98       	lddpc	r8,80002ea0 <tpa6130_dac_output+0x54>
80002e80:	70 28       	ld.w	r8,r8[0x8]
80002e82:	e2 18 00 02 	andl	r8,0x2,COH
80002e86:	c0 60       	breq	80002e92 <tpa6130_dac_output+0x46>
      pdca_enable_interrupt_reload_counter_zero(TPA6130_ABDAC_PDCA_CHANNEL);
80002e88:	30 0c       	mov	r12,0
80002e8a:	f0 1f 00 08 	mcall	80002ea8 <tpa6130_dac_output+0x5c>
80002e8e:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80002e92:	30 1c       	mov	r12,1
  }
  return true;
}
80002e94:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002e98:	80 00       	ld.sh	r0,r0[0x0]
80002e9a:	42 78       	lddsp	r8,sp[0x9c]
80002e9c:	80 00       	ld.sh	r0,r0[0x0]
80002e9e:	42 d8       	lddsp	r8,sp[0xb4]
80002ea0:	00 00       	add	r0,r0
80002ea2:	05 58       	ld.sh	r8,--r2
80002ea4:	80 00       	ld.sh	r0,r0[0x0]
80002ea6:	42 58       	lddsp	r8,sp[0x94]
80002ea8:	80 00       	ld.sh	r0,r0[0x0]
80002eaa:	42 68       	lddsp	r8,sp[0x98]

80002eac <tpa6130_read_data>:
 *  \param reg Register index.
 *  \param shadow Read from device (shadow=false) or from shadowed register
 *  (shadow=true).
 */
static uint8_t tpa6130_read_data(uint8_t reg, bool shadow)
{
80002eac:	d4 01       	pushm	lr
80002eae:	20 6d       	sub	sp,24
  uint8_t data;
  /*If we want to read from the shadowed registers */
  if(shadow)
80002eb0:	58 0b       	cp.w	r11,0
80002eb2:	c0 90       	breq	80002ec4 <tpa6130_read_data+0x18>
  {
    data = *((uint8_t *) &tpa6130_shadow_regs + reg - 1);
80002eb4:	48 d8       	lddpc	r8,80002ee8 <tpa6130_read_data+0x3c>
80002eb6:	f0 0c 00 0c 	add	r12,r8,r12
80002eba:	f9 38 ff ff 	ld.ub	r8,r12[-1]
80002ebe:	fb 68 00 17 	st.b	sp[23],r8
80002ec2:	c0 f8       	rjmp	80002ee0 <tpa6130_read_data+0x34>
      .chip = TPA6130_TWI_ADDRESS,
      .addr_length = 1,//AVR32_TWI_MMR_IADRSZ_ONE_BYTE,
      .addr = reg,
      .buffer = &data,
      .length = sizeof(data)
    };
80002ec4:	36 08       	mov	r8,96
80002ec6:	ba 88       	st.b	sp[0x0],r8
80002ec8:	50 1c       	stdsp	sp[0x4],r12
80002eca:	30 18       	mov	r8,1
80002ecc:	50 28       	stdsp	sp[0x8],r8
80002ece:	fa c9 ff e9 	sub	r9,sp,-23
80002ed2:	50 39       	stdsp	sp[0xc],r9
80002ed4:	50 48       	stdsp	sp[0x10],r8
    twi_master_read(TPA6130_TWI, &twi_package);
80002ed6:	1a 9b       	mov	r11,sp
80002ed8:	fe 7c 2c 00 	mov	r12,-54272
80002edc:	f0 1f 00 04 	mcall	80002eec <tpa6130_read_data+0x40>
  //print_dbg(" = 0x");
  //print_dbg_hex(data);
  //print_dbg("\n");

  return data;
}
80002ee0:	fb 3c 00 17 	ld.ub	r12,sp[23]
80002ee4:	2f ad       	sub	sp,-24
80002ee6:	d8 02       	popm	pc
80002ee8:	00 00       	add	r0,r0
80002eea:	00 08       	add	r8,r0
80002eec:	80 00       	ld.sh	r0,r0[0x0]
80002eee:	47 98       	lddsp	r8,sp[0x1e4]

80002ef0 <tpa6130_powerup>:
  tpa6130_write_data(TPA6130_CONTROL, data | SW_SHUTDOWN);
}
/*! \brief Powers up the amplifier from low power mode.
 */
void tpa6130_powerup(void)
{
80002ef0:	d4 01       	pushm	lr
  uint8_t data;
  data = tpa6130_read_data(TPA6130_CONTROL, TWI_READ_HW);
80002ef2:	30 0b       	mov	r11,0
80002ef4:	30 1c       	mov	r12,1
80002ef6:	f0 1f 00 05 	mcall	80002f08 <tpa6130_powerup+0x18>
  tpa6130_write_data(TPA6130_CONTROL, data & (~SW_SHUTDOWN));
80002efa:	18 9b       	mov	r11,r12
80002efc:	e2 1b 00 fe 	andl	r11,0xfe,COH
80002f00:	30 1c       	mov	r12,1
80002f02:	f0 1f 00 03 	mcall	80002f0c <tpa6130_powerup+0x1c>
}
80002f06:	d8 02       	popm	pc
80002f08:	80 00       	ld.sh	r0,r0[0x0]
80002f0a:	2e ac       	sub	r12,-22
80002f0c:	80 00       	ld.sh	r0,r0[0x0]
80002f0e:	2d cc       	sub	r12,-36

80002f10 <tpa6130_shutdown>:

/*! \brief Shuts down the amplifier and sets it into low power mode.
 *  This is the software low power mode described in the datasheet.
 */
void tpa6130_shutdown(void)
{
80002f10:	d4 01       	pushm	lr
  uint8_t data;
  data = tpa6130_read_data(TPA6130_CONTROL, TWI_READ_HW);
80002f12:	30 0b       	mov	r11,0
80002f14:	30 1c       	mov	r12,1
80002f16:	f0 1f 00 05 	mcall	80002f28 <tpa6130_shutdown+0x18>
  tpa6130_write_data(TPA6130_CONTROL, data | SW_SHUTDOWN);
80002f1a:	18 9b       	mov	r11,r12
80002f1c:	a1 ab       	sbr	r11,0x0
80002f1e:	5c 5b       	castu.b	r11
80002f20:	30 1c       	mov	r12,1
80002f22:	f0 1f 00 03 	mcall	80002f2c <tpa6130_shutdown+0x1c>
}
80002f26:	d8 02       	popm	pc
80002f28:	80 00       	ld.sh	r0,r0[0x0]
80002f2a:	2e ac       	sub	r12,-22
80002f2c:	80 00       	ld.sh	r0,r0[0x0]
80002f2e:	2d cc       	sub	r12,-36

80002f30 <tpa6130_dac_stop>:
/*! \brief Stops the ABDAC and puts the amplifier in low power mode.
 *  Additionally it sets all used pins to the GPIO state.
 *  The counter part of this function is tpa6130_dac_start(...)
 */
void tpa6130_dac_stop(void)
{
80002f30:	d4 01       	pushm	lr
  /* Disable amplifier 1st */
  tpa6130_shutdown();
80002f32:	f0 1f 00 0b 	mcall	80002f5c <tpa6130_dac_stop+0x2c>
  /* Flush the dac */
  // Don't flush the DAC when stop
  //tpa6130_dac_flush();

  /* Disable ABDAC */
  abdac_disable(TPA6130_ABDAC);
80002f36:	fe 7c 40 00 	mov	r12,-49152
80002f3a:	f0 1f 00 0a 	mcall	80002f60 <tpa6130_dac_stop+0x30>

  /* Stop  PDCA */
  pdca_disable(TPA6130_ABDAC_PDCA_CHANNEL);
80002f3e:	30 0c       	mov	r12,0
80002f40:	f0 1f 00 09 	mcall	80002f64 <tpa6130_dac_stop+0x34>

  /* Set used GPIO pins to GPIO state */
  gpio_enable_gpio(TPA6130_ABDAC_GPIO_MAP,
80002f44:	30 4b       	mov	r11,4
80002f46:	48 9c       	lddpc	r12,80002f68 <tpa6130_dac_stop+0x38>
80002f48:	f0 1f 00 09 	mcall	80002f6c <tpa6130_dac_stop+0x3c>
    sizeof(TPA6130_ABDAC_GPIO_MAP)
    / sizeof(TPA6130_ABDAC_GPIO_MAP[0]));

  tpa6130_output_param.num_channels = 0;
80002f4c:	48 98       	lddpc	r8,80002f70 <tpa6130_dac_stop+0x40>
80002f4e:	30 09       	mov	r9,0
80002f50:	b0 89       	st.b	r8[0x0],r9
  tpa6130_output_param.callback     = NULL;
80002f52:	30 09       	mov	r9,0
80002f54:	91 19       	st.w	r8[0x4],r9
  tpa6130_output_param.callback_opt = 0;
80002f56:	91 29       	st.w	r8[0x8],r9
}
80002f58:	d8 02       	popm	pc
80002f5a:	00 00       	add	r0,r0
80002f5c:	80 00       	ld.sh	r0,r0[0x0]
80002f5e:	2f 10       	sub	r0,-15
80002f60:	80 00       	ld.sh	r0,r0[0x0]
80002f62:	3c 10       	mov	r0,-63
80002f64:	80 00       	ld.sh	r0,r0[0x0]
80002f66:	42 38       	lddsp	r8,sp[0x8c]
80002f68:	80 00       	ld.sh	r0,r0[0x0]
80002f6a:	cc 18       	rjmp	800030ec <et024006_SetLimits+0x2c>
80002f6c:	80 00       	ld.sh	r0,r0[0x0]
80002f6e:	40 f4       	lddsp	r4,sp[0x3c]
80002f70:	00 00       	add	r0,r0
80002f72:	05 58       	ld.sh	r8,--r2

80002f74 <tpa6130_init>:
 *  specified in the conf_tpa6130.h file (stereo, mono ..).
 *
 *  \returns A positive value upon success and a negative value upon failure.
 */
int8_t tpa6130_init(void)
{
80002f74:	d4 01       	pushm	lr
  /* Check if the device responds on the TWI bus*/
  if(twi_probe(TPA6130_TWI, TPA6130_TWI_ADDRESS) != TWI_SUCCESS)
80002f76:	36 0b       	mov	r11,96
80002f78:	fe 7c 2c 00 	mov	r12,-54272
80002f7c:	f0 1f 00 0e 	mcall	80002fb4 <tpa6130_init+0x40>
80002f80:	c0 40       	breq	80002f88 <tpa6130_init+0x14>
80002f82:	e0 6c 00 fd 	mov	r12,253
80002f86:	d8 02       	popm	pc
  return TWI_NO_CHIP_FOUND;
  /* If the device has no valid version we can not use it */
  if(tpa6130_read_data(TPA6130_I2C_ADDRESS_VERSION, TWI_READ_HW)!= VERSION)
80002f88:	30 0b       	mov	r11,0
80002f8a:	30 4c       	mov	r12,4
80002f8c:	f0 1f 00 0b 	mcall	80002fb8 <tpa6130_init+0x44>
80002f90:	30 28       	mov	r8,2
80002f92:	f0 0c 18 00 	cp.b	r12,r8
80002f96:	c0 40       	breq	80002f9e <tpa6130_init+0x2a>
80002f98:	e0 6c 00 f8 	mov	r12,248
80002f9c:	d8 02       	popm	pc
  {
    return -8;
  }
  /* un-mute the output channels, the volume is still 0 and
   * should be increased by an application (fade-in/fade-out) */
  tpa6130_write_data(TPA6130_VOLUME_AND_MUTE, tpa6130_shadow_regs.volume_and_mute);
80002f9e:	48 88       	lddpc	r8,80002fbc <tpa6130_init+0x48>
80002fa0:	11 9b       	ld.ub	r11,r8[0x1]
80002fa2:	30 2c       	mov	r12,2
80002fa4:	f0 1f 00 07 	mcall	80002fc0 <tpa6130_init+0x4c>
  /* set stereo/mono mode and enable both amplifiers (left/right) */
  tpa6130_write_data(TPA6130_CONTROL,(TPA6130_MODE << 4) | HP_EN_L | HP_EN_R);
80002fa8:	e0 6b 00 c0 	mov	r11,192
80002fac:	30 1c       	mov	r12,1
80002fae:	f0 1f 00 05 	mcall	80002fc0 <tpa6130_init+0x4c>
80002fb2:	d8 0a       	popm	pc,r12=0
80002fb4:	80 00       	ld.sh	r0,r0[0x0]
80002fb6:	47 70       	lddsp	r0,sp[0x1dc]
80002fb8:	80 00       	ld.sh	r0,r0[0x0]
80002fba:	2e ac       	sub	r12,-22
80002fbc:	00 00       	add	r0,r0
80002fbe:	00 08       	add	r8,r0
80002fc0:	80 00       	ld.sh	r0,r0[0x0]
80002fc2:	2d cc       	sub	r12,-36

80002fc4 <tpa6130_dac_setup>:
                       uint8_t bits_per_sample,
                       bool swap_channels,
                       void (*callback)(uint32_t arg),
                       uint32_t callback_opt,
                       uint32_t pba_hz)
{
80002fc4:	eb cd 40 c0 	pushm	r6-r7,lr
80002fc8:	20 6d       	sub	sp,24
80002fca:	18 97       	mov	r7,r12
80002fcc:	12 96       	mov	r6,r9
80002fce:	40 9a       	lddsp	r10,sp[0x24]
  // save input parameters to local driver data
  tpa6130_output_param.num_channels = num_channels;
80002fd0:	49 a9       	lddpc	r9,80003038 <tpa6130_dac_setup+0x74>
80002fd2:	b2 8b       	st.b	r9[0x0],r11
  tpa6130_output_param.callback     = callback;
80002fd4:	93 18       	st.w	r9[0x4],r8
  tpa6130_output_param.callback_opt = callback_opt;
80002fd6:	93 2a       	st.w	r9[0x8],r10

  /* Probe for amplifier and initialize it */
  tpa6130_init();
80002fd8:	f0 1f 00 19 	mcall	8000303c <tpa6130_dac_setup+0x78>
   * The generic clock input must be greater than 256*sample_rate_hz
   * or the setup of the ABDAC will fail silently here.
   * TODO we could add asserts here to detect wrong settings during
   * compile time.
   */
  if(!abdac_set_dac_sample_rate(sample_rate_hz)) {
80002fdc:	0e 9c       	mov	r12,r7
80002fde:	f0 1f 00 19 	mcall	80003040 <tpa6130_dac_setup+0x7c>
80002fe2:	c0 a1       	brne	80002ff6 <tpa6130_dac_setup+0x32>
    // if it is not possible to set correctly the sample rate
    // Use default set function
    abdac_set_dac_hz(TPA6130_ABDAC, TPA6130_ABDAC_GCLK_INPUT_HZ,sample_rate_hz);
80002fe4:	0e 9a       	mov	r10,r7
80002fe6:	e0 6b 1b 00 	mov	r11,6912
80002fea:	ea 1b 00 b7 	orh	r11,0xb7
80002fee:	fe 7c 40 00 	mov	r12,-49152
80002ff2:	f0 1f 00 15 	mcall	80003044 <tpa6130_dac_setup+0x80>
  }
#endif

  if(swap_channels)
80002ff6:	58 06       	cp.w	r6,0
80002ff8:	c0 50       	breq	80003002 <tpa6130_dac_setup+0x3e>
  {
    abdac_swap_channels(TPA6130_ABDAC);
80002ffa:	fe 7c 40 00 	mov	r12,-49152
80002ffe:	f0 1f 00 13 	mcall	80003048 <tpa6130_dac_setup+0x84>
  }
  abdac_enable(TPA6130_ABDAC);
80003002:	fe 7c 40 00 	mov	r12,-49152
80003006:	f0 1f 00 12 	mcall	8000304c <tpa6130_dac_setup+0x88>
    .size   = 0,
    .r_addr   = 0,
    .r_size   = 0,
    .pid    = TPA6130_ABDAC_PDCA_PID,
    .transfer_size  = PDCA_TRANSFER_SIZE_WORD
  };
8000300a:	49 28       	lddpc	r8,80003050 <tpa6130_dac_setup+0x8c>
8000300c:	1a 9b       	mov	r11,sp
8000300e:	f0 e6 00 00 	ld.d	r6,r8[0]
80003012:	fa e7 00 00 	st.d	sp[0],r6
80003016:	f0 e6 00 08 	ld.d	r6,r8[8]
8000301a:	fa e7 00 08 	st.d	sp[8],r6
8000301e:	f0 e8 00 10 	ld.d	r8,r8[16]
80003022:	fa e9 00 10 	st.d	sp[16],r8

  /* Initialize the PCDA for the ABDAC
   * The channel number can be set in the configuration file
   * with the define TPA6130_ABDAC_PDCA_CHANNEL.
   */
  pdca_init_channel(TPA6130_ABDAC_PDCA_CHANNEL,
80003026:	30 0c       	mov	r12,0
80003028:	f0 1f 00 0b 	mcall	80003054 <tpa6130_dac_setup+0x90>
    &tpa6130_abdac_pdca_options);
  /* Enable the PDCA channel. Since we did not provide any data
   * yet the channel is in idle mode */
  pdca_enable(TPA6130_ABDAC_PDCA_CHANNEL);
8000302c:	30 0c       	mov	r12,0
8000302e:	f0 1f 00 0b 	mcall	80003058 <tpa6130_dac_setup+0x94>

}
80003032:	2f ad       	sub	sp,-24
80003034:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003038:	00 00       	add	r0,r0
8000303a:	05 58       	ld.sh	r8,--r2
8000303c:	80 00       	ld.sh	r0,r0[0x0]
8000303e:	2f 74       	sub	r4,-9
80003040:	80 00       	ld.sh	r0,r0[0x0]
80003042:	3c bc       	mov	r12,-53
80003044:	80 00       	ld.sh	r0,r0[0x0]
80003046:	3c 3e       	mov	lr,-61
80003048:	80 00       	ld.sh	r0,r0[0x0]
8000304a:	3c 26       	mov	r6,-62
8000304c:	80 00       	ld.sh	r0,r0[0x0]
8000304e:	3b fc       	mov	r12,-65
80003050:	80 00       	ld.sh	r0,r0[0x0]
80003052:	cc 00       	breq	80002fd2 <tpa6130_dac_setup+0xe>
80003054:	80 00       	ld.sh	r0,r0[0x0]
80003056:	43 10       	lddsp	r0,sp[0xc4]
80003058:	80 00       	ld.sh	r0,r0[0x0]
8000305a:	42 48       	lddsp	r8,sp[0x90]

8000305c <tpa6130_dac_start>:
                       uint8_t bits_per_sample,
                       bool swap_channels,
                       void (*callback)(uint32_t arg),
                       uint32_t callback_opt,
                       uint32_t pba_hz)
{
8000305c:	eb cd 40 fe 	pushm	r1-r7,lr
80003060:	fa c4 ff e0 	sub	r4,sp,-32
80003064:	18 92       	mov	r2,r12
80003066:	16 93       	mov	r3,r11
80003068:	14 95       	mov	r5,r10
8000306a:	12 97       	mov	r7,r9
8000306c:	10 96       	mov	r6,r8
8000306e:	68 01       	ld.w	r1,r4[0x0]
80003070:	68 14       	ld.w	r4,r4[0x4]
  /* stop ABDAC if running*/
  tpa6130_dac_stop();
80003072:	f0 1f 00 0d 	mcall	800030a4 <tpa6130_dac_start+0x48>

  /* configure used pins for ABDAC */
  gpio_enable_module(TPA6130_ABDAC_GPIO_MAP,
80003076:	30 4b       	mov	r11,4
80003078:	48 cc       	lddpc	r12,800030a8 <tpa6130_dac_start+0x4c>
8000307a:	f0 1f 00 0d 	mcall	800030ac <tpa6130_dac_start+0x50>
    sizeof(TPA6130_ABDAC_GPIO_MAP) /
    sizeof(TPA6130_ABDAC_GPIO_MAP[0]));

  /* configure and start PDC and ABDAC*/
  tpa6130_dac_setup(sample_rate_hz,
8000307e:	1a d4       	st.w	--sp,r4
80003080:	1a d1       	st.w	--sp,r1
80003082:	0c 98       	mov	r8,r6
80003084:	0e 99       	mov	r9,r7
80003086:	0a 9a       	mov	r10,r5
80003088:	06 9b       	mov	r11,r3
8000308a:	04 9c       	mov	r12,r2
8000308c:	f0 1f 00 09 	mcall	800030b0 <tpa6130_dac_start+0x54>
    pba_hz);

  /* Register a interrupt service routine for the ABDAC channel of
   * the PDCA
   */
  irq_register_handler(tpa6130_abdac_tx_pdca_int_handler, TPA6130_ABDAC_PDCA_IRQ, 1);
80003090:	30 1a       	mov	r10,1
80003092:	36 0b       	mov	r11,96
80003094:	48 8c       	lddpc	r12,800030b4 <tpa6130_dac_start+0x58>
80003096:	f0 1f 00 09 	mcall	800030b8 <tpa6130_dac_start+0x5c>

  tpa6130_powerup();
8000309a:	f0 1f 00 09 	mcall	800030bc <tpa6130_dac_start+0x60>
8000309e:	2f ed       	sub	sp,-8

}
800030a0:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800030a4:	80 00       	ld.sh	r0,r0[0x0]
800030a6:	2f 30       	sub	r0,-13
800030a8:	80 00       	ld.sh	r0,r0[0x0]
800030aa:	cc 18       	rjmp	8000322c <et024006_PrintString+0xa4>
800030ac:	80 00       	ld.sh	r0,r0[0x0]
800030ae:	40 ac       	lddsp	r12,sp[0x28]
800030b0:	80 00       	ld.sh	r0,r0[0x0]
800030b2:	2f c4       	sub	r4,-4
800030b4:	80 00       	ld.sh	r0,r0[0x0]
800030b6:	2d 6c       	sub	r12,-42
800030b8:	80 00       	ld.sh	r0,r0[0x0]
800030ba:	41 6c       	lddsp	r12,sp[0x58]
800030bc:	80 00       	ld.sh	r0,r0[0x0]
800030be:	2e f0       	sub	r0,-17

800030c0 <et024006_SetLimits>:
/*! \brief Sets the display limits according to the corner coordinates.
 *  Writing to the display will result in writing to the area specified through
 *  this function.
 */
void et024006_SetLimits( uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2 )
{
800030c0:	eb cd 40 80 	pushm	r7,lr

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800030c4:	fc 1e c0 00 	movh	lr,0xc000
800030c8:	30 28       	mov	r8,2
800030ca:	bc 08       	st.h	lr[0x0],r8
  *ET024006_PARAM_ADDR = (uint16_t) value;
800030cc:	ef dc c1 08 	bfextu	r7,r12,0x8,0x8
800030d0:	fc 18 c0 20 	movh	r8,0xc020
800030d4:	b0 07       	st.h	r8[0x0],r7

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800030d6:	30 37       	mov	r7,3
800030d8:	bc 07       	st.h	lr[0x0],r7
  *ET024006_PARAM_ADDR = (uint16_t) value;
800030da:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800030dc:	30 4c       	mov	r12,4
800030de:	bc 0c       	st.h	lr[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
800030e0:	f9 da c1 08 	bfextu	r12,r10,0x8,0x8
800030e4:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800030e6:	30 5c       	mov	r12,5
800030e8:	bc 0c       	st.h	lr[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
800030ea:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800030ec:	30 6a       	mov	r10,6
800030ee:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800030f0:	f5 db c1 08 	bfextu	r10,r11,0x8,0x8
800030f4:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800030f6:	30 7a       	mov	r10,7
800030f8:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800030fa:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800030fc:	30 8a       	mov	r10,8
800030fe:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003100:	f5 d9 c1 08 	bfextu	r10,r9,0x8,0x8
80003104:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003106:	30 9a       	mov	r10,9
80003108:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000310a:	b0 09       	st.h	r8[0x0],r9
  et024006_WriteRegister( HIMAX_COL_ADDR_END1, (x2 & 0xff) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START2, (y1 >> 8) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START1, (y1 & 0xff) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_END2, (y2 >> 8) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_END1, (y2 & 0xff) );
}
8000310c:	e3 cd 80 80 	ldm	sp++,r7,pc

80003110 <et024006_DrawPixel>:
  return color;
}


void et024006_DrawPixel( uint16_t x, uint16_t y, et024006_color_t color )
{
80003110:	eb cd 40 80 	pushm	r7,lr
80003114:	14 97       	mov	r7,r10
  // Sanity check on parameters.
  Assert( x < ET024006_WIDTH );
  Assert( y < ET024006_HEIGHT );

  // Set up draw area and write the two bytes of pixel data.
  et024006_SetLimits( x, y, x, y );
80003116:	5c 7b       	castu.h	r11
80003118:	5c 7c       	castu.h	r12
8000311a:	16 99       	mov	r9,r11
8000311c:	18 9a       	mov	r10,r12
8000311e:	f0 1f 00 06 	mcall	80003134 <et024006_DrawPixel+0x24>
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003122:	32 29       	mov	r9,34
80003124:	fc 18 c0 00 	movh	r8,0xc000
80003128:	b0 09       	st.h	r8[0x0],r9
  et024006_SendSPI( ET024006_ID | ET024006_BS0 | ET024006_RS );
  et024006_SendSPI( color & 0xff );
  et024006_SendSPI( color >> 8 );
  et024006_DeselectSPI();
#else
  *ET024006_PARAM_ADDR = color;
8000312a:	fc 18 c0 20 	movh	r8,0xc020
8000312e:	b0 07       	st.h	r8[0x0],r7
#endif
}
80003130:	e3 cd 80 80 	ldm	sp++,r7,pc
80003134:	80 00       	ld.sh	r0,r0[0x0]
80003136:	30 c0       	mov	r0,12

80003138 <et024006_SetQuickLimits>:

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003138:	fc 19 c0 00 	movh	r9,0xc000
8000313c:	30 28       	mov	r8,2
8000313e:	b2 08       	st.h	r9[0x0],r8
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003140:	f5 dc c1 08 	bfextu	r10,r12,0x8,0x8
80003144:	fc 18 c0 20 	movh	r8,0xc020
80003148:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000314a:	30 3a       	mov	r10,3
8000314c:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000314e:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003150:	30 6a       	mov	r10,6
80003152:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003154:	f5 db c1 08 	bfextu	r10,r11,0x8,0x8
80003158:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000315a:	30 7a       	mov	r10,7
8000315c:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000315e:	b0 0b       	st.h	r8[0x0],r11
{
  et024006_WriteRegister( HIMAX_COL_ADDR_START2, (x >> 8) );
  et024006_WriteRegister( HIMAX_COL_ADDR_START1, (x & 0xff) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START2, (y >> 8) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START1, (y & 0xff) );
}
80003160:	5e fc       	retal	r12
80003162:	d7 03       	nop

80003164 <et024006_DrawQuickPixel>:
  et024006_WriteRegister( HIMAX_ROW_ADDR_END1, (y & 0xff) );
}


void et024006_DrawQuickPixel( uint16_t x, uint16_t y, et024006_color_t color )
{
80003164:	eb cd 40 80 	pushm	r7,lr
80003168:	14 97       	mov	r7,r10
  // Sanity check on parameters.
  Assert( x < ET024006_WIDTH );
  Assert( y < ET024006_HEIGHT );

  // Set up draw area and write the two bytes of pixel data.
  et024006_SetQuickLimits( x, y );
8000316a:	5c 7b       	castu.h	r11
8000316c:	5c 7c       	castu.h	r12
8000316e:	f0 1f 00 06 	mcall	80003184 <et024006_DrawQuickPixel+0x20>
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003172:	32 29       	mov	r9,34
80003174:	fc 18 c0 00 	movh	r8,0xc000
80003178:	b0 09       	st.h	r8[0x0],r9
  et024006_SendSPI( color & 0xff );
  et024006_SendSPI( color >> 8 );
  et024006_DeselectSPI();
#endif
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  *ET024006_PARAM_ADDR = color;
8000317a:	fc 18 c0 20 	movh	r8,0xc020
8000317e:	b0 07       	st.h	r8[0x0],r7
#endif

}
80003180:	e3 cd 80 80 	ldm	sp++,r7,pc
80003184:	80 00       	ld.sh	r0,r0[0x0]
80003186:	31 38       	mov	r8,19

80003188 <et024006_PrintString>:
void et024006_PrintString(char *lcd_string, const unsigned char *font_style,
                          uint16_t x,
                          uint16_t y,
                          uint16_t fcolor,
                          int bcolor)
{
80003188:	d4 31       	pushm	r0-r7,lr
8000318a:	20 dd       	sub	sp,52
8000318c:	18 97       	mov	r7,r12
8000318e:	50 6b       	stdsp	sp[0x18],r11
80003190:	50 8a       	stdsp	sp[0x20],r10
80003192:	50 29       	stdsp	sp[0x8],r9
80003194:	10 94       	mov	r4,r8
80003196:	41 63       	lddsp	r3,sp[0x58]
  unsigned char mask = 0, xfont, yfont, font_size;
  const unsigned char *data;
  uint16_t saved_x = x;

  // if string is empty there is nothing to do
  if( *lcd_string == '\0')
80003198:	19 89       	ld.ub	r9,r12[0x0]
8000319a:	30 08       	mov	r8,0
8000319c:	f0 09 18 00 	cp.b	r9,r8
800031a0:	e0 80 01 0c 	breq	800033b8 <et024006_PrintString+0x230>
    return;

  data = font_style;  // point to the start of the font table
  xfont = *data;  // get font x width
800031a4:	16 98       	mov	r8,r11
800031a6:	11 3a       	ld.ub	r10,r8++
800031a8:	50 4a       	stdsp	sp[0x10],r10
  data++;
  yfont = *data;  // get font y length
800031aa:	11 89       	ld.ub	r9,r8[0x0]
800031ac:	50 39       	stdsp	sp[0xc],r9
  data++;
  font_size = *data;  // get data bytes per font
800031ae:	11 98       	ld.ub	r8,r8[0x1]
800031b0:	50 58       	stdsp	sp[0x14],r8

  // If transparent mode
  if(bcolor == -1)
800031b2:	5b f3       	cp.w	r3,-1
800031b4:	e0 81 00 8d 	brne	800032ce <et024006_PrintString+0x146>
  {
    // set window to display size
    et024006_SetLimits( 0, 0, ET024006_WIDTH - 1, ET024006_HEIGHT - 1 );
800031b8:	e0 69 00 ef 	mov	r9,239
800031bc:	e0 6a 01 3f 	mov	r10,319
800031c0:	30 0b       	mov	r11,0
800031c2:	16 9c       	mov	r12,r11
800031c4:	f0 1f 00 7e 	mcall	800033bc <et024006_PrintString+0x234>
        data =  (font_style + font_size) +  // header offset
          (font_size * (int)(*lcd_string - 32)); // character select
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;
800031c8:	40 58       	lddsp	r8,sp[0x14]
800031ca:	50 c8       	stdsp	sp[0x30],r8
800031cc:	f0 08 00 18 	add	r8,r8,r8<<0x1
800031d0:	a5 78       	lsl	r8,0x5
800031d2:	40 69       	lddsp	r9,sp[0x18]
800031d4:	10 09       	add	r9,r8
800031d6:	50 b9       	stdsp	sp[0x2c],r9
800031d8:	ee c8 ff ff 	sub	r8,r7,-1
800031dc:	50 98       	stdsp	sp[0x24],r8
800031de:	40 8a       	lddsp	r10,sp[0x20]
800031e0:	5c 8a       	casts.h	r10
800031e2:	50 aa       	stdsp	sp[0x28],r10
      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
        {
          if (*data & mask) // if pixel data then put dot
800031e4:	30 03       	mov	r3,0
          {
            et024006_DrawQuickPixel( col, row, fcolor );
800031e6:	08 90       	mov	r0,r4
800031e8:	5c 70       	castu.h	r0
    // set window to display size
    et024006_SetLimits( 0, 0, ET024006_WIDTH - 1, ET024006_HEIGHT - 1 );

    do
    {
      if(*lcd_string =='\n') {
800031ea:	40 99       	lddsp	r9,sp[0x24]
800031ec:	f3 38 ff ff 	ld.ub	r8,r9[-1]
800031f0:	30 aa       	mov	r10,10
800031f2:	f4 08 18 00 	cp.b	r8,r10
800031f6:	c0 b1       	brne	8000320c <et024006_PrintString+0x84>
        x = saved_x;
        y += yfont;
800031f8:	40 28       	lddsp	r8,sp[0x8]
800031fa:	40 39       	lddsp	r9,sp[0xc]
800031fc:	12 08       	add	r8,r9
800031fe:	5c 88       	casts.h	r8
80003200:	50 28       	stdsp	sp[0x8],r8
80003202:	40 98       	lddsp	r8,sp[0x24]
80003204:	40 8a       	lddsp	r10,sp[0x20]
80003206:	5c 8a       	casts.h	r10
80003208:	50 aa       	stdsp	sp[0x28],r10
        lcd_string++;  // next character in string
        continue;
8000320a:	c5 a8       	rjmp	800032be <et024006_PrintString+0x136>
      } else if(*lcd_string =='\t') {
8000320c:	30 99       	mov	r9,9
8000320e:	f2 08 18 00 	cp.b	r8,r9
80003212:	c0 81       	brne	80003222 <et024006_PrintString+0x9a>
        x += xfont;
80003214:	40 a8       	lddsp	r8,sp[0x28]
80003216:	40 49       	lddsp	r9,sp[0x10]
80003218:	12 08       	add	r8,r9
8000321a:	5c 88       	casts.h	r8
8000321c:	50 a8       	stdsp	sp[0x28],r8
8000321e:	40 98       	lddsp	r8,sp[0x24]
        lcd_string++;  // next character in string
        continue;
80003220:	c4 f8       	rjmp	800032be <et024006_PrintString+0x136>
      }
      // Checks if the character can be printed
      if (*lcd_string >= 32 && *lcd_string < (32 + 96))
80003222:	f0 ca 00 20 	sub	r10,r8,32
80003226:	35 f9       	mov	r9,95
80003228:	f2 0a 18 00 	cp.b	r10,r9
8000322c:	e0 88 00 04 	brls	80003234 <et024006_PrintString+0xac>
80003230:	40 b5       	lddsp	r5,sp[0x2c]
80003232:	c0 a8       	rjmp	80003246 <et024006_PrintString+0xbe>
      {
        // point to character data in font table
        data =  (font_style + font_size) +  // header offset
80003234:	22 08       	sub	r8,32
80003236:	40 ca       	lddsp	r10,sp[0x30]
80003238:	f0 0a 02 45 	mul	r5,r8,r10
8000323c:	40 59       	lddsp	r9,sp[0x14]
8000323e:	12 05       	add	r5,r9
80003240:	40 68       	lddsp	r8,sp[0x18]
80003242:	f0 05 00 05 	add	r5,r8,r5
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
80003246:	40 22       	lddsp	r2,sp[0x8]
80003248:	5c 72       	castu.h	r2
8000324a:	40 3a       	lddsp	r10,sp[0xc]
8000324c:	e4 0a 00 0a 	add	r10,r2,r10
80003250:	50 1a       	stdsp	sp[0x4],r10
80003252:	04 3a       	cp.w	r10,r2
80003254:	e0 8a 00 2f 	brle	800032b2 <et024006_PrintString+0x12a>
80003258:	40 21       	lddsp	r1,sp[0x8]
8000325a:	5c 81       	casts.h	r1
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
8000325c:	40 a9       	lddsp	r9,sp[0x28]
8000325e:	5c 79       	castu.h	r9
80003260:	50 09       	stdsp	sp[0x0],r9
80003262:	12 94       	mov	r4,r9
80003264:	40 48       	lddsp	r8,sp[0x10]
80003266:	10 04       	add	r4,r8
80003268:	40 aa       	lddsp	r10,sp[0x28]
8000326a:	5c 8a       	casts.h	r10
8000326c:	50 7a       	stdsp	sp[0x1c],r10
8000326e:	c1 b8       	rjmp	800032a4 <et024006_PrintString+0x11c>
        {
          if (*data & mask) // if pixel data then put dot
          {
            et024006_DrawQuickPixel( col, row, fcolor );
          }
          mask >>= 1;
80003270:	a1 96       	lsr	r6,0x1
      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
        {
          if (*data & mask) // if pixel data then put dot
80003272:	0b 88       	ld.ub	r8,r5[0x0]
80003274:	ed e8 00 08 	and	r8,r6,r8
80003278:	e6 08 18 00 	cp.b	r8,r3
8000327c:	c0 50       	breq	80003286 <et024006_PrintString+0xfe>
          {
            et024006_DrawQuickPixel( col, row, fcolor );
8000327e:	00 9a       	mov	r10,r0
80003280:	04 9b       	mov	r11,r2
80003282:	f0 1f 00 50 	mcall	800033c0 <et024006_PrintString+0x238>
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
80003286:	2f f7       	sub	r7,-1
80003288:	5c 87       	casts.h	r7
8000328a:	0e 9c       	mov	r12,r7
8000328c:	5c 7c       	castu.h	r12
8000328e:	08 3c       	cp.w	r12,r4
80003290:	cf 05       	brlt	80003270 <et024006_PrintString+0xe8>
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
80003292:	2f f1       	sub	r1,-1
80003294:	5c 81       	casts.h	r1
80003296:	e5 d1 c0 10 	bfextu	r2,r1,0x0,0x10
8000329a:	40 19       	lddsp	r9,sp[0x4]
8000329c:	04 39       	cp.w	r9,r2
8000329e:	e0 8a 00 0a 	brle	800032b2 <et024006_PrintString+0x12a>
            et024006_DrawQuickPixel( col, row, fcolor );
          }
          mask >>= 1;
        }
        // Next row data
        data++;
800032a2:	2f f5       	sub	r5,-1
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
800032a4:	40 0c       	lddsp	r12,sp[0x0]
800032a6:	08 3c       	cp.w	r12,r4
800032a8:	cf 54       	brge	80003292 <et024006_PrintString+0x10a>
800032aa:	40 77       	lddsp	r7,sp[0x1c]
800032ac:	e0 66 00 80 	mov	r6,128
800032b0:	ce 1b       	rjmp	80003272 <et024006_PrintString+0xea>
        }
        // Next row data
        data++;
      }
      // move to next character start pixel
      x += xfont;
800032b2:	40 a8       	lddsp	r8,sp[0x28]
800032b4:	40 4a       	lddsp	r10,sp[0x10]
800032b6:	14 08       	add	r8,r10
800032b8:	5c 88       	casts.h	r8
800032ba:	50 a8       	stdsp	sp[0x28],r8
800032bc:	40 98       	lddsp	r8,sp[0x24]
800032be:	40 99       	lddsp	r9,sp[0x24]
800032c0:	2f f9       	sub	r9,-1
800032c2:	50 99       	stdsp	sp[0x24],r9
      lcd_string++;  // next character in string

    }while(*lcd_string !='\0');  // keep spitting chars out until end of string
800032c4:	11 88       	ld.ub	r8,r8[0x0]
800032c6:	e6 08 18 00 	cp.b	r8,r3
800032ca:	c9 01       	brne	800031ea <et024006_PrintString+0x62>
800032cc:	c7 68       	rjmp	800033b8 <et024006_PrintString+0x230>
800032ce:	f8 c8 ff ff 	sub	r8,r12,-1
800032d2:	50 08       	stdsp	sp[0x0],r8
800032d4:	40 8c       	lddsp	r12,sp[0x20]
800032d6:	5c 8c       	casts.h	r12
      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
        {
          if (*data & mask) // if pixel data then put dot
800032d8:	30 06       	mov	r6,0
          {
            *ET024006_PARAM_ADDR = fcolor;
          }
          else  // else use background color
          {
            *ET024006_PARAM_ADDR = bcolor;
800032da:	5c 83       	casts.h	r3
800032dc:	fc 15 c0 20 	movh	r5,0xc020
  }
  else
  {
    do
    {
      if(*lcd_string =='\n') {
800032e0:	40 0a       	lddsp	r10,sp[0x0]
800032e2:	f5 31 ff ff 	ld.ub	r1,r10[-1]
800032e6:	30 a8       	mov	r8,10
800032e8:	f0 01 18 00 	cp.b	r1,r8
800032ec:	c0 b1       	brne	80003302 <et024006_PrintString+0x17a>
        x = saved_x;
        y += yfont;
800032ee:	40 28       	lddsp	r8,sp[0x8]
800032f0:	40 39       	lddsp	r9,sp[0xc]
800032f2:	12 08       	add	r8,r9
800032f4:	5c 88       	casts.h	r8
800032f6:	50 28       	stdsp	sp[0x8],r8
800032f8:	14 98       	mov	r8,r10
800032fa:	40 8a       	lddsp	r10,sp[0x20]
800032fc:	5c 8a       	casts.h	r10
800032fe:	50 1a       	stdsp	sp[0x4],r10
        lcd_string++;  // next character in string
        continue;
80003300:	c5 28       	rjmp	800033a4 <et024006_PrintString+0x21c>
      } else if(*lcd_string =='\t') {
80003302:	30 98       	mov	r8,9
80003304:	f0 01 18 00 	cp.b	r1,r8
80003308:	c0 71       	brne	80003316 <et024006_PrintString+0x18e>
        x += xfont;
8000330a:	40 49       	lddsp	r9,sp[0x10]
8000330c:	12 0c       	add	r12,r9
8000330e:	5c 8c       	casts.h	r12
80003310:	50 1c       	stdsp	sp[0x4],r12
80003312:	40 08       	lddsp	r8,sp[0x0]
        lcd_string++;  // next character in string
        continue;
80003314:	c4 88       	rjmp	800033a4 <et024006_PrintString+0x21c>
      // point to character data in font table
      data =  (font_style + font_size) +  // header offset
        (font_size * (int)(*lcd_string - 32)); // character select

      // set a window for the character
      et024006_SetLimits( x, y, x + xfont - 1, y + yfont - 1 );
80003316:	40 32       	lddsp	r2,sp[0xc]
80003318:	40 47       	lddsp	r7,sp[0x10]
8000331a:	f8 07 00 08 	add	r8,r12,r7
8000331e:	5c 88       	casts.h	r8
80003320:	50 18       	stdsp	sp[0x4],r8
80003322:	04 99       	mov	r9,r2
80003324:	20 19       	sub	r9,1
80003326:	40 28       	lddsp	r8,sp[0x8]
80003328:	10 09       	add	r9,r8
8000332a:	40 1a       	lddsp	r10,sp[0x4]
8000332c:	20 1a       	sub	r10,1
8000332e:	5c 79       	castu.h	r9
80003330:	5c 7a       	castu.h	r10
80003332:	10 9b       	mov	r11,r8
80003334:	5c 7b       	castu.h	r11
80003336:	5c 7c       	castu.h	r12
80003338:	f0 1f 00 21 	mcall	800033bc <et024006_PrintString+0x234>
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000333c:	32 29       	mov	r9,34
8000333e:	fc 18 c0 00 	movh	r8,0xc000
80003342:	b0 09       	st.h	r8[0x0],r9

      // set a window for the character
      et024006_SetLimits( x, y, x + xfont - 1, y + yfont - 1 );
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
80003344:	40 3a       	lddsp	r10,sp[0xc]
80003346:	58 0a       	cp.w	r10,0
80003348:	c2 d0       	breq	800033a2 <et024006_PrintString+0x21a>
        x += xfont;
        lcd_string++;  // next character in string
        continue;
      }
      // point to character data in font table
      data =  (font_style + font_size) +  // header offset
8000334a:	e2 ce 00 20 	sub	lr,r1,32
8000334e:	40 59       	lddsp	r9,sp[0x14]
80003350:	f2 0e 02 4e 	mul	lr,r9,lr
80003354:	12 0e       	add	lr,r9
80003356:	40 68       	lddsp	r8,sp[0x18]
80003358:	f0 0e 00 0e 	add	lr,r8,lr
8000335c:	30 0c       	mov	r12,0
      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
        {
          if (*data & mask) // if pixel data then put dot
8000335e:	e0 60 00 80 	mov	r0,128
80003362:	18 91       	mov	r1,r12
80003364:	c1 98       	rjmp	80003396 <et024006_PrintString+0x20e>
          }
          else  // else use background color
          {
            *ET024006_PARAM_ADDR = bcolor;
          }
          mask >>= 1;
80003366:	a1 99       	lsr	r9,0x1
      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
        {
          if (*data & mask) // if pixel data then put dot
80003368:	f3 eb 00 0a 	and	r10,r9,r11
          {
            *ET024006_PARAM_ADDR = fcolor;
8000336c:	ec 0a 18 00 	cp.b	r10,r6
80003370:	e8 0a 17 10 	movne	r10,r4
80003374:	eb fa 1c 00 	st.hne	r5[0x0],r10
          }
          else  // else use background color
          {
            *ET024006_PARAM_ADDR = bcolor;
80003378:	eb f3 0c 00 	st.heq	r5[0x0],r3
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
8000337c:	2f f8       	sub	r8,-1
8000337e:	5c 88       	casts.h	r8
80003380:	f0 07 19 00 	cp.h	r7,r8
80003384:	fe 9b ff f1 	brhi	80003366 <et024006_PrintString+0x1de>

      // set a window for the character
      et024006_SetLimits( x, y, x + xfont - 1, y + yfont - 1 );
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
80003388:	2f fc       	sub	r12,-1
8000338a:	5c 8c       	casts.h	r12
8000338c:	f8 02 19 00 	cp.h	r2,r12
80003390:	e0 88 00 09 	brls	800033a2 <et024006_PrintString+0x21a>
          }
          mask >>= 1;
        }

        // Next row data
        data++;
80003394:	2f fe       	sub	lr,-1
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
80003396:	58 07       	cp.w	r7,0
80003398:	cf 80       	breq	80003388 <et024006_PrintString+0x200>
        {
          if (*data & mask) // if pixel data then put dot
8000339a:	1d 8b       	ld.ub	r11,lr[0x0]
8000339c:	00 99       	mov	r9,r0
8000339e:	02 98       	mov	r8,r1
800033a0:	ce 4b       	rjmp	80003368 <et024006_PrintString+0x1e0>
800033a2:	40 08       	lddsp	r8,sp[0x0]
800033a4:	40 09       	lddsp	r9,sp[0x0]
800033a6:	2f f9       	sub	r9,-1
800033a8:	50 09       	stdsp	sp[0x0],r9
      }
      // move to next character start pixel
      x += xfont;
      lcd_string++;  // next character in string

    }while(*lcd_string !='\0');  // keep spitting chars out until end of string
800033aa:	11 88       	ld.ub	r8,r8[0x0]
800033ac:	ec 08 18 00 	cp.b	r8,r6
800033b0:	c0 40       	breq	800033b8 <et024006_PrintString+0x230>
800033b2:	40 1c       	lddsp	r12,sp[0x4]
800033b4:	5c 8c       	casts.h	r12
800033b6:	c9 5b       	rjmp	800032e0 <et024006_PrintString+0x158>
  }
}
800033b8:	2f 3d       	sub	sp,-52
800033ba:	d8 32       	popm	r0-r7,pc
800033bc:	80 00       	ld.sh	r0,r0[0x0]
800033be:	30 c0       	mov	r0,12
800033c0:	80 00       	ld.sh	r0,r0[0x0]
800033c2:	31 64       	mov	r4,22

800033c4 <et024006_DrawLine>:
  et024006_DrawFilledRect( x, y, 1, length, color );
}


void et024006_DrawLine( uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, et024006_color_t color )
{
800033c4:	d4 31       	pushm	r0-r7,lr
800033c6:	20 3d       	sub	sp,12
800033c8:	18 95       	mov	r5,r12
800033ca:	16 94       	mov	r4,r11
800033cc:	14 93       	mov	r3,r10
800033ce:	12 92       	mov	r2,r9
800033d0:	10 91       	mov	r1,r8
  et024006_SetLimits( 0, 0, ET024006_WIDTH - 1, ET024006_HEIGHT - 1 );
800033d2:	e0 69 00 ef 	mov	r9,239
800033d6:	e0 6a 01 3f 	mov	r10,319
800033da:	30 0b       	mov	r11,0
800033dc:	16 9c       	mov	r12,r11
800033de:	f0 1f 00 3e 	mcall	800034d4 <et024006_DrawLine+0x110>
  Assert( y2 < ET024006_HEIGHT );

  // Compute deltas, ie. "width" and "height" of line, then
  // compute x and y direction, and make deltas positive for later use.
  int16_t xinc = 1; // Start off assuming direction is positive, ie. right.
  int16_t dx = x2 - x1;
800033e2:	0a 13       	sub	r3,r5
800033e4:	5c 83       	casts.h	r3
  if (dx < 0){
800033e6:	30 08       	mov	r8,0
800033e8:	f0 03 19 00 	cp.h	r3,r8
800033ec:	c0 35       	brlt	800033f2 <et024006_DrawLine+0x2e>
800033ee:	30 10       	mov	r0,1
800033f0:	c0 48       	rjmp	800033f8 <et024006_DrawLine+0x34>
    xinc = -1;
    dx = -dx;
800033f2:	5c 33       	neg	r3
800033f4:	5c 83       	casts.h	r3
800033f6:	3f f0       	mov	r0,-1
  }
  int16_t yinc = 1; // Start off assuming direction is positive, ie. down.
  int16_t dy = y2 - y1;
800033f8:	08 12       	sub	r2,r4
800033fa:	5c 82       	casts.h	r2
  if (dy < 0){
800033fc:	30 08       	mov	r8,0
800033fe:	f0 02 19 00 	cp.h	r2,r8
80003402:	c0 45       	brlt	8000340a <et024006_DrawLine+0x46>
80003404:	30 18       	mov	r8,1
80003406:	50 18       	stdsp	sp[0x4],r8
80003408:	c0 58       	rjmp	80003412 <et024006_DrawLine+0x4e>
    yinc = -1;
    dy = -dy;
8000340a:	5c 32       	neg	r2
8000340c:	5c 82       	casts.h	r2
8000340e:	3f f9       	mov	r9,-1
80003410:	50 19       	stdsp	sp[0x4],r9
  // Set up current point.
  uint16_t x = x1;
  uint16_t y = y1;
  uint16_t i;
  // A "flat" line (dx>dy) is handled differently from a "steep" line (dx<dy).
  if (dx > dy) {
80003412:	e4 03 19 00 	cp.h	r3,r2
80003416:	e0 8a 00 2e 	brle	80003472 <et024006_DrawLine+0xae>
    // Walk along X, draw pixel, and step Y when required.
    int16_t e = dx >> 1;
    for ( i = 0; i <= dx; ++i) {
8000341a:	50 03       	stdsp	sp[0x0],r3
8000341c:	58 03       	cp.w	r3,0
8000341e:	c5 85       	brlt	800034ce <et024006_DrawLine+0x10a>
  uint16_t y = y1;
  uint16_t i;
  // A "flat" line (dx>dy) is handled differently from a "steep" line (dx<dy).
  if (dx > dy) {
    // Walk along X, draw pixel, and step Y when required.
    int16_t e = dx >> 1;
80003420:	e6 07 14 01 	asr	r7,r3,0x1
80003424:	5c 84       	casts.h	r4
80003426:	5c 85       	casts.h	r5
80003428:	30 06       	mov	r6,0
    for ( i = 0; i <= dx; ++i) {
      et024006_DrawQuickPixel(x,y,color);
8000342a:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
      // Sub-pixel "error" overflowed, so we step Y and reset the "error".
      if (e <= 0){
8000342e:	30 01       	mov	r1,0
80003430:	50 23       	stdsp	sp[0x8],r3
80003432:	1c 93       	mov	r3,lr
  // A "flat" line (dx>dy) is handled differently from a "steep" line (dx<dy).
  if (dx > dy) {
    // Walk along X, draw pixel, and step Y when required.
    int16_t e = dx >> 1;
    for ( i = 0; i <= dx; ++i) {
      et024006_DrawQuickPixel(x,y,color);
80003434:	06 9a       	mov	r10,r3
80003436:	08 9b       	mov	r11,r4
80003438:	5c 7b       	castu.h	r11
8000343a:	f9 d5 c0 10 	bfextu	r12,r5,0x0,0x10
8000343e:	f0 1f 00 27 	mcall	800034d8 <et024006_DrawLine+0x114>
      // Sub-pixel "error" overflowed, so we step Y and reset the "error".
      if (e <= 0){
80003442:	e2 07 19 00 	cp.h	r7,r1
80003446:	e0 89 00 08 	brgt	80003456 <et024006_DrawLine+0x92>
        e += dx;
8000344a:	40 29       	lddsp	r9,sp[0x8]
8000344c:	12 07       	add	r7,r9
8000344e:	5c 87       	casts.h	r7
        y += yinc;
80003450:	40 18       	lddsp	r8,sp[0x4]
80003452:	10 04       	add	r4,r8
80003454:	5c 84       	casts.h	r4
  uint16_t i;
  // A "flat" line (dx>dy) is handled differently from a "steep" line (dx<dy).
  if (dx > dy) {
    // Walk along X, draw pixel, and step Y when required.
    int16_t e = dx >> 1;
    for ( i = 0; i <= dx; ++i) {
80003456:	2f f6       	sub	r6,-1
80003458:	5c 86       	casts.h	r6
8000345a:	f1 d6 c0 10 	bfextu	r8,r6,0x0,0x10
8000345e:	40 09       	lddsp	r9,sp[0x0]
80003460:	12 38       	cp.w	r8,r9
80003462:	e0 89 00 36 	brgt	800034ce <et024006_DrawLine+0x10a>
      if (e <= 0){
        e += dx;
        y += yinc;
      }
      // Walk one step along X.
      e -= dy;
80003466:	04 17       	sub	r7,r2
80003468:	5c 87       	casts.h	r7
8000346a:	e0 05 00 05 	add	r5,r0,r5
8000346e:	5c 85       	casts.h	r5
80003470:	ce 2b       	rjmp	80003434 <et024006_DrawLine+0x70>
      x += xinc;
    }
  } else {
    // Walk along Y, draw pixel, and step X when required.
    int16_t e = dy >> 1;
    for (i = 0; i <= dy; ++i) {
80003472:	50 02       	stdsp	sp[0x0],r2
80003474:	58 02       	cp.w	r2,0
80003476:	c2 c5       	brlt	800034ce <et024006_DrawLine+0x10a>
      e -= dy;
      x += xinc;
    }
  } else {
    // Walk along Y, draw pixel, and step X when required.
    int16_t e = dy >> 1;
80003478:	e4 07 14 01 	asr	r7,r2,0x1
8000347c:	5c 84       	casts.h	r4
8000347e:	5c 85       	casts.h	r5
80003480:	30 06       	mov	r6,0
    for (i = 0; i <= dy; ++i) {
      et024006_DrawQuickPixel(x,y,color);
80003482:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
      // Sub-pixel "error" overflowed, so we step X and reset the "error".
      if (e <= 0){
80003486:	30 01       	mov	r1,0
80003488:	50 22       	stdsp	sp[0x8],r2
8000348a:	40 12       	lddsp	r2,sp[0x4]
8000348c:	50 10       	stdsp	sp[0x4],r0
8000348e:	1c 90       	mov	r0,lr
    }
  } else {
    // Walk along Y, draw pixel, and step X when required.
    int16_t e = dy >> 1;
    for (i = 0; i <= dy; ++i) {
      et024006_DrawQuickPixel(x,y,color);
80003490:	00 9a       	mov	r10,r0
80003492:	08 9b       	mov	r11,r4
80003494:	5c 7b       	castu.h	r11
80003496:	f9 d5 c0 10 	bfextu	r12,r5,0x0,0x10
8000349a:	f0 1f 00 10 	mcall	800034d8 <et024006_DrawLine+0x114>
      // Sub-pixel "error" overflowed, so we step X and reset the "error".
      if (e <= 0){
8000349e:	e2 07 19 00 	cp.h	r7,r1
800034a2:	e0 89 00 08 	brgt	800034b2 <et024006_DrawLine+0xee>
        e += dy;
800034a6:	40 29       	lddsp	r9,sp[0x8]
800034a8:	12 07       	add	r7,r9
800034aa:	5c 87       	casts.h	r7
        x += xinc;
800034ac:	40 18       	lddsp	r8,sp[0x4]
800034ae:	10 05       	add	r5,r8
800034b0:	5c 85       	casts.h	r5
      x += xinc;
    }
  } else {
    // Walk along Y, draw pixel, and step X when required.
    int16_t e = dy >> 1;
    for (i = 0; i <= dy; ++i) {
800034b2:	2f f6       	sub	r6,-1
800034b4:	5c 86       	casts.h	r6
800034b6:	f1 d6 c0 10 	bfextu	r8,r6,0x0,0x10
800034ba:	40 09       	lddsp	r9,sp[0x0]
800034bc:	12 38       	cp.w	r8,r9
800034be:	e0 89 00 08 	brgt	800034ce <et024006_DrawLine+0x10a>
      if (e <= 0){
        e += dy;
        x += xinc;
      }
      // Walk one step along Y.
      e -= dx;
800034c2:	06 17       	sub	r7,r3
800034c4:	5c 87       	casts.h	r7
800034c6:	e4 04 00 04 	add	r4,r2,r4
800034ca:	5c 84       	casts.h	r4
800034cc:	ce 2b       	rjmp	80003490 <et024006_DrawLine+0xcc>
      y += yinc;
    }
  }
}
800034ce:	2f dd       	sub	sp,-12
800034d0:	d8 32       	popm	r0-r7,pc
800034d2:	00 00       	add	r0,r0
800034d4:	80 00       	ld.sh	r0,r0[0x0]
800034d6:	30 c0       	mov	r0,12
800034d8:	80 00       	ld.sh	r0,r0[0x0]
800034da:	31 64       	mov	r4,22

800034dc <et024006_DuplicatePixel>:
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800034dc:	32 29       	mov	r9,34
800034de:	fc 18 c0 00 	movh	r8,0xc000
800034e2:	b0 09       	st.h	r8[0x0],r9
  Assert( count > 0 );

  et024006_SelectRegister( HIMAX_SRAMWRITE );
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  //uint8_t countLowByte = count;
  while (count >= 8) {
800034e4:	58 7b       	cp.w	r11,7
800034e6:	e0 88 00 13 	brls	8000350c <et024006_DuplicatePixel+0x30>
800034ea:	16 99       	mov	r9,r11
    *ET024006_PARAM_ADDR = color;
800034ec:	fc 18 c0 20 	movh	r8,0xc020
800034f0:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
800034f2:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
800034f4:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
800034f6:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
800034f8:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
800034fa:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
800034fc:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
800034fe:	b0 0c       	st.h	r8[0x0],r12
    count-=8;
80003500:	20 89       	sub	r9,8
  Assert( count > 0 );

  et024006_SelectRegister( HIMAX_SRAMWRITE );
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  //uint8_t countLowByte = count;
  while (count >= 8) {
80003502:	58 79       	cp.w	r9,7
80003504:	fe 9b ff f6 	brhi	800034f0 <et024006_DuplicatePixel+0x14>



/* --- Pixel block operations --- */

void et024006_DuplicatePixel( et024006_color_t color, uint32_t count )
80003508:	f7 db c0 03 	bfextu	r11,r11,0x0,0x3
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    count-=8;
  }
  while (count > 0) {
8000350c:	58 0b       	cp.w	r11,0
8000350e:	5e 0c       	reteq	r12
    *ET024006_PARAM_ADDR = color;
80003510:	fc 18 c0 20 	movh	r8,0xc020
80003514:	b0 0c       	st.h	r8[0x0],r12
    --count;
80003516:	20 1b       	sub	r11,1
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    count-=8;
  }
  while (count > 0) {
80003518:	cf e1       	brne	80003514 <et024006_DuplicatePixel+0x38>
8000351a:	5e fc       	retal	r12

8000351c <et024006_DrawFilledRect>:
  }
}


void et024006_DrawFilledRect( uint16_t x, uint16_t y, uint16_t width, uint16_t height, et024006_color_t color )
{
8000351c:	eb cd 40 e0 	pushm	r5-r7,lr
80003520:	14 97       	mov	r7,r10
80003522:	12 96       	mov	r6,r9
80003524:	10 95       	mov	r5,r8
  // More sanity check.
  Assert( x2 < ET024006_WIDTH );
  Assert( y2 < ET024006_HEIGHT );

  // Set up draw area and copy pixel color until area is full.
  et024006_SetLimits( x, y, x2, y2 );
80003526:	f6 c9 00 01 	sub	r9,r11,1
8000352a:	0c 09       	add	r9,r6
8000352c:	f8 ca 00 01 	sub	r10,r12,1
80003530:	0e 0a       	add	r10,r7
80003532:	5c 79       	castu.h	r9
80003534:	5c 7a       	castu.h	r10
80003536:	5c 7b       	castu.h	r11
80003538:	5c 7c       	castu.h	r12
8000353a:	f0 1f 00 07 	mcall	80003554 <et024006_DrawFilledRect+0x38>
  uint32_t count = (uint32_t) width * height;
  et024006_DuplicatePixel( color, count );
8000353e:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80003542:	5c 77       	castu.h	r7
80003544:	af 3b       	mul	r11,r7
80003546:	f9 d5 c0 10 	bfextu	r12,r5,0x0,0x10
8000354a:	f0 1f 00 04 	mcall	80003558 <et024006_DrawFilledRect+0x3c>
}
8000354e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003552:	00 00       	add	r0,r0
80003554:	80 00       	ld.sh	r0,r0[0x0]
80003556:	30 c0       	mov	r0,12
80003558:	80 00       	ld.sh	r0,r0[0x0]
8000355a:	34 dc       	mov	r12,77

8000355c <et024006_DrawVertLine>:
  et024006_DrawFilledRect( x, y, length, 1, color );
}


void et024006_DrawVertLine( uint16_t x, uint16_t y, uint16_t length, et024006_color_t color )
{
8000355c:	d4 01       	pushm	lr
  et024006_DrawFilledRect( x, y, 1, length, color );
8000355e:	f1 d9 c0 10 	bfextu	r8,r9,0x0,0x10
80003562:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80003566:	30 1a       	mov	r10,1
80003568:	5c 7b       	castu.h	r11
8000356a:	5c 7c       	castu.h	r12
8000356c:	f0 1f 00 02 	mcall	80003574 <et024006_DrawVertLine+0x18>
}
80003570:	d8 02       	popm	pc
80003572:	00 00       	add	r0,r0
80003574:	80 00       	ld.sh	r0,r0[0x0]
80003576:	35 1c       	mov	r12,81

80003578 <et024006_DrawFilledCircle>:
	uint16_t x,
	uint16_t y,
	uint16_t radius,
	uint16_t color,
	uint8_t quadrantMask )
{
80003578:	d4 31       	pushm	r0-r7,lr
8000357a:	20 5d       	sub	sp,20
8000357c:	18 92       	mov	r2,r12
8000357e:	16 90       	mov	r0,r11
	// Draw only a pixel if radius is zero.
	if (radius == 0) {
80003580:	58 0a       	cp.w	r10,0
80003582:	c0 81       	brne	80003592 <et024006_DrawFilledCircle+0x1a>
		et024006_DrawPixel( x, y, color );
80003584:	f5 d9 c0 10 	bfextu	r10,r9,0x0,0x10
80003588:	5c 7b       	castu.h	r11
8000358a:	5c 7c       	castu.h	r12
8000358c:	f0 1f 00 4f 	mcall	800036c8 <et024006_DrawFilledCircle+0x150>
		return;
80003590:	c9 98       	rjmp	800036c2 <et024006_DrawFilledCircle+0x14a>
	}

	// Set up start iterators.
	uint16_t offsetX = 0;
	uint16_t offsetY = radius;
	int16_t error = 3 - 2 * radius;
80003592:	f4 04 10 fe 	mul	r4,r10,-2
80003596:	2f d4       	sub	r4,-3
80003598:	5c 84       	casts.h	r4
8000359a:	e7 dc b0 10 	bfexts	r3,r12,0x0,0x10
8000359e:	ef da b0 10 	bfexts	r7,r10,0x0,0x10
800035a2:	30 15       	mov	r5,1
800035a4:	30 06       	mov	r6,0

	// Iterate offsetX from 0 to radius.
	while (offsetX <= offsetY) {
		// Draw vertical lines tracking each quadrant.
		if (quadrantMask & TFT_QUADRANT0) {
800035a6:	10 9a       	mov	r10,r8
800035a8:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800035ac:	50 18       	stdsp	sp[0x4],r8
			et024006_DrawVertLine( x + offsetY, y - offsetX,
800035ae:	e3 d9 c0 10 	bfextu	r1,r9,0x0,0x10
				offsetX + 1, color );
			et024006_DrawVertLine( x + offsetX, y - offsetY,
				offsetY + 1, color );
		}
		if (quadrantMask & TFT_QUADRANT1) {
800035b2:	14 99       	mov	r9,r10
800035b4:	e2 19 00 0c 	andl	r9,0xc,COH
800035b8:	50 29       	stdsp	sp[0x8],r9
			et024006_DrawVertLine( x - offsetY, y - offsetX,
				offsetX + 1, color );
			et024006_DrawVertLine( x - offsetX, y - offsetY,
				offsetY + 1, color );
		}
		if (quadrantMask & TFT_QUADRANT2) {
800035ba:	14 98       	mov	r8,r10
800035bc:	e2 18 00 30 	andl	r8,0x30,COH
800035c0:	50 38       	stdsp	sp[0xc],r8
			et024006_DrawVertLine( x - offsetY, y, offsetX + 1,
800035c2:	f3 db c0 10 	bfextu	r9,r11,0x0,0x10
800035c6:	50 09       	stdsp	sp[0x0],r9
				color );
			et024006_DrawVertLine( x - offsetX, y, offsetY + 1,
				color );
		}
		if (quadrantMask & TFT_QUADRANT3) {
800035c8:	e2 1a 00 c0 	andl	r10,0xc0,COH
800035cc:	50 4a       	stdsp	sp[0x10],r10
	int16_t error = 3 - 2 * radius;

	// Iterate offsetX from 0 to radius.
	while (offsetX <= offsetY) {
		// Draw vertical lines tracking each quadrant.
		if (quadrantMask & TFT_QUADRANT0) {
800035ce:	40 18       	lddsp	r8,sp[0x4]
800035d0:	58 08       	cp.w	r8,0
800035d2:	c1 70       	breq	80003600 <et024006_DrawFilledCircle+0x88>
			et024006_DrawVertLine( x + offsetY, y - offsetX,
800035d4:	e0 06 01 0b 	sub	r11,r0,r6
800035d8:	0e 9c       	mov	r12,r7
800035da:	04 0c       	add	r12,r2
800035dc:	02 99       	mov	r9,r1
800035de:	f5 d5 c0 10 	bfextu	r10,r5,0x0,0x10
800035e2:	5c 7b       	castu.h	r11
800035e4:	5c 7c       	castu.h	r12
800035e6:	f0 1f 00 3a 	mcall	800036cc <et024006_DrawFilledCircle+0x154>
				offsetX + 1, color );
			et024006_DrawVertLine( x + offsetX, y - offsetY,
800035ea:	0e 9a       	mov	r10,r7
800035ec:	2f fa       	sub	r10,-1
800035ee:	e0 07 01 0b 	sub	r11,r0,r7
800035f2:	02 99       	mov	r9,r1
800035f4:	5c 7a       	castu.h	r10
800035f6:	5c 7b       	castu.h	r11
800035f8:	f9 d3 c0 10 	bfextu	r12,r3,0x0,0x10
800035fc:	f0 1f 00 34 	mcall	800036cc <et024006_DrawFilledCircle+0x154>
				offsetY + 1, color );
		}
		if (quadrantMask & TFT_QUADRANT1) {
80003600:	40 28       	lddsp	r8,sp[0x8]
80003602:	58 08       	cp.w	r8,0
80003604:	c1 80       	breq	80003634 <et024006_DrawFilledCircle+0xbc>
			et024006_DrawVertLine( x - offsetY, y - offsetX,
80003606:	e0 06 01 0b 	sub	r11,r0,r6
8000360a:	e4 07 01 0c 	sub	r12,r2,r7
8000360e:	02 99       	mov	r9,r1
80003610:	f5 d5 c0 10 	bfextu	r10,r5,0x0,0x10
80003614:	5c 7b       	castu.h	r11
80003616:	5c 7c       	castu.h	r12
80003618:	f0 1f 00 2d 	mcall	800036cc <et024006_DrawFilledCircle+0x154>
				offsetX + 1, color );
			et024006_DrawVertLine( x - offsetX, y - offsetY,
8000361c:	0e 9a       	mov	r10,r7
8000361e:	2f fa       	sub	r10,-1
80003620:	e0 07 01 0b 	sub	r11,r0,r7
80003624:	e4 06 01 0c 	sub	r12,r2,r6
80003628:	02 99       	mov	r9,r1
8000362a:	5c 7a       	castu.h	r10
8000362c:	5c 7b       	castu.h	r11
8000362e:	5c 7c       	castu.h	r12
80003630:	f0 1f 00 27 	mcall	800036cc <et024006_DrawFilledCircle+0x154>
				offsetY + 1, color );
		}
		if (quadrantMask & TFT_QUADRANT2) {
80003634:	40 39       	lddsp	r9,sp[0xc]
80003636:	58 09       	cp.w	r9,0
80003638:	c1 40       	breq	80003660 <et024006_DrawFilledCircle+0xe8>
			et024006_DrawVertLine( x - offsetY, y, offsetX + 1,
8000363a:	e4 07 01 0c 	sub	r12,r2,r7
8000363e:	02 99       	mov	r9,r1
80003640:	f5 d5 c0 10 	bfextu	r10,r5,0x0,0x10
80003644:	40 0b       	lddsp	r11,sp[0x0]
80003646:	5c 7c       	castu.h	r12
80003648:	f0 1f 00 21 	mcall	800036cc <et024006_DrawFilledCircle+0x154>
				color );
			et024006_DrawVertLine( x - offsetX, y, offsetY + 1,
8000364c:	0e 9a       	mov	r10,r7
8000364e:	2f fa       	sub	r10,-1
80003650:	e4 06 01 0c 	sub	r12,r2,r6
80003654:	02 99       	mov	r9,r1
80003656:	5c 7a       	castu.h	r10
80003658:	40 0b       	lddsp	r11,sp[0x0]
8000365a:	5c 7c       	castu.h	r12
8000365c:	f0 1f 00 1c 	mcall	800036cc <et024006_DrawFilledCircle+0x154>
				color );
		}
		if (quadrantMask & TFT_QUADRANT3) {
80003660:	40 49       	lddsp	r9,sp[0x10]
80003662:	58 09       	cp.w	r9,0
80003664:	c1 30       	breq	8000368a <et024006_DrawFilledCircle+0x112>
			et024006_DrawVertLine( x + offsetY, y, offsetX + 1,
80003666:	0e 9c       	mov	r12,r7
80003668:	04 0c       	add	r12,r2
8000366a:	02 99       	mov	r9,r1
8000366c:	f5 d5 c0 10 	bfextu	r10,r5,0x0,0x10
80003670:	40 0b       	lddsp	r11,sp[0x0]
80003672:	5c 7c       	castu.h	r12
80003674:	f0 1f 00 16 	mcall	800036cc <et024006_DrawFilledCircle+0x154>
				color );
			et024006_DrawVertLine( x + offsetX, y, offsetY + 1,
80003678:	0e 9a       	mov	r10,r7
8000367a:	2f fa       	sub	r10,-1
8000367c:	02 99       	mov	r9,r1
8000367e:	5c 7a       	castu.h	r10
80003680:	40 0b       	lddsp	r11,sp[0x0]
80003682:	f9 d3 c0 10 	bfextu	r12,r3,0x0,0x10
80003686:	f0 1f 00 12 	mcall	800036cc <et024006_DrawFilledCircle+0x154>
				color );
		}

		// Update error value and step offsetY when required.
		if (error < 0) {
8000368a:	30 09       	mov	r9,0
8000368c:	f2 04 19 00 	cp.h	r4,r9
80003690:	c0 84       	brge	800036a0 <et024006_DrawFilledCircle+0x128>
			error += ((offsetX << 2) + 6);
80003692:	ec 08 15 02 	lsl	r8,r6,0x2
80003696:	f0 04 00 04 	add	r4,r8,r4
8000369a:	2f a4       	sub	r4,-6
8000369c:	5c 84       	casts.h	r4
8000369e:	c0 98       	rjmp	800036b0 <et024006_DrawFilledCircle+0x138>
		} else {
			error += (((offsetX - offsetY) << 2) + 10);
800036a0:	2f 64       	sub	r4,-10
800036a2:	ec 07 01 08 	sub	r8,r6,r7
800036a6:	a3 68       	lsl	r8,0x2
800036a8:	10 04       	add	r4,r8
800036aa:	5c 84       	casts.h	r4
			--offsetY;
800036ac:	20 17       	sub	r7,1
800036ae:	5c 87       	casts.h	r7
		}

		// Next X.
		++offsetX;
800036b0:	2f f6       	sub	r6,-1
800036b2:	5c 86       	casts.h	r6
800036b4:	2f f5       	sub	r5,-1
800036b6:	5c 85       	casts.h	r5
800036b8:	2f f3       	sub	r3,-1
800036ba:	5c 83       	casts.h	r3
	uint16_t offsetX = 0;
	uint16_t offsetY = radius;
	int16_t error = 3 - 2 * radius;

	// Iterate offsetX from 0 to radius.
	while (offsetX <= offsetY) {
800036bc:	ec 07 19 00 	cp.h	r7,r6
800036c0:	c8 72       	brcc	800035ce <et024006_DrawFilledCircle+0x56>
		}

		// Next X.
		++offsetX;
	}
}
800036c2:	2f bd       	sub	sp,-20
800036c4:	d8 32       	popm	r0-r7,pc
800036c6:	00 00       	add	r0,r0
800036c8:	80 00       	ld.sh	r0,r0[0x0]
800036ca:	31 10       	mov	r0,17
800036cc:	80 00       	ld.sh	r0,r0[0x0]
800036ce:	35 5c       	mov	r12,85

800036d0 <et024006_DrawHorizLine>:
  return color;
}


void et024006_DrawHorizLine( uint16_t x, uint16_t y, uint16_t length, et024006_color_t color )
{
800036d0:	d4 01       	pushm	lr
  et024006_DrawFilledRect( x, y, length, 1, color );
800036d2:	f1 d9 c0 10 	bfextu	r8,r9,0x0,0x10
800036d6:	30 19       	mov	r9,1
800036d8:	5c 7a       	castu.h	r10
800036da:	5c 7b       	castu.h	r11
800036dc:	5c 7c       	castu.h	r12
800036de:	f0 1f 00 02 	mcall	800036e4 <et024006_DrawHorizLine+0x14>
}
800036e2:	d8 02       	popm	pc
800036e4:	80 00       	ld.sh	r0,r0[0x0]
800036e6:	35 1c       	mov	r12,81

800036e8 <et024006_AdjustGamma>:

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800036e8:	fc 19 c0 00 	movh	r9,0xc000
800036ec:	34 6a       	mov	r10,70
800036ee:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800036f0:	fc 18 c0 20 	movh	r8,0xc020
800036f4:	e0 6b 00 94 	mov	r11,148
800036f8:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800036fa:	34 7b       	mov	r11,71
800036fc:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800036fe:	34 1b       	mov	r11,65
80003700:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003702:	34 8b       	mov	r11,72
80003704:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003706:	30 0b       	mov	r11,0
80003708:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000370a:	34 9b       	mov	r11,73
8000370c:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000370e:	33 3b       	mov	r11,51
80003710:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003712:	34 ab       	mov	r11,74
80003714:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003716:	32 5b       	mov	r11,37
80003718:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000371a:	34 bb       	mov	r11,75
8000371c:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000371e:	34 5b       	mov	r11,69
80003720:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003722:	34 cb       	mov	r11,76
80003724:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003726:	34 4b       	mov	r11,68
80003728:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000372a:	34 db       	mov	r11,77
8000372c:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000372e:	37 7b       	mov	r11,119
80003730:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003732:	34 eb       	mov	r11,78
80003734:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003736:	31 2b       	mov	r11,18
80003738:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000373a:	34 fb       	mov	r11,79
8000373c:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000373e:	e0 6b 00 cc 	mov	r11,204
80003742:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003744:	35 0b       	mov	r11,80
80003746:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003748:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000374a:	35 1a       	mov	r10,81
8000374c:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000374e:	e0 69 00 82 	mov	r9,130
80003752:	b0 09       	st.h	r8[0x0],r9
  et024006_WriteRegister( HIMAX_GAMMACTRL8, 0x77 );
  et024006_WriteRegister( HIMAX_GAMMACTRL9, 0x12 );
  et024006_WriteRegister( HIMAX_GAMMACTRL10, 0xCC );
  et024006_WriteRegister( HIMAX_GAMMACTRL11, 0x46 );
  et024006_WriteRegister( HIMAX_GAMMACTRL12, 0x82 );
}
80003754:	5e fc       	retal	r12
80003756:	d7 03       	nop

80003758 <et024006_Init>:
 *  @param cpu_hz CPU speed in Hz. This is needed for power up timings.
 *  @param hsb_hz HSB bus speed in Hz. This parameter is needed to set up the SMC.
 *  If SPI mode is used then this parameter is ignored.
 */
void et024006_Init( unsigned long cpu_hz, unsigned long hsb_hz )
{
80003758:	eb cd 40 c0 	pushm	r6-r7,lr
  tft_data.cpu_hz = cpu_hz;
8000375c:	fe f7 04 80 	ld.w	r7,pc[1152]
80003760:	8f 0c       	st.w	r7[0x0],r12
  tft_data.hsb_hz = hsb_hz;
80003762:	8f 1b       	st.w	r7[0x4],r11

#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_SPI)
  et024006_InitSPI();
#endif
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  smc_init(tft_data.hsb_hz);
80003764:	16 9c       	mov	r12,r11
80003766:	f0 1f 01 1f 	mcall	80003be0 <et024006_Init+0x488>
static void et024006_SetupInterface( void )
{

  // et024006_TE (tearing sync) signal from display is input
  // without any pull resistors
  gpio_enable_gpio_pin(ET024006DHU_TE_PIN);
8000376a:	35 5c       	mov	r12,85
8000376c:	f0 1f 01 1e 	mcall	80003be4 <et024006_Init+0x48c>

  // Backlight pin (PWM) for display is output
  gpio_enable_module_pin(ET024006DHU_BL_PIN, ET024006DHU_BL_FUNCTION);
80003770:	30 2b       	mov	r11,2
80003772:	33 2c       	mov	r12,50
80003774:	f0 1f 01 1d 	mcall	80003be8 <et024006_Init+0x490>
  // Turns backlight ON
  /*TODO Add backlight driver */

  // Reset pin for display is output
  gpio_set_gpio_pin(ET024006DHU_RESET_PIN);
80003778:	35 2c       	mov	r12,82
8000377a:	f0 1f 01 1d 	mcall	80003bec <et024006_Init+0x494>
/*! \brief Does a hard reset of the display.
 */
static void et024006_ResetDisplay( void )
{
  // clear reset line
  gpio_clr_gpio_pin(ET024006DHU_RESET_PIN);
8000377e:	35 2c       	mov	r12,82
80003780:	f0 1f 01 1c 	mcall	80003bf0 <et024006_Init+0x498>
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
80003784:	6e 07       	ld.w	r7,r7[0x0]
80003786:	33 28       	mov	r8,50
80003788:	ee 08 06 46 	mulu.d	r6,r7,r8
8000378c:	ee 78 42 40 	mov	r8,1000000
80003790:	30 09       	mov	r9,0
80003792:	ee 7a 42 3f 	mov	r10,999999
80003796:	30 0b       	mov	r11,0
80003798:	ec 0a 00 0a 	add	r10,r6,r10
8000379c:	ee 0b 00 4b 	adc	r11,r7,r11
800037a0:	f0 1f 01 15 	mcall	80003bf4 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800037a4:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800037a8:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800037ac:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800037b0:	14 38       	cp.w	r8,r10
800037b2:	e0 88 00 09 	brls	800037c4 <et024006_Init+0x6c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800037b6:	12 38       	cp.w	r8,r9
800037b8:	fe 98 ff fa 	brls	800037ac <et024006_Init+0x54>
800037bc:	12 3a       	cp.w	r10,r9
800037be:	e0 83 00 a2 	brlo	80003902 <et024006_Init+0x1aa>
800037c2:	cf 5b       	rjmp	800037ac <et024006_Init+0x54>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800037c4:	12 38       	cp.w	r8,r9
800037c6:	e0 8b 00 9e 	brhi	80003902 <et024006_Init+0x1aa>
800037ca:	12 3a       	cp.w	r10,r9
800037cc:	e0 83 00 9b 	brlo	80003902 <et024006_Init+0x1aa>
800037d0:	ce eb       	rjmp	800037ac <et024006_Init+0x54>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800037d2:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800037d6:	14 38       	cp.w	r8,r10
800037d8:	e0 88 00 09 	brls	800037ea <et024006_Init+0x92>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800037dc:	12 38       	cp.w	r8,r9
800037de:	fe 98 ff fa 	brls	800037d2 <et024006_Init+0x7a>
800037e2:	12 3a       	cp.w	r10,r9
800037e4:	e0 83 00 a9 	brlo	80003936 <et024006_Init+0x1de>
800037e8:	cf 5b       	rjmp	800037d2 <et024006_Init+0x7a>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800037ea:	12 38       	cp.w	r8,r9
800037ec:	e0 8b 00 a5 	brhi	80003936 <et024006_Init+0x1de>
800037f0:	12 3a       	cp.w	r10,r9
800037f2:	e0 83 00 a2 	brlo	80003936 <et024006_Init+0x1de>
800037f6:	ce eb       	rjmp	800037d2 <et024006_Init+0x7a>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800037f8:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800037fc:	14 38       	cp.w	r8,r10
800037fe:	e0 88 00 09 	brls	80003810 <et024006_Init+0xb8>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80003802:	12 38       	cp.w	r8,r9
80003804:	fe 98 ff fa 	brls	800037f8 <et024006_Init+0xa0>
80003808:	12 3a       	cp.w	r10,r9
8000380a:	e0 83 01 1e 	brlo	80003a46 <et024006_Init+0x2ee>
8000380e:	cf 5b       	rjmp	800037f8 <et024006_Init+0xa0>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80003810:	12 38       	cp.w	r8,r9
80003812:	e0 8b 01 1a 	brhi	80003a46 <et024006_Init+0x2ee>
80003816:	12 3a       	cp.w	r10,r9
80003818:	e0 83 01 17 	brlo	80003a46 <et024006_Init+0x2ee>
8000381c:	ce eb       	rjmp	800037f8 <et024006_Init+0xa0>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000381e:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80003822:	14 38       	cp.w	r8,r10
80003824:	e0 88 00 09 	brls	80003836 <et024006_Init+0xde>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80003828:	12 38       	cp.w	r8,r9
8000382a:	fe 98 ff fa 	brls	8000381e <et024006_Init+0xc6>
8000382e:	12 3a       	cp.w	r10,r9
80003830:	e0 83 01 29 	brlo	80003a82 <et024006_Init+0x32a>
80003834:	cf 5b       	rjmp	8000381e <et024006_Init+0xc6>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80003836:	12 38       	cp.w	r8,r9
80003838:	e0 8b 01 25 	brhi	80003a82 <et024006_Init+0x32a>
8000383c:	12 3a       	cp.w	r10,r9
8000383e:	e0 83 01 22 	brlo	80003a82 <et024006_Init+0x32a>
80003842:	ce eb       	rjmp	8000381e <et024006_Init+0xc6>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80003844:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80003848:	14 38       	cp.w	r8,r10
8000384a:	e0 88 00 09 	brls	8000385c <et024006_Init+0x104>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000384e:	12 38       	cp.w	r8,r9
80003850:	fe 98 ff fa 	brls	80003844 <et024006_Init+0xec>
80003854:	12 3a       	cp.w	r10,r9
80003856:	e0 83 01 35 	brlo	80003ac0 <et024006_Init+0x368>
8000385a:	cf 5b       	rjmp	80003844 <et024006_Init+0xec>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000385c:	12 38       	cp.w	r8,r9
8000385e:	e0 8b 01 31 	brhi	80003ac0 <et024006_Init+0x368>
80003862:	12 3a       	cp.w	r10,r9
80003864:	e0 83 01 2e 	brlo	80003ac0 <et024006_Init+0x368>
80003868:	ce eb       	rjmp	80003844 <et024006_Init+0xec>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000386a:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000386e:	14 38       	cp.w	r8,r10
80003870:	e0 88 00 09 	brls	80003882 <et024006_Init+0x12a>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80003874:	12 38       	cp.w	r8,r9
80003876:	fe 98 ff fa 	brls	8000386a <et024006_Init+0x112>
8000387a:	12 3a       	cp.w	r10,r9
8000387c:	e0 83 01 40 	brlo	80003afc <et024006_Init+0x3a4>
80003880:	cf 5b       	rjmp	8000386a <et024006_Init+0x112>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80003882:	12 38       	cp.w	r8,r9
80003884:	e0 8b 01 3c 	brhi	80003afc <et024006_Init+0x3a4>
80003888:	12 3a       	cp.w	r10,r9
8000388a:	e0 83 01 39 	brlo	80003afc <et024006_Init+0x3a4>
8000388e:	ce eb       	rjmp	8000386a <et024006_Init+0x112>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80003890:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80003894:	14 38       	cp.w	r8,r10
80003896:	e0 88 00 09 	brls	800038a8 <et024006_Init+0x150>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000389a:	12 38       	cp.w	r8,r9
8000389c:	fe 98 ff fa 	brls	80003890 <et024006_Init+0x138>
800038a0:	12 3a       	cp.w	r10,r9
800038a2:	e0 83 01 4b 	brlo	80003b38 <et024006_Init+0x3e0>
800038a6:	cf 5b       	rjmp	80003890 <et024006_Init+0x138>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800038a8:	12 38       	cp.w	r8,r9
800038aa:	e0 8b 01 47 	brhi	80003b38 <et024006_Init+0x3e0>
800038ae:	12 3a       	cp.w	r10,r9
800038b0:	e0 83 01 44 	brlo	80003b38 <et024006_Init+0x3e0>
800038b4:	ce eb       	rjmp	80003890 <et024006_Init+0x138>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800038b6:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800038ba:	14 38       	cp.w	r8,r10
800038bc:	e0 88 00 09 	brls	800038ce <et024006_Init+0x176>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800038c0:	12 38       	cp.w	r8,r9
800038c2:	fe 98 ff fa 	brls	800038b6 <et024006_Init+0x15e>
800038c6:	12 3a       	cp.w	r10,r9
800038c8:	e0 83 01 56 	brlo	80003b74 <et024006_Init+0x41c>
800038cc:	cf 5b       	rjmp	800038b6 <et024006_Init+0x15e>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800038ce:	12 38       	cp.w	r8,r9
800038d0:	e0 8b 01 52 	brhi	80003b74 <et024006_Init+0x41c>
800038d4:	12 3a       	cp.w	r10,r9
800038d6:	e0 83 01 4f 	brlo	80003b74 <et024006_Init+0x41c>
800038da:	ce eb       	rjmp	800038b6 <et024006_Init+0x15e>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800038dc:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800038e0:	14 38       	cp.w	r8,r10
800038e2:	e0 88 00 09 	brls	800038f4 <et024006_Init+0x19c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800038e6:	12 38       	cp.w	r8,r9
800038e8:	fe 98 ff fa 	brls	800038dc <et024006_Init+0x184>
800038ec:	12 3a       	cp.w	r10,r9
800038ee:	e0 83 01 64 	brlo	80003bb6 <et024006_Init+0x45e>
800038f2:	cf 5b       	rjmp	800038dc <et024006_Init+0x184>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800038f4:	12 38       	cp.w	r8,r9
800038f6:	e0 8b 01 60 	brhi	80003bb6 <et024006_Init+0x45e>
800038fa:	12 3a       	cp.w	r10,r9
800038fc:	e0 83 01 5d 	brlo	80003bb6 <et024006_Init+0x45e>
80003900:	ce eb       	rjmp	800038dc <et024006_Init+0x184>
  // 50us delay
  cpu_delay_us( 50, tft_data.cpu_hz );

  gpio_set_gpio_pin(ET024006DHU_RESET_PIN);
80003902:	35 2c       	mov	r12,82
80003904:	f0 1f 00 ba 	mcall	80003bec <et024006_Init+0x494>
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80003908:	fe f8 02 d4 	ld.w	r8,pc[724]
8000390c:	70 07       	ld.w	r7,r8[0x0]
8000390e:	30 58       	mov	r8,5
80003910:	ee 08 06 46 	mulu.d	r6,r7,r8
80003914:	e0 68 03 e8 	mov	r8,1000
80003918:	30 09       	mov	r9,0
8000391a:	e0 6a 03 e7 	mov	r10,999
8000391e:	30 0b       	mov	r11,0
80003920:	ec 0a 00 0a 	add	r10,r6,r10
80003924:	ee 0b 00 4b 	adc	r11,r7,r11
80003928:	f0 1f 00 b3 	mcall	80003bf4 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000392c:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80003930:	f0 0a 00 0a 	add	r10,r8,r10
80003934:	c4 fb       	rjmp	800037d2 <et024006_Init+0x7a>
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  smc_init(tft_data.hsb_hz);
#endif
  et024006_SetupInterface();
  et024006_ResetDisplay();
  et024006_AdjustGamma();
80003936:	f0 1f 00 b1 	mcall	80003bf8 <et024006_Init+0x4a0>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000393a:	fc 19 c0 00 	movh	r9,0xc000
8000393e:	30 1a       	mov	r10,1
80003940:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003942:	fc 18 c0 20 	movh	r8,0xc020
80003946:	30 6b       	mov	r11,6
80003948:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000394a:	33 ab       	mov	r11,58
8000394c:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000394e:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003950:	33 bb       	mov	r11,59
80003952:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003954:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003956:	33 ca       	mov	r10,60
80003958:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000395a:	e0 6a 00 f0 	mov	r10,240
8000395e:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003960:	33 db       	mov	r11,61
80003962:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003964:	30 07       	mov	r7,0
80003966:	b0 07       	st.h	r8[0x0],r7

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003968:	33 eb       	mov	r11,62
8000396a:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000396c:	33 8b       	mov	r11,56
8000396e:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003970:	34 0c       	mov	r12,64
80003972:	b2 0c       	st.h	r9[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003974:	30 fe       	mov	lr,15
80003976:	b0 0e       	st.h	r8[0x0],lr

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003978:	34 1e       	mov	lr,65
8000397a:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000397c:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000397e:	32 7a       	mov	r10,39
80003980:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003982:	30 2a       	mov	r10,2
80003984:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003986:	32 8e       	mov	lr,40
80003988:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000398a:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000398c:	32 9e       	mov	lr,41
8000398e:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003990:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003992:	32 ae       	mov	lr,42
80003994:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003996:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003998:	32 ce       	mov	lr,44
8000399a:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000399c:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000399e:	32 de       	mov	lr,45
800039a0:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
800039a2:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800039a4:	31 9a       	mov	r10,25
800039a6:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800039a8:	34 9a       	mov	r10,73
800039aa:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800039ac:	e0 6a 00 93 	mov	r10,147
800039b0:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800039b2:	30 8a       	mov	r10,8
800039b4:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800039b6:	31 6a       	mov	r10,22
800039b8:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800039ba:	36 8a       	mov	r10,104
800039bc:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800039be:	32 3a       	mov	r10,35
800039c0:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800039c2:	e0 6a 00 95 	mov	r10,149
800039c6:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800039c8:	32 4e       	mov	lr,36
800039ca:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
800039cc:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800039ce:	32 5a       	mov	r10,37
800039d0:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800039d2:	e0 6a 00 ff 	mov	r10,255
800039d6:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800039d8:	e0 6a 00 90 	mov	r10,144
800039dc:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800039de:	37 fa       	mov	r10,127
800039e0:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800039e2:	33 5a       	mov	r10,53
800039e4:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800039e6:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800039e8:	33 6a       	mov	r10,54
800039ea:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800039ec:	37 8a       	mov	r10,120
800039ee:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800039f0:	31 da       	mov	r10,29
800039f2:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800039f4:	30 7a       	mov	r10,7
800039f6:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800039f8:	31 ea       	mov	r10,30
800039fa:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800039fc:	b0 07       	st.h	r8[0x0],r7

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800039fe:	31 fa       	mov	r10,31
80003a00:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003a02:	30 4a       	mov	r10,4
80003a04:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003a06:	32 0a       	mov	r10,32
80003a08:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003a0a:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003a0c:	34 4a       	mov	r10,68
80003a0e:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003a10:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003a12:	34 5a       	mov	r10,69
80003a14:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003a16:	31 29       	mov	r9,18
80003a18:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80003a1a:	4f 18       	lddpc	r8,80003bdc <et024006_Init+0x484>
80003a1c:	70 07       	ld.w	r7,r8[0x0]
80003a1e:	30 a8       	mov	r8,10
80003a20:	ee 08 06 46 	mulu.d	r6,r7,r8
80003a24:	e0 68 03 e8 	mov	r8,1000
80003a28:	30 09       	mov	r9,0
80003a2a:	e0 6a 03 e7 	mov	r10,999
80003a2e:	30 0b       	mov	r11,0
80003a30:	ec 0a 00 0a 	add	r10,r6,r10
80003a34:	ee 0b 00 4b 	adc	r11,r7,r11
80003a38:	f0 1f 00 6f 	mcall	80003bf4 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80003a3c:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80003a40:	f0 0a 00 0a 	add	r10,r8,r10
80003a44:	cd aa       	rjmp	800037f8 <et024006_Init+0xa0>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003a46:	31 c9       	mov	r9,28
80003a48:	fc 18 c0 00 	movh	r8,0xc000
80003a4c:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003a4e:	30 49       	mov	r9,4
80003a50:	fc 18 c0 20 	movh	r8,0xc020
80003a54:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80003a56:	4e 28       	lddpc	r8,80003bdc <et024006_Init+0x484>
80003a58:	70 07       	ld.w	r7,r8[0x0]
80003a5a:	31 48       	mov	r8,20
80003a5c:	ee 08 06 46 	mulu.d	r6,r7,r8
80003a60:	e0 68 03 e8 	mov	r8,1000
80003a64:	30 09       	mov	r9,0
80003a66:	e0 6a 03 e7 	mov	r10,999
80003a6a:	30 0b       	mov	r11,0
80003a6c:	ec 0a 00 0a 	add	r10,r6,r10
80003a70:	ee 0b 00 4b 	adc	r11,r7,r11
80003a74:	f0 1f 00 60 	mcall	80003bf4 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80003a78:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80003a7c:	f0 0a 00 0a 	add	r10,r8,r10
80003a80:	cc fa       	rjmp	8000381e <et024006_Init+0xc6>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003a82:	34 39       	mov	r9,67
80003a84:	fc 18 c0 00 	movh	r8,0xc000
80003a88:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003a8a:	e0 69 00 80 	mov	r9,128
80003a8e:	fc 18 c0 20 	movh	r8,0xc020
80003a92:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80003a94:	4d 28       	lddpc	r8,80003bdc <et024006_Init+0x484>
80003a96:	70 07       	ld.w	r7,r8[0x0]
80003a98:	30 58       	mov	r8,5
80003a9a:	ee 08 06 46 	mulu.d	r6,r7,r8
80003a9e:	e0 68 03 e8 	mov	r8,1000
80003aa2:	30 09       	mov	r9,0
80003aa4:	e0 6a 03 e7 	mov	r10,999
80003aa8:	30 0b       	mov	r11,0
80003aaa:	ec 0a 00 0a 	add	r10,r6,r10
80003aae:	ee 0b 00 4b 	adc	r11,r7,r11
80003ab2:	f0 1f 00 51 	mcall	80003bf4 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80003ab6:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80003aba:	f0 0a 00 0a 	add	r10,r8,r10
80003abe:	cc 3a       	rjmp	80003844 <et024006_Init+0xec>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003ac0:	31 b9       	mov	r9,27
80003ac2:	fc 18 c0 00 	movh	r8,0xc000
80003ac6:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003ac8:	30 89       	mov	r9,8
80003aca:	fc 18 c0 20 	movh	r8,0xc020
80003ace:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80003ad0:	4c 38       	lddpc	r8,80003bdc <et024006_Init+0x484>
80003ad2:	70 07       	ld.w	r7,r8[0x0]
80003ad4:	32 88       	mov	r8,40
80003ad6:	ee 08 06 46 	mulu.d	r6,r7,r8
80003ada:	e0 68 03 e8 	mov	r8,1000
80003ade:	30 09       	mov	r9,0
80003ae0:	e0 6a 03 e7 	mov	r10,999
80003ae4:	30 0b       	mov	r11,0
80003ae6:	ec 0a 00 0a 	add	r10,r6,r10
80003aea:	ee 0b 00 4b 	adc	r11,r7,r11
80003aee:	f0 1f 00 42 	mcall	80003bf4 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80003af2:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80003af6:	f0 0a 00 0a 	add	r10,r8,r10
80003afa:	cb 8a       	rjmp	8000386a <et024006_Init+0x112>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003afc:	31 b9       	mov	r9,27
80003afe:	fc 18 c0 00 	movh	r8,0xc000
80003b02:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003b04:	31 09       	mov	r9,16
80003b06:	fc 18 c0 20 	movh	r8,0xc020
80003b0a:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80003b0c:	4b 48       	lddpc	r8,80003bdc <et024006_Init+0x484>
80003b0e:	70 07       	ld.w	r7,r8[0x0]
80003b10:	32 88       	mov	r8,40
80003b12:	ee 08 06 46 	mulu.d	r6,r7,r8
80003b16:	e0 68 03 e8 	mov	r8,1000
80003b1a:	30 09       	mov	r9,0
80003b1c:	e0 6a 03 e7 	mov	r10,999
80003b20:	30 0b       	mov	r11,0
80003b22:	ec 0a 00 0a 	add	r10,r6,r10
80003b26:	ee 0b 00 4b 	adc	r11,r7,r11
80003b2a:	f0 1f 00 33 	mcall	80003bf4 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80003b2e:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80003b32:	f0 0a 00 0a 	add	r10,r8,r10
80003b36:	ca da       	rjmp	80003890 <et024006_Init+0x138>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003b38:	32 69       	mov	r9,38
80003b3a:	fc 18 c0 00 	movh	r8,0xc000
80003b3e:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003b40:	30 49       	mov	r9,4
80003b42:	fc 18 c0 20 	movh	r8,0xc020
80003b46:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80003b48:	4a 58       	lddpc	r8,80003bdc <et024006_Init+0x484>
80003b4a:	70 07       	ld.w	r7,r8[0x0]
80003b4c:	32 88       	mov	r8,40
80003b4e:	ee 08 06 46 	mulu.d	r6,r7,r8
80003b52:	e0 68 03 e8 	mov	r8,1000
80003b56:	30 09       	mov	r9,0
80003b58:	e0 6a 03 e7 	mov	r10,999
80003b5c:	30 0b       	mov	r11,0
80003b5e:	ec 0a 00 0a 	add	r10,r6,r10
80003b62:	ee 0b 00 4b 	adc	r11,r7,r11
80003b66:	f0 1f 00 24 	mcall	80003bf4 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80003b6a:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80003b6e:	f0 0a 00 0a 	add	r10,r8,r10
80003b72:	ca 2a       	rjmp	800038b6 <et024006_Init+0x15e>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003b74:	fc 19 c0 00 	movh	r9,0xc000
80003b78:	32 6a       	mov	r10,38
80003b7a:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003b7c:	fc 18 c0 20 	movh	r8,0xc020
80003b80:	32 4b       	mov	r11,36
80003b82:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003b84:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003b86:	32 c9       	mov	r9,44
80003b88:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80003b8a:	49 58       	lddpc	r8,80003bdc <et024006_Init+0x484>
80003b8c:	70 07       	ld.w	r7,r8[0x0]
80003b8e:	32 88       	mov	r8,40
80003b90:	ee 08 06 46 	mulu.d	r6,r7,r8
80003b94:	e0 68 03 e8 	mov	r8,1000
80003b98:	30 09       	mov	r9,0
80003b9a:	e0 6a 03 e7 	mov	r10,999
80003b9e:	30 0b       	mov	r11,0
80003ba0:	ec 0a 00 0a 	add	r10,r6,r10
80003ba4:	ee 0b 00 4b 	adc	r11,r7,r11
80003ba8:	f0 1f 00 13 	mcall	80003bf4 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80003bac:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80003bb0:	f0 0a 00 0a 	add	r10,r8,r10
80003bb4:	c9 4a       	rjmp	800038dc <et024006_Init+0x184>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003bb6:	fc 19 c0 00 	movh	r9,0xc000
80003bba:	32 68       	mov	r8,38
80003bbc:	b2 08       	st.h	r9[0x0],r8
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003bbe:	fc 18 c0 20 	movh	r8,0xc020
80003bc2:	33 ca       	mov	r10,60
80003bc4:	b0 0a       	st.h	r8[0x0],r10
}

__always_inline static uint8_t et024006_ReadRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003bc6:	37 0a       	mov	r10,112
80003bc8:	b2 0a       	st.h	r9[0x0],r10
  return *ET024006_PARAM_ADDR;
80003bca:	90 0b       	ld.sh	r11,r8[0x0]
80003bcc:	5c 5b       	castu.b	r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003bce:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003bd0:	16 99       	mov	r9,r11
80003bd2:	a3 b9       	sbr	r9,0x3
80003bd4:	b0 09       	st.h	r8[0x0],r9
  et024006_GeneralSettings();
  et024006_InterfaceSettings();
  et024006_PowerSettings();
  et024006_PowerUp();
  et024006_PowerOn();
}
80003bd6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003bda:	00 00       	add	r0,r0
80003bdc:	00 00       	add	r0,r0
80003bde:	05 64       	ld.uh	r4,--r2
80003be0:	80 00       	ld.sh	r0,r0[0x0]
80003be2:	3f 30       	mov	r0,-13
80003be4:	80 00       	ld.sh	r0,r0[0x0]
80003be6:	40 dc       	lddsp	r12,sp[0x34]
80003be8:	80 00       	ld.sh	r0,r0[0x0]
80003bea:	40 5a       	lddsp	r10,sp[0x14]
80003bec:	80 00       	ld.sh	r0,r0[0x0]
80003bee:	41 32       	lddsp	r2,sp[0x4c]
80003bf0:	80 00       	ld.sh	r0,r0[0x0]
80003bf2:	41 4e       	lddsp	lr,sp[0x50]
80003bf4:	80 00       	ld.sh	r0,r0[0x0]
80003bf6:	79 be       	ld.w	lr,r12[0x6c]
80003bf8:	80 00       	ld.sh	r0,r0[0x0]
80003bfa:	36 e8       	mov	r8,110

80003bfc <abdac_enable>:
#include "abdac.h"

void abdac_enable(volatile avr32_abdac_t *abdac)
{
  volatile avr32_pm_t *pm = &AVR32_PM;
  pm->gcctrl[ABDAC_GCLK] |= GCLK_BIT(CEN);
80003bfc:	fe 78 0c 00 	mov	r8,-62464
80003c00:	71 d9       	ld.w	r9,r8[0x74]
80003c02:	a3 a9       	sbr	r9,0x2
80003c04:	f1 49 00 74 	st.w	r8[116],r9
  abdac->cr |= (unsigned int) ABDAC_BIT(CR_EN);
80003c08:	78 28       	ld.w	r8,r12[0x8]
80003c0a:	bf b8       	sbr	r8,0x1f
80003c0c:	99 28       	st.w	r12[0x8],r8
}
80003c0e:	5e fc       	retal	r12

80003c10 <abdac_disable>:

void abdac_disable(volatile avr32_abdac_t *abdac)
{
  volatile avr32_pm_t *pm = &AVR32_PM;
  abdac->cr &= ~ABDAC_BIT(CR_EN);
80003c10:	78 28       	ld.w	r8,r12[0x8]
80003c12:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80003c16:	99 28       	st.w	r12[0x8],r8
  pm->gcctrl[ABDAC_GCLK] &= ~GCLK_BIT(CEN);
80003c18:	fe 78 0c 00 	mov	r8,-62464
80003c1c:	71 d9       	ld.w	r9,r8[0x74]
80003c1e:	a3 c9       	cbr	r9,0x2
80003c20:	f1 49 00 74 	st.w	r8[116],r9
}
80003c24:	5e fc       	retal	r12

80003c26 <abdac_swap_channels>:

void abdac_swap_channels(volatile avr32_abdac_t *abdac)
{
  if(abdac->cr & ABDAC_BIT(CR_SWAP))
80003c26:	78 28       	ld.w	r8,r12[0x8]
80003c28:	e6 18 40 00 	andh	r8,0x4000,COH
80003c2c:	c0 50       	breq	80003c36 <abdac_swap_channels+0x10>
    abdac->cr &= ~ABDAC_BIT(CR_SWAP);
80003c2e:	78 28       	ld.w	r8,r12[0x8]
80003c30:	bf c8       	cbr	r8,0x1e
80003c32:	99 28       	st.w	r12[0x8],r8
80003c34:	5e fc       	retal	r12
  else
    abdac->cr |= ABDAC_BIT(CR_SWAP);
80003c36:	78 28       	ld.w	r8,r12[0x8]
80003c38:	bf a8       	sbr	r8,0x1e
80003c3a:	99 28       	st.w	r12[0x8],r8
80003c3c:	5e fc       	retal	r12

80003c3e <abdac_set_dac_hz>:
{
  volatile avr32_pm_t *pm = &AVR32_PM;
  unsigned short div;

  // Use OSC0
  pm->GCCTRL[ABDAC_GCLK].pllsel=0;// Oscillator source
80003c3e:	fe 78 0c 00 	mov	r8,-62464
80003c42:	71 d9       	ld.w	r9,r8[0x74]
80003c44:	30 0c       	mov	r12,0
80003c46:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
80003c4a:	f1 49 00 74 	st.w	r8[116],r9
  pm->GCCTRL[ABDAC_GCLK].oscsel=0;// OSC0
80003c4e:	71 d9       	ld.w	r9,r8[0x74]
80003c50:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80003c54:	f1 49 00 74 	st.w	r8[116],r9

  if (bus_hz < (256 * dac_hz)) {
80003c58:	a9 6a       	lsl	r10,0x8
80003c5a:	16 3a       	cp.w	r10,r11
80003c5c:	e0 88 00 09 	brls	80003c6e <abdac_set_dac_hz+0x30>
    // Disable diven to get the highest sample rate
    pm->GCCTRL[ABDAC_GCLK].diven=0;
80003c60:	71 d9       	ld.w	r9,r8[0x74]
80003c62:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80003c66:	f1 49 00 74 	st.w	r8[116],r9
80003c6a:	31 6c       	mov	r12,22
    return EINVAL;
80003c6c:	5e fc       	retal	r12
  }

  div = bus_hz / (256 * dac_hz);
80003c6e:	f6 0a 0d 08 	divu	r8,r11,r10
80003c72:	5c 88       	casts.h	r8

  if (div > 1) {
80003c74:	30 19       	mov	r9,1
80003c76:	f2 08 19 00 	cp.h	r8,r9
80003c7a:	e0 88 00 14 	brls	80003ca2 <abdac_set_dac_hz+0x64>
    // Enable DIV
    pm->GCCTRL[ABDAC_GCLK].div= (div / 2) - 1;
80003c7e:	f9 d8 c0 2f 	bfextu	r12,r8,0x1,0xf
80003c82:	20 1c       	sub	r12,1
80003c84:	5c 5c       	castu.b	r12
80003c86:	fe 79 0c 00 	mov	r9,-62464
80003c8a:	73 da       	ld.w	r10,r9[0x74]
80003c8c:	f5 dc d1 08 	bfins	r10,r12,0x8,0x8
80003c90:	f3 4a 00 74 	st.w	r9[116],r10
    pm->GCCTRL[ABDAC_GCLK].diven=1;
80003c94:	73 da       	ld.w	r10,r9[0x74]
80003c96:	30 1c       	mov	r12,1
80003c98:	f5 dc d0 81 	bfins	r10,r12,0x4,0x1
80003c9c:	f3 4a 00 74 	st.w	r9[116],r10
80003ca0:	c0 98       	rjmp	80003cb2 <abdac_set_dac_hz+0x74>
  } else {
    // Disable DIV
    pm->GCCTRL[ABDAC_GCLK].diven=0;
80003ca2:	fe 79 0c 00 	mov	r9,-62464
80003ca6:	73 da       	ld.w	r10,r9[0x74]
80003ca8:	30 0c       	mov	r12,0
80003caa:	f5 dc d0 81 	bfins	r10,r12,0x4,0x1
80003cae:	f3 4a 00 74 	st.w	r9[116],r10
  }

  return (bus_hz / (256 * div));
80003cb2:	5c 78       	castu.h	r8
80003cb4:	a9 68       	lsl	r8,0x8
80003cb6:	f6 08 0d 0a 	divu	r10,r11,r8
80003cba:	5e fa       	retal	r10

80003cbc <abdac_set_dac_sample_rate>:
  //
  // Reminder : The frequency of this ABDAC clock must be 256
  // times the frequency of the desired samplerate

  volatile avr32_pm_t *pm = &AVR32_PM;
  switch(dac_hz) {
80003cbc:	e0 4c 56 22 	cp.w	r12,22050
80003cc0:	e0 80 00 8d 	breq	80003dda <abdac_set_dac_sample_rate+0x11e>
80003cc4:	e0 8b 00 12 	brhi	80003ce8 <abdac_set_dac_sample_rate+0x2c>
80003cc8:	e0 4c 2b 11 	cp.w	r12,11025
80003ccc:	c3 b0       	breq	80003d42 <abdac_set_dac_sample_rate+0x86>
80003cce:	e0 8b 00 06 	brhi	80003cda <abdac_set_dac_sample_rate+0x1e>
80003cd2:	e0 4c 1f 40 	cp.w	r12,8000
80003cd6:	c1 b1       	brne	80003d0c <abdac_set_dac_sample_rate+0x50>
80003cd8:	c1 b8       	rjmp	80003d0e <abdac_set_dac_sample_rate+0x52>
80003cda:	e0 4c 2e e0 	cp.w	r12,12000
80003cde:	c4 b0       	breq	80003d74 <abdac_set_dac_sample_rate+0xb8>
80003ce0:	e0 4c 3e 80 	cp.w	r12,16000
80003ce4:	c1 41       	brne	80003d0c <abdac_set_dac_sample_rate+0x50>
80003ce6:	c6 18       	rjmp	80003da8 <abdac_set_dac_sample_rate+0xec>
80003ce8:	e0 4c 7d 00 	cp.w	r12,32000
80003cec:	e0 80 00 aa 	breq	80003e40 <abdac_set_dac_sample_rate+0x184>
80003cf0:	e0 8b 00 06 	brhi	80003cfc <abdac_set_dac_sample_rate+0x40>
80003cf4:	e0 4c 5d c0 	cp.w	r12,24000
80003cf8:	c0 a1       	brne	80003d0c <abdac_set_dac_sample_rate+0x50>
80003cfa:	c8 98       	rjmp	80003e0c <abdac_set_dac_sample_rate+0x150>
80003cfc:	e0 4c ac 44 	cp.w	r12,44100
80003d00:	e0 80 00 b9 	breq	80003e72 <abdac_set_dac_sample_rate+0x1b6>
80003d04:	e0 4c bb 80 	cp.w	r12,48000
80003d08:	e0 80 00 ce 	breq	80003ea4 <abdac_set_dac_sample_rate+0x1e8>
80003d0c:	5e fd       	retal	0
    case 8000:// PLL0/30/256
         pm->GCCTRL[ABDAC_GCLK].div= 14; // div by 2*(14+1)=30
80003d0e:	fe 78 0c 00 	mov	r8,-62464
80003d12:	71 d9       	ld.w	r9,r8[0x74]
80003d14:	30 ea       	mov	r10,14
80003d16:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
80003d1a:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80003d1e:	71 d9       	ld.w	r9,r8[0x74]
80003d20:	30 1c       	mov	r12,1
80003d22:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80003d26:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
80003d2a:	71 d9       	ld.w	r9,r8[0x74]
80003d2c:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
80003d30:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=0;// PLL 0
80003d34:	71 d9       	ld.w	r9,r8[0x74]
80003d36:	30 0a       	mov	r10,0
80003d38:	f3 da d0 01 	bfins	r9,r10,0x0,0x1
80003d3c:	f1 49 00 74 	st.w	r8[116],r9
      break;
80003d40:	5e fc       	retal	r12
    case 11025:// OSC1/4/256
         pm->GCCTRL[ABDAC_GCLK].div= 1;  // div by 2*(1+1)=4
80003d42:	fe 78 0c 00 	mov	r8,-62464
80003d46:	71 d9       	ld.w	r9,r8[0x74]
80003d48:	30 1c       	mov	r12,1
80003d4a:	f3 dc d1 08 	bfins	r9,r12,0x8,0x8
80003d4e:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80003d52:	71 d9       	ld.w	r9,r8[0x74]
80003d54:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80003d58:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=0;// Oscillator source
80003d5c:	71 d9       	ld.w	r9,r8[0x74]
80003d5e:	30 0a       	mov	r10,0
80003d60:	f3 da d0 21 	bfins	r9,r10,0x1,0x1
80003d64:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// OSC1
80003d68:	71 d9       	ld.w	r9,r8[0x74]
80003d6a:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80003d6e:	f1 49 00 74 	st.w	r8[116],r9
        break;
80003d72:	5e fc       	retal	r12
    case 12000:// PLL0/20/256
         pm->GCCTRL[ABDAC_GCLK].div= 9;  // div by 2*(9+1)=20
80003d74:	fe 78 0c 00 	mov	r8,-62464
80003d78:	71 d9       	ld.w	r9,r8[0x74]
80003d7a:	30 9a       	mov	r10,9
80003d7c:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
80003d80:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80003d84:	71 d9       	ld.w	r9,r8[0x74]
80003d86:	30 1c       	mov	r12,1
80003d88:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80003d8c:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
80003d90:	71 d9       	ld.w	r9,r8[0x74]
80003d92:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
80003d96:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=0;// PLL 0
80003d9a:	71 d9       	ld.w	r9,r8[0x74]
80003d9c:	30 0a       	mov	r10,0
80003d9e:	f3 da d0 01 	bfins	r9,r10,0x0,0x1
80003da2:	f1 49 00 74 	st.w	r8[116],r9
        break;
80003da6:	5e fc       	retal	r12
    case 16000:// PLL1/12/256
         pm->GCCTRL[ABDAC_GCLK].div= 5;  // div by 2*(5+1)=12
80003da8:	fe 78 0c 00 	mov	r8,-62464
80003dac:	71 d9       	ld.w	r9,r8[0x74]
80003dae:	30 5a       	mov	r10,5
80003db0:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
80003db4:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80003db8:	71 d9       	ld.w	r9,r8[0x74]
80003dba:	30 1c       	mov	r12,1
80003dbc:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80003dc0:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
80003dc4:	71 d9       	ld.w	r9,r8[0x74]
80003dc6:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
80003dca:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// PLL 1
80003dce:	71 d9       	ld.w	r9,r8[0x74]
80003dd0:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80003dd4:	f1 49 00 74 	st.w	r8[116],r9
        break;
80003dd8:	5e fc       	retal	r12
    case 22050:// OSC1/2/256
         pm->GCCTRL[ABDAC_GCLK].div= 0;  // div by 2*(0+1)=2
80003dda:	fe 78 0c 00 	mov	r8,-62464
80003dde:	71 d9       	ld.w	r9,r8[0x74]
80003de0:	30 0a       	mov	r10,0
80003de2:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
80003de6:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // div Enable
80003dea:	71 d9       	ld.w	r9,r8[0x74]
80003dec:	30 1c       	mov	r12,1
80003dee:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80003df2:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=0;// Oscillator source
80003df6:	71 d9       	ld.w	r9,r8[0x74]
80003df8:	f3 da d0 21 	bfins	r9,r10,0x1,0x1
80003dfc:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// OSC1
80003e00:	71 d9       	ld.w	r9,r8[0x74]
80003e02:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80003e06:	f1 49 00 74 	st.w	r8[116],r9
        break;
80003e0a:	5e fc       	retal	r12
    case 24000:// PLL0/10/256
         pm->GCCTRL[ABDAC_GCLK].div= 4;  // div by 2*(4+1)=10
80003e0c:	fe 78 0c 00 	mov	r8,-62464
80003e10:	71 d9       	ld.w	r9,r8[0x74]
80003e12:	30 4a       	mov	r10,4
80003e14:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
80003e18:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80003e1c:	71 d9       	ld.w	r9,r8[0x74]
80003e1e:	30 1c       	mov	r12,1
80003e20:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80003e24:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
80003e28:	71 d9       	ld.w	r9,r8[0x74]
80003e2a:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
80003e2e:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=0;// PLL 0
80003e32:	71 d9       	ld.w	r9,r8[0x74]
80003e34:	30 0a       	mov	r10,0
80003e36:	f3 da d0 01 	bfins	r9,r10,0x0,0x1
80003e3a:	f1 49 00 74 	st.w	r8[116],r9
        break;
80003e3e:	5e fc       	retal	r12
    case 32000:// PLL1/6/256
         pm->GCCTRL[ABDAC_GCLK].div= 2;  // div by 2*(2+1)=6
80003e40:	fe 78 0c 00 	mov	r8,-62464
80003e44:	71 d9       	ld.w	r9,r8[0x74]
80003e46:	30 2a       	mov	r10,2
80003e48:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
80003e4c:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80003e50:	71 d9       	ld.w	r9,r8[0x74]
80003e52:	30 1c       	mov	r12,1
80003e54:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80003e58:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
80003e5c:	71 d9       	ld.w	r9,r8[0x74]
80003e5e:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
80003e62:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// PLL 1
80003e66:	71 d9       	ld.w	r9,r8[0x74]
80003e68:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80003e6c:	f1 49 00 74 	st.w	r8[116],r9
        break;
80003e70:	5e fc       	retal	r12
    case 44100:// OSC1/256
         pm->GCCTRL[ABDAC_GCLK].div= 0;  // No Div factor
80003e72:	fe 78 0c 00 	mov	r8,-62464
80003e76:	71 da       	ld.w	r10,r8[0x74]
80003e78:	30 09       	mov	r9,0
80003e7a:	f5 d9 d1 08 	bfins	r10,r9,0x8,0x8
80003e7e:	f1 4a 00 74 	st.w	r8[116],r10
         pm->GCCTRL[ABDAC_GCLK].diven=0; // div disable
80003e82:	71 da       	ld.w	r10,r8[0x74]
80003e84:	f5 d9 d0 81 	bfins	r10,r9,0x4,0x1
80003e88:	f1 4a 00 74 	st.w	r8[116],r10
         pm->GCCTRL[ABDAC_GCLK].pllsel=0;// Oscillator source
80003e8c:	71 da       	ld.w	r10,r8[0x74]
80003e8e:	f5 d9 d0 21 	bfins	r10,r9,0x1,0x1
80003e92:	f1 4a 00 74 	st.w	r8[116],r10
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// OSC1
80003e96:	71 d9       	ld.w	r9,r8[0x74]
80003e98:	30 1c       	mov	r12,1
80003e9a:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80003e9e:	f1 49 00 74 	st.w	r8[116],r9
        break;
80003ea2:	5e fc       	retal	r12
    case 48000:// PLL1/4/256
         pm->GCCTRL[ABDAC_GCLK].div= 1;  // div by 2*(1+1)=4
80003ea4:	fe 78 0c 00 	mov	r8,-62464
80003ea8:	71 d9       	ld.w	r9,r8[0x74]
80003eaa:	30 1c       	mov	r12,1
80003eac:	f3 dc d1 08 	bfins	r9,r12,0x8,0x8
80003eb0:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80003eb4:	71 d9       	ld.w	r9,r8[0x74]
80003eb6:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80003eba:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
80003ebe:	71 d9       	ld.w	r9,r8[0x74]
80003ec0:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
80003ec4:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// PLL 1
80003ec8:	71 d9       	ld.w	r9,r8[0x74]
80003eca:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80003ece:	f1 49 00 74 	st.w	r8[116],r9
  // this can be reached on J16-pin8
  //pm->gcctrl[2] = pm->gcctrl[ABDAC_GCLK];
  //pm->GCCTRL[2].cen = 1;
  //gpio_enable_module_pin(AVR32_PM_GCLK_2_1_PIN, AVR32_PM_GCLK_2_1_FUNCTION);
  return true;
}
80003ed2:	5e fc       	retal	r12

80003ed4 <adc_configure>:
	adc->mr |= 1 << AVR32_ADC_LOWRES_OFFSET;
#endif

	/* Set Sample/Hold time to max so that the ADC capacitor should be
	 * loaded entirely */
	adc->mr |= 0xF << AVR32_ADC_SHTIM_OFFSET;
80003ed4:	78 18       	ld.w	r8,r12[0x4]
80003ed6:	ea 18 0f 00 	orh	r8,0xf00
80003eda:	99 18       	st.w	r12[0x4],r8

	/* Set Startup to max so that the ADC capacitor should be loaded
	 * entirely */
	adc->mr |= 0x1F << AVR32_ADC_STARTUP_OFFSET;
80003edc:	78 18       	ld.w	r8,r12[0x4]
80003ede:	ea 18 00 1f 	orh	r8,0x1f
80003ee2:	99 18       	st.w	r12[0x4],r8
}
80003ee4:	5e fc       	retal	r12

80003ee6 <adc_start>:
void adc_start(volatile avr32_adc_t *adc)
{
	Assert( adc != NULL );

	/* start conversion */
	adc->cr = AVR32_ADC_START_MASK;
80003ee6:	30 28       	mov	r8,2
80003ee8:	99 08       	st.w	r12[0x0],r8
}
80003eea:	5e fc       	retal	r12

80003eec <adc_enable>:
	Assert( adc != NULL );
	Assert( channel <= AVR32_ADC_CHANNELS_MSB ); /* check if channel exist
	                                              **/

	/* enable channel */
	adc->cher = (1 << channel);
80003eec:	30 18       	mov	r8,1
80003eee:	f0 0b 09 48 	lsl	r8,r8,r11
80003ef2:	99 48       	st.w	r12[0x10],r8
}
80003ef4:	5e fc       	retal	r12

80003ef6 <adc_check_eoc>:
	Assert( adc != NULL );
	Assert( channel <= AVR32_ADC_CHANNELS_MSB ); /* check if channel exist
	                                              **/

	/* get SR register : EOC bit for channel */
	return ((adc->sr & (1 << channel)) ? true : false);
80003ef6:	78 78       	ld.w	r8,r12[0x1c]
80003ef8:	30 19       	mov	r9,1
80003efa:	f2 0b 09 49 	lsl	r9,r9,r11
80003efe:	f3 e8 00 08 	and	r8,r9,r8
}
80003f02:	5f 1c       	srne	r12
80003f04:	5e fc       	retal	r12
80003f06:	d7 03       	nop

80003f08 <adc_get_value>:
 * \param *adc Base address of the ADC
 * \param  channel   channel to handle (0 to 7)
 * \return The value acquired (unsigned long)
 */
uint32_t adc_get_value(volatile avr32_adc_t *adc, uint16_t channel)
{
80003f08:	eb cd 40 e0 	pushm	r5-r7,lr
80003f0c:	18 97       	mov	r7,r12
80003f0e:	16 95       	mov	r5,r11
	Assert( adc != NULL );
	Assert( channel <= AVR32_ADC_CHANNELS_MSB );

	/* wait for end of conversion */
	while (adc_check_eoc(adc, channel) != true) {
80003f10:	ed db c0 10 	bfextu	r6,r11,0x0,0x10
80003f14:	0c 9b       	mov	r11,r6
80003f16:	0e 9c       	mov	r12,r7
80003f18:	f0 1f 00 05 	mcall	80003f2c <adc_get_value+0x24>
80003f1c:	cf c0       	breq	80003f14 <adc_get_value+0xc>
	}

	return *((uint32_t *)((&(adc->cdr0)) + channel));
80003f1e:	2d 07       	sub	r7,-48
80003f20:	5c 75       	castu.h	r5
}
80003f22:	ee 05 03 2c 	ld.w	r12,r7[r5<<0x2]
80003f26:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003f2a:	00 00       	add	r0,r0
80003f2c:	80 00       	ld.sh	r0,r0[0x0]
80003f2e:	3e f6       	mov	r6,-17

80003f30 <smc_init>:

static void smc_enable_muxed_pins(void);


void smc_init(unsigned long hsb_hz)
{
80003f30:	eb cd 40 fc 	pushm	r2-r7,lr
  unsigned long hsb_mhz_up = (hsb_hz + 999999) / 1000000;
80003f34:	ee 78 42 3f 	mov	r8,999999
80003f38:	f8 08 00 09 	add	r9,r12,r8
80003f3c:	e0 68 de 83 	mov	r8,56963
80003f40:	ea 18 43 1b 	orh	r8,0x431b
80003f44:	f2 08 06 48 	mulu.d	r8,r9,r8
80003f48:	f2 08 16 12 	lsr	r8,r9,0x12
//! Whether to use the NCS0 pin
#ifdef SMC_USE_NCS0
  #include SMC_COMPONENT_CS0

  // Setup SMC for NCS0
  SMC_CS_SETUP(0)
80003f4c:	f0 08 00 25 	add	r5,r8,r8<<0x2
80003f50:	a3 65       	lsl	r5,0x2
80003f52:	ea c5 fc 19 	sub	r5,r5,-999
80003f56:	e0 69 4d d3 	mov	r9,19923
80003f5a:	ea 19 10 62 	orh	r9,0x1062
80003f5e:	ea 09 06 44 	mulu.d	r4,r5,r9
80003f62:	a7 85       	lsr	r5,0x6
80003f64:	f0 0a 15 04 	lsl	r10,r8,0x4
80003f68:	f4 08 01 07 	sub	r7,r10,r8
80003f6c:	a1 77       	lsl	r7,0x1
80003f6e:	ee c7 fc 19 	sub	r7,r7,-999
80003f72:	ee 09 06 46 	mulu.d	r6,r7,r9
80003f76:	0e 94       	mov	r4,r7
80003f78:	a7 84       	lsr	r4,0x6
80003f7a:	f4 08 01 07 	sub	r7,r10,r8
80003f7e:	a3 67       	lsl	r7,0x2
80003f80:	ee c7 fc 19 	sub	r7,r7,-999
80003f84:	ee 09 06 46 	mulu.d	r6,r7,r9
80003f88:	a7 87       	lsr	r7,0x6
80003f8a:	f0 03 10 5a 	mul	r3,r8,90
80003f8e:	e6 c3 fc 19 	sub	r3,r3,-999
80003f92:	e6 09 06 42 	mulu.d	r2,r3,r9
80003f96:	e6 0c 16 06 	lsr	r12,r3,0x6
80003f9a:	e0 63 00 d2 	mov	r3,210
80003f9e:	f0 03 02 43 	mul	r3,r8,r3
80003fa2:	e6 c3 fc 19 	sub	r3,r3,-999
80003fa6:	e6 09 06 42 	mulu.d	r2,r3,r9
80003faa:	e6 06 16 06 	lsr	r6,r3,0x6
80003fae:	f4 08 01 0b 	sub	r11,r10,r8
80003fb2:	a5 6b       	lsl	r11,0x4
80003fb4:	f6 cb fc 19 	sub	r11,r11,-999
80003fb8:	f6 09 06 4a 	mulu.d	r10,r11,r9
80003fbc:	f6 0e 16 06 	lsr	lr,r11,0x6
80003fc0:	f0 03 10 64 	mul	r3,r8,100
80003fc4:	e6 c3 fc 19 	sub	r3,r3,-999
80003fc8:	e6 09 06 42 	mulu.d	r2,r3,r9
80003fcc:	a7 83       	lsr	r3,0x6
80003fce:	e0 6a 01 0e 	mov	r10,270
80003fd2:	b5 38       	mul	r8,r10
80003fd4:	f0 c8 fc 19 	sub	r8,r8,-999
80003fd8:	f0 09 06 48 	mulu.d	r8,r8,r9
80003fdc:	a7 89       	lsr	r9,0x6
80003fde:	ec 04 00 0a 	add	r10,r6,r4
80003fe2:	1c 3a       	cp.w	r10,lr
80003fe4:	f4 0e 17 20 	movhs	lr,r10
80003fe8:	ee 05 00 0b 	add	r11,r7,r5
80003fec:	18 3b       	cp.w	r11,r12
80003fee:	f6 0c 17 20 	movhs	r12,r11
80003ff2:	06 3b       	cp.w	r11,r3
80003ff4:	e6 0b 17 30 	movlo	r11,r3
80003ff8:	12 3a       	cp.w	r10,r9
80003ffa:	f4 09 17 20 	movhs	r9,r10
80003ffe:	eb e4 11 05 	or	r5,r5,r4<<0x10
80004002:	fe 6a 1c 00 	mov	r10,-123904
80004006:	95 05       	st.w	r10[0x0],r5
80004008:	ef e6 11 07 	or	r7,r7,r6<<0x10
8000400c:	ef ec 10 87 	or	r7,r7,r12<<0x8
80004010:	ef ee 11 87 	or	r7,r7,lr<<0x18
80004014:	95 17       	st.w	r10[0x4],r7
80004016:	1c 39       	cp.w	r9,lr
80004018:	f2 0e 17 20 	movhs	lr,r9
8000401c:	18 3b       	cp.w	r11,r12
8000401e:	f8 0b 17 30 	movlo	r11,r12
80004022:	f7 ee 11 0b 	or	r11,r11,lr<<0x10
80004026:	95 2b       	st.w	r10[0x8],r11
80004028:	e0 68 10 03 	mov	r8,4099
8000402c:	95 38       	st.w	r10[0xc],r8
8000402e:	30 19       	mov	r9,1
80004030:	48 48       	lddpc	r8,80004040 <smc_init+0x110>
80004032:	b0 89       	st.b	r8[0x0],r9
        {ATPASTE2(EBI_NCS_5,_PIN),ATPASTE2(EBI_NCS_5,_FUNCTION)},
    #endif
#endif
 };

  gpio_enable_module(SMC_EBI_GPIO_MAP, sizeof(SMC_EBI_GPIO_MAP) / sizeof(SMC_EBI_GPIO_MAP[0]));
80004034:	31 4b       	mov	r11,20
80004036:	48 4c       	lddpc	r12,80004044 <smc_init+0x114>
80004038:	f0 1f 00 04 	mcall	80004048 <smc_init+0x118>
  #undef NCS_CONTROLLED_WRITE
  #undef NWAIT_MODE
#endif
  // Put the multiplexed MCU pins used for the SM under control of the SMC.
  smc_enable_muxed_pins();
}
8000403c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80004040:	00 00       	add	r0,r0
80004042:	05 6c       	ld.uh	r12,--r2
80004044:	80 00       	ld.sh	r0,r0[0x0]
80004046:	cf 40       	breq	8000402e <smc_init+0xfe>
80004048:	80 00       	ld.sh	r0,r0[0x0]
8000404a:	40 ac       	lddsp	r12,sp[0x28]

8000404c <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
8000404c:	fe 68 14 00 	mov	r8,-125952
80004050:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
80004052:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
80004056:	91 09       	st.w	r8[0x0],r9
}
80004058:	5e fc       	retal	r12

8000405a <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000405a:	f8 08 16 05 	lsr	r8,r12,0x5
8000405e:	a9 68       	lsl	r8,0x8
80004060:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80004064:	58 1b       	cp.w	r11,1
80004066:	c0 d0       	breq	80004080 <gpio_enable_module_pin+0x26>
80004068:	c0 63       	brcs	80004074 <gpio_enable_module_pin+0x1a>
8000406a:	58 2b       	cp.w	r11,2
8000406c:	c1 00       	breq	8000408c <gpio_enable_module_pin+0x32>
8000406e:	58 3b       	cp.w	r11,3
80004070:	c1 40       	breq	80004098 <gpio_enable_module_pin+0x3e>
80004072:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80004074:	30 19       	mov	r9,1
80004076:	f2 0c 09 49 	lsl	r9,r9,r12
8000407a:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000407c:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000407e:	c1 28       	rjmp	800040a2 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80004080:	30 19       	mov	r9,1
80004082:	f2 0c 09 49 	lsl	r9,r9,r12
80004086:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80004088:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000408a:	c0 c8       	rjmp	800040a2 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000408c:	30 19       	mov	r9,1
8000408e:	f2 0c 09 49 	lsl	r9,r9,r12
80004092:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80004094:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004096:	c0 68       	rjmp	800040a2 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80004098:	30 19       	mov	r9,1
8000409a:	f2 0c 09 49 	lsl	r9,r9,r12
8000409e:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800040a0:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800040a2:	30 19       	mov	r9,1
800040a4:	f2 0c 09 4c 	lsl	r12,r9,r12
800040a8:	91 2c       	st.w	r8[0x8],r12
800040aa:	5e fd       	retal	0

800040ac <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
800040ac:	d4 21       	pushm	r4-r7,lr
800040ae:	18 97       	mov	r7,r12
800040b0:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800040b2:	58 0b       	cp.w	r11,0
800040b4:	c0 31       	brne	800040ba <gpio_enable_module+0xe>
800040b6:	30 05       	mov	r5,0
800040b8:	c0 d8       	rjmp	800040d2 <gpio_enable_module+0x26>
800040ba:	30 06       	mov	r6,0
800040bc:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800040be:	6e 1b       	ld.w	r11,r7[0x4]
800040c0:	6e 0c       	ld.w	r12,r7[0x0]
800040c2:	f0 1f 00 06 	mcall	800040d8 <gpio_enable_module+0x2c>
800040c6:	18 45       	or	r5,r12
		gpiomap++;
800040c8:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800040ca:	2f f6       	sub	r6,-1
800040cc:	0c 34       	cp.w	r4,r6
800040ce:	fe 9b ff f8 	brhi	800040be <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
800040d2:	0a 9c       	mov	r12,r5
800040d4:	d8 22       	popm	r4-r7,pc
800040d6:	00 00       	add	r0,r0
800040d8:	80 00       	ld.sh	r0,r0[0x0]
800040da:	40 5a       	lddsp	r10,sp[0x14]

800040dc <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800040dc:	f8 08 16 05 	lsr	r8,r12,0x5
800040e0:	a9 68       	lsl	r8,0x8
800040e2:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
800040e6:	30 19       	mov	r9,1
800040e8:	f2 0c 09 4c 	lsl	r12,r9,r12
800040ec:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
800040f0:	91 1c       	st.w	r8[0x4],r12
}
800040f2:	5e fc       	retal	r12

800040f4 <gpio_enable_gpio>:
 *
 * \param gpiomap The pin map.
 * \param size The number of pins in \a gpiomap.
 */
void gpio_enable_gpio(const gpio_map_t gpiomap, uint32_t size)
{
800040f4:	eb cd 40 e0 	pushm	r5-r7,lr
800040f8:	18 97       	mov	r7,r12
800040fa:	16 96       	mov	r6,r11
	uint32_t i;

	for (i = 0; i < size; i++) {
800040fc:	58 0b       	cp.w	r11,0
800040fe:	c0 a0       	breq	80004112 <gpio_enable_gpio+0x1e>
80004100:	30 05       	mov	r5,0
		gpio_enable_gpio_pin(gpiomap->pin);
80004102:	6e 0c       	ld.w	r12,r7[0x0]
80004104:	f0 1f 00 05 	mcall	80004118 <gpio_enable_gpio+0x24>
		gpiomap++;
80004108:	2f 87       	sub	r7,-8
 */
void gpio_enable_gpio(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t i;

	for (i = 0; i < size; i++) {
8000410a:	2f f5       	sub	r5,-1
8000410c:	0a 36       	cp.w	r6,r5
8000410e:	fe 9b ff fa 	brhi	80004102 <gpio_enable_gpio+0xe>
80004112:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004116:	00 00       	add	r0,r0
80004118:	80 00       	ld.sh	r0,r0[0x0]
8000411a:	40 dc       	lddsp	r12,sp[0x34]

8000411c <gpio_get_pin_value>:
 *
 * \return The pin value.
 */
bool gpio_get_pin_value(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000411c:	f8 08 16 05 	lsr	r8,r12,0x5
80004120:	a9 68       	lsl	r8,0x8
80004122:	e0 28 f0 00 	sub	r8,61440
	
	return (gpio_port->pvr >> (pin & 0x1F)) & 1;
80004126:	71 88       	ld.w	r8,r8[0x60]
80004128:	f0 0c 0a 4c 	lsr	r12,r8,r12
}
8000412c:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80004130:	5e fc       	retal	r12

80004132 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004132:	f8 08 16 05 	lsr	r8,r12,0x5
80004136:	a9 68       	lsl	r8,0x8
80004138:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
8000413c:	30 19       	mov	r9,1
8000413e:	f2 0c 09 4c 	lsl	r12,r9,r12
80004142:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80004146:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000414a:	91 1c       	st.w	r8[0x4],r12
}
8000414c:	5e fc       	retal	r12

8000414e <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000414e:	f8 08 16 05 	lsr	r8,r12,0x5
80004152:	a9 68       	lsl	r8,0x8
80004154:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80004158:	30 19       	mov	r9,1
8000415a:	f2 0c 09 4c 	lsl	r12,r9,r12
8000415e:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80004162:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80004166:	91 1c       	st.w	r8[0x4],r12
}
80004168:	5e fc       	retal	r12
8000416a:	d7 03       	nop

8000416c <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
8000416c:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80004170:	49 99       	lddpc	r9,800041d4 <INTC_register_interrupt+0x68>
80004172:	f2 08 00 39 	add	r9,r9,r8<<0x3
80004176:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000417a:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
8000417c:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80004180:	58 0a       	cp.w	r10,0
80004182:	c0 91       	brne	80004194 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004184:	49 59       	lddpc	r9,800041d8 <INTC_register_interrupt+0x6c>
80004186:	49 6a       	lddpc	r10,800041dc <INTC_register_interrupt+0x70>
80004188:	12 1a       	sub	r10,r9
8000418a:	fe 79 08 00 	mov	r9,-63488
8000418e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004192:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80004194:	58 1a       	cp.w	r10,1
80004196:	c0 a1       	brne	800041aa <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80004198:	49 09       	lddpc	r9,800041d8 <INTC_register_interrupt+0x6c>
8000419a:	49 2a       	lddpc	r10,800041e0 <INTC_register_interrupt+0x74>
8000419c:	12 1a       	sub	r10,r9
8000419e:	bf aa       	sbr	r10,0x1e
800041a0:	fe 79 08 00 	mov	r9,-63488
800041a4:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800041a8:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
800041aa:	58 2a       	cp.w	r10,2
800041ac:	c0 a1       	brne	800041c0 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
800041ae:	48 b9       	lddpc	r9,800041d8 <INTC_register_interrupt+0x6c>
800041b0:	48 da       	lddpc	r10,800041e4 <INTC_register_interrupt+0x78>
800041b2:	12 1a       	sub	r10,r9
800041b4:	bf ba       	sbr	r10,0x1f
800041b6:	fe 79 08 00 	mov	r9,-63488
800041ba:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800041be:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800041c0:	48 69       	lddpc	r9,800041d8 <INTC_register_interrupt+0x6c>
800041c2:	48 aa       	lddpc	r10,800041e8 <INTC_register_interrupt+0x7c>
800041c4:	12 1a       	sub	r10,r9
800041c6:	ea 1a c0 00 	orh	r10,0xc000
800041ca:	fe 79 08 00 	mov	r9,-63488
800041ce:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800041d2:	5e fc       	retal	r12
800041d4:	80 00       	ld.sh	r0,r0[0x0]
800041d6:	cf e0       	breq	800041d2 <INTC_register_interrupt+0x66>
800041d8:	80 00       	ld.sh	r0,r0[0x0]
800041da:	ca 00       	breq	8000411a <gpio_enable_gpio+0x26>
800041dc:	80 00       	ld.sh	r0,r0[0x0]
800041de:	cb 04       	brge	8000413e <gpio_set_gpio_pin+0xc>
800041e0:	80 00       	ld.sh	r0,r0[0x0]
800041e2:	cb 12       	brcc	80004144 <gpio_set_gpio_pin+0x12>
800041e4:	80 00       	ld.sh	r0,r0[0x0]
800041e6:	cb 20       	breq	8000414a <gpio_set_gpio_pin+0x18>
800041e8:	80 00       	ld.sh	r0,r0[0x0]
800041ea:	cb 2e       	rcall	80003f4e <smc_init+0x1e>

800041ec <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
800041ec:	fe 78 08 00 	mov	r8,-63488
800041f0:	e0 69 00 83 	mov	r9,131
800041f4:	f2 0c 01 0c 	sub	r12,r9,r12
800041f8:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
800041fc:	f2 ca ff c0 	sub	r10,r9,-64
80004200:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80004204:	58 08       	cp.w	r8,0
80004206:	c0 21       	brne	8000420a <_get_interrupt_handler+0x1e>
80004208:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
8000420a:	f0 08 12 00 	clz	r8,r8
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000420e:	48 5a       	lddpc	r10,80004220 <_get_interrupt_handler+0x34>
80004210:	f4 09 00 39 	add	r9,r10,r9<<0x3
80004214:	f0 08 11 1f 	rsub	r8,r8,31
80004218:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000421a:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
8000421e:	5e fc       	retal	r12
80004220:	80 00       	ld.sh	r0,r0[0x0]
80004222:	cf e0       	breq	8000421e <_get_interrupt_handler+0x32>

80004224 <pdca_get_handler>:
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
80004224:	30 e8       	mov	r8,14
80004226:	f0 0c 18 00 	cp.b	r12,r8
8000422a:	e0 88 00 03 	brls	80004230 <pdca_get_handler+0xc>
8000422e:	5e fe       	retal	-1

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
80004230:	a7 6c       	lsl	r12,0x6
80004232:	e0 3c 00 00 	sub	r12,65536
	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
		return (volatile avr32_pdca_channel_t *)PDCA_INVALID_ARGUMENT;
	}

	return pdca_channel;
}
80004236:	5e fc       	retal	r12

80004238 <pdca_disable>:

	return (pdca_channel->sr & AVR32_PDCA_TEN_MASK) != 0;
}

void pdca_disable(uint8_t pdca_ch_number)
{
80004238:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
8000423a:	f0 1f 00 03 	mcall	80004244 <pdca_disable+0xc>
			pdca_ch_number);

	/* Disable transfer */
	pdca_channel->cr = AVR32_PDCA_TDIS_MASK;
8000423e:	30 28       	mov	r8,2
80004240:	99 58       	st.w	r12[0x14],r8
}
80004242:	d8 02       	popm	pc
80004244:	80 00       	ld.sh	r0,r0[0x0]
80004246:	42 24       	lddsp	r4,sp[0x88]

80004248 <pdca_enable>:

void pdca_enable(uint8_t pdca_ch_number)
{
80004248:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
8000424a:	f0 1f 00 03 	mcall	80004254 <pdca_enable+0xc>
			pdca_ch_number);

	/* Enable transfer */
	pdca_channel->cr = AVR32_PDCA_TEN_MASK;
8000424e:	30 18       	mov	r8,1
80004250:	99 58       	st.w	r12[0x14],r8
}
80004252:	d8 02       	popm	pc
80004254:	80 00       	ld.sh	r0,r0[0x0]
80004256:	42 24       	lddsp	r4,sp[0x88]

80004258 <pdca_enable_interrupt_transfer_complete>:

	cpu_irq_restore(flags);
}

void pdca_enable_interrupt_transfer_complete(uint8_t pdca_ch_number)
{
80004258:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
8000425a:	f0 1f 00 03 	mcall	80004264 <pdca_enable_interrupt_transfer_complete+0xc>
			pdca_ch_number);

	pdca_channel->ier = AVR32_PDCA_TRC_MASK;
8000425e:	30 28       	mov	r8,2
80004260:	99 88       	st.w	r12[0x20],r8
}
80004262:	d8 02       	popm	pc
80004264:	80 00       	ld.sh	r0,r0[0x0]
80004266:	42 24       	lddsp	r4,sp[0x88]

80004268 <pdca_enable_interrupt_reload_counter_zero>:

	cpu_irq_restore(flags);
}

void pdca_enable_interrupt_reload_counter_zero(uint8_t pdca_ch_number)
{
80004268:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
8000426a:	f0 1f 00 03 	mcall	80004274 <pdca_enable_interrupt_reload_counter_zero+0xc>
			pdca_ch_number);

	pdca_channel->ier = AVR32_PDCA_RCZ_MASK;
8000426e:	30 18       	mov	r8,1
80004270:	99 88       	st.w	r12[0x20],r8
}
80004272:	d8 02       	popm	pc
80004274:	80 00       	ld.sh	r0,r0[0x0]
80004276:	42 24       	lddsp	r4,sp[0x88]

80004278 <pdca_get_transfer_status>:

uint32_t pdca_get_transfer_status(uint8_t pdca_ch_number)
{
80004278:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
8000427a:	f0 1f 00 03 	mcall	80004284 <pdca_get_transfer_status+0xc>
			pdca_ch_number);

	return pdca_channel->isr;
8000427e:	78 bc       	ld.w	r12,r12[0x2c]
}
80004280:	d8 02       	popm	pc
80004282:	00 00       	add	r0,r0
80004284:	80 00       	ld.sh	r0,r0[0x0]
80004286:	42 24       	lddsp	r4,sp[0x88]

80004288 <pdca_disable_interrupt_reload_counter_zero>:

	pdca_channel->ier = AVR32_PDCA_TRC_MASK;
}

void pdca_disable_interrupt_reload_counter_zero(uint8_t pdca_ch_number)
{
80004288:	d4 01       	pushm	lr
8000428a:	20 1d       	sub	sp,4
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
8000428c:	f0 1f 00 08 	mcall	800042ac <pdca_disable_interrupt_reload_counter_zero+0x24>

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80004290:	e1 b8 00 00 	mfsr	r8,0x0
80004294:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
80004296:	d3 03       	ssrf	0x10

	return flags;
80004298:	40 08       	lddsp	r8,sp[0x0]
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	pdca_channel->idr = AVR32_PDCA_RCZ_MASK;
8000429a:	30 19       	mov	r9,1
8000429c:	99 99       	st.w	r12[0x24],r9
	pdca_channel->isr;
8000429e:	78 b9       	ld.w	r9,r12[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800042a0:	e6 18 00 01 	andh	r8,0x1,COH
800042a4:	c0 21       	brne	800042a8 <pdca_disable_interrupt_reload_counter_zero+0x20>
      cpu_irq_enable();
800042a6:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
800042a8:	2f fd       	sub	sp,-4
800042aa:	d8 02       	popm	pc
800042ac:	80 00       	ld.sh	r0,r0[0x0]
800042ae:	42 24       	lddsp	r4,sp[0x88]

800042b0 <pdca_disable_interrupt_transfer_complete>:

	pdca_channel->ier = AVR32_PDCA_TERR_MASK;
}

void pdca_disable_interrupt_transfer_complete(uint8_t pdca_ch_number)
{
800042b0:	d4 01       	pushm	lr
800042b2:	20 1d       	sub	sp,4
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
800042b4:	f0 1f 00 08 	mcall	800042d4 <pdca_disable_interrupt_transfer_complete+0x24>

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800042b8:	e1 b8 00 00 	mfsr	r8,0x0
800042bc:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
800042be:	d3 03       	ssrf	0x10

	return flags;
800042c0:	40 08       	lddsp	r8,sp[0x0]
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	pdca_channel->idr = AVR32_PDCA_TRC_MASK;
800042c2:	30 29       	mov	r9,2
800042c4:	99 99       	st.w	r12[0x24],r9
	pdca_channel->isr;
800042c6:	78 b9       	ld.w	r9,r12[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800042c8:	e6 18 00 01 	andh	r8,0x1,COH
800042cc:	c0 21       	brne	800042d0 <pdca_disable_interrupt_transfer_complete+0x20>
      cpu_irq_enable();
800042ce:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
800042d0:	2f fd       	sub	sp,-4
800042d2:	d8 02       	popm	pc
800042d4:	80 00       	ld.sh	r0,r0[0x0]
800042d6:	42 24       	lddsp	r4,sp[0x88]

800042d8 <pdca_reload_channel>:
	return pdca_channel->tcrr;
}

void pdca_reload_channel(uint8_t pdca_ch_number, volatile void *addr,
		uint32_t size)
{
800042d8:	eb cd 40 c0 	pushm	r6-r7,lr
800042dc:	20 1d       	sub	sp,4
800042de:	16 96       	mov	r6,r11
800042e0:	14 97       	mov	r7,r10
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
800042e2:	f0 1f 00 0b 	mcall	8000430c <pdca_reload_channel+0x34>

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800042e6:	e1 b8 00 00 	mfsr	r8,0x0
800042ea:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
800042ec:	d3 03       	ssrf	0x10

	return flags;
800042ee:	40 08       	lddsp	r8,sp[0x0]
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	/* set up next memory address */
	pdca_channel->marr = (uint32_t)addr;
800042f0:	99 36       	st.w	r12[0xc],r6
	/* set up next memory size */
	pdca_channel->tcrr = size;
800042f2:	99 47       	st.w	r12[0x10],r7
	pdca_channel->cr = AVR32_PDCA_ECLR_MASK;
800042f4:	e0 69 01 00 	mov	r9,256
800042f8:	99 59       	st.w	r12[0x14],r9
	pdca_channel->isr;
800042fa:	78 b9       	ld.w	r9,r12[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800042fc:	e6 18 00 01 	andh	r8,0x1,COH
80004300:	c0 21       	brne	80004304 <pdca_reload_channel+0x2c>
      cpu_irq_enable();
80004302:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
80004304:	2f fd       	sub	sp,-4
80004306:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000430a:	00 00       	add	r0,r0
8000430c:	80 00       	ld.sh	r0,r0[0x0]
8000430e:	42 24       	lddsp	r4,sp[0x88]

80004310 <pdca_init_channel>:
	return pdca_channel;
}

uint32_t pdca_init_channel(uint8_t pdca_ch_number,
		const pdca_channel_options_t *opt)
{
80004310:	eb cd 40 e0 	pushm	r5-r7,lr
80004314:	20 1d       	sub	sp,4
80004316:	18 95       	mov	r5,r12
80004318:	16 96       	mov	r6,r11
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
8000431a:	f0 1f 00 13 	mcall	80004364 <pdca_init_channel+0x54>
8000431e:	18 97       	mov	r7,r12
			pdca_ch_number);

	pdca_disable_interrupt_transfer_complete(pdca_ch_number); 
80004320:	0a 9c       	mov	r12,r5
80004322:	f0 1f 00 12 	mcall	80004368 <pdca_init_channel+0x58>
	pdca_disable_interrupt_reload_counter_zero(pdca_ch_number);
80004326:	0a 9c       	mov	r12,r5
80004328:	f0 1f 00 11 	mcall	8000436c <pdca_init_channel+0x5c>

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000432c:	e1 b8 00 00 	mfsr	r8,0x0
80004330:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
80004332:	d3 03       	ssrf	0x10

	return flags;
80004334:	40 08       	lddsp	r8,sp[0x0]
	
	irqflags_t flags = cpu_irq_save();

	pdca_channel->mar = (uint32_t)opt->addr;
80004336:	6c 09       	ld.w	r9,r6[0x0]
80004338:	8f 09       	st.w	r7[0x0],r9
	pdca_channel->tcr = opt->size;
8000433a:	6c 19       	ld.w	r9,r6[0x4]
8000433c:	8f 29       	st.w	r7[0x8],r9
	pdca_channel->psr = opt->pid;
8000433e:	6c 49       	ld.w	r9,r6[0x10]
80004340:	8f 19       	st.w	r7[0x4],r9
	pdca_channel->marr = (uint32_t)opt->r_addr;
80004342:	6c 29       	ld.w	r9,r6[0x8]
80004344:	8f 39       	st.w	r7[0xc],r9
	pdca_channel->tcrr = opt->r_size;
80004346:	6c 39       	ld.w	r9,r6[0xc]
80004348:	8f 49       	st.w	r7[0x10],r9
	pdca_channel->mr =
8000434a:	6c 59       	ld.w	r9,r6[0x14]
8000434c:	8f 69       	st.w	r7[0x18],r9
#if (AVR32_PDCA_H_VERSION >= 120)
			opt->etrig << AVR32_PDCA_ETRIG_OFFSET |
#endif
			opt->transfer_size << AVR32_PDCA_SIZE_OFFSET;
	pdca_channel->cr = AVR32_PDCA_ECLR_MASK;
8000434e:	e0 69 01 00 	mov	r9,256
80004352:	8f 59       	st.w	r7[0x14],r9
	pdca_channel->isr;
80004354:	6e b9       	ld.w	r9,r7[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80004356:	e6 18 00 01 	andh	r8,0x1,COH
8000435a:	c0 21       	brne	8000435e <pdca_init_channel+0x4e>
      cpu_irq_enable();
8000435c:	d5 03       	csrf	0x10
	
	cpu_irq_restore(flags);

	return PDCA_SUCCESS;
}
8000435e:	2f fd       	sub	sp,-4
80004360:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80004364:	80 00       	ld.sh	r0,r0[0x0]
80004366:	42 24       	lddsp	r4,sp[0x88]
80004368:	80 00       	ld.sh	r0,r0[0x0]
8000436a:	42 b0       	lddsp	r0,sp[0xac]
8000436c:	80 00       	ld.sh	r0,r0[0x0]
8000436e:	42 88       	lddsp	r8,sp[0xa0]

80004370 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80004370:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
80004372:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80004376:	99 a8       	st.w	r12[0x28],r8
}
80004378:	5e fc       	retal	r12
8000437a:	d7 03       	nop

8000437c <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
8000437c:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
8000437e:	ec 5b bb 9f 	cp.w	r11,899999
80004382:	e0 8b 00 04 	brhi	8000438a <pm_enable_osc0_crystal+0xe>
80004386:	30 4b       	mov	r11,4
80004388:	c1 38       	rjmp	800043ae <pm_enable_osc0_crystal+0x32>
8000438a:	e0 68 c6 bf 	mov	r8,50879
8000438e:	ea 18 00 2d 	orh	r8,0x2d
80004392:	10 3b       	cp.w	r11,r8
80004394:	e0 8b 00 04 	brhi	8000439c <pm_enable_osc0_crystal+0x20>
80004398:	30 5b       	mov	r11,5
8000439a:	c0 a8       	rjmp	800043ae <pm_enable_osc0_crystal+0x32>
8000439c:	e0 68 12 00 	mov	r8,4608
800043a0:	ea 18 00 7a 	orh	r8,0x7a
800043a4:	10 3b       	cp.w	r11,r8
800043a6:	f9 bb 03 06 	movlo	r11,6
800043aa:	f9 bb 02 07 	movhs	r11,7
800043ae:	f0 1f 00 02 	mcall	800043b4 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
800043b2:	d8 02       	popm	pc
800043b4:	80 00       	ld.sh	r0,r0[0x0]
800043b6:	43 70       	lddsp	r0,sp[0xdc]

800043b8 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800043b8:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
800043ba:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800043be:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
800043c0:	78 08       	ld.w	r8,r12[0x0]
800043c2:	a3 a8       	sbr	r8,0x2
800043c4:	99 08       	st.w	r12[0x0],r8
}
800043c6:	5e fc       	retal	r12

800043c8 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800043c8:	79 58       	ld.w	r8,r12[0x54]
800043ca:	e2 18 00 80 	andl	r8,0x80,COH
800043ce:	cf d0       	breq	800043c8 <pm_wait_for_clk0_ready>
}
800043d0:	5e fc       	retal	r12
800043d2:	d7 03       	nop

800043d4 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
800043d4:	eb cd 40 80 	pushm	r7,lr
800043d8:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
800043da:	f0 1f 00 04 	mcall	800043e8 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
800043de:	0e 9c       	mov	r12,r7
800043e0:	f0 1f 00 03 	mcall	800043ec <pm_enable_clk0+0x18>
}
800043e4:	e3 cd 80 80 	ldm	sp++,r7,pc
800043e8:	80 00       	ld.sh	r0,r0[0x0]
800043ea:	43 b8       	lddsp	r8,sp[0xec]
800043ec:	80 00       	ld.sh	r0,r0[0x0]
800043ee:	43 c8       	lddsp	r8,sp[0xf0]

800043f0 <pm_set_osc1_mode>:
 * \param mode Oscillator 1 mode (i.e. AVR32_PM_OSCCTRL1_MODE_x).
 */
static void pm_set_osc1_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl1_t u_avr32_pm_oscctrl1 = {pm->oscctrl1};
800043f0:	78 b8       	ld.w	r8,r12[0x2c]
  // Modify
  u_avr32_pm_oscctrl1.OSCCTRL1.mode = mode;
800043f2:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl1 = u_avr32_pm_oscctrl1.oscctrl1;
800043f6:	99 b8       	st.w	r12[0x2c],r8
}
800043f8:	5e fc       	retal	r12
800043fa:	d7 03       	nop

800043fc <pm_enable_osc1_crystal>:
  pm_set_osc1_mode(pm, AVR32_PM_OSCCTRL1_MODE_EXT_CLOCK);
}


void pm_enable_osc1_crystal(volatile avr32_pm_t *pm, unsigned int fosc1)
{
800043fc:	d4 01       	pushm	lr
  pm_set_osc1_mode(pm, (fosc1 <  900000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G0 :
800043fe:	ec 5b bb 9f 	cp.w	r11,899999
80004402:	e0 8b 00 04 	brhi	8000440a <pm_enable_osc1_crystal+0xe>
80004406:	30 4b       	mov	r11,4
80004408:	c1 38       	rjmp	8000442e <pm_enable_osc1_crystal+0x32>
8000440a:	e0 68 c6 bf 	mov	r8,50879
8000440e:	ea 18 00 2d 	orh	r8,0x2d
80004412:	10 3b       	cp.w	r11,r8
80004414:	e0 8b 00 04 	brhi	8000441c <pm_enable_osc1_crystal+0x20>
80004418:	30 5b       	mov	r11,5
8000441a:	c0 a8       	rjmp	8000442e <pm_enable_osc1_crystal+0x32>
8000441c:	e0 68 12 00 	mov	r8,4608
80004420:	ea 18 00 7a 	orh	r8,0x7a
80004424:	10 3b       	cp.w	r11,r8
80004426:	f9 bb 03 06 	movlo	r11,6
8000442a:	f9 bb 02 07 	movhs	r11,7
8000442e:	f0 1f 00 02 	mcall	80004434 <pm_enable_osc1_crystal+0x38>
                       (fosc1 < 3000000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G1 :
                       (fosc1 < 8000000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G3);
}
80004432:	d8 02       	popm	pc
80004434:	80 00       	ld.sh	r0,r0[0x0]
80004436:	43 f0       	lddsp	r0,sp[0xfc]

80004438 <pm_enable_clk1_no_wait>:


void pm_enable_clk1_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl1_t u_avr32_pm_oscctrl1 = {pm->oscctrl1};
80004438:	78 b8       	ld.w	r8,r12[0x2c]
  // Modify
  u_avr32_pm_oscctrl1.OSCCTRL1.startup = startup;
8000443a:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl1 = u_avr32_pm_oscctrl1.oscctrl1;
8000443e:	99 b8       	st.w	r12[0x2c],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC1EN_MASK;
80004440:	78 08       	ld.w	r8,r12[0x0]
80004442:	a3 b8       	sbr	r8,0x3
80004444:	99 08       	st.w	r12[0x0],r8
}
80004446:	5e fc       	retal	r12

80004448 <pm_wait_for_clk1_ready>:


void pm_wait_for_clk1_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC1RDY_MASK));
80004448:	79 58       	ld.w	r8,r12[0x54]
8000444a:	e2 18 01 00 	andl	r8,0x100,COH
8000444e:	cf d0       	breq	80004448 <pm_wait_for_clk1_ready>
}
80004450:	5e fc       	retal	r12
80004452:	d7 03       	nop

80004454 <pm_enable_clk1>:
                                           AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G3);
}


void pm_enable_clk1(volatile avr32_pm_t *pm, unsigned int startup)
{
80004454:	eb cd 40 80 	pushm	r7,lr
80004458:	18 97       	mov	r7,r12
  pm_enable_clk1_no_wait(pm, startup);
8000445a:	f0 1f 00 04 	mcall	80004468 <pm_enable_clk1+0x14>
  pm_wait_for_clk1_ready(pm);
8000445e:	0e 9c       	mov	r12,r7
80004460:	f0 1f 00 03 	mcall	8000446c <pm_enable_clk1+0x18>
}
80004464:	e3 cd 80 80 	ldm	sp++,r7,pc
80004468:	80 00       	ld.sh	r0,r0[0x0]
8000446a:	44 38       	lddsp	r8,sp[0x10c]
8000446c:	80 00       	ld.sh	r0,r0[0x0]
8000446e:	44 48       	lddsp	r8,sp[0x110]

80004470 <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
80004470:	eb cd 40 d0 	pushm	r4,r6-r7,lr
80004474:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
80004478:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
8000447a:	09 f7       	ld.ub	r7,r4[0x7]
8000447c:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
80004480:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
80004484:	09 b4       	ld.ub	r4,r4[0x3]
80004486:	08 96       	mov	r6,r4
80004488:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
8000448c:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
80004490:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
80004494:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
80004498:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
8000449c:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
800044a0:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
800044a4:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
800044a8:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
800044aa:	79 58       	ld.w	r8,r12[0x54]
800044ac:	e2 18 00 20 	andl	r8,0x20,COH
800044b0:	cf d0       	breq	800044aa <pm_cksel+0x3a>
}
800044b2:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

800044b6 <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
800044b6:	eb cd 40 80 	pushm	r7,lr
800044ba:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
800044bc:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
800044be:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
800044c2:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
800044c6:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
800044ca:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
800044ce:	2f 8b       	sub	r11,-8
800044d0:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
800044d4:	e3 cd 80 80 	ldm	sp++,r7,pc

800044d8 <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
800044d8:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
800044da:	2f 8b       	sub	r11,-8
800044dc:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
800044e0:	f5 e9 10 19 	or	r9,r10,r9<<0x1
800044e4:	f3 e8 10 28 	or	r8,r9,r8<<0x2
800044e8:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
800044ec:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
800044f0:	d8 02       	popm	pc

800044f2 <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
800044f2:	2f 8b       	sub	r11,-8
800044f4:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
800044f8:	a1 a8       	sbr	r8,0x0
800044fa:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
800044fe:	5e fc       	retal	r12

80004500 <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80004500:	79 58       	ld.w	r8,r12[0x54]
80004502:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004506:	cf d0       	breq	80004500 <pm_wait_for_pll0_locked>
}
80004508:	5e fc       	retal	r12

8000450a <pm_wait_for_pll1_locked>:


void pm_wait_for_pll1_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK1_MASK));
8000450a:	79 58       	ld.w	r8,r12[0x54]
8000450c:	e2 18 00 02 	andl	r8,0x2,COH
80004510:	cf d0       	breq	8000450a <pm_wait_for_pll1_locked>
}
80004512:	5e fc       	retal	r12

80004514 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80004514:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80004516:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
8000451a:	99 08       	st.w	r12[0x0],r8
}
8000451c:	5e fc       	retal	r12
8000451e:	d7 03       	nop

80004520 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80004520:	eb cd 40 c0 	pushm	r6-r7,lr
80004524:	18 97       	mov	r7,r12
80004526:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80004528:	f0 1f 00 06 	mcall	80004540 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
8000452c:	0c 9b       	mov	r11,r6
8000452e:	0e 9c       	mov	r12,r7
80004530:	f0 1f 00 05 	mcall	80004544 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80004534:	30 1b       	mov	r11,1
80004536:	0e 9c       	mov	r12,r7
80004538:	f0 1f 00 04 	mcall	80004548 <pm_switch_to_osc0+0x28>
}
8000453c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004540:	80 00       	ld.sh	r0,r0[0x0]
80004542:	43 7c       	lddsp	r12,sp[0xdc]
80004544:	80 00       	ld.sh	r0,r0[0x0]
80004546:	43 d4       	lddsp	r4,sp[0xf4]
80004548:	80 00       	ld.sh	r0,r0[0x0]
8000454a:	45 14       	lddsp	r4,sp[0x144]

8000454c <pwm_channel_init>:

int pwm_channel_init( unsigned int channel_id, const avr32_pwm_channel_t *pwm_channel)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;

  if (pwm_channel == 0) // Null pointer.
8000454c:	58 0b       	cp.w	r11,0
8000454e:	c1 90       	breq	80004580 <pwm_channel_init+0x34>
    return PWM_INVALID_ARGUMENT;
  if (channel_id > AVR32_PWM_LINES_MSB) // Control input values.
80004550:	58 6c       	cp.w	r12,6
80004552:	e0 8b 00 17 	brhi	80004580 <pwm_channel_init+0x34>
    return PWM_INVALID_INPUT;

  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode.
80004556:	76 0a       	ld.w	r10,r11[0x0]
80004558:	fe 78 30 00 	mov	r8,-53248
8000455c:	f8 c9 ff f0 	sub	r9,r12,-16
80004560:	a5 79       	lsl	r9,0x5
80004562:	f0 09 00 09 	add	r9,r8,r9
80004566:	93 0a       	st.w	r9[0x0],r10
  pwm->channel[channel_id].cdty= pwm_channel->cdty; // Duty cycle, should be < CPRD.
80004568:	76 19       	ld.w	r9,r11[0x4]
8000456a:	a5 7c       	lsl	r12,0x5
8000456c:	f0 0c 00 0c 	add	r12,r8,r12
80004570:	f8 c8 fd fc 	sub	r8,r12,-516
80004574:	91 09       	st.w	r8[0x0],r9
  pwm->channel[channel_id].cprd= pwm_channel->cprd; // Channel period.
80004576:	76 28       	ld.w	r8,r11[0x8]
80004578:	f8 cc fd f8 	sub	r12,r12,-520
8000457c:	99 08       	st.w	r12[0x0],r8
8000457e:	5e fd       	retal	0

  return PWM_SUCCESS;
80004580:	5e ff       	retal	1

80004582 <pwm_start_channels>:
}


int pwm_start_channels(unsigned long channels_bitmask)
{
  if (channels_bitmask & ~((1 << (AVR32_PWM_LINES_MSB + 1)) - 1))
80004582:	18 98       	mov	r8,r12
80004584:	e0 18 ff 80 	andl	r8,0xff80
80004588:	c0 20       	breq	8000458c <pwm_start_channels+0xa>
8000458a:	5e ff       	retal	1
    return PWM_INVALID_INPUT;

  AVR32_PWM.ena = channels_bitmask; // Enable channels.
8000458c:	fe 78 30 00 	mov	r8,-53248
80004590:	91 1c       	st.w	r8[0x4],r12
80004592:	5e fd       	retal	0

80004594 <pwm_async_update_channel>:

int pwm_async_update_channel(unsigned int channel_id, const avr32_pwm_channel_t *pwm_channel)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;

  if (channel_id > AVR32_PWM_LINES_MSB)
80004594:	58 6c       	cp.w	r12,6
80004596:	e0 88 00 03 	brls	8000459c <pwm_async_update_channel+0x8>
8000459a:	5e ff       	retal	1
     return PWM_INVALID_INPUT;

  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode register: update of the period or duty cycle.
8000459c:	76 0a       	ld.w	r10,r11[0x0]
8000459e:	fe 78 30 00 	mov	r8,-53248
800045a2:	f8 c9 ff f0 	sub	r9,r12,-16
800045a6:	a5 79       	lsl	r9,0x5
800045a8:	f0 09 00 09 	add	r9,r8,r9
800045ac:	93 0a       	st.w	r9[0x0],r10
  pwm->channel[channel_id].cupd= pwm_channel->cupd; // Channel update CPRDx or CDTYx according to CPD value in CMRx.
800045ae:	76 49       	ld.w	r9,r11[0x10]
800045b0:	a5 7c       	lsl	r12,0x5
800045b2:	18 08       	add	r8,r12
800045b4:	f0 c8 fd f0 	sub	r8,r8,-528
800045b8:	91 09       	st.w	r8[0x0],r9
800045ba:	5e fd       	retal	0

800045bc <pwm_init>:


int pwm_init(const pwm_opt_t *opt)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
800045bc:	e1 b8 00 00 	mfsr	r8,0x0

  if (opt == 0 ) // Null pointer.
800045c0:	58 0c       	cp.w	r12,0
800045c2:	c0 21       	brne	800045c6 <pwm_init+0xa>
800045c4:	5e ff       	retal	1
    return PWM_INVALID_INPUT;

  // Disable interrupt.
  if (global_interrupt_enabled) Disable_global_interrupt();
800045c6:	e6 18 00 01 	andh	r8,0x1,COH
800045ca:	c0 91       	brne	800045dc <pwm_init+0x20>
800045cc:	d3 03       	ssrf	0x10
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
800045ce:	fe 78 30 00 	mov	r8,-53248
800045d2:	37 f9       	mov	r9,127
800045d4:	91 59       	st.w	r8[0x14],r9
  pwm->isr;
800045d6:	70 78       	ld.w	r8,r8[0x1c]
  if (global_interrupt_enabled) Enable_global_interrupt();
800045d8:	d5 03       	csrf	0x10
800045da:	c0 68       	rjmp	800045e6 <pwm_init+0x2a>
  if (opt == 0 ) // Null pointer.
    return PWM_INVALID_INPUT;

  // Disable interrupt.
  if (global_interrupt_enabled) Disable_global_interrupt();
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
800045dc:	fe 78 30 00 	mov	r8,-53248
800045e0:	37 f9       	mov	r9,127
800045e2:	91 59       	st.w	r8[0x14],r9
  pwm->isr;
800045e4:	70 78       	ld.w	r8,r8[0x1c]
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
    ((opt->diva)<<AVR32_PWM_DIVA_OFFSET) |
800045e6:	78 08       	ld.w	r8,r12[0x0]
800045e8:	78 39       	ld.w	r9,r12[0xc]
800045ea:	a9 69       	lsl	r9,0x8
800045ec:	f3 e8 11 09 	or	r9,r9,r8<<0x10
800045f0:	78 18       	ld.w	r8,r12[0x4]
800045f2:	10 49       	or	r9,r8
800045f4:	78 28       	ld.w	r8,r12[0x8]
800045f6:	f3 e8 11 89 	or	r9,r9,r8<<0x18
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
  pwm->isr;
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
800045fa:	fe 78 30 00 	mov	r8,-53248
800045fe:	91 09       	st.w	r8[0x0],r9
80004600:	5e fd       	retal	0
80004602:	d7 03       	nop

80004604 <twi_master_interrupt_handler>:
__interrupt
#endif
static void twi_master_interrupt_handler(void)
{
  // get masked status register value
  int status = twi_inst->sr & twi_it_mask;
80004604:	4a 78       	lddpc	r8,800046a0 <twi_master_interrupt_handler+0x9c>
80004606:	70 08       	ld.w	r8,r8[0x0]
80004608:	70 89       	ld.w	r9,r8[0x20]
8000460a:	4a 7a       	lddpc	r10,800046a4 <twi_master_interrupt_handler+0xa0>
8000460c:	74 0a       	ld.w	r10,r10[0x0]
8000460e:	f5 e9 00 09 	and	r9,r10,r9

  // this is a NACK
  if (status & AVR32_TWI_SR_NACK_MASK)
80004612:	12 9a       	mov	r10,r9
80004614:	e2 1a 01 00 	andl	r10,0x100,COH
80004618:	c3 91       	brne	8000468a <twi_master_interrupt_handler+0x86>
  {
    goto nack;
  }
  // this is a RXRDY
  else if (status & AVR32_TWI_SR_RXRDY_MASK)
8000461a:	12 9a       	mov	r10,r9
8000461c:	e2 1a 00 02 	andl	r10,0x2,COH
80004620:	c1 70       	breq	8000464e <twi_master_interrupt_handler+0x4a>
  {
    // get data from Receive Holding Register
    *twi_rx_data = twi_inst->rhr;
80004622:	4a 29       	lddpc	r9,800046a8 <twi_master_interrupt_handler+0xa4>
80004624:	72 0a       	ld.w	r10,r9[0x0]
80004626:	70 cb       	ld.w	r11,r8[0x30]
80004628:	b4 8b       	st.b	r10[0x0],r11
    twi_rx_data++;
8000462a:	72 0a       	ld.w	r10,r9[0x0]
8000462c:	2f fa       	sub	r10,-1
8000462e:	93 0a       	st.w	r9[0x0],r10
    // last byte to receive
    if(--twi_rx_nb_bytes==1)
80004630:	49 f9       	lddpc	r9,800046ac <twi_master_interrupt_handler+0xa8>
80004632:	72 0a       	ld.w	r10,r9[0x0]
80004634:	20 1a       	sub	r10,1
80004636:	93 0a       	st.w	r9[0x0],r10
80004638:	72 09       	ld.w	r9,r9[0x0]
    {
      // set stop bit
      twi_inst->cr = AVR32_TWI_STOP_MASK;
8000463a:	58 19       	cp.w	r9,1
8000463c:	f9 b9 00 02 	moveq	r9,2
80004640:	f1 f9 0a 00 	st.weq	r8[0x0],r9
    }
    // receive complete
    if (twi_rx_nb_bytes==0)
80004644:	49 a9       	lddpc	r9,800046ac <twi_master_interrupt_handler+0xa8>
80004646:	72 09       	ld.w	r9,r9[0x0]
80004648:	58 09       	cp.w	r9,0
8000464a:	c2 30       	breq	80004690 <twi_master_interrupt_handler+0x8c>
8000464c:	d6 03       	rete
      // finish the receive operation
      goto complete;
    }
  }
  // this is a TXRDY
  else if (status & AVR32_TWI_SR_TXRDY_MASK)
8000464e:	12 9a       	mov	r10,r9
80004650:	e2 1a 00 04 	andl	r10,0x4,COH
80004654:	c1 70       	breq	80004682 <twi_master_interrupt_handler+0x7e>
  {
    // decrease transmited bytes number
    twi_tx_nb_bytes--;
80004656:	49 79       	lddpc	r9,800046b0 <twi_master_interrupt_handler+0xac>
80004658:	72 0a       	ld.w	r10,r9[0x0]
8000465a:	20 1a       	sub	r10,1
8000465c:	93 0a       	st.w	r9[0x0],r10
    // no more bytes to transmit
    if (twi_tx_nb_bytes <= 0)
8000465e:	72 09       	ld.w	r9,r9[0x0]
80004660:	58 09       	cp.w	r9,0
80004662:	e0 89 00 0a 	brgt	80004676 <twi_master_interrupt_handler+0x72>
    {
      // enable TXCOMP IT and unmask all others IT
      twi_it_mask = AVR32_TWI_IER_TXCOMP_MASK;
80004666:	49 09       	lddpc	r9,800046a4 <twi_master_interrupt_handler+0xa0>
80004668:	30 1a       	mov	r10,1
8000466a:	93 0a       	st.w	r9[0x0],r10
      twi_inst->idr = ~0UL;
8000466c:	3f fa       	mov	r10,-1
8000466e:	91 aa       	st.w	r8[0x28],r10
      twi_inst->ier = twi_it_mask;
80004670:	72 09       	ld.w	r9,r9[0x0]
80004672:	91 99       	st.w	r8[0x24],r9
80004674:	d6 03       	rete
    }
    else
    {
      // put the byte in the Transmit Holding Register
      twi_inst->thr = *twi_tx_data++;
80004676:	49 0a       	lddpc	r10,800046b4 <twi_master_interrupt_handler+0xb0>
80004678:	74 09       	ld.w	r9,r10[0x0]
8000467a:	13 3b       	ld.ub	r11,r9++
8000467c:	91 db       	st.w	r8[0x34],r11
8000467e:	95 09       	st.w	r10[0x0],r9
80004680:	d6 03       	rete
    }
  }
  // this is a TXCOMP
  else if (status & AVR32_TWI_SR_TXCOMP_MASK)
80004682:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80004686:	c0 51       	brne	80004690 <twi_master_interrupt_handler+0x8c>
80004688:	d6 03       	rete
  }

  return;

nack:
  twi_nack = true;
8000468a:	30 1a       	mov	r10,1
8000468c:	48 b9       	lddpc	r9,800046b8 <twi_master_interrupt_handler+0xb4>
8000468e:	b2 8a       	st.b	r9[0x0],r10

complete:
  // disable all interrupts
  twi_inst->idr = ~0UL;
80004690:	3f f9       	mov	r9,-1
80004692:	91 a9       	st.w	r8[0x28],r9
  twi_inst->sr;
80004694:	70 88       	ld.w	r8,r8[0x20]
  twi_busy = false;
80004696:	30 09       	mov	r9,0
80004698:	48 98       	lddpc	r8,800046bc <twi_master_interrupt_handler+0xb8>
8000469a:	b0 89       	st.b	r8[0x0],r9
8000469c:	d6 03       	rete
8000469e:	00 00       	add	r0,r0
800046a0:	00 00       	add	r0,r0
800046a2:	06 6c       	and	r12,r3
800046a4:	00 00       	add	r0,r0
800046a6:	06 68       	and	r8,r3
800046a8:	00 00       	add	r0,r0
800046aa:	06 78       	tst	r8,r3
800046ac:	00 00       	add	r0,r0
800046ae:	06 74       	tst	r4,r3
800046b0:	00 00       	add	r0,r0
800046b2:	06 64       	and	r4,r3
800046b4:	00 00       	add	r0,r0
800046b6:	06 70       	tst	r0,r3
800046b8:	00 00       	add	r0,r0
800046ba:	06 61       	and	r1,r3
800046bc:	00 00       	add	r0,r0
800046be:	06 60       	and	r0,r3

800046c0 <twi_is_busy>:
}


bool twi_is_busy(void)
{
  if( twi_busy ) {
800046c0:	48 28       	lddpc	r8,800046c8 <twi_is_busy+0x8>
800046c2:	11 8c       	ld.ub	r12,r8[0x0]
    return true;          // Still receiving/transmitting...
  }
  else {
    return false;
  }
}
800046c4:	5e fc       	retal	r12
800046c6:	00 00       	add	r0,r0
800046c8:	00 00       	add	r0,r0
800046ca:	06 60       	and	r0,r3

800046cc <twi_master_write>:
  return TWI_SUCCESS;
}


int twi_master_write(volatile avr32_twi_t *twi, const twi_package_t *package)
{
800046cc:	eb cd 40 c0 	pushm	r6-r7,lr
800046d0:	18 96       	mov	r6,r12
800046d2:	16 97       	mov	r7,r11
  // No data to send
  if (package->length == 0)
800046d4:	76 48       	ld.w	r8,r11[0x10]
800046d6:	58 08       	cp.w	r8,0
800046d8:	c0 51       	brne	800046e2 <twi_master_write+0x16>
800046da:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
  {
    return TWI_INVALID_ARGUMENT;
  }

  while( twi_is_busy() ) {
    cpu_relax();
800046de:	fe cf ff fc 	sub	pc,pc,-4
  if (package->length == 0)
  {
    return TWI_INVALID_ARGUMENT;
  }

  while( twi_is_busy() ) {
800046e2:	f0 1f 00 1d 	mcall	80004754 <twi_master_write+0x88>
800046e6:	cf c1       	brne	800046de <twi_master_write+0x12>
    cpu_relax();
  };

  twi_nack = false;
800046e8:	30 09       	mov	r9,0
800046ea:	49 c8       	lddpc	r8,80004758 <twi_master_write+0x8c>
800046ec:	b0 89       	st.b	r8[0x0],r9
  twi_busy = true;
800046ee:	30 19       	mov	r9,1
800046f0:	49 b8       	lddpc	r8,8000475c <twi_master_write+0x90>
800046f2:	b0 89       	st.b	r8[0x0],r9

  // Enable master transfer, disable slave
  twi->cr =   AVR32_TWI_CR_MSEN_MASK
800046f4:	32 48       	mov	r8,36
800046f6:	8d 08       	st.w	r6[0x0],r8
            | AVR32_TWI_CR_SVDIS_MASK
#endif
            ;

  // set write mode, slave address and 3 internal address byte length
  twi->mmr = (0 << AVR32_TWI_MMR_MREAD_OFFSET) |
800046f8:	6e 28       	ld.w	r8,r7[0x8]
800046fa:	a9 68       	lsl	r8,0x8
800046fc:	e2 18 03 00 	andl	r8,0x300,COH
80004700:	0f 89       	ld.ub	r9,r7[0x0]
80004702:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80004706:	8d 18       	st.w	r6[0x4],r8
             (package->chip << AVR32_TWI_MMR_DADR_OFFSET) |
             ((package->addr_length << AVR32_TWI_MMR_IADRSZ_OFFSET) & AVR32_TWI_MMR_IADRSZ_MASK);

  // Set pointer to TWIM instance for IT
  twi_inst = twi;
80004708:	49 68       	lddpc	r8,80004760 <twi_master_write+0x94>
8000470a:	91 06       	st.w	r8[0x0],r6

  // set internal address for remote chip
  twi->iadr = package->addr;
8000470c:	6e 18       	ld.w	r8,r7[0x4]
8000470e:	8d 38       	st.w	r6[0xc],r8

  // get a pointer to applicative data
  twi_tx_data = package->buffer;
80004710:	6e 39       	ld.w	r9,r7[0xc]
80004712:	49 58       	lddpc	r8,80004764 <twi_master_write+0x98>
80004714:	91 09       	st.w	r8[0x0],r9

  // get a copy of nb bytes to write
  twi_tx_nb_bytes = package->length;
80004716:	6e 4a       	ld.w	r10,r7[0x10]
80004718:	49 49       	lddpc	r9,80004768 <twi_master_write+0x9c>
8000471a:	93 0a       	st.w	r9[0x0],r10

  // put the first byte in the Transmit Holding Register
  twi->thr = *twi_tx_data++;
8000471c:	70 09       	ld.w	r9,r8[0x0]
8000471e:	13 3a       	ld.ub	r10,r9++
80004720:	8d da       	st.w	r6[0x34],r10
80004722:	91 09       	st.w	r8[0x0],r9

  // mask NACK and TXRDY interrupts
  twi_it_mask = AVR32_TWI_IER_NACK_MASK | AVR32_TWI_IER_TXRDY_MASK;
80004724:	49 28       	lddpc	r8,8000476c <twi_master_write+0xa0>
80004726:	e0 69 01 04 	mov	r9,260
8000472a:	91 09       	st.w	r8[0x0],r9

  // update IMR through IER
  twi->ier = twi_it_mask;
8000472c:	70 08       	ld.w	r8,r8[0x0]
8000472e:	8d 98       	st.w	r6[0x24],r8

  // send data
  while( twi_is_busy() ) {
80004730:	c0 38       	rjmp	80004736 <twi_master_write+0x6a>
    cpu_relax();
80004732:	fe cf ff fc 	sub	pc,pc,-4

  // update IMR through IER
  twi->ier = twi_it_mask;

  // send data
  while( twi_is_busy() ) {
80004736:	f0 1f 00 08 	mcall	80004754 <twi_master_write+0x88>
8000473a:	cf c1       	brne	80004732 <twi_master_write+0x66>
    cpu_relax();
  }

  // Disable master transfer
  twi->cr =  AVR32_TWI_CR_MSDIS_MASK;
8000473c:	30 88       	mov	r8,8
8000473e:	8d 08       	st.w	r6[0x0],r8

  if( twi_nack )
80004740:	48 68       	lddpc	r8,80004758 <twi_master_write+0x8c>
80004742:	11 8c       	ld.ub	r12,r8[0x0]
80004744:	58 0c       	cp.w	r12,0
80004746:	f9 bc 01 fb 	movne	r12,-5
8000474a:	f9 bc 00 00 	moveq	r12,0
    return TWI_RECEIVE_NACK;

  return TWI_SUCCESS;
}
8000474e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004752:	00 00       	add	r0,r0
80004754:	80 00       	ld.sh	r0,r0[0x0]
80004756:	46 c0       	lddsp	r0,sp[0x1b0]
80004758:	00 00       	add	r0,r0
8000475a:	06 61       	and	r1,r3
8000475c:	00 00       	add	r0,r0
8000475e:	06 60       	and	r0,r3
80004760:	00 00       	add	r0,r0
80004762:	06 6c       	and	r12,r3
80004764:	00 00       	add	r0,r0
80004766:	06 70       	tst	r0,r3
80004768:	00 00       	add	r0,r0
8000476a:	06 64       	and	r4,r3
8000476c:	00 00       	add	r0,r0
8000476e:	06 68       	and	r8,r3

80004770 <twi_probe>:
  if (global_interrupt_enabled) Enable_global_interrupt();
}


int twi_probe(volatile avr32_twi_t *twi, char chip_addr)
{
80004770:	d4 01       	pushm	lr
80004772:	20 6d       	sub	sp,24
  twi_package_t package;
  char data[1] = {0};
80004774:	30 08       	mov	r8,0
80004776:	ba 88       	st.b	sp[0x0],r8

  // data to send
  package.buffer = data;
80004778:	50 4d       	stdsp	sp[0x10],sp
  // chip address
  package.chip = chip_addr;
8000477a:	ba cb       	st.b	sp[0x4],r11
  // frame length
  package.length = 1;
8000477c:	30 18       	mov	r8,1
8000477e:	50 58       	stdsp	sp[0x14],r8
  // address length
  package.addr_length = 0;
80004780:	30 08       	mov	r8,0
80004782:	50 38       	stdsp	sp[0xc],r8
  // internal chip address
  package.addr = 0;
80004784:	50 28       	stdsp	sp[0x8],r8
  // perform a master write access
  return (twi_master_write(twi, &package));
80004786:	fa cb ff fc 	sub	r11,sp,-4
8000478a:	f0 1f 00 03 	mcall	80004794 <twi_probe+0x24>
}
8000478e:	2f ad       	sub	sp,-24
80004790:	d8 02       	popm	pc
80004792:	00 00       	add	r0,r0
80004794:	80 00       	ld.sh	r0,r0[0x0]
80004796:	46 cc       	lddsp	r12,sp[0x1b0]

80004798 <twi_master_read>:


int twi_master_read(volatile avr32_twi_t *twi, const twi_package_t *package)
{
80004798:	eb cd 40 c0 	pushm	r6-r7,lr
8000479c:	18 96       	mov	r6,r12
8000479e:	16 97       	mov	r7,r11
  // check argument
  if (package->length == 0)
800047a0:	76 48       	ld.w	r8,r11[0x10]
800047a2:	58 08       	cp.w	r8,0
800047a4:	c0 51       	brne	800047ae <twi_master_read+0x16>
800047a6:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
  {
    return TWI_INVALID_ARGUMENT;
  }

  while( twi_is_busy() ) {
    cpu_relax();
800047aa:	fe cf ff fc 	sub	pc,pc,-4
  if (package->length == 0)
  {
    return TWI_INVALID_ARGUMENT;
  }

  while( twi_is_busy() ) {
800047ae:	f0 1f 00 1f 	mcall	80004828 <twi_master_read+0x90>
800047b2:	cf c1       	brne	800047aa <twi_master_read+0x12>
    cpu_relax();
  };

  twi_nack = false;
800047b4:	30 09       	mov	r9,0
800047b6:	49 e8       	lddpc	r8,8000482c <twi_master_read+0x94>
800047b8:	b0 89       	st.b	r8[0x0],r9
  twi_busy = true;
800047ba:	30 19       	mov	r9,1
800047bc:	49 d8       	lddpc	r8,80004830 <twi_master_read+0x98>
800047be:	b0 89       	st.b	r8[0x0],r9

  // set read mode, slave address and 3 internal address byte length
  twi->mmr = (package->chip << AVR32_TWI_MMR_DADR_OFFSET) |
800047c0:	0f 89       	ld.ub	r9,r7[0x0]
800047c2:	6e 28       	ld.w	r8,r7[0x8]
800047c4:	a9 68       	lsl	r8,0x8
800047c6:	e2 18 03 00 	andl	r8,0x300,COH
800047ca:	f1 e9 11 08 	or	r8,r8,r9<<0x10
800047ce:	ad a8       	sbr	r8,0xc
800047d0:	8d 18       	st.w	r6[0x4],r8
             ((package->addr_length << AVR32_TWI_MMR_IADRSZ_OFFSET) & AVR32_TWI_MMR_IADRSZ_MASK) |
             (1 << AVR32_TWI_MMR_MREAD_OFFSET);

  // Set pointer to TWIM instance for IT
  twi_inst = twi;
800047d2:	49 98       	lddpc	r8,80004834 <twi_master_read+0x9c>
800047d4:	91 06       	st.w	r8[0x0],r6

  // set internal address for remote chip
  twi->iadr = package->addr;
800047d6:	6e 18       	ld.w	r8,r7[0x4]
800047d8:	8d 38       	st.w	r6[0xc],r8

  // get a pointer to applicative data
  twi_rx_data = package->buffer;
800047da:	6e 39       	ld.w	r9,r7[0xc]
800047dc:	49 78       	lddpc	r8,80004838 <twi_master_read+0xa0>
800047de:	91 09       	st.w	r8[0x0],r9

  // get a copy of nb bytes to read
  twi_rx_nb_bytes = package->length;
800047e0:	6e 49       	ld.w	r9,r7[0x10]
800047e2:	49 78       	lddpc	r8,8000483c <twi_master_read+0xa4>
800047e4:	91 09       	st.w	r8[0x0],r9

  // Enable master transfer
  twi->cr =  AVR32_TWI_CR_MSEN_MASK;
800047e6:	30 49       	mov	r9,4
800047e8:	8d 09       	st.w	r6[0x0],r9

  // Send start condition
  twi->cr = AVR32_TWI_START_MASK;
800047ea:	30 19       	mov	r9,1
800047ec:	8d 09       	st.w	r6[0x0],r9

  // only one byte to receive
  if(twi_rx_nb_bytes == 1)
800047ee:	70 08       	ld.w	r8,r8[0x0]
  {
    // set stop bit
    twi->cr = AVR32_TWI_STOP_MASK;
800047f0:	12 38       	cp.w	r8,r9
800047f2:	f9 b8 00 02 	moveq	r8,2
800047f6:	ed f8 0a 00 	st.weq	r6[0x0],r8
  }

  // mask NACK and RXRDY interrupts
  twi_it_mask = AVR32_TWI_IER_NACK_MASK | AVR32_TWI_IER_RXRDY_MASK;
800047fa:	49 28       	lddpc	r8,80004840 <twi_master_read+0xa8>
800047fc:	e0 69 01 02 	mov	r9,258
80004800:	91 09       	st.w	r8[0x0],r9

  // update IMR through IER
  twi->ier = twi_it_mask;
80004802:	70 08       	ld.w	r8,r8[0x0]
80004804:	8d 98       	st.w	r6[0x24],r8

  // get data
  while( twi_is_busy() ) {
80004806:	c0 38       	rjmp	8000480c <twi_master_read+0x74>
    cpu_relax();
80004808:	fe cf ff fc 	sub	pc,pc,-4

  // update IMR through IER
  twi->ier = twi_it_mask;

  // get data
  while( twi_is_busy() ) {
8000480c:	f0 1f 00 07 	mcall	80004828 <twi_master_read+0x90>
80004810:	cf c1       	brne	80004808 <twi_master_read+0x70>
    cpu_relax();
  }

  // Disable master transfer
  twi->cr =  AVR32_TWI_CR_MSDIS_MASK;
80004812:	30 88       	mov	r8,8
80004814:	8d 08       	st.w	r6[0x0],r8

  if( twi_nack )
80004816:	48 68       	lddpc	r8,8000482c <twi_master_read+0x94>
80004818:	11 8c       	ld.ub	r12,r8[0x0]
8000481a:	58 0c       	cp.w	r12,0
8000481c:	f9 bc 01 fb 	movne	r12,-5
80004820:	f9 bc 00 00 	moveq	r12,0
    return TWI_RECEIVE_NACK;

  return TWI_SUCCESS;
}
80004824:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004828:	80 00       	ld.sh	r0,r0[0x0]
8000482a:	46 c0       	lddsp	r0,sp[0x1b0]
8000482c:	00 00       	add	r0,r0
8000482e:	06 61       	and	r1,r3
80004830:	00 00       	add	r0,r0
80004832:	06 60       	and	r0,r3
80004834:	00 00       	add	r0,r0
80004836:	06 6c       	and	r12,r3
80004838:	00 00       	add	r0,r0
8000483a:	06 78       	tst	r8,r3
8000483c:	00 00       	add	r0,r0
8000483e:	06 74       	tst	r4,r3
80004840:	00 00       	add	r0,r0
80004842:	06 68       	and	r8,r3

80004844 <twi_master_init>:
  return TWI_SUCCESS;
}


int twi_master_init(volatile avr32_twi_t *twi, const twi_options_t *opt)
{
80004844:	eb cd 40 c0 	pushm	r6-r7,lr
80004848:	18 97       	mov	r7,r12
8000484a:	16 96       	mov	r6,r11
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
8000484c:	e1 b8 00 00 	mfsr	r8,0x0
  int status = TWI_SUCCESS;

  // Set pointer to TWIM instance for IT
  twi_inst = twi;
80004850:	4a 09       	lddpc	r9,800048d0 <twi_master_init+0x8c>
80004852:	93 0c       	st.w	r9[0x0],r12

  // Disable TWI interrupts
  if (global_interrupt_enabled) Disable_global_interrupt();
80004854:	e6 18 00 01 	andh	r8,0x1,COH
80004858:	c0 a1       	brne	8000486c <twi_master_init+0x28>
8000485a:	d3 03       	ssrf	0x10
  twi->idr = ~0UL;
8000485c:	3f f8       	mov	r8,-1
8000485e:	99 a8       	st.w	r12[0x28],r8
  twi->sr;
80004860:	78 88       	ld.w	r8,r12[0x20]

  // Reset TWI
  twi->cr = AVR32_TWI_CR_SWRST_MASK;
80004862:	e0 68 00 80 	mov	r8,128
80004866:	99 08       	st.w	r12[0x0],r8
  if (global_interrupt_enabled) Enable_global_interrupt();
80004868:	d5 03       	csrf	0x10
8000486a:	c0 78       	rjmp	80004878 <twi_master_init+0x34>
  // Set pointer to TWIM instance for IT
  twi_inst = twi;

  // Disable TWI interrupts
  if (global_interrupt_enabled) Disable_global_interrupt();
  twi->idr = ~0UL;
8000486c:	3f f8       	mov	r8,-1
8000486e:	99 a8       	st.w	r12[0x28],r8
  twi->sr;
80004870:	78 88       	ld.w	r8,r12[0x20]

  // Reset TWI
  twi->cr = AVR32_TWI_CR_SWRST_MASK;
80004872:	e0 68 00 80 	mov	r8,128
80004876:	99 08       	st.w	r12[0x0],r8
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Dummy read in SR
  twi->sr;
80004878:	6e 88       	ld.w	r8,r7[0x20]

  // Disable all interrupts
  Disable_global_interrupt();
8000487a:	d3 03       	ssrf	0x10

  // Register TWI handler on level 2
  INTC_register_interrupt( &twi_master_interrupt_handler, AVR32_TWI_IRQ, AVR32_INTC_INT1);
8000487c:	30 1a       	mov	r10,1
8000487e:	e0 6b 01 60 	mov	r11,352
80004882:	49 5c       	lddpc	r12,800048d4 <twi_master_init+0x90>
80004884:	f0 1f 00 15 	mcall	800048d8 <twi_master_init+0x94>

  // Enable all interrupts
  Enable_global_interrupt();
80004888:	d5 03       	csrf	0x10
static int twi_set_speed(volatile avr32_twi_t *twi, unsigned int speed, unsigned long pba_hz)
{
  unsigned int ckdiv = 0;
  unsigned int c_lh_div;

  c_lh_div = pba_hz / (speed * 2) - 4;
8000488a:	6c 19       	ld.w	r9,r6[0x4]
8000488c:	a1 79       	lsl	r9,0x1
8000488e:	6c 08       	ld.w	r8,r6[0x0]
80004890:	f0 09 0d 08 	divu	r8,r8,r9
80004894:	20 48       	sub	r8,4

  // cldiv must fit in 8 bits, ckdiv must fit in 3 bits
  while ((c_lh_div > 0xFF) && (ckdiv < 0x7))
80004896:	e0 48 00 ff 	cp.w	r8,255
8000489a:	e0 8b 00 04 	brhi	800048a2 <twi_master_init+0x5e>
8000489e:	30 09       	mov	r9,0
800048a0:	c0 f8       	rjmp	800048be <twi_master_init+0x7a>
800048a2:	30 09       	mov	r9,0
800048a4:	30 0c       	mov	r12,0
  {
    // increase clock divider
    ckdiv++;
800048a6:	2f f9       	sub	r9,-1
    // divide cldiv value
    c_lh_div /= 2;
800048a8:	a1 98       	lsr	r8,0x1
  unsigned int c_lh_div;

  c_lh_div = pba_hz / (speed * 2) - 4;

  // cldiv must fit in 8 bits, ckdiv must fit in 3 bits
  while ((c_lh_div > 0xFF) && (ckdiv < 0x7))
800048aa:	e0 48 00 ff 	cp.w	r8,255
800048ae:	5f bb       	srhi	r11
800048b0:	58 69       	cp.w	r9,6
800048b2:	5f 8a       	srls	r10
800048b4:	f7 ea 00 0a 	and	r10,r11,r10
800048b8:	f8 0a 18 00 	cp.b	r10,r12
800048bc:	cf 51       	brne	800048a6 <twi_master_init+0x62>
    // divide cldiv value
    c_lh_div /= 2;
  }

  // set clock waveform generator register
  twi->cwgr = ((c_lh_div << AVR32_TWI_CWGR_CLDIV_OFFSET) |
800048be:	b1 69       	lsl	r9,0x10
800048c0:	f3 e8 10 89 	or	r9,r9,r8<<0x8
800048c4:	f3 e8 10 08 	or	r8,r9,r8
800048c8:	8f 48       	st.w	r7[0x10],r8

  // Probe the component
  //status = twi_probe(twi, opt->chip);

  return status;
}
800048ca:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
800048ce:	00 00       	add	r0,r0
800048d0:	00 00       	add	r0,r0
800048d2:	06 6c       	and	r12,r3
800048d4:	80 00       	ld.sh	r0,r0[0x0]
800048d6:	46 04       	lddsp	r4,sp[0x180]
800048d8:	80 00       	ld.sh	r0,r0[0x0]
800048da:	41 6c       	lddsp	r12,sp[0x58]

800048dc <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
800048dc:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
800048de:	f6 08 15 04 	lsl	r8,r11,0x4
800048e2:	14 38       	cp.w	r8,r10
800048e4:	f9 b8 08 10 	movls	r8,16
800048e8:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
800048ec:	f0 0b 02 4b 	mul	r11,r8,r11
800048f0:	f6 09 16 01 	lsr	r9,r11,0x1
800048f4:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
800048f8:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
800048fc:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80004900:	f2 cb 00 01 	sub	r11,r9,1
80004904:	e0 4b ff fe 	cp.w	r11,65534
80004908:	e0 88 00 03 	brls	8000490e <usart_set_async_baudrate+0x32>
8000490c:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
8000490e:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80004910:	e8 6e 00 00 	mov	lr,524288
80004914:	59 08       	cp.w	r8,16
80004916:	fc 08 17 10 	movne	r8,lr
8000491a:	f9 b8 00 00 	moveq	r8,0
8000491e:	e4 1b ff f7 	andh	r11,0xfff7
80004922:	e0 1b fe cf 	andl	r11,0xfecf
80004926:	16 48       	or	r8,r11
80004928:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
8000492a:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
8000492e:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80004932:	99 89       	st.w	r12[0x20],r9
80004934:	d8 0a       	popm	pc,r12=0

80004936 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80004936:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80004938:	e2 18 00 02 	andl	r8,0x2,COH
8000493c:	c0 31       	brne	80004942 <usart_write_char+0xc>
8000493e:	30 2c       	mov	r12,2
80004940:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80004942:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80004946:	99 7b       	st.w	r12[0x1c],r11
80004948:	5e fd       	retal	0
8000494a:	d7 03       	nop

8000494c <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
8000494c:	eb cd 40 e0 	pushm	r5-r7,lr
80004950:	18 96       	mov	r6,r12
80004952:	16 95       	mov	r5,r11
80004954:	e0 67 27 0f 	mov	r7,9999
80004958:	c0 68       	rjmp	80004964 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
8000495a:	58 07       	cp.w	r7,0
8000495c:	c0 31       	brne	80004962 <usart_putchar+0x16>
8000495e:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80004962:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80004964:	0a 9b       	mov	r11,r5
80004966:	0c 9c       	mov	r12,r6
80004968:	f0 1f 00 03 	mcall	80004974 <usart_putchar+0x28>
8000496c:	cf 71       	brne	8000495a <usart_putchar+0xe>

  return USART_SUCCESS;
}
8000496e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004972:	00 00       	add	r0,r0
80004974:	80 00       	ld.sh	r0,r0[0x0]
80004976:	49 36       	lddpc	r6,800049c0 <usart_getchar+0x24>

80004978 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80004978:	78 58       	ld.w	r8,r12[0x14]
8000497a:	e2 18 00 e0 	andl	r8,0xe0,COH
8000497e:	c0 30       	breq	80004984 <usart_read_char+0xc>
80004980:	30 4c       	mov	r12,4
80004982:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80004984:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80004986:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000498a:	c0 31       	brne	80004990 <usart_read_char+0x18>
8000498c:	30 3c       	mov	r12,3
8000498e:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80004990:	78 68       	ld.w	r8,r12[0x18]
80004992:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80004996:	97 08       	st.w	r11[0x0],r8
80004998:	5e fd       	retal	0
8000499a:	d7 03       	nop

8000499c <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
8000499c:	eb cd 40 c0 	pushm	r6-r7,lr
800049a0:	20 1d       	sub	sp,4
800049a2:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
800049a4:	1a 97       	mov	r7,sp
800049a6:	1a 9b       	mov	r11,sp
800049a8:	0c 9c       	mov	r12,r6
800049aa:	f0 1f 00 07 	mcall	800049c4 <usart_getchar+0x28>
800049ae:	58 3c       	cp.w	r12,3
800049b0:	cf b0       	breq	800049a6 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
800049b2:	58 4c       	cp.w	r12,4
800049b4:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
800049b8:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
800049bc:	2f fd       	sub	sp,-4
800049be:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800049c2:	00 00       	add	r0,r0
800049c4:	80 00       	ld.sh	r0,r0[0x0]
800049c6:	49 78       	lddpc	r8,80004a20 <usart_init_rs232+0x8>

800049c8 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
800049c8:	eb cd 40 c0 	pushm	r6-r7,lr
800049cc:	18 96       	mov	r6,r12
800049ce:	16 97       	mov	r7,r11
  while (*string != '\0')
800049d0:	17 8b       	ld.ub	r11,r11[0x0]
800049d2:	58 0b       	cp.w	r11,0
800049d4:	c0 80       	breq	800049e4 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
800049d6:	2f f7       	sub	r7,-1
800049d8:	0c 9c       	mov	r12,r6
800049da:	f0 1f 00 04 	mcall	800049e8 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
800049de:	0f 8b       	ld.ub	r11,r7[0x0]
800049e0:	58 0b       	cp.w	r11,0
800049e2:	cf a1       	brne	800049d6 <usart_write_line+0xe>
800049e4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800049e8:	80 00       	ld.sh	r0,r0[0x0]
800049ea:	49 4c       	lddpc	r12,80004a38 <usart_init_rs232+0x20>

800049ec <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
800049ec:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
800049f0:	e6 18 00 01 	andh	r8,0x1,COH
800049f4:	c0 71       	brne	80004a02 <usart_reset+0x16>
800049f6:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
800049f8:	3f f8       	mov	r8,-1
800049fa:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800049fc:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
800049fe:	d5 03       	csrf	0x10
80004a00:	c0 48       	rjmp	80004a08 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80004a02:	3f f8       	mov	r8,-1
80004a04:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80004a06:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80004a08:	30 08       	mov	r8,0
80004a0a:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80004a0c:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80004a0e:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80004a10:	ea 68 61 0c 	mov	r8,680204
80004a14:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80004a16:	5e fc       	retal	r12

80004a18 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80004a18:	eb cd 40 e0 	pushm	r5-r7,lr
80004a1c:	18 96       	mov	r6,r12
80004a1e:	16 97       	mov	r7,r11
80004a20:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80004a22:	f0 1f 00 2f 	mcall	80004adc <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80004a26:	58 07       	cp.w	r7,0
80004a28:	c5 80       	breq	80004ad8 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80004a2a:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004a2c:	30 49       	mov	r9,4
80004a2e:	f2 08 18 00 	cp.b	r8,r9
80004a32:	e0 88 00 53 	brls	80004ad8 <usart_init_rs232+0xc0>
80004a36:	30 99       	mov	r9,9
80004a38:	f2 08 18 00 	cp.b	r8,r9
80004a3c:	e0 8b 00 4e 	brhi	80004ad8 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80004a40:	0f d9       	ld.ub	r9,r7[0x5]
80004a42:	30 78       	mov	r8,7
80004a44:	f0 09 18 00 	cp.b	r9,r8
80004a48:	e0 8b 00 48 	brhi	80004ad8 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80004a4c:	8e 39       	ld.sh	r9,r7[0x6]
80004a4e:	e0 68 01 01 	mov	r8,257
80004a52:	f0 09 19 00 	cp.h	r9,r8
80004a56:	e0 8b 00 41 	brhi	80004ad8 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80004a5a:	ef 39 00 08 	ld.ub	r9,r7[8]
80004a5e:	30 38       	mov	r8,3
80004a60:	f0 09 18 00 	cp.b	r9,r8
80004a64:	e0 8b 00 3a 	brhi	80004ad8 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80004a68:	0a 9a       	mov	r10,r5
80004a6a:	6e 0b       	ld.w	r11,r7[0x0]
80004a6c:	0c 9c       	mov	r12,r6
80004a6e:	f0 1f 00 1d 	mcall	80004ae0 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004a72:	58 1c       	cp.w	r12,1
80004a74:	c3 20       	breq	80004ad8 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80004a76:	0f c8       	ld.ub	r8,r7[0x4]
80004a78:	30 99       	mov	r9,9
80004a7a:	f2 08 18 00 	cp.b	r8,r9
80004a7e:	c0 51       	brne	80004a88 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80004a80:	6c 18       	ld.w	r8,r6[0x4]
80004a82:	b1 b8       	sbr	r8,0x11
80004a84:	8d 18       	st.w	r6[0x4],r8
80004a86:	c0 68       	rjmp	80004a92 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80004a88:	6c 19       	ld.w	r9,r6[0x4]
80004a8a:	20 58       	sub	r8,5
80004a8c:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80004a90:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80004a92:	6c 19       	ld.w	r9,r6[0x4]
80004a94:	ef 3a 00 08 	ld.ub	r10,r7[8]
80004a98:	0f d8       	ld.ub	r8,r7[0x5]
80004a9a:	a9 78       	lsl	r8,0x9
80004a9c:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80004aa0:	12 48       	or	r8,r9
80004aa2:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80004aa4:	8e 38       	ld.sh	r8,r7[0x6]
80004aa6:	30 29       	mov	r9,2
80004aa8:	f2 08 19 00 	cp.h	r8,r9
80004aac:	e0 88 00 09 	brls	80004abe <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80004ab0:	6c 18       	ld.w	r8,r6[0x4]
80004ab2:	ad b8       	sbr	r8,0xd
80004ab4:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80004ab6:	8e b8       	ld.uh	r8,r7[0x6]
80004ab8:	20 28       	sub	r8,2
80004aba:	8d a8       	st.w	r6[0x28],r8
80004abc:	c0 68       	rjmp	80004ac8 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80004abe:	6c 19       	ld.w	r9,r6[0x4]
80004ac0:	5c 78       	castu.h	r8
80004ac2:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80004ac6:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80004ac8:	6c 18       	ld.w	r8,r6[0x4]
80004aca:	e0 18 ff f0 	andl	r8,0xfff0
80004ace:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80004ad0:	35 08       	mov	r8,80
80004ad2:	8d 08       	st.w	r6[0x0],r8
80004ad4:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80004ad8:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80004adc:	80 00       	ld.sh	r0,r0[0x0]
80004ade:	49 ec       	lddpc	r12,80004b54 <_stext+0x8>
80004ae0:	80 00       	ld.sh	r0,r0[0x0]
80004ae2:	48 dc       	lddpc	r12,80004b14 <print_ulong+0x24>

80004ae4 <print>:
  print_hex(DBG_USART, n);
}


void print(volatile avr32_usart_t *usart, const char *str)
{
80004ae4:	d4 01       	pushm	lr
  // Invoke the USART driver to transmit the input string with the given USART.
  usart_write_line(usart, str);
80004ae6:	f0 1f 00 02 	mcall	80004aec <print+0x8>
}
80004aea:	d8 02       	popm	pc
80004aec:	80 00       	ld.sh	r0,r0[0x0]
80004aee:	49 c8       	lddpc	r8,80004b5c <_stext+0x10>

80004af0 <print_ulong>:
  usart_putchar(usart, c);
}


void print_ulong(volatile avr32_usart_t *usart, unsigned long n)
{
80004af0:	eb cd 40 e0 	pushm	r5-r7,lr
80004af4:	20 3d       	sub	sp,12
  char tmp[11];
  int i = sizeof(tmp) - 1;

  // Convert the given number to an ASCII decimal representation.
  tmp[i] = '\0';
80004af6:	30 08       	mov	r8,0
80004af8:	fb 68 00 0a 	st.b	sp[10],r8
80004afc:	30 a9       	mov	r9,10
  do
  {
    tmp[--i] = '0' + n % 10;
80004afe:	1a 95       	mov	r5,sp
80004b00:	e0 6e cc cd 	mov	lr,52429
80004b04:	ea 1e cc cc 	orh	lr,0xcccc
80004b08:	20 19       	sub	r9,1
80004b0a:	f6 0e 06 46 	mulu.d	r6,r11,lr
80004b0e:	0e 98       	mov	r8,r7
80004b10:	a3 98       	lsr	r8,0x3
80004b12:	f0 08 00 2a 	add	r10,r8,r8<<0x2
80004b16:	f6 0a 01 1b 	sub	r11,r11,r10<<0x1
80004b1a:	2d 0b       	sub	r11,-48
80004b1c:	ea 09 0b 0b 	st.b	r5[r9],r11
    n /= 10;
80004b20:	10 9b       	mov	r11,r8
  } while (n);
80004b22:	58 08       	cp.w	r8,0
80004b24:	cf 21       	brne	80004b08 <print_ulong+0x18>

  // Transmit the resulting string with the given USART.
  print(usart, tmp + i);
80004b26:	1a 9b       	mov	r11,sp
80004b28:	12 0b       	add	r11,r9
80004b2a:	f0 1f 00 03 	mcall	80004b34 <print_ulong+0x44>
}
80004b2e:	2f dd       	sub	sp,-12
80004b30:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004b34:	80 00       	ld.sh	r0,r0[0x0]
80004b36:	4a e4       	lddpc	r4,80004bec <init_sys_clocks+0x5c>

80004b38 <print_dbg_ulong>:
  print_char(DBG_USART, c);
}


void print_dbg_ulong(unsigned long n)
{
80004b38:	d4 01       	pushm	lr
  // Redirection to the debug USART.
  print_ulong(DBG_USART, n);
80004b3a:	18 9b       	mov	r11,r12
80004b3c:	fe 7c 14 00 	mov	r12,-60416
80004b40:	f0 1f 00 02 	mcall	80004b48 <print_dbg_ulong+0x10>
}
80004b44:	d8 02       	popm	pc
80004b46:	00 00       	add	r0,r0
80004b48:	80 00       	ld.sh	r0,r0[0x0]
80004b4a:	4a f0       	lddpc	r0,80004c04 <init_sys_clocks+0x74>

80004b4c <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80004b4c:	e0 7d 00 00 	mov	sp,65536

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80004b50:	fe c0 81 50 	sub	r0,pc,-32432

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80004b54:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80004b58:	d5 53       	csrf	0x15
  cp      r0, r1
80004b5a:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
80004b5c:	e0 61 05 38 	mov	r1,1336
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80004b60:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80004b62:	c0 62       	brcc	80004b6e <idata_load_loop_end>
  cp      r0, r1
80004b64:	48 92       	lddpc	r2,80004b88 <udata_clear_loop_end+0x4>

80004b66 <idata_load_loop>:
  brlo    idata_load_loop
80004b66:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80004b68:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80004b6a:	02 30       	cp.w	r0,r1
  cp      r0, r1
80004b6c:	cf d3       	brcs	80004b66 <idata_load_loop>

80004b6e <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80004b6e:	e0 60 05 38 	mov	r0,1336
  mov     r2, 0
  mov     r3, 0
80004b72:	e0 61 10 70 	mov	r1,4208
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80004b76:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80004b78:	c0 62       	brcc	80004b84 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80004b7a:	30 02       	mov	r2,0
80004b7c:	30 03       	mov	r3,0

80004b7e <udata_clear_loop>:
80004b7e:	a1 22       	st.d	r0++,r2
80004b80:	02 30       	cp.w	r0,r1
80004b82:	cf e3       	brcs	80004b7e <udata_clear_loop>

80004b84 <udata_clear_loop_end>:
80004b84:	fe cf ff 00 	sub	pc,pc,-256
80004b88:	80 02       	ld.sh	r2,r0[0x0]
80004b8a:	fa c8 5e fc 	sub	r8,sp,24316

80004b8c <master_callback>:
		adc_underrun_callback();;
	}
	else if( arg == AUDIO_ADC_RELOAD_CB ){
		adc_reload_callback();;
	}
}
80004b8c:	5e fc       	retal	r12
80004b8e:	d7 03       	nop

80004b90 <init_sys_clocks>:
void adc_reload_callback(void){
  // Nothing todo
}


void init_sys_clocks(void)	{
80004b90:	eb cd 40 c0 	pushm	r6-r7,lr
	// Switch to OSC0 to speed up the booting
	pm_switch_to_osc0(&AVR32_PM, FOSC0, OSC0_STARTUP);
80004b94:	30 3a       	mov	r10,3
80004b96:	e0 6b 1b 00 	mov	r11,6912
80004b9a:	ea 1b 00 b7 	orh	r11,0xb7
80004b9e:	fe 7c 0c 00 	mov	r12,-62464
80004ba2:	f0 1f 00 2e 	mcall	80004c58 <init_sys_clocks+0xc8>

	// Start oscillator1
	pm_enable_osc1_crystal(&AVR32_PM, FOSC1);
80004ba6:	e0 6b 44 00 	mov	r11,17408
80004baa:	ea 1b 00 ac 	orh	r11,0xac
80004bae:	fe 7c 0c 00 	mov	r12,-62464
80004bb2:	f0 1f 00 2b 	mcall	80004c5c <init_sys_clocks+0xcc>
	pm_enable_clk1(&AVR32_PM, OSC1_STARTUP);
80004bb6:	30 3b       	mov	r11,3
80004bb8:	fe 7c 0c 00 	mov	r12,-62464
80004bbc:	f0 1f 00 29 	mcall	80004c60 <init_sys_clocks+0xd0>

	// Set PLL0 (fed from OSC1 = 11.2896 MHz) to 124.1856 MHz
	// We use OSC1 since we need a correct master clock for the SSC module to generate
	// the correct sample rate
	pm_pll_setup(&AVR32_PM, 0,  // pll.
80004bc0:	31 06       	mov	r6,16
80004bc2:	1a d6       	st.w	--sp,r6
80004bc4:	30 18       	mov	r8,1
80004bc6:	10 99       	mov	r9,r8
80004bc8:	30 aa       	mov	r10,10
80004bca:	30 0b       	mov	r11,0
80004bcc:	fe 7c 0c 00 	mov	r12,-62464
80004bd0:	f0 1f 00 25 	mcall	80004c64 <init_sys_clocks+0xd4>
	1,   // osc.
	16); // lockcount.

	// Set PLL operating range and divider (fpll = fvco/2)
	// -> PLL0 output = 62.0928 MHz
	pm_pll_set_option(&AVR32_PM, 0, // pll.
80004bd4:	30 08       	mov	r8,0
80004bd6:	30 19       	mov	r9,1
80004bd8:	12 9a       	mov	r10,r9
80004bda:	10 9b       	mov	r11,r8
80004bdc:	fe 7c 0c 00 	mov	r12,-62464
80004be0:	f0 1f 00 22 	mcall	80004c68 <init_sys_clocks+0xd8>
	1,  // pll_freq.
	1,  // pll_div2.
	0); // pll_wbwdisable.

	// start PLL0 and wait for the lock
	pm_pll_enable(&AVR32_PM, 0);
80004be4:	30 0b       	mov	r11,0
80004be6:	fe 7c 0c 00 	mov	r12,-62464
80004bea:	f0 1f 00 21 	mcall	80004c6c <init_sys_clocks+0xdc>
	pm_wait_for_pll0_locked(&AVR32_PM);
80004bee:	fe 7c 0c 00 	mov	r12,-62464
80004bf2:	f0 1f 00 20 	mcall	80004c70 <init_sys_clocks+0xe0>
	// Set all peripheral clocks torun at master clock rate
	pm_cksel(&AVR32_PM,
80004bf6:	30 07       	mov	r7,0
80004bf8:	1a d7       	st.w	--sp,r7
80004bfa:	1a d7       	st.w	--sp,r7
80004bfc:	0e 98       	mov	r8,r7
80004bfe:	0e 99       	mov	r9,r7
80004c00:	0e 9a       	mov	r10,r7
80004c02:	0e 9b       	mov	r11,r7
80004c04:	fe 7c 0c 00 	mov	r12,-62464
80004c08:	f0 1f 00 1b 	mcall	80004c74 <init_sys_clocks+0xe4>
	0,   // pbbsel.
	0,   // hsbdiv.
	0);  // hsbsel.

	// Set one waitstate for the flash
	flashc_set_wait_state(1);
80004c0c:	30 1c       	mov	r12,1
80004c0e:	f0 1f 00 1b 	mcall	80004c78 <init_sys_clocks+0xe8>

	// Switch to PLL0 as the master clock
	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCCTRL_MCSEL_PLL0);
80004c12:	30 2b       	mov	r11,2
80004c14:	fe 7c 0c 00 	mov	r12,-62464
80004c18:	f0 1f 00 19 	mcall	80004c7c <init_sys_clocks+0xec>

	// Use 12MHz from OSC0 and generate 96 MHz
	pm_pll_setup(&AVR32_PM, 1,  // pll.
80004c1c:	1a d6       	st.w	--sp,r6
80004c1e:	0e 98       	mov	r8,r7
80004c20:	30 19       	mov	r9,1
80004c22:	30 7a       	mov	r10,7
80004c24:	12 9b       	mov	r11,r9
80004c26:	fe 7c 0c 00 	mov	r12,-62464
80004c2a:	f0 1f 00 0f 	mcall	80004c64 <init_sys_clocks+0xd4>
	7,   // mul.
	1,   // div.
	0,   // osc.
	16); // lockcount.

	pm_pll_set_option(&AVR32_PM, 1, // pll.
80004c2e:	0e 98       	mov	r8,r7
80004c30:	30 19       	mov	r9,1
80004c32:	12 9a       	mov	r10,r9
80004c34:	12 9b       	mov	r11,r9
80004c36:	fe 7c 0c 00 	mov	r12,-62464
80004c3a:	f0 1f 00 0c 	mcall	80004c68 <init_sys_clocks+0xd8>
	1,  // pll_freq: choose the range 80-180MHz.
	1,  // pll_div2.
	0); // pll_wbwdisable.

	// start PLL1 and wait forl lock
	pm_pll_enable(&AVR32_PM, 1);
80004c3e:	30 1b       	mov	r11,1
80004c40:	fe 7c 0c 00 	mov	r12,-62464
80004c44:	f0 1f 00 0a 	mcall	80004c6c <init_sys_clocks+0xdc>

	// Wait for PLL1 locked.
	pm_wait_for_pll1_locked(&AVR32_PM);
80004c48:	fe 7c 0c 00 	mov	r12,-62464
80004c4c:	f0 1f 00 0d 	mcall	80004c80 <init_sys_clocks+0xf0>
80004c50:	0c 0d       	add	sp,r6

}
80004c52:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004c56:	00 00       	add	r0,r0
80004c58:	80 00       	ld.sh	r0,r0[0x0]
80004c5a:	45 20       	lddsp	r0,sp[0x148]
80004c5c:	80 00       	ld.sh	r0,r0[0x0]
80004c5e:	43 fc       	lddsp	r12,sp[0xfc]
80004c60:	80 00       	ld.sh	r0,r0[0x0]
80004c62:	44 54       	lddsp	r4,sp[0x114]
80004c64:	80 00       	ld.sh	r0,r0[0x0]
80004c66:	44 b6       	lddsp	r6,sp[0x12c]
80004c68:	80 00       	ld.sh	r0,r0[0x0]
80004c6a:	44 d8       	lddsp	r8,sp[0x134]
80004c6c:	80 00       	ld.sh	r0,r0[0x0]
80004c6e:	44 f2       	lddsp	r2,sp[0x13c]
80004c70:	80 00       	ld.sh	r0,r0[0x0]
80004c72:	45 00       	lddsp	r0,sp[0x140]
80004c74:	80 00       	ld.sh	r0,r0[0x0]
80004c76:	44 70       	lddsp	r0,sp[0x11c]
80004c78:	80 00       	ld.sh	r0,r0[0x0]
80004c7a:	40 4c       	lddsp	r12,sp[0x10]
80004c7c:	80 00       	ld.sh	r0,r0[0x0]
80004c7e:	45 14       	lddsp	r4,sp[0x144]
80004c80:	80 00       	ld.sh	r0,r0[0x0]
80004c82:	45 0a       	lddsp	r10,sp[0x140]

80004c84 <main>:
			//gpio_clr_gpio_pin(LED3_GPIO);
			xSemaphoreGive(xMutexSD);
		}
	}
}
int main( void ){
80004c84:	d4 21       	pushm	r4-r7,lr
80004c86:	20 bd       	sub	sp,44
	init_sys_clocks();
80004c88:	f0 1f 01 02 	mcall	80005090 <main+0x40c>
	
	et024006_Init( FPBA_HZ, FPBA_HZ );
80004c8c:	e0 6b 76 00 	mov	r11,30208
80004c90:	ea 1b 03 b3 	orh	r11,0x3b3
80004c94:	16 9c       	mov	r12,r11
80004c96:	f0 1f 01 00 	mcall	80005094 <main+0x410>
	pwm_opt_t opt = {
		.diva = 0,
		.divb = 0,
		.prea = 0,
		.preb = 0
	};
80004c9a:	30 07       	mov	r7,0
80004c9c:	50 07       	stdsp	sp[0x0],r7
80004c9e:	50 17       	stdsp	sp[0x4],r7
80004ca0:	50 27       	stdsp	sp[0x8],r7
80004ca2:	50 37       	stdsp	sp[0xc],r7
	pwm_init(&opt);
80004ca4:	1a 9c       	mov	r12,sp
80004ca6:	f0 1f 00 fd 	mcall	80005098 <main+0x414>
	pwm_channel6.CMR.calg = PWM_MODE_LEFT_ALIGNED;
80004caa:	fe fb 03 f2 	ld.w	r11,pc[1010]
80004cae:	76 08       	ld.w	r8,r11[0x0]
	pwm_channel6.CMR.cpol = PWM_POLARITY_HIGH; //PWM_POLARITY_LOW;//PWM_POLARITY_HIGH;
	pwm_channel6.CMR.cpd = PWM_UPDATE_DUTY;
80004cb0:	e0 18 f8 ff 	andl	r8,0xf8ff
	pwm_channel6.CMR.cpre = AVR32_PWM_CMR_CPRE_MCK_DIV_2;
80004cb4:	a9 b8       	sbr	r8,0x9
80004cb6:	30 19       	mov	r9,1
80004cb8:	f1 d9 d0 04 	bfins	r8,r9,0x0,0x4
80004cbc:	97 08       	st.w	r11[0x0],r8

	pwm_channel_init(6, &pwm_channel6);
80004cbe:	30 6c       	mov	r12,6
80004cc0:	f0 1f 00 f8 	mcall	800050a0 <main+0x41c>
	pwm_start_channels(AVR32_PWM_ENA_CHID6_MASK);
80004cc4:	34 0c       	mov	r12,64
80004cc6:	f0 1f 00 f8 	mcall	800050a4 <main+0x420>
int main( void ){
	init_sys_clocks();
	
	et024006_Init( FPBA_HZ, FPBA_HZ );
	tft_bl_init();
	et024006_DrawFilledRect(0 , 0, ET024006_WIDTH, ET024006_HEIGHT, BLACK);
80004cca:	0e 98       	mov	r8,r7
80004ccc:	e0 69 00 f0 	mov	r9,240
80004cd0:	e0 6a 01 40 	mov	r10,320
80004cd4:	0e 9b       	mov	r11,r7
80004cd6:	0e 9c       	mov	r12,r7
80004cd8:	f0 1f 00 f4 	mcall	800050a8 <main+0x424>
	while(pwm_channel6.cdty < pwm_channel6.cprd){
80004cdc:	fe f7 03 c0 	ld.w	r7,pc[960]
		pwm_channel6.cdty++;
		pwm_channel6.cupd = pwm_channel6.cdty;
		//pwm_channel6.cdty--;
		pwm_async_update_channel(AVR32_PWM_ENA_CHID6, &pwm_channel6);
80004ce0:	30 66       	mov	r6,6
	init_sys_clocks();
	
	et024006_Init( FPBA_HZ, FPBA_HZ );
	tft_bl_init();
	et024006_DrawFilledRect(0 , 0, ET024006_WIDTH, ET024006_HEIGHT, BLACK);
	while(pwm_channel6.cdty < pwm_channel6.cprd){
80004ce2:	c1 e8       	rjmp	80004d1e <main+0x9a>
		pwm_channel6.cdty++;
80004ce4:	2f f8       	sub	r8,-1
80004ce6:	8f 18       	st.w	r7[0x4],r8
		pwm_channel6.cupd = pwm_channel6.cdty;
80004ce8:	8f 48       	st.w	r7[0x10],r8
		//pwm_channel6.cdty--;
		pwm_async_update_channel(AVR32_PWM_ENA_CHID6, &pwm_channel6);
80004cea:	0e 9b       	mov	r11,r7
80004cec:	0c 9c       	mov	r12,r6
80004cee:	f0 1f 00 f0 	mcall	800050ac <main+0x428>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80004cf2:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80004cf6:	e0 79 d4 c0 	mov	r9,120000
80004cfa:	f0 09 00 0a 	add	r10,r8,r9
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80004cfe:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80004d02:	14 38       	cp.w	r8,r10
80004d04:	e0 88 00 08 	brls	80004d14 <main+0x90>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80004d08:	12 38       	cp.w	r8,r9
80004d0a:	fe 98 ff fa 	brls	80004cfe <main+0x7a>
80004d0e:	12 3a       	cp.w	r10,r9
80004d10:	c0 73       	brcs	80004d1e <main+0x9a>
80004d12:	cf 6b       	rjmp	80004cfe <main+0x7a>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80004d14:	12 38       	cp.w	r8,r9
80004d16:	e0 8b 00 04 	brhi	80004d1e <main+0x9a>
80004d1a:	12 3a       	cp.w	r10,r9
80004d1c:	cf 12       	brcc	80004cfe <main+0x7a>
	init_sys_clocks();
	
	et024006_Init( FPBA_HZ, FPBA_HZ );
	tft_bl_init();
	et024006_DrawFilledRect(0 , 0, ET024006_WIDTH, ET024006_HEIGHT, BLACK);
	while(pwm_channel6.cdty < pwm_channel6.cprd){
80004d1e:	6e 18       	ld.w	r8,r7[0x4]
80004d20:	6e 29       	ld.w	r9,r7[0x8]
80004d22:	12 38       	cp.w	r8,r9
80004d24:	ce 03       	brcs	80004ce4 <main+0x60>
		//pwm_channel6.cdty--;
		pwm_async_update_channel(AVR32_PWM_ENA_CHID6, &pwm_channel6);
		delay_ms(10);
	}
	//
	et024006_DrawFilledRect(0 , 0, ET024006_WIDTH, ET024006_HEIGHT, BLACK );
80004d26:	30 08       	mov	r8,0
80004d28:	e0 69 00 f0 	mov	r9,240
80004d2c:	e0 6a 01 40 	mov	r10,320
80004d30:	10 9b       	mov	r11,r8
80004d32:	10 9c       	mov	r12,r8
80004d34:	f0 1f 00 dd 	mcall	800050a8 <main+0x424>
	//Temperatura
	et024006_DrawFilledRect(10 , 40, 20, 140, WHITE );
80004d38:	e0 68 ff ff 	mov	r8,65535
80004d3c:	e0 69 00 8c 	mov	r9,140
80004d40:	31 4a       	mov	r10,20
80004d42:	32 8b       	mov	r11,40
80004d44:	30 ac       	mov	r12,10
80004d46:	f0 1f 00 d9 	mcall	800050a8 <main+0x424>
	//gas
	et024006_DrawFilledRect(140, 100, 60, 40, RED );
80004d4a:	e0 68 f8 00 	mov	r8,63488
80004d4e:	32 89       	mov	r9,40
80004d50:	33 ca       	mov	r10,60
80004d52:	36 4b       	mov	r11,100
80004d54:	e0 6c 00 8c 	mov	r12,140
80004d58:	f0 1f 00 d4 	mcall	800050a8 <main+0x424>
	et024006_DrawFilledRect(145, 105, 50, 30, BLACK );
80004d5c:	30 08       	mov	r8,0
80004d5e:	31 e9       	mov	r9,30
80004d60:	33 2a       	mov	r10,50
80004d62:	36 9b       	mov	r11,105
80004d64:	e0 6c 00 91 	mov	r12,145
80004d68:	f0 1f 00 d0 	mcall	800050a8 <main+0x424>
	et024006_DrawHorizLine(120,100,100,RED);
80004d6c:	e0 69 f8 00 	mov	r9,63488
80004d70:	36 4a       	mov	r10,100
80004d72:	14 9b       	mov	r11,r10
80004d74:	37 8c       	mov	r12,120
80004d76:	f0 1f 00 cf 	mcall	800050b0 <main+0x42c>
	et024006_DrawLine(120,100,170,60,RED);
80004d7a:	e0 68 f8 00 	mov	r8,63488
80004d7e:	33 c9       	mov	r9,60
80004d80:	e0 6a 00 aa 	mov	r10,170
80004d84:	36 4b       	mov	r11,100
80004d86:	37 8c       	mov	r12,120
80004d88:	f0 1f 00 cb 	mcall	800050b4 <main+0x430>
	et024006_DrawLine(170,60,220,100,RED);
80004d8c:	e0 68 f8 00 	mov	r8,63488
80004d90:	36 49       	mov	r9,100
80004d92:	e0 6a 00 dc 	mov	r10,220
80004d96:	33 cb       	mov	r11,60
80004d98:	e0 6c 00 aa 	mov	r12,170
80004d9c:	f0 1f 00 c6 	mcall	800050b4 <main+0x430>
	//iluminosidad
	et024006_DrawFilledCircle(280,90,30,BLUE,0xFF);
80004da0:	e0 68 00 ff 	mov	r8,255
80004da4:	31 f9       	mov	r9,31
80004da6:	31 ea       	mov	r10,30
80004da8:	35 ab       	mov	r11,90
80004daa:	e0 6c 01 18 	mov	r12,280
80004dae:	f0 1f 00 c3 	mcall	800050b8 <main+0x434>
	et024006_DrawFilledCircle(280,90,29,BLACK,0xFF);
80004db2:	e0 68 00 ff 	mov	r8,255
80004db6:	30 09       	mov	r9,0
80004db8:	31 da       	mov	r10,29
80004dba:	35 ab       	mov	r11,90
80004dbc:	e0 6c 01 18 	mov	r12,280
80004dc0:	f0 1f 00 be 	mcall	800050b8 <main+0x434>
	et024006_DrawLine(240,120,250,110,BLUE);
80004dc4:	31 f8       	mov	r8,31
80004dc6:	36 e9       	mov	r9,110
80004dc8:	e0 6a 00 fa 	mov	r10,250
80004dcc:	37 8b       	mov	r11,120
80004dce:	e0 6c 00 f0 	mov	r12,240
80004dd2:	f0 1f 00 b9 	mcall	800050b4 <main+0x430>
	et024006_DrawLine(240,100,245,90,BLUE);
80004dd6:	31 f8       	mov	r8,31
80004dd8:	35 a9       	mov	r9,90
80004dda:	e0 6a 00 f5 	mov	r10,245
80004dde:	36 4b       	mov	r11,100
80004de0:	e0 6c 00 f0 	mov	r12,240
80004de4:	f0 1f 00 b4 	mcall	800050b4 <main+0x430>
	et024006_DrawLine(240,70,245,80,BLUE);
80004de8:	31 f8       	mov	r8,31
80004dea:	35 09       	mov	r9,80
80004dec:	e0 6a 00 f5 	mov	r10,245
80004df0:	34 6b       	mov	r11,70
80004df2:	e0 6c 00 f0 	mov	r12,240
80004df6:	f0 1f 00 b0 	mcall	800050b4 <main+0x430>
	et024006_DrawLine(240,50,250,60,BLUE);
80004dfa:	31 f8       	mov	r8,31
80004dfc:	33 c9       	mov	r9,60
80004dfe:	e0 6a 00 fa 	mov	r10,250
80004e02:	33 2b       	mov	r11,50
80004e04:	e0 6c 00 f0 	mov	r12,240
80004e08:	f0 1f 00 ab 	mcall	800050b4 <main+0x430>
	et024006_DrawVertLine(270,40,10,BLUE);
80004e0c:	31 f9       	mov	r9,31
80004e0e:	30 aa       	mov	r10,10
80004e10:	32 8b       	mov	r11,40
80004e12:	e0 6c 01 0e 	mov	r12,270
80004e16:	f0 1f 00 aa 	mcall	800050bc <main+0x438>
	et024006_DrawVertLine(290,40,10,BLUE);
80004e1a:	31 f9       	mov	r9,31
80004e1c:	30 aa       	mov	r10,10
80004e1e:	32 8b       	mov	r11,40
80004e20:	e0 6c 01 22 	mov	r12,290
80004e24:	f0 1f 00 a6 	mcall	800050bc <main+0x438>
	et024006_DrawLine(310,60,320,50,BLUE);
80004e28:	31 f8       	mov	r8,31
80004e2a:	33 29       	mov	r9,50
80004e2c:	e0 6a 01 40 	mov	r10,320
80004e30:	33 cb       	mov	r11,60
80004e32:	e0 6c 01 36 	mov	r12,310
80004e36:	f0 1f 00 a0 	mcall	800050b4 <main+0x430>
	et024006_DrawLine(315,80,320,70,BLUE);
80004e3a:	31 f8       	mov	r8,31
80004e3c:	34 69       	mov	r9,70
80004e3e:	e0 6a 01 40 	mov	r10,320
80004e42:	35 0b       	mov	r11,80
80004e44:	e0 6c 01 3b 	mov	r12,315
80004e48:	f0 1f 00 9b 	mcall	800050b4 <main+0x430>
	et024006_DrawLine(315,90,320,100,BLUE);
80004e4c:	31 f8       	mov	r8,31
80004e4e:	36 49       	mov	r9,100
80004e50:	e0 6a 01 40 	mov	r10,320
80004e54:	35 ab       	mov	r11,90
80004e56:	e0 6c 01 3b 	mov	r12,315
80004e5a:	f0 1f 00 97 	mcall	800050b4 <main+0x430>
	et024006_DrawLine(310,110,320,120,BLUE);
80004e5e:	31 f8       	mov	r8,31
80004e60:	37 89       	mov	r9,120
80004e62:	e0 6a 01 40 	mov	r10,320
80004e66:	36 eb       	mov	r11,110
80004e68:	e0 6c 01 36 	mov	r12,310
80004e6c:	f0 1f 00 92 	mcall	800050b4 <main+0x430>
	et024006_DrawLine(270,140, 290, 140, BLUE);
80004e70:	31 f8       	mov	r8,31
80004e72:	e0 69 00 8c 	mov	r9,140
80004e76:	e0 6a 01 22 	mov	r10,290
80004e7a:	12 9b       	mov	r11,r9
80004e7c:	e0 6c 01 0e 	mov	r12,270
80004e80:	f0 1f 00 8d 	mcall	800050b4 <main+0x430>
	et024006_DrawLine(270,135, 290, 135, BLUE);
80004e84:	31 f8       	mov	r8,31
80004e86:	e0 69 00 87 	mov	r9,135
80004e8a:	e0 6a 01 22 	mov	r10,290
80004e8e:	12 9b       	mov	r11,r9
80004e90:	e0 6c 01 0e 	mov	r12,270
80004e94:	f0 1f 00 88 	mcall	800050b4 <main+0x430>
	et024006_DrawLine(270,130, 290, 130, BLUE);
80004e98:	31 f8       	mov	r8,31
80004e9a:	e0 69 00 82 	mov	r9,130
80004e9e:	e0 6a 01 22 	mov	r10,290
80004ea2:	12 9b       	mov	r11,r9
80004ea4:	e0 6c 01 0e 	mov	r12,270
80004ea8:	f0 1f 00 83 	mcall	800050b4 <main+0x430>
	et024006_DrawLine(270,125, 290, 125, BLUE);
80004eac:	31 f8       	mov	r8,31
80004eae:	37 d9       	mov	r9,125
80004eb0:	e0 6a 01 22 	mov	r10,290
80004eb4:	12 9b       	mov	r11,r9
80004eb6:	e0 6c 01 0e 	mov	r12,270
80004eba:	f0 1f 00 7f 	mcall	800050b4 <main+0x430>
	et024006_DrawLine(270,120, 290, 120, BLUE);
80004ebe:	31 f8       	mov	r8,31
80004ec0:	37 89       	mov	r9,120
80004ec2:	e0 6a 01 22 	mov	r10,290
80004ec6:	12 9b       	mov	r11,r9
80004ec8:	e0 6c 01 0e 	mov	r12,270
80004ecc:	f0 1f 00 7a 	mcall	800050b4 <main+0x430>
	et024006_DrawLine(270,140, 270, 120, BLUE);
80004ed0:	31 f8       	mov	r8,31
80004ed2:	37 89       	mov	r9,120
80004ed4:	e0 6a 01 0e 	mov	r10,270
80004ed8:	e0 6b 00 8c 	mov	r11,140
80004edc:	14 9c       	mov	r12,r10
80004ede:	f0 1f 00 76 	mcall	800050b4 <main+0x430>
	et024006_DrawLine(290,140, 290, 120, BLUE);
80004ee2:	31 f8       	mov	r8,31
80004ee4:	37 89       	mov	r9,120
80004ee6:	e0 6a 01 22 	mov	r10,290
80004eea:	e0 6b 00 8c 	mov	r11,140
80004eee:	14 9c       	mov	r12,r10
80004ef0:	f0 1f 00 71 	mcall	800050b4 <main+0x430>
		{SD_MMC_SPI_MISO_PIN, SD_MMC_SPI_MISO_FUNCTION},  // MISO.
		{SD_MMC_SPI_MOSI_PIN, SD_MMC_SPI_MOSI_FUNCTION},  // MOSI.
		{SD_MMC_SPI_NPCS_PIN, SD_MMC_SPI_NPCS_FUNCTION}   // Chip Select NPCS.
	};
	
	gpio_enable_module(GPIO_MAP,sizeof(GPIO_MAP) / sizeof(GPIO_MAP[0]));
80004ef4:	30 ab       	mov	r11,10
80004ef6:	4f 3c       	lddpc	r12,800050c0 <main+0x43c>
80004ef8:	f0 1f 00 73 	mcall	800050c4 <main+0x440>
	  const twi_options_t TPA6130_TWI_OPTIONS ={
		  .pba_hz = 62092800,
		  .speed  = TPA6130_TWI_MASTER_SPEED,
		  .chip   = TPA6130_TWI_ADDRESS
	  };
80004efc:	4f 38       	lddpc	r8,800050c8 <main+0x444>
80004efe:	fa cb ff e0 	sub	r11,sp,-32
80004f02:	f0 e6 00 00 	ld.d	r6,r8[0]
80004f06:	f6 e7 00 00 	st.d	r11[0],r6
80004f0a:	70 28       	ld.w	r8,r8[0x8]
80004f0c:	97 28       	st.w	r11[0x8],r8
	  // Initialize as master.
	twi_master_init(TPA6130_TWI, &TPA6130_TWI_OPTIONS);
80004f0e:	fe 7c 2c 00 	mov	r12,-54272
80004f12:	f0 1f 00 6f 	mcall	800050cc <main+0x448>
	tpa6130_init();
80004f16:	f0 1f 00 6f 	mcall	800050d0 <main+0x44c>
	tpa6130_dac_start(DEFAULT_DAC_SAMPLE_RATE_HZ,//Sample Rate
80004f1a:	e0 66 76 00 	mov	r6,30208
80004f1e:	ea 16 03 b3 	orh	r6,0x3b3
80004f22:	1a d6       	st.w	--sp,r6
80004f24:	30 38       	mov	r8,3
80004f26:	1a d8       	st.w	--sp,r8
80004f28:	4e b8       	lddpc	r8,800050d4 <main+0x450>
80004f2a:	30 09       	mov	r9,0
80004f2c:	31 0a       	mov	r10,16
80004f2e:	30 2b       	mov	r11,2
80004f30:	e0 6c 2b 11 	mov	r12,11025
80004f34:	f0 1f 00 69 	mcall	800050d8 <main+0x454>
		DEFAULT_DAC_SWAP_CHANNELS,//Swap Left right channel
		master_callback,
		AUDIO_DAC_OUT_OF_SAMPLE_CB
		| AUDIO_DAC_RELOAD_CB,
		62092800);//Frecuencia del reloj sncrono PLL0
	tpa6130_set_volume(0x3F);//6 bits
80004f38:	33 fc       	mov	r12,63
80004f3a:	f0 1f 00 69 	mcall	800050dc <main+0x458>
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Initialize USART in RS232 mode.
	usart_init_rs232(&AVR32_USART0, &USART_OPTIONS,62092800);	
80004f3e:	0c 9a       	mov	r10,r6
80004f40:	4e 8b       	lddpc	r11,800050e0 <main+0x45c>
80004f42:	fe 7c 14 00 	mov	r12,-60416
80004f46:	f0 1f 00 68 	mcall	800050e4 <main+0x460>
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80004f4a:	4e 88       	lddpc	r8,800050e8 <main+0x464>
80004f4c:	fa c7 ff e8 	sub	r7,sp,-24
80004f50:	f0 ea 00 00 	ld.d	r10,r8[0]
80004f54:	ee eb 00 00 	st.d	r7[0],r10
80004f58:	f0 e8 00 08 	ld.d	r8,r8[8]
80004f5c:	ee e9 00 08 	st.d	r7[8],r8
	// Initialize as master.
	spi_initMaster(SD_MMC_SPI, &spiOptions);
80004f60:	0e 9b       	mov	r11,r7
80004f62:	fe 7c 24 00 	mov	r12,-56320
80004f66:	f0 1f 00 62 	mcall	800050ec <main+0x468>
	// Set SPI selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(SD_MMC_SPI, 0, 0, 0);
80004f6a:	30 09       	mov	r9,0
80004f6c:	12 9a       	mov	r10,r9
80004f6e:	12 9b       	mov	r11,r9
80004f70:	fe 7c 24 00 	mov	r12,-56320
80004f74:	f0 1f 00 5f 	mcall	800050f0 <main+0x46c>
	// Enable SPI module.
	spi_enable(SD_MMC_SPI);
80004f78:	fe 7c 24 00 	mov	r12,-56320
80004f7c:	f0 1f 00 5e 	mcall	800050f4 <main+0x470>
	// Initialize SD/MMC driver with SPI clock (PBA).
	sd_mmc_spi_init(spiOptions, FPBA_HZ);
80004f80:	20 4d       	sub	sp,16
80004f82:	ee e8 00 00 	ld.d	r8,r7[0]
80004f86:	fa e9 00 00 	st.d	sp[0],r8
80004f8a:	ee e8 00 08 	ld.d	r8,r7[8]
80004f8e:	fa e9 00 08 	st.d	sp[8],r8
80004f92:	0c 9c       	mov	r12,r6
80004f94:	f0 1f 00 59 	mcall	800050f8 <main+0x474>
	
	AVR32_ADC.mr |= 0x1 << AVR32_ADC_MR_PRESCAL_OFFSET;
80004f98:	fe 77 3c 00 	mov	r7,-50176
80004f9c:	6e 18       	ld.w	r8,r7[0x4]
80004f9e:	a9 a8       	sbr	r8,0x8
80004fa0:	8f 18       	st.w	r7[0x4],r8
	adc_configure(&AVR32_ADC);
80004fa2:	0e 9c       	mov	r12,r7
80004fa4:	f0 1f 00 56 	mcall	800050fc <main+0x478>
	adc_enable(&AVR32_ADC, 0);//Habilitar ADC canal 0
80004fa8:	30 0b       	mov	r11,0
80004faa:	0e 9c       	mov	r12,r7
80004fac:	f0 1f 00 55 	mcall	80005100 <main+0x47c>
	adc_enable(&AVR32_ADC, 2);//Habilitar ADC canal 2
80004fb0:	30 2b       	mov	r11,2
80004fb2:	0e 9c       	mov	r12,r7
80004fb4:	f0 1f 00 53 	mcall	80005100 <main+0x47c>
	
	
	xTaskCreate( vTareaADC, "Task 1",	1000, NULL,1,  &myTask1Handle);
80004fb8:	30 07       	mov	r7,0
80004fba:	1a d7       	st.w	--sp,r7
80004fbc:	1a d7       	st.w	--sp,r7
80004fbe:	4d 28       	lddpc	r8,80005104 <main+0x480>
80004fc0:	1a d8       	st.w	--sp,r8
80004fc2:	30 18       	mov	r8,1
80004fc4:	0e 99       	mov	r9,r7
80004fc6:	e0 6a 03 e8 	mov	r10,1000
80004fca:	4d 0b       	lddpc	r11,80005108 <main+0x484>
80004fcc:	4d 0c       	lddpc	r12,8000510c <main+0x488>
80004fce:	f0 1f 00 51 	mcall	80005110 <main+0x48c>
	xTaskCreate( vTareaAudioTemperatura, "Task 2", 1000, NULL, 1, &myTask2Handle);
80004fd2:	2f 7d       	sub	sp,-36
80004fd4:	1a d7       	st.w	--sp,r7
80004fd6:	1a d7       	st.w	--sp,r7
80004fd8:	4c f6       	lddpc	r6,80005114 <main+0x490>
80004fda:	1a d6       	st.w	--sp,r6
80004fdc:	30 18       	mov	r8,1
80004fde:	0e 99       	mov	r9,r7
80004fe0:	e0 6a 03 e8 	mov	r10,1000
80004fe4:	4c db       	lddpc	r11,80005118 <main+0x494>
80004fe6:	4c ec       	lddpc	r12,8000511c <main+0x498>
80004fe8:	f0 1f 00 4a 	mcall	80005110 <main+0x48c>
	xTaskCreate( vTareaLCD, "Task 3", 1000, NULL, 1, &myTask3Handle);
80004fec:	1a d7       	st.w	--sp,r7
80004fee:	1a d7       	st.w	--sp,r7
80004ff0:	4c c8       	lddpc	r8,80005120 <main+0x49c>
80004ff2:	1a d8       	st.w	--sp,r8
80004ff4:	30 18       	mov	r8,1
80004ff6:	0e 99       	mov	r9,r7
80004ff8:	e0 6a 03 e8 	mov	r10,1000
80004ffc:	4c ab       	lddpc	r11,80005124 <main+0x4a0>
80004ffe:	4c bc       	lddpc	r12,80005128 <main+0x4a4>
80005000:	f0 1f 00 44 	mcall	80005110 <main+0x48c>
	xTaskCreate( vTareaAudioGas, "Task 4", 1000, NULL, 1, &myTask4Handle);
80005004:	1a d7       	st.w	--sp,r7
80005006:	1a d7       	st.w	--sp,r7
80005008:	4c 95       	lddpc	r5,8000512c <main+0x4a8>
8000500a:	1a d5       	st.w	--sp,r5
8000500c:	30 18       	mov	r8,1
8000500e:	0e 99       	mov	r9,r7
80005010:	e0 6a 03 e8 	mov	r10,1000
80005014:	4c 7b       	lddpc	r11,80005130 <main+0x4ac>
80005016:	4c 8c       	lddpc	r12,80005134 <main+0x4b0>
80005018:	f0 1f 00 3e 	mcall	80005110 <main+0x48c>
	xTaskCreate( vTareaAudioLuces, "Task 5", 1000, NULL, 1, &myTask5Handle);
8000501c:	2f 7d       	sub	sp,-36
8000501e:	1a d7       	st.w	--sp,r7
80005020:	1a d7       	st.w	--sp,r7
80005022:	4c 64       	lddpc	r4,80005138 <main+0x4b4>
80005024:	1a d4       	st.w	--sp,r4
80005026:	30 18       	mov	r8,1
80005028:	0e 99       	mov	r9,r7
8000502a:	e0 6a 03 e8 	mov	r10,1000
8000502e:	4c 4b       	lddpc	r11,8000513c <main+0x4b8>
80005030:	4c 4c       	lddpc	r12,80005140 <main+0x4bc>
80005032:	f0 1f 00 38 	mcall	80005110 <main+0x48c>
	xTaskCreate( vTareaSD, "Task 6", 1000, NULL, 1, &myTask6Handle);
80005036:	1a d7       	st.w	--sp,r7
80005038:	1a d7       	st.w	--sp,r7
8000503a:	4c 38       	lddpc	r8,80005144 <main+0x4c0>
8000503c:	1a d8       	st.w	--sp,r8
8000503e:	30 18       	mov	r8,1
80005040:	0e 99       	mov	r9,r7
80005042:	e0 6a 03 e8 	mov	r10,1000
80005046:	4c 1b       	lddpc	r11,80005148 <main+0x4c4>
80005048:	4c 1c       	lddpc	r12,8000514c <main+0x4c8>
8000504a:	f0 1f 00 32 	mcall	80005110 <main+0x48c>
	xTaskCreate( vTareaSD_RX, "Task 7", 1000, NULL, 1, &myTask7Handle);
8000504e:	1a d7       	st.w	--sp,r7
80005050:	1a d7       	st.w	--sp,r7
80005052:	4c 08       	lddpc	r8,80005150 <main+0x4cc>
80005054:	1a d8       	st.w	--sp,r8
80005056:	30 18       	mov	r8,1
80005058:	0e 99       	mov	r9,r7
8000505a:	e0 6a 03 e8 	mov	r10,1000
8000505e:	4b eb       	lddpc	r11,80005154 <main+0x4d0>
80005060:	4b ec       	lddpc	r12,80005158 <main+0x4d4>
80005062:	f0 1f 00 2c 	mcall	80005110 <main+0x48c>
	vTaskSuspend(myTask2Handle);
80005066:	2f 7d       	sub	sp,-36
80005068:	6c 0c       	ld.w	r12,r6[0x0]
8000506a:	f0 1f 00 3d 	mcall	8000515c <main+0x4d8>
	vTaskSuspend(myTask4Handle);
8000506e:	6a 0c       	ld.w	r12,r5[0x0]
80005070:	f0 1f 00 3b 	mcall	8000515c <main+0x4d8>
	vTaskSuspend(myTask5Handle);
80005074:	68 0c       	ld.w	r12,r4[0x0]
80005076:	f0 1f 00 3a 	mcall	8000515c <main+0x4d8>
	//vTaskSuspend(myTask7Handle);
	xMutex=xSemaphoreCreateMutex();
8000507a:	f0 1f 00 3a 	mcall	80005160 <main+0x4dc>
8000507e:	4b a8       	lddpc	r8,80005164 <main+0x4e0>
80005080:	91 0c       	st.w	r8[0x0],r12
	xMutexSD=xSemaphoreCreateMutex();  
80005082:	f0 1f 00 38 	mcall	80005160 <main+0x4dc>
80005086:	4b 98       	lddpc	r8,80005168 <main+0x4e4>
80005088:	91 0c       	st.w	r8[0x0],r12
// 	gpio_enable_pin_interrupt(57, 1);
	
//	Enable_global_interrupt();

	//Start the scheduler so the tasks start executing. 
	vTaskStartScheduler(); 
8000508a:	f0 1f 00 39 	mcall	8000516c <main+0x4e8>
8000508e:	c0 08       	rjmp	8000508e <main+0x40a>
80005090:	80 00       	ld.sh	r0,r0[0x0]
80005092:	4b 90       	lddpc	r0,80005174 <vTareaSD_RX+0x4>
80005094:	80 00       	ld.sh	r0,r0[0x0]
80005096:	37 58       	mov	r8,117
80005098:	80 00       	ld.sh	r0,r0[0x0]
8000509a:	45 bc       	lddsp	r12,sp[0x16c]
8000509c:	00 00       	add	r0,r0
8000509e:	00 0c       	add	r12,r0
800050a0:	80 00       	ld.sh	r0,r0[0x0]
800050a2:	45 4c       	lddsp	r12,sp[0x150]
800050a4:	80 00       	ld.sh	r0,r0[0x0]
800050a6:	45 82       	lddsp	r2,sp[0x160]
800050a8:	80 00       	ld.sh	r0,r0[0x0]
800050aa:	35 1c       	mov	r12,81
800050ac:	80 00       	ld.sh	r0,r0[0x0]
800050ae:	45 94       	lddsp	r4,sp[0x164]
800050b0:	80 00       	ld.sh	r0,r0[0x0]
800050b2:	36 d0       	mov	r0,109
800050b4:	80 00       	ld.sh	r0,r0[0x0]
800050b6:	33 c4       	mov	r4,60
800050b8:	80 00       	ld.sh	r0,r0[0x0]
800050ba:	35 78       	mov	r8,87
800050bc:	80 00       	ld.sh	r0,r0[0x0]
800050be:	35 5c       	mov	r12,85
800050c0:	80 02       	ld.sh	r2,r0[0x0]
800050c2:	27 c4       	sub	r4,124
800050c4:	80 00       	ld.sh	r0,r0[0x0]
800050c6:	40 ac       	lddsp	r12,sp[0x28]
800050c8:	80 02       	ld.sh	r2,r0[0x0]
800050ca:	27 20       	sub	r0,114
800050cc:	80 00       	ld.sh	r0,r0[0x0]
800050ce:	48 44       	lddpc	r4,800050dc <main+0x458>
800050d0:	80 00       	ld.sh	r0,r0[0x0]
800050d2:	2f 74       	sub	r4,-9
800050d4:	80 00       	ld.sh	r0,r0[0x0]
800050d6:	4b 8c       	lddpc	r12,800051b4 <vTareaSD_RX+0x44>
800050d8:	80 00       	ld.sh	r0,r0[0x0]
800050da:	30 5c       	mov	r12,5
800050dc:	80 00       	ld.sh	r0,r0[0x0]
800050de:	2e 1c       	sub	r12,-31
800050e0:	80 02       	ld.sh	r2,r0[0x0]
800050e2:	27 b8       	sub	r8,123
800050e4:	80 00       	ld.sh	r0,r0[0x0]
800050e6:	4a 18       	lddpc	r8,80005168 <main+0x4e4>
800050e8:	80 02       	ld.sh	r2,r0[0x0]
800050ea:	28 14       	sub	r4,-127
800050ec:	80 00       	ld.sh	r0,r0[0x0]
800050ee:	2b 98       	sub	r8,-71
800050f0:	80 00       	ld.sh	r0,r0[0x0]
800050f2:	2b d0       	sub	r0,-67
800050f4:	80 00       	ld.sh	r0,r0[0x0]
800050f6:	2d 28       	sub	r8,-46
800050f8:	80 00       	ld.sh	r0,r0[0x0]
800050fa:	2b 44       	sub	r4,-76
800050fc:	80 00       	ld.sh	r0,r0[0x0]
800050fe:	3e d4       	mov	r4,-19
80005100:	80 00       	ld.sh	r0,r0[0x0]
80005102:	3e ec       	mov	r12,-18
80005104:	00 00       	add	r0,r0
80005106:	06 90       	mov	r0,r3
80005108:	80 02       	ld.sh	r2,r0[0x0]
8000510a:	27 2c       	sub	r12,114
8000510c:	80 00       	ld.sh	r0,r0[0x0]
8000510e:	59 cc       	cp.w	r12,28
80005110:	80 00       	ld.sh	r0,r0[0x0]
80005112:	6b 7c       	ld.w	r12,r5[0x5c]
80005114:	00 00       	add	r0,r0
80005116:	06 84       	andn	r4,r3
80005118:	80 02       	ld.sh	r2,r0[0x0]
8000511a:	27 34       	sub	r4,115
8000511c:	80 00       	ld.sh	r0,r0[0x0]
8000511e:	59 70       	cp.w	r0,23
80005120:	00 00       	add	r0,r0
80005122:	06 7c       	tst	r12,r3
80005124:	80 02       	ld.sh	r2,r0[0x0]
80005126:	27 3c       	sub	r12,115
80005128:	80 00       	ld.sh	r0,r0[0x0]
8000512a:	53 a8       	stdsp	sp[0xe8],r8
8000512c:	00 00       	add	r0,r0
8000512e:	06 8c       	andn	r12,r3
80005130:	80 02       	ld.sh	r2,r0[0x0]
80005132:	27 44       	sub	r4,116
80005134:	80 00       	ld.sh	r0,r0[0x0]
80005136:	59 14       	cp.w	r4,17
80005138:	00 00       	add	r0,r0
8000513a:	06 88       	andn	r8,r3
8000513c:	80 02       	ld.sh	r2,r0[0x0]
8000513e:	27 4c       	sub	r12,116
80005140:	80 00       	ld.sh	r0,r0[0x0]
80005142:	58 b8       	cp.w	r8,11
80005144:	00 00       	add	r0,r0
80005146:	06 94       	mov	r4,r3
80005148:	80 02       	ld.sh	r2,r0[0x0]
8000514a:	27 54       	sub	r4,117
8000514c:	80 00       	ld.sh	r0,r0[0x0]
8000514e:	52 6c       	stdsp	sp[0x98],r12
80005150:	00 00       	add	r0,r0
80005152:	06 80       	andn	r0,r3
80005154:	80 02       	ld.sh	r2,r0[0x0]
80005156:	27 5c       	sub	r12,117
80005158:	80 00       	ld.sh	r0,r0[0x0]
8000515a:	51 70       	stdsp	sp[0x5c],r0
8000515c:	80 00       	ld.sh	r0,r0[0x0]
8000515e:	69 68       	ld.w	r8,r4[0x58]
80005160:	80 00       	ld.sh	r0,r0[0x0]
80005162:	63 7c       	ld.w	r12,r1[0x5c]
80005164:	00 00       	add	r0,r0
80005166:	0e 44       	or	r4,r7
80005168:	00 00       	add	r0,r0
8000516a:	0a 38       	cp.w	r8,r5
8000516c:	80 00       	ld.sh	r0,r0[0x0]
8000516e:	6d 64       	ld.w	r4,r6[0x58]

80005170 <vTareaSD_RX>:
			xSemaphoreGive(xMutexSD);
			vTaskDelay(100);
		}
	}
}
void vTareaSD_RX( void *pvParameters ){
80005170:	d4 31       	pushm	r0-r7,lr
	int aaa;
	while(1){
		if(xSemaphoreTake(xMutexSD,0xFFFFFFFF)==1){
80005172:	4a d6       	lddpc	r6,80005224 <vTareaSD_RX+0xb4>
					if (sd_mmc_spi_mem_check()){
						sd_mmc_spi_read_open(k);
						spi_write(SD_MMC_SPI,0xFF); // Write a first dummy data to synchronize transfer
						sd_mmc_spi_read_sector_to_ram(&buffer_rx_spi);
						//et024006_PrintString(buffer_rx_spi, (const unsigned char *)&FONT6x8, 0, 100+(k*5), RED, -1);
						sprintf(buffer_rx,"%d",datos[k-5]);
80005174:	4a d4       	lddpc	r4,80005228 <vTareaSD_RX+0xb8>
	}
}
void vTareaSD_RX( void *pvParameters ){
	int aaa;
	while(1){
		if(xSemaphoreTake(xMutexSD,0xFFFFFFFF)==1){
80005176:	30 09       	mov	r9,0
80005178:	3f fa       	mov	r10,-1
8000517a:	12 9b       	mov	r11,r9
8000517c:	6c 0c       	ld.w	r12,r6[0x0]
8000517e:	f0 1f 00 2c 	mcall	8000522c <vTareaSD_RX+0xbc>
80005182:	58 1c       	cp.w	r12,1
80005184:	cf 91       	brne	80005176 <vTareaSD_RX+0x6>
			if(gpio_get_pin_value(QT1081_TOUCH_SENSOR_ENTER)==1){
80005186:	33 ac       	mov	r12,58
80005188:	f0 1f 00 2a 	mcall	80005230 <vTareaSD_RX+0xc0>
8000518c:	c4 50       	breq	80005216 <vTareaSD_RX+0xa6>
			et024006_DrawFilledRect(0 , 0, ET024006_WIDTH, ET024006_HEIGHT, BLACK);
8000518e:	30 08       	mov	r8,0
80005190:	e0 69 00 f0 	mov	r9,240
80005194:	e0 6a 01 40 	mov	r10,320
80005198:	10 9b       	mov	r11,r8
8000519a:	10 9c       	mov	r12,r8
8000519c:	f0 1f 00 26 	mcall	80005234 <vTareaSD_RX+0xc4>
			et024006_PrintString("Mensajes guardados en SD:", (const unsigned char *)&FONT6x8, 0, 90, RED, -1);
800051a0:	4a 63       	lddpc	r3,80005238 <vTareaSD_RX+0xc8>
800051a2:	3f f8       	mov	r8,-1
800051a4:	1a d8       	st.w	--sp,r8
800051a6:	e0 68 f8 00 	mov	r8,63488
800051aa:	35 a9       	mov	r9,90
800051ac:	30 0a       	mov	r10,0
800051ae:	06 9b       	mov	r11,r3
800051b0:	4a 3c       	lddpc	r12,8000523c <vTareaSD_RX+0xcc>
800051b2:	f0 1f 00 24 	mcall	80005240 <vTareaSD_RX+0xd0>
800051b6:	e0 65 00 96 	mov	r5,150
800051ba:	30 57       	mov	r7,5
800051bc:	2f fd       	sub	sp,-4
				while(rxFlag == 0);
				et024006_PrintString(buffer_rx_spi, (const unsigned char *)&FONT6x8, 0, 100+(k*10), RED, -1);
				rxFlag = 0;*/
					if (sd_mmc_spi_mem_check()){
						sd_mmc_spi_read_open(k);
						spi_write(SD_MMC_SPI,0xFF); // Write a first dummy data to synchronize transfer
800051be:	e0 62 00 ff 	mov	r2,255
800051c2:	fe 71 24 00 	mov	r1,-56320
						sd_mmc_spi_read_sector_to_ram(&buffer_rx_spi);
						//et024006_PrintString(buffer_rx_spi, (const unsigned char *)&FONT6x8, 0, 100+(k*5), RED, -1);
						sprintf(buffer_rx,"%d",datos[k-5]);
						et024006_PrintString(buffer_rx, (const unsigned char *)&FONT6x8, 0, 100+(k*10), RED, -1);						
800051c6:	3f f0       	mov	r0,-1
				pdca_channelrx->cr = AVR32_PDCA_TEN_MASK; // Enable RX PDCA transfer first
				pdca_channeltx->cr = AVR32_PDCA_TEN_MASK; // and TX PDCA transfer
				while(rxFlag == 0);
				et024006_PrintString(buffer_rx_spi, (const unsigned char *)&FONT6x8, 0, 100+(k*10), RED, -1);
				rxFlag = 0;*/
					if (sd_mmc_spi_mem_check()){
800051c8:	f0 1f 00 1f 	mcall	80005244 <vTareaSD_RX+0xd4>
800051cc:	c2 10       	breq	8000520e <vTareaSD_RX+0x9e>
						sd_mmc_spi_read_open(k);
800051ce:	0e 9c       	mov	r12,r7
800051d0:	f0 1f 00 1e 	mcall	80005248 <vTareaSD_RX+0xd8>
						spi_write(SD_MMC_SPI,0xFF); // Write a first dummy data to synchronize transfer
800051d4:	04 9b       	mov	r11,r2
800051d6:	02 9c       	mov	r12,r1
800051d8:	f0 1f 00 1d 	mcall	8000524c <vTareaSD_RX+0xdc>
						sd_mmc_spi_read_sector_to_ram(&buffer_rx_spi);
800051dc:	49 dc       	lddpc	r12,80005250 <vTareaSD_RX+0xe0>
800051de:	f0 1f 00 1e 	mcall	80005254 <vTareaSD_RX+0xe4>
800051e2:	ee c8 00 05 	sub	r8,r7,5
						//et024006_PrintString(buffer_rx_spi, (const unsigned char *)&FONT6x8, 0, 100+(k*5), RED, -1);
						sprintf(buffer_rx,"%d",datos[k-5]);
800051e6:	49 d9       	lddpc	r9,80005258 <vTareaSD_RX+0xe8>
800051e8:	f2 08 07 08 	ld.ub	r8,r9[r8]
800051ec:	68 0c       	ld.w	r12,r4[0x0]
800051ee:	1a d8       	st.w	--sp,r8
800051f0:	49 bb       	lddpc	r11,8000525c <vTareaSD_RX+0xec>
800051f2:	f0 1f 00 1c 	mcall	80005260 <vTareaSD_RX+0xf0>
						et024006_PrintString(buffer_rx, (const unsigned char *)&FONT6x8, 0, 100+(k*10), RED, -1);						
800051f6:	68 0c       	ld.w	r12,r4[0x0]
800051f8:	1a d0       	st.w	--sp,r0
800051fa:	e0 68 f8 00 	mov	r8,63488
800051fe:	0a 99       	mov	r9,r5
80005200:	30 0a       	mov	r10,0
80005202:	06 9b       	mov	r11,r3
80005204:	f0 1f 00 0f 	mcall	80005240 <vTareaSD_RX+0xd0>
						sd_mmc_spi_read_close();
80005208:	f0 1f 00 17 	mcall	80005264 <vTareaSD_RX+0xf4>
8000520c:	2f ed       	sub	sp,-8
	while(1){
		if(xSemaphoreTake(xMutexSD,0xFFFFFFFF)==1){
			if(gpio_get_pin_value(QT1081_TOUCH_SENSOR_ENTER)==1){
			et024006_DrawFilledRect(0 , 0, ET024006_WIDTH, ET024006_HEIGHT, BLACK);
			et024006_PrintString("Mensajes guardados en SD:", (const unsigned char *)&FONT6x8, 0, 90, RED, -1);
				for(int k = 5; k <=15; k++){
8000520e:	2f f7       	sub	r7,-1
80005210:	2f 65       	sub	r5,-10
80005212:	59 07       	cp.w	r7,16
80005214:	cd a1       	brne	800051c8 <vTareaSD_RX+0x58>
				
					}
				}
			}
			//gpio_clr_gpio_pin(LED3_GPIO);
			xSemaphoreGive(xMutexSD);
80005216:	30 09       	mov	r9,0
80005218:	12 9a       	mov	r10,r9
8000521a:	12 9b       	mov	r11,r9
8000521c:	6c 0c       	ld.w	r12,r6[0x0]
8000521e:	f0 1f 00 13 	mcall	80005268 <vTareaSD_RX+0xf8>
80005222:	ca ab       	rjmp	80005176 <vTareaSD_RX+0x6>
80005224:	00 00       	add	r0,r0
80005226:	0a 38       	cp.w	r8,r5
80005228:	00 00       	add	r0,r0
8000522a:	0e 40       	or	r0,r7
8000522c:	80 00       	ld.sh	r0,r0[0x0]
8000522e:	60 c0       	ld.w	r0,r0[0x30]
80005230:	80 00       	ld.sh	r0,r0[0x0]
80005232:	41 1c       	lddsp	r12,sp[0x44]
80005234:	80 00       	ld.sh	r0,r0[0x0]
80005236:	35 1c       	mov	r12,81
80005238:	80 00       	ld.sh	r0,r0[0x0]
8000523a:	cc 38       	rjmp	800053c0 <vTareaLCD+0x18>
8000523c:	80 02       	ld.sh	r2,r0[0x0]
8000523e:	27 64       	sub	r4,118
80005240:	80 00       	ld.sh	r0,r0[0x0]
80005242:	31 88       	mov	r8,24
80005244:	80 00       	ld.sh	r0,r0[0x0]
80005246:	2b 1c       	sub	r12,-79
80005248:	80 00       	ld.sh	r0,r0[0x0]
8000524a:	21 dc       	sub	r12,29
8000524c:	80 00       	ld.sh	r0,r0[0x0]
8000524e:	2d 2e       	sub	lr,-46
80005250:	00 00       	add	r0,r0
80005252:	0a 54       	eor	r4,r5
80005254:	80 00       	ld.sh	r0,r0[0x0]
80005256:	26 20       	sub	r0,98
80005258:	00 00       	add	r0,r0
8000525a:	0a 40       	or	r0,r5
8000525c:	80 02       	ld.sh	r2,r0[0x0]
8000525e:	27 80       	sub	r0,120
80005260:	80 00       	ld.sh	r0,r0[0x0]
80005262:	84 a8       	ld.uh	r8,r2[0x4]
80005264:	80 00       	ld.sh	r0,r0[0x0]
80005266:	21 d0       	sub	r0,29
80005268:	80 00       	ld.sh	r0,r0[0x0]
8000526a:	62 7c       	ld.w	r12,r1[0x1c]

8000526c <vTareaSD>:
			}
		}
		vTaskDelay(100);
	}
}
void vTareaSD( void *pvParameters ){
8000526c:	d4 31       	pushm	r0-r7,lr
8000526e:	20 3d       	sub	sp,12
80005270:	30 54       	mov	r4,5
	int temperaturaSDRecibido;
	int gasSDRecibido;
	int iluminosidadSDRecibido;
	int seccion=5;
	while(1){
		if(xSemaphoreTake(xMutexSD,0xFFFFFFFF)==1){
80005272:	4c 06       	lddpc	r6,80005370 <vTareaSD+0x104>
80005274:	30 07       	mov	r7,0
80005276:	3f f5       	mov	r5,-1
			if(temperaturaSDQueue!=0){
80005278:	4b f2       	lddpc	r2,80005374 <vTareaSD+0x108>
					if(seccion >= 20){
						seccion = 5;
					}
				}
			}
			if(gasSDQueue!=0){
8000527a:	4c 01       	lddpc	r1,80005378 <vTareaSD+0x10c>
					if(seccion >= 20){
						seccion = 5;
					}
				}
			}
			if(iluminosidadSDQueue!=0){
8000527c:	4c 00       	lddpc	r0,8000537c <vTareaSD+0x110>
				xQueueReceive(iluminosidadSDQueue,(void*)&iluminosidadSDRecibido,5);
8000527e:	08 93       	mov	r3,r4
	int temperaturaSDRecibido;
	int gasSDRecibido;
	int iluminosidadSDRecibido;
	int seccion=5;
	while(1){
		if(xSemaphoreTake(xMutexSD,0xFFFFFFFF)==1){
80005280:	0e 99       	mov	r9,r7
80005282:	0a 9a       	mov	r10,r5
80005284:	0e 9b       	mov	r11,r7
80005286:	6c 0c       	ld.w	r12,r6[0x0]
80005288:	f0 1f 00 3e 	mcall	80005380 <vTareaSD+0x114>
8000528c:	58 1c       	cp.w	r12,1
8000528e:	cf 91       	brne	80005280 <vTareaSD+0x14>
			if(temperaturaSDQueue!=0){
80005290:	64 0c       	ld.w	r12,r2[0x0]
80005292:	58 0c       	cp.w	r12,0
80005294:	c2 00       	breq	800052d4 <vTareaSD+0x68>
				xQueueReceive(temperaturaSDQueue,(void*)&temperaturaSDRecibido,5);
80005296:	0e 99       	mov	r9,r7
80005298:	06 9a       	mov	r10,r3
8000529a:	fa cb ff f8 	sub	r11,sp,-8
8000529e:	f0 1f 00 39 	mcall	80005380 <vTareaSD+0x114>
				float temperatura=(float)temperaturaSDRecibido;
				sprintf(buffer_rx,"%d",10000);//+(temperatura/80*23));
800052a2:	4b 98       	lddpc	r8,80005384 <vTareaSD+0x118>
800052a4:	70 0c       	ld.w	r12,r8[0x0]
800052a6:	e0 68 27 10 	mov	r8,10000
800052aa:	1a d8       	st.w	--sp,r8
800052ac:	4b 7b       	lddpc	r11,80005388 <vTareaSD+0x11c>
800052ae:	f0 1f 00 38 	mcall	8000538c <vTareaSD+0x120>
				if (sd_mmc_spi_mem_check()){
800052b2:	f0 1f 00 38 	mcall	80005390 <vTareaSD+0x124>
800052b6:	2f fd       	sub	sp,-4
800052b8:	58 0c       	cp.w	r12,0
800052ba:	c0 d0       	breq	800052d4 <vTareaSD+0x68>
					sd_mmc_spi_write_open(seccion);
800052bc:	08 9c       	mov	r12,r4
800052be:	f0 1f 00 36 	mcall	80005394 <vTareaSD+0x128>
					//et024006_PrintString(buffer_rx,(const unsigned char *)&FONT8x16,45,115,RED,-1);
					sd_mmc_spi_write_sector_from_ram(&buffer_rx);
800052c2:	4b 1c       	lddpc	r12,80005384 <vTareaSD+0x118>
800052c4:	f0 1f 00 35 	mcall	80005398 <vTareaSD+0x12c>
					sd_mmc_spi_write_close();
800052c8:	f0 1f 00 35 	mcall	8000539c <vTareaSD+0x130>
					seccion++;
800052cc:	2f f4       	sub	r4,-1
					if(seccion >= 20){
800052ce:	59 44       	cp.w	r4,20
800052d0:	f9 b4 04 05 	movge	r4,5
						seccion = 5;
					}
				}
			}
			if(gasSDQueue!=0){
800052d4:	62 0c       	ld.w	r12,r1[0x0]
800052d6:	58 0c       	cp.w	r12,0
800052d8:	c2 00       	breq	80005318 <vTareaSD+0xac>
				xQueueReceive(gasSDQueue,(void*)&gasSDRecibido,5);
800052da:	0e 99       	mov	r9,r7
800052dc:	06 9a       	mov	r10,r3
800052de:	fa cb ff fc 	sub	r11,sp,-4
800052e2:	f0 1f 00 28 	mcall	80005380 <vTareaSD+0x114>
				if (sd_mmc_spi_mem_check()){
800052e6:	f0 1f 00 2b 	mcall	80005390 <vTareaSD+0x124>
800052ea:	c1 70       	breq	80005318 <vTareaSD+0xac>
					sd_mmc_spi_write_open(seccion);
800052ec:	08 9c       	mov	r12,r4
800052ee:	f0 1f 00 2a 	mcall	80005394 <vTareaSD+0x128>
					sprintf(buffer_rx,"%d",20000+gasSDRecibido);
800052f2:	4a 58       	lddpc	r8,80005384 <vTareaSD+0x118>
800052f4:	70 0c       	ld.w	r12,r8[0x0]
800052f6:	40 18       	lddsp	r8,sp[0x4]
800052f8:	f0 c8 b1 e0 	sub	r8,r8,-20000
800052fc:	1a d8       	st.w	--sp,r8
800052fe:	4a 3b       	lddpc	r11,80005388 <vTareaSD+0x11c>
80005300:	f0 1f 00 23 	mcall	8000538c <vTareaSD+0x120>
					//et024006_PrintString(buffer_rx,(const unsigned char *)&FONT8x16,45,115,RED,-1);
					sd_mmc_spi_write_sector_from_ram(&buffer_rx);
80005304:	4a 0c       	lddpc	r12,80005384 <vTareaSD+0x118>
80005306:	f0 1f 00 25 	mcall	80005398 <vTareaSD+0x12c>
					sd_mmc_spi_write_close();
8000530a:	f0 1f 00 25 	mcall	8000539c <vTareaSD+0x130>
					seccion++;
8000530e:	2f f4       	sub	r4,-1
					if(seccion >= 20){
80005310:	2f fd       	sub	sp,-4
80005312:	59 44       	cp.w	r4,20
80005314:	f9 b4 04 05 	movge	r4,5
						seccion = 5;
					}
				}
			}
			if(iluminosidadSDQueue!=0){
80005318:	60 0c       	ld.w	r12,r0[0x0]
8000531a:	58 0c       	cp.w	r12,0
8000531c:	c1 f0       	breq	8000535a <vTareaSD+0xee>
				xQueueReceive(iluminosidadSDQueue,(void*)&iluminosidadSDRecibido,5);
8000531e:	0e 99       	mov	r9,r7
80005320:	06 9a       	mov	r10,r3
80005322:	1a 9b       	mov	r11,sp
80005324:	f0 1f 00 17 	mcall	80005380 <vTareaSD+0x114>
				if (sd_mmc_spi_mem_check()){
80005328:	f0 1f 00 1a 	mcall	80005390 <vTareaSD+0x124>
8000532c:	c1 70       	breq	8000535a <vTareaSD+0xee>
					sd_mmc_spi_write_open(seccion);
8000532e:	08 9c       	mov	r12,r4
80005330:	f0 1f 00 19 	mcall	80005394 <vTareaSD+0x128>
					sprintf(buffer_rx,"%d",30000+iluminosidadSDRecibido);
80005334:	49 48       	lddpc	r8,80005384 <vTareaSD+0x118>
80005336:	70 0c       	ld.w	r12,r8[0x0]
80005338:	40 08       	lddsp	r8,sp[0x0]
8000533a:	f0 c8 8a d0 	sub	r8,r8,-30000
8000533e:	1a d8       	st.w	--sp,r8
80005340:	49 2b       	lddpc	r11,80005388 <vTareaSD+0x11c>
80005342:	f0 1f 00 13 	mcall	8000538c <vTareaSD+0x120>
					//et024006_PrintString(buffer_rx,(const unsigned char *)&FONT8x16,45,115,RED,-1);
					sd_mmc_spi_write_sector_from_ram(&buffer_rx);
80005346:	49 0c       	lddpc	r12,80005384 <vTareaSD+0x118>
80005348:	f0 1f 00 14 	mcall	80005398 <vTareaSD+0x12c>
					sd_mmc_spi_write_close();
8000534c:	f0 1f 00 14 	mcall	8000539c <vTareaSD+0x130>
					seccion++;
80005350:	2f f4       	sub	r4,-1
					if(seccion >= 20){
80005352:	2f fd       	sub	sp,-4
80005354:	59 44       	cp.w	r4,20
80005356:	f9 b4 04 05 	movge	r4,5
						seccion = 5;
					}
				}
			}
			xSemaphoreGive(xMutexSD);
8000535a:	0e 99       	mov	r9,r7
8000535c:	0e 9a       	mov	r10,r7
8000535e:	0e 9b       	mov	r11,r7
80005360:	6c 0c       	ld.w	r12,r6[0x0]
80005362:	f0 1f 00 10 	mcall	800053a0 <vTareaSD+0x134>
			vTaskDelay(100);
80005366:	36 4c       	mov	r12,100
80005368:	f0 1f 00 0f 	mcall	800053a4 <vTareaSD+0x138>
8000536c:	c8 ab       	rjmp	80005280 <vTareaSD+0x14>
8000536e:	00 00       	add	r0,r0
80005370:	00 00       	add	r0,r0
80005372:	0a 38       	cp.w	r8,r5
80005374:	00 00       	add	r0,r0
80005376:	0e 4c       	or	r12,r7
80005378:	00 00       	add	r0,r0
8000537a:	10 5c       	eor	r12,r8
8000537c:	00 00       	add	r0,r0
8000537e:	0a 50       	eor	r0,r5
80005380:	80 00       	ld.sh	r0,r0[0x0]
80005382:	60 c0       	ld.w	r0,r0[0x30]
80005384:	00 00       	add	r0,r0
80005386:	0e 40       	or	r0,r7
80005388:	80 02       	ld.sh	r2,r0[0x0]
8000538a:	27 80       	sub	r0,120
8000538c:	80 00       	ld.sh	r0,r0[0x0]
8000538e:	84 a8       	ld.uh	r8,r2[0x4]
80005390:	80 00       	ld.sh	r0,r0[0x0]
80005392:	2b 1c       	sub	r12,-79
80005394:	80 00       	ld.sh	r0,r0[0x0]
80005396:	21 b4       	sub	r4,27
80005398:	80 00       	ld.sh	r0,r0[0x0]
8000539a:	23 7c       	sub	r12,55
8000539c:	80 00       	ld.sh	r0,r0[0x0]
8000539e:	21 24       	sub	r4,18
800053a0:	80 00       	ld.sh	r0,r0[0x0]
800053a2:	62 7c       	ld.w	r12,r1[0x1c]
800053a4:	80 00       	ld.sh	r0,r0[0x0]
800053a6:	6a 5c       	ld.w	r12,r5[0x14]

800053a8 <vTareaLCD>:
			while(!tpa6130_dac_output(NULL, 0));
			//xSemaphoreGive(xMutexAudio);
		//}
	}
}
void vTareaLCD( void *pvParameters ){
800053a8:	d4 31       	pushm	r0-r7,lr
800053aa:	20 3d       	sub	sp,12
	int gasRecibido;
	int iluminosidadRecibido;
	int temperaturaPrimeraVez=1;
	int gasPrimeraVez=1;
	while(1){
		if(temperaturaQueue!=0){
800053ac:	fe f5 04 a8 	ld.w	r5,pc[1192]
			xQueueReceive(temperaturaQueue,(void*)&temperaturaRecibido,5);	
800053b0:	fa c4 ff f8 	sub	r4,sp,-8
800053b4:	30 07       	mov	r7,0
800053b6:	30 56       	mov	r6,5
			float temperatura=(float)temperaturaRecibido;
			if((temperatura/80*11)>=12){
800053b8:	fc 13 42 a0 	movh	r3,0x42a0
800053bc:	fc 12 41 30 	movh	r2,0x4130
800053c0:	fc 11 41 40 	movh	r1,0x4140
					//tpa6130_dac_mute(1);
					//vTaskSuspend(myTask2Handle);	
				//}
 			}
 			else{
				 if(gpio_get_pin_value(QT1081_TOUCH_SENSOR_ENTER)==0){
800053c4:	33 a0       	mov	r0,58
	int gasRecibido;
	int iluminosidadRecibido;
	int temperaturaPrimeraVez=1;
	int gasPrimeraVez=1;
	while(1){
		if(temperaturaQueue!=0){
800053c6:	6a 0c       	ld.w	r12,r5[0x0]
800053c8:	58 0c       	cp.w	r12,0
800053ca:	c5 d0       	breq	80005484 <vTareaLCD+0xdc>
			xQueueReceive(temperaturaQueue,(void*)&temperaturaRecibido,5);	
800053cc:	0e 99       	mov	r9,r7
800053ce:	0c 9a       	mov	r10,r6
800053d0:	08 9b       	mov	r11,r4
800053d2:	f0 1f 01 22 	mcall	80005858 <vTareaLCD+0x4b0>
			float temperatura=(float)temperaturaRecibido;
			if((temperatura/80*11)>=12){
800053d6:	40 2c       	lddsp	r12,sp[0x8]
800053d8:	f0 1f 01 21 	mcall	8000585c <vTareaLCD+0x4b4>
800053dc:	06 9b       	mov	r11,r3
800053de:	f0 1f 01 21 	mcall	80005860 <vTareaLCD+0x4b8>
800053e2:	04 9b       	mov	r11,r2
800053e4:	f0 1f 01 20 	mcall	80005864 <vTareaLCD+0x4bc>
800053e8:	02 9b       	mov	r11,r1
800053ea:	f0 1f 01 20 	mcall	80005868 <vTareaLCD+0x4c0>
800053ee:	c2 b0       	breq	80005444 <vTareaLCD+0x9c>
				if(gpio_get_pin_value(QT1081_TOUCH_SENSOR_ENTER)==0){
800053f0:	00 9c       	mov	r12,r0
800053f2:	f0 1f 01 1f 	mcall	8000586c <vTareaLCD+0x4c4>
800053f6:	c1 e1       	brne	80005432 <vTareaLCD+0x8a>
					et024006_DrawFilledRect(0 ,0, 30,240, BLACK );
800053f8:	0e 98       	mov	r8,r7
800053fa:	e0 69 00 f0 	mov	r9,240
800053fe:	31 ea       	mov	r10,30
80005400:	0e 9b       	mov	r11,r7
80005402:	0e 9c       	mov	r12,r7
80005404:	f0 1f 01 1b 	mcall	80005870 <vTareaLCD+0x4c8>
					et024006_PrintString("Mensajes guardados en SD:", (const unsigned char *)&FONT6x8, 0, 90, BLACK, -1);
80005408:	3f f8       	mov	r8,-1
8000540a:	1a d8       	st.w	--sp,r8
8000540c:	0e 98       	mov	r8,r7
8000540e:	35 a9       	mov	r9,90
80005410:	0e 9a       	mov	r10,r7
80005412:	fe fb 04 62 	ld.w	r11,pc[1122]
80005416:	fe fc 04 62 	ld.w	r12,pc[1122]
8000541a:	f0 1f 01 19 	mcall	8000587c <vTareaLCD+0x4d4>
 					et024006_DrawFilledRect(10 , 40, 20, 140, RED );
8000541e:	e0 68 f8 00 	mov	r8,63488
80005422:	e0 69 00 8c 	mov	r9,140
80005426:	31 4a       	mov	r10,20
80005428:	32 8b       	mov	r11,40
8000542a:	30 ac       	mov	r12,10
8000542c:	f0 1f 01 11 	mcall	80005870 <vTareaLCD+0x4c8>
80005430:	2f fd       	sub	sp,-4
				}
				gpio_clr_gpio_pin(LED0_GPIO);
80005432:	33 bc       	mov	r12,59
80005434:	f0 1f 01 13 	mcall	80005880 <vTareaLCD+0x4d8>
				//if(temperaturaPrimeraVez==1){
					//temperaturaPrimeraVez=0;
					//tpa6130_dac_mute(0);
					vTaskResume(myTask2Handle);
80005438:	fe f8 04 4c 	ld.w	r8,pc[1100]
8000543c:	70 0c       	ld.w	r12,r8[0x0]
8000543e:	f0 1f 01 13 	mcall	80005888 <vTareaLCD+0x4e0>
80005442:	c2 18       	rjmp	80005484 <vTareaLCD+0xdc>
					//tpa6130_dac_mute(1);
					//vTaskSuspend(myTask2Handle);	
				//}
 			}
 			else{
				 if(gpio_get_pin_value(QT1081_TOUCH_SENSOR_ENTER)==0){
80005444:	00 9c       	mov	r12,r0
80005446:	f0 1f 01 0a 	mcall	8000586c <vTareaLCD+0x4c4>
8000544a:	c1 51       	brne	80005474 <vTareaLCD+0xcc>
					 et024006_PrintString("Mensajes guardados en SD:", (const unsigned char *)&FONT6x8, 0, 90, BLACK, -1);
8000544c:	3f f8       	mov	r8,-1
8000544e:	1a d8       	st.w	--sp,r8
80005450:	0e 98       	mov	r8,r7
80005452:	35 a9       	mov	r9,90
80005454:	0e 9a       	mov	r10,r7
80005456:	fe fb 04 1e 	ld.w	r11,pc[1054]
8000545a:	fe fc 04 1e 	ld.w	r12,pc[1054]
8000545e:	f0 1f 01 08 	mcall	8000587c <vTareaLCD+0x4d4>
 					et024006_DrawFilledRect(10 , 40, 20, 140,BLUE );
80005462:	31 f8       	mov	r8,31
80005464:	e0 69 00 8c 	mov	r9,140
80005468:	31 4a       	mov	r10,20
8000546a:	32 8b       	mov	r11,40
8000546c:	30 ac       	mov	r12,10
8000546e:	f0 1f 01 01 	mcall	80005870 <vTareaLCD+0x4c8>
80005472:	2f fd       	sub	sp,-4
				 }
					gpio_set_gpio_pin(LED0_GPIO);
80005474:	33 bc       	mov	r12,59
80005476:	f0 1f 01 06 	mcall	8000588c <vTareaLCD+0x4e4>
					vTaskSuspend(myTask2Handle);
8000547a:	fe f8 04 0a 	ld.w	r8,pc[1034]
8000547e:	70 0c       	ld.w	r12,r8[0x0]
80005480:	f0 1f 01 04 	mcall	80005890 <vTareaLCD+0x4e8>
			}
		}
		if(gasQueue!=0){
80005484:	fe f8 04 10 	ld.w	r8,pc[1040]
80005488:	70 0c       	ld.w	r12,r8[0x0]
8000548a:	58 0c       	cp.w	r12,0
8000548c:	c6 b0       	breq	80005562 <vTareaLCD+0x1ba>
			xQueueReceive(gasQueue,(void*)&gasRecibido,5);
8000548e:	0e 99       	mov	r9,r7
80005490:	0c 9a       	mov	r10,r6
80005492:	fa cb ff fc 	sub	r11,sp,-4
80005496:	f0 1f 00 f1 	mcall	80005858 <vTareaLCD+0x4b0>
			if(gasRecibido>=250){
8000549a:	40 18       	lddsp	r8,sp[0x4]
8000549c:	e0 48 00 f9 	cp.w	r8,249
800054a0:	e0 8a 00 2e 	brle	800054fc <vTareaLCD+0x154>
				
 				et024006_DrawFilledRect(140, 100, 60, 40, RED );
800054a4:	e0 68 f8 00 	mov	r8,63488
800054a8:	32 89       	mov	r9,40
800054aa:	33 ca       	mov	r10,60
800054ac:	36 4b       	mov	r11,100
800054ae:	e0 6c 00 8c 	mov	r12,140
800054b2:	f0 1f 00 f0 	mcall	80005870 <vTareaLCD+0x4c8>
 				et024006_DrawHorizLine(120,100,100,RED);
800054b6:	e0 69 f8 00 	mov	r9,63488
800054ba:	36 4a       	mov	r10,100
800054bc:	14 9b       	mov	r11,r10
800054be:	37 8c       	mov	r12,120
800054c0:	f0 1f 00 f6 	mcall	80005898 <vTareaLCD+0x4f0>
 				et024006_DrawLine(120,100,170,60,RED);
800054c4:	e0 68 f8 00 	mov	r8,63488
800054c8:	33 c9       	mov	r9,60
800054ca:	e0 6a 00 aa 	mov	r10,170
800054ce:	36 4b       	mov	r11,100
800054d0:	37 8c       	mov	r12,120
800054d2:	f0 1f 00 f3 	mcall	8000589c <vTareaLCD+0x4f4>
 				et024006_DrawLine(170,60,220,100,RED);
800054d6:	e0 68 f8 00 	mov	r8,63488
800054da:	36 49       	mov	r9,100
800054dc:	e0 6a 00 dc 	mov	r10,220
800054e0:	33 cb       	mov	r11,60
800054e2:	e0 6c 00 aa 	mov	r12,170
800054e6:	f0 1f 00 ee 	mcall	8000589c <vTareaLCD+0x4f4>
				 gpio_clr_gpio_pin(LED1_GPIO);
800054ea:	33 cc       	mov	r12,60
800054ec:	f0 1f 00 e5 	mcall	80005880 <vTareaLCD+0x4d8>
				//if(gasPrimeraVez==1){
					//gasPrimeraVez=0;
					//tpa6130_dac_mute(0);
					vTaskResume(myTask4Handle);
800054f0:	fe f8 03 b0 	ld.w	r8,pc[944]
800054f4:	70 0c       	ld.w	r12,r8[0x0]
800054f6:	f0 1f 00 e5 	mcall	80005888 <vTareaLCD+0x4e0>
800054fa:	c3 48       	rjmp	80005562 <vTareaLCD+0x1ba>
					//vTaskSuspend(myTask4Handle);
				//}
 			}
 			else{
				 
				 et024006_DrawFilledRect(140, 100, 60, 40, RED );
800054fc:	e0 68 f8 00 	mov	r8,63488
80005500:	32 89       	mov	r9,40
80005502:	33 ca       	mov	r10,60
80005504:	36 4b       	mov	r11,100
80005506:	e0 6c 00 8c 	mov	r12,140
8000550a:	f0 1f 00 da 	mcall	80005870 <vTareaLCD+0x4c8>
				 et024006_DrawFilledRect(145, 105, 50, 30, BLACK );
8000550e:	0e 98       	mov	r8,r7
80005510:	31 e9       	mov	r9,30
80005512:	33 2a       	mov	r10,50
80005514:	36 9b       	mov	r11,105
80005516:	e0 6c 00 91 	mov	r12,145
8000551a:	f0 1f 00 d6 	mcall	80005870 <vTareaLCD+0x4c8>
				 et024006_DrawHorizLine(120,100,100,RED);
8000551e:	e0 69 f8 00 	mov	r9,63488
80005522:	36 4a       	mov	r10,100
80005524:	14 9b       	mov	r11,r10
80005526:	37 8c       	mov	r12,120
80005528:	f0 1f 00 dc 	mcall	80005898 <vTareaLCD+0x4f0>
				 et024006_DrawLine(120,100,170,60,RED);
8000552c:	e0 68 f8 00 	mov	r8,63488
80005530:	33 c9       	mov	r9,60
80005532:	e0 6a 00 aa 	mov	r10,170
80005536:	36 4b       	mov	r11,100
80005538:	37 8c       	mov	r12,120
8000553a:	f0 1f 00 d9 	mcall	8000589c <vTareaLCD+0x4f4>
				 et024006_DrawLine(170,60,220,100,RED);
8000553e:	e0 68 f8 00 	mov	r8,63488
80005542:	36 49       	mov	r9,100
80005544:	e0 6a 00 dc 	mov	r10,220
80005548:	33 cb       	mov	r11,60
8000554a:	e0 6c 00 aa 	mov	r12,170
8000554e:	f0 1f 00 d4 	mcall	8000589c <vTareaLCD+0x4f4>
				 gpio_set_gpio_pin(LED1_GPIO);
80005552:	33 cc       	mov	r12,60
80005554:	f0 1f 00 ce 	mcall	8000588c <vTareaLCD+0x4e4>
				 vTaskSuspend(myTask4Handle);
80005558:	fe f8 03 48 	ld.w	r8,pc[840]
8000555c:	70 0c       	ld.w	r12,r8[0x0]
8000555e:	f0 1f 00 cd 	mcall	80005890 <vTareaLCD+0x4e8>
			 }
		}
		if(iluminosidadQueue!=0){
80005562:	fe f8 03 42 	ld.w	r8,pc[834]
80005566:	70 0c       	ld.w	r12,r8[0x0]
80005568:	58 0c       	cp.w	r12,0
8000556a:	e0 80 01 70 	breq	8000584a <vTareaLCD+0x4a2>
			xQueueReceive(iluminosidadQueue,(void*)&iluminosidadRecibido,5);
8000556e:	0e 99       	mov	r9,r7
80005570:	0c 9a       	mov	r10,r6
80005572:	1a 9b       	mov	r11,sp
80005574:	f0 1f 00 b9 	mcall	80005858 <vTareaLCD+0x4b0>
			if(iluminosidadRecibido>=900){
80005578:	40 08       	lddsp	r8,sp[0x0]
8000557a:	e0 48 03 83 	cp.w	r8,899
8000557e:	e0 8a 00 b4 	brle	800056e6 <vTareaLCD+0x33e>
				
				et024006_DrawFilledCircle(280,90,30,BLUE,0xFF);
80005582:	e0 68 00 ff 	mov	r8,255
80005586:	31 f9       	mov	r9,31
80005588:	31 ea       	mov	r10,30
8000558a:	35 ab       	mov	r11,90
8000558c:	e0 6c 01 18 	mov	r12,280
80005590:	f0 1f 00 c6 	mcall	800058a8 <vTareaLCD+0x500>
				et024006_DrawFilledCircle(280,90,29,BLACK,0xFF);
80005594:	e0 68 00 ff 	mov	r8,255
80005598:	0e 99       	mov	r9,r7
8000559a:	31 da       	mov	r10,29
8000559c:	35 ab       	mov	r11,90
8000559e:	e0 6c 01 18 	mov	r12,280
800055a2:	f0 1f 00 c2 	mcall	800058a8 <vTareaLCD+0x500>
				et024006_DrawLine(240,120,250,110,BLUE);
800055a6:	31 f8       	mov	r8,31
800055a8:	36 e9       	mov	r9,110
800055aa:	e0 6a 00 fa 	mov	r10,250
800055ae:	37 8b       	mov	r11,120
800055b0:	e0 6c 00 f0 	mov	r12,240
800055b4:	f0 1f 00 ba 	mcall	8000589c <vTareaLCD+0x4f4>
				et024006_DrawLine(240,100,245,90,BLUE);
800055b8:	31 f8       	mov	r8,31
800055ba:	35 a9       	mov	r9,90
800055bc:	e0 6a 00 f5 	mov	r10,245
800055c0:	36 4b       	mov	r11,100
800055c2:	e0 6c 00 f0 	mov	r12,240
800055c6:	f0 1f 00 b6 	mcall	8000589c <vTareaLCD+0x4f4>
				et024006_DrawLine(240,70,245,80,BLUE);
800055ca:	31 f8       	mov	r8,31
800055cc:	35 09       	mov	r9,80
800055ce:	e0 6a 00 f5 	mov	r10,245
800055d2:	34 6b       	mov	r11,70
800055d4:	e0 6c 00 f0 	mov	r12,240
800055d8:	f0 1f 00 b1 	mcall	8000589c <vTareaLCD+0x4f4>
				et024006_DrawLine(240,50,250,60,BLUE);
800055dc:	31 f8       	mov	r8,31
800055de:	33 c9       	mov	r9,60
800055e0:	e0 6a 00 fa 	mov	r10,250
800055e4:	33 2b       	mov	r11,50
800055e6:	e0 6c 00 f0 	mov	r12,240
800055ea:	f0 1f 00 ad 	mcall	8000589c <vTareaLCD+0x4f4>
				et024006_DrawVertLine(270,40,10,BLUE);
800055ee:	31 f9       	mov	r9,31
800055f0:	30 aa       	mov	r10,10
800055f2:	32 8b       	mov	r11,40
800055f4:	e0 6c 01 0e 	mov	r12,270
800055f8:	f0 1f 00 ad 	mcall	800058ac <vTareaLCD+0x504>
				et024006_DrawVertLine(290,40,10,BLUE);
800055fc:	31 f9       	mov	r9,31
800055fe:	30 aa       	mov	r10,10
80005600:	32 8b       	mov	r11,40
80005602:	e0 6c 01 22 	mov	r12,290
80005606:	f0 1f 00 aa 	mcall	800058ac <vTareaLCD+0x504>
				et024006_DrawLine(310,60,320,50,BLUE);
8000560a:	31 f8       	mov	r8,31
8000560c:	33 29       	mov	r9,50
8000560e:	e0 6a 01 40 	mov	r10,320
80005612:	33 cb       	mov	r11,60
80005614:	e0 6c 01 36 	mov	r12,310
80005618:	f0 1f 00 a1 	mcall	8000589c <vTareaLCD+0x4f4>
				et024006_DrawLine(315,80,320,70,BLUE);
8000561c:	31 f8       	mov	r8,31
8000561e:	34 69       	mov	r9,70
80005620:	e0 6a 01 40 	mov	r10,320
80005624:	35 0b       	mov	r11,80
80005626:	e0 6c 01 3b 	mov	r12,315
8000562a:	f0 1f 00 9d 	mcall	8000589c <vTareaLCD+0x4f4>
				et024006_DrawLine(315,90,320,100,BLUE);
8000562e:	31 f8       	mov	r8,31
80005630:	36 49       	mov	r9,100
80005632:	e0 6a 01 40 	mov	r10,320
80005636:	35 ab       	mov	r11,90
80005638:	e0 6c 01 3b 	mov	r12,315
8000563c:	f0 1f 00 98 	mcall	8000589c <vTareaLCD+0x4f4>
				et024006_DrawLine(310,110,320,120,BLUE);
80005640:	31 f8       	mov	r8,31
80005642:	37 89       	mov	r9,120
80005644:	e0 6a 01 40 	mov	r10,320
80005648:	36 eb       	mov	r11,110
8000564a:	e0 6c 01 36 	mov	r12,310
8000564e:	f0 1f 00 94 	mcall	8000589c <vTareaLCD+0x4f4>
				et024006_DrawLine(270,140, 290, 140, BLUE);
80005652:	31 f8       	mov	r8,31
80005654:	e0 69 00 8c 	mov	r9,140
80005658:	e0 6a 01 22 	mov	r10,290
8000565c:	12 9b       	mov	r11,r9
8000565e:	e0 6c 01 0e 	mov	r12,270
80005662:	f0 1f 00 8f 	mcall	8000589c <vTareaLCD+0x4f4>
				et024006_DrawLine(270,135, 290, 135, BLUE);
80005666:	31 f8       	mov	r8,31
80005668:	e0 69 00 87 	mov	r9,135
8000566c:	e0 6a 01 22 	mov	r10,290
80005670:	12 9b       	mov	r11,r9
80005672:	e0 6c 01 0e 	mov	r12,270
80005676:	f0 1f 00 8a 	mcall	8000589c <vTareaLCD+0x4f4>
				et024006_DrawLine(270,130, 290, 130, BLUE);
8000567a:	31 f8       	mov	r8,31
8000567c:	e0 69 00 82 	mov	r9,130
80005680:	e0 6a 01 22 	mov	r10,290
80005684:	12 9b       	mov	r11,r9
80005686:	e0 6c 01 0e 	mov	r12,270
8000568a:	f0 1f 00 85 	mcall	8000589c <vTareaLCD+0x4f4>
				et024006_DrawLine(270,125, 290, 125, BLUE);
8000568e:	31 f8       	mov	r8,31
80005690:	37 d9       	mov	r9,125
80005692:	e0 6a 01 22 	mov	r10,290
80005696:	12 9b       	mov	r11,r9
80005698:	e0 6c 01 0e 	mov	r12,270
8000569c:	f0 1f 00 80 	mcall	8000589c <vTareaLCD+0x4f4>
				et024006_DrawLine(270,120, 290, 120, BLUE);
800056a0:	31 f8       	mov	r8,31
800056a2:	37 89       	mov	r9,120
800056a4:	e0 6a 01 22 	mov	r10,290
800056a8:	12 9b       	mov	r11,r9
800056aa:	e0 6c 01 0e 	mov	r12,270
800056ae:	f0 1f 00 7c 	mcall	8000589c <vTareaLCD+0x4f4>
				et024006_DrawLine(270,140, 270, 120, BLUE);
800056b2:	31 f8       	mov	r8,31
800056b4:	37 89       	mov	r9,120
800056b6:	e0 6a 01 0e 	mov	r10,270
800056ba:	e0 6b 00 8c 	mov	r11,140
800056be:	14 9c       	mov	r12,r10
800056c0:	f0 1f 00 77 	mcall	8000589c <vTareaLCD+0x4f4>
				et024006_DrawLine(290,140, 290, 120, BLUE);
800056c4:	31 f8       	mov	r8,31
800056c6:	37 89       	mov	r9,120
800056c8:	e0 6a 01 22 	mov	r10,290
800056cc:	e0 6b 00 8c 	mov	r11,140
800056d0:	14 9c       	mov	r12,r10
800056d2:	f0 1f 00 73 	mcall	8000589c <vTareaLCD+0x4f4>
				gpio_set_gpio_pin(LED2_GPIO);
800056d6:	0c 9c       	mov	r12,r6
800056d8:	f0 1f 00 6d 	mcall	8000588c <vTareaLCD+0x4e4>
				//if(gasPrimeraVez==1){
				//gasPrimeraVez=0;
				//tpa6130_dac_mute(0);
				vTaskResume(myTask5Handle);
800056dc:	4f 58       	lddpc	r8,800058b0 <vTareaLCD+0x508>
800056de:	70 0c       	ld.w	r12,r8[0x0]
800056e0:	f0 1f 00 6a 	mcall	80005888 <vTareaLCD+0x4e0>
800056e4:	cb 38       	rjmp	8000584a <vTareaLCD+0x4a2>
				//tpa6130_dac_mute(1);
				//vTaskSuspend(myTask4Handle);
				//}
			}
			else{
				et024006_DrawFilledCircle(280,90,30,BLUE,0xFF);
800056e6:	e0 68 00 ff 	mov	r8,255
800056ea:	31 f9       	mov	r9,31
800056ec:	31 ea       	mov	r10,30
800056ee:	35 ab       	mov	r11,90
800056f0:	e0 6c 01 18 	mov	r12,280
800056f4:	f0 1f 00 6d 	mcall	800058a8 <vTareaLCD+0x500>
				et024006_DrawFilledCircle(280,90,29,YELLOW,0xFF);
800056f8:	e0 68 00 ff 	mov	r8,255
800056fc:	e0 69 ff e0 	mov	r9,65504
80005700:	31 da       	mov	r10,29
80005702:	35 ab       	mov	r11,90
80005704:	e0 6c 01 18 	mov	r12,280
80005708:	f0 1f 00 68 	mcall	800058a8 <vTareaLCD+0x500>
				et024006_DrawLine(240,120,250,110,BLUE);
8000570c:	31 f8       	mov	r8,31
8000570e:	36 e9       	mov	r9,110
80005710:	e0 6a 00 fa 	mov	r10,250
80005714:	37 8b       	mov	r11,120
80005716:	e0 6c 00 f0 	mov	r12,240
8000571a:	f0 1f 00 61 	mcall	8000589c <vTareaLCD+0x4f4>
				et024006_DrawLine(240,100,245,90,BLUE);
8000571e:	31 f8       	mov	r8,31
80005720:	35 a9       	mov	r9,90
80005722:	e0 6a 00 f5 	mov	r10,245
80005726:	36 4b       	mov	r11,100
80005728:	e0 6c 00 f0 	mov	r12,240
8000572c:	f0 1f 00 5c 	mcall	8000589c <vTareaLCD+0x4f4>
				et024006_DrawLine(240,70,245,80,BLUE);
80005730:	31 f8       	mov	r8,31
80005732:	35 09       	mov	r9,80
80005734:	e0 6a 00 f5 	mov	r10,245
80005738:	34 6b       	mov	r11,70
8000573a:	e0 6c 00 f0 	mov	r12,240
8000573e:	f0 1f 00 58 	mcall	8000589c <vTareaLCD+0x4f4>
				et024006_DrawLine(240,50,250,60,BLUE);
80005742:	31 f8       	mov	r8,31
80005744:	33 c9       	mov	r9,60
80005746:	e0 6a 00 fa 	mov	r10,250
8000574a:	33 2b       	mov	r11,50
8000574c:	e0 6c 00 f0 	mov	r12,240
80005750:	f0 1f 00 53 	mcall	8000589c <vTareaLCD+0x4f4>
				et024006_DrawVertLine(270,40,10,BLUE);
80005754:	31 f9       	mov	r9,31
80005756:	30 aa       	mov	r10,10
80005758:	32 8b       	mov	r11,40
8000575a:	e0 6c 01 0e 	mov	r12,270
8000575e:	f0 1f 00 54 	mcall	800058ac <vTareaLCD+0x504>
				et024006_DrawVertLine(290,40,10,BLUE);
80005762:	31 f9       	mov	r9,31
80005764:	30 aa       	mov	r10,10
80005766:	32 8b       	mov	r11,40
80005768:	e0 6c 01 22 	mov	r12,290
8000576c:	f0 1f 00 50 	mcall	800058ac <vTareaLCD+0x504>
				et024006_DrawLine(310,60,320,50,BLUE);
80005770:	31 f8       	mov	r8,31
80005772:	33 29       	mov	r9,50
80005774:	e0 6a 01 40 	mov	r10,320
80005778:	33 cb       	mov	r11,60
8000577a:	e0 6c 01 36 	mov	r12,310
8000577e:	f0 1f 00 48 	mcall	8000589c <vTareaLCD+0x4f4>
				et024006_DrawLine(315,80,320,70,BLUE);
80005782:	31 f8       	mov	r8,31
80005784:	34 69       	mov	r9,70
80005786:	e0 6a 01 40 	mov	r10,320
8000578a:	35 0b       	mov	r11,80
8000578c:	e0 6c 01 3b 	mov	r12,315
80005790:	f0 1f 00 43 	mcall	8000589c <vTareaLCD+0x4f4>
				et024006_DrawLine(315,90,320,100,BLUE);
80005794:	31 f8       	mov	r8,31
80005796:	36 49       	mov	r9,100
80005798:	e0 6a 01 40 	mov	r10,320
8000579c:	35 ab       	mov	r11,90
8000579e:	e0 6c 01 3b 	mov	r12,315
800057a2:	f0 1f 00 3f 	mcall	8000589c <vTareaLCD+0x4f4>
				et024006_DrawLine(310,110,320,120,BLUE);
800057a6:	31 f8       	mov	r8,31
800057a8:	37 89       	mov	r9,120
800057aa:	e0 6a 01 40 	mov	r10,320
800057ae:	36 eb       	mov	r11,110
800057b0:	e0 6c 01 36 	mov	r12,310
800057b4:	f0 1f 00 3a 	mcall	8000589c <vTareaLCD+0x4f4>
				et024006_DrawLine(270,140, 290, 140, BLUE);
800057b8:	31 f8       	mov	r8,31
800057ba:	e0 69 00 8c 	mov	r9,140
800057be:	e0 6a 01 22 	mov	r10,290
800057c2:	12 9b       	mov	r11,r9
800057c4:	e0 6c 01 0e 	mov	r12,270
800057c8:	f0 1f 00 35 	mcall	8000589c <vTareaLCD+0x4f4>
				et024006_DrawLine(270,135, 290, 135, BLUE);
800057cc:	31 f8       	mov	r8,31
800057ce:	e0 69 00 87 	mov	r9,135
800057d2:	e0 6a 01 22 	mov	r10,290
800057d6:	12 9b       	mov	r11,r9
800057d8:	e0 6c 01 0e 	mov	r12,270
800057dc:	f0 1f 00 30 	mcall	8000589c <vTareaLCD+0x4f4>
				et024006_DrawLine(270,130, 290, 130, BLUE);
800057e0:	31 f8       	mov	r8,31
800057e2:	e0 69 00 82 	mov	r9,130
800057e6:	e0 6a 01 22 	mov	r10,290
800057ea:	12 9b       	mov	r11,r9
800057ec:	e0 6c 01 0e 	mov	r12,270
800057f0:	f0 1f 00 2b 	mcall	8000589c <vTareaLCD+0x4f4>
				et024006_DrawLine(270,125, 290, 125, BLUE);
800057f4:	31 f8       	mov	r8,31
800057f6:	37 d9       	mov	r9,125
800057f8:	e0 6a 01 22 	mov	r10,290
800057fc:	12 9b       	mov	r11,r9
800057fe:	e0 6c 01 0e 	mov	r12,270
80005802:	f0 1f 00 27 	mcall	8000589c <vTareaLCD+0x4f4>
				et024006_DrawLine(270,120, 290, 120, BLUE);
80005806:	31 f8       	mov	r8,31
80005808:	37 89       	mov	r9,120
8000580a:	e0 6a 01 22 	mov	r10,290
8000580e:	12 9b       	mov	r11,r9
80005810:	e0 6c 01 0e 	mov	r12,270
80005814:	f0 1f 00 22 	mcall	8000589c <vTareaLCD+0x4f4>
				et024006_DrawLine(270,140, 270, 120, BLUE);
80005818:	31 f8       	mov	r8,31
8000581a:	37 89       	mov	r9,120
8000581c:	e0 6a 01 0e 	mov	r10,270
80005820:	e0 6b 00 8c 	mov	r11,140
80005824:	14 9c       	mov	r12,r10
80005826:	f0 1f 00 1e 	mcall	8000589c <vTareaLCD+0x4f4>
				et024006_DrawLine(290,140, 290, 120, BLUE);
8000582a:	31 f8       	mov	r8,31
8000582c:	37 89       	mov	r9,120
8000582e:	e0 6a 01 22 	mov	r10,290
80005832:	e0 6b 00 8c 	mov	r11,140
80005836:	14 9c       	mov	r12,r10
80005838:	f0 1f 00 19 	mcall	8000589c <vTareaLCD+0x4f4>
				gpio_clr_gpio_pin(LED2_GPIO);
8000583c:	0c 9c       	mov	r12,r6
8000583e:	f0 1f 00 11 	mcall	80005880 <vTareaLCD+0x4d8>
				vTaskSuspend(myTask5Handle);
80005842:	49 c8       	lddpc	r8,800058b0 <vTareaLCD+0x508>
80005844:	70 0c       	ld.w	r12,r8[0x0]
80005846:	f0 1f 00 13 	mcall	80005890 <vTareaLCD+0x4e8>
			}
		}
		vTaskDelay(100);
8000584a:	36 4c       	mov	r12,100
8000584c:	f0 1f 00 1a 	mcall	800058b4 <vTareaLCD+0x50c>
	}
80005850:	fe 9f fd bb 	bral	800053c6 <vTareaLCD+0x1e>
80005854:	00 00       	add	r0,r0
80005856:	0e 58       	eor	r8,r7
80005858:	80 00       	ld.sh	r0,r0[0x0]
8000585a:	60 c0       	ld.w	r0,r0[0x30]
8000585c:	80 00       	ld.sh	r0,r0[0x0]
8000585e:	79 12       	ld.w	r2,r12[0x44]
80005860:	80 00       	ld.sh	r0,r0[0x0]
80005862:	76 d0       	ld.w	r0,r11[0x34]
80005864:	80 00       	ld.sh	r0,r0[0x0]
80005866:	78 30       	ld.w	r0,r12[0xc]
80005868:	80 00       	ld.sh	r0,r0[0x0]
8000586a:	73 84       	ld.w	r4,r9[0x60]
8000586c:	80 00       	ld.sh	r0,r0[0x0]
8000586e:	41 1c       	lddsp	r12,sp[0x44]
80005870:	80 00       	ld.sh	r0,r0[0x0]
80005872:	35 1c       	mov	r12,81
80005874:	80 00       	ld.sh	r0,r0[0x0]
80005876:	cc 38       	rjmp	800059fc <vTareaADC+0x30>
80005878:	80 02       	ld.sh	r2,r0[0x0]
8000587a:	27 64       	sub	r4,118
8000587c:	80 00       	ld.sh	r0,r0[0x0]
8000587e:	31 88       	mov	r8,24
80005880:	80 00       	ld.sh	r0,r0[0x0]
80005882:	41 4e       	lddsp	lr,sp[0x50]
80005884:	00 00       	add	r0,r0
80005886:	06 84       	andn	r4,r3
80005888:	80 00       	ld.sh	r0,r0[0x0]
8000588a:	68 e8       	ld.w	r8,r4[0x38]
8000588c:	80 00       	ld.sh	r0,r0[0x0]
8000588e:	41 32       	lddsp	r2,sp[0x4c]
80005890:	80 00       	ld.sh	r0,r0[0x0]
80005892:	69 68       	ld.w	r8,r4[0x58]
80005894:	00 00       	add	r0,r0
80005896:	0a 3c       	cp.w	r12,r5
80005898:	80 00       	ld.sh	r0,r0[0x0]
8000589a:	36 d0       	mov	r0,109
8000589c:	80 00       	ld.sh	r0,r0[0x0]
8000589e:	33 c4       	mov	r4,60
800058a0:	00 00       	add	r0,r0
800058a2:	06 8c       	andn	r12,r3
800058a4:	00 00       	add	r0,r0
800058a6:	0e 3c       	cp.w	r12,r7
800058a8:	80 00       	ld.sh	r0,r0[0x0]
800058aa:	35 78       	mov	r8,87
800058ac:	80 00       	ld.sh	r0,r0[0x0]
800058ae:	35 5c       	mov	r12,85
800058b0:	00 00       	add	r0,r0
800058b2:	06 88       	andn	r8,r3
800058b4:	80 00       	ld.sh	r0,r0[0x0]
800058b6:	6a 5c       	ld.w	r12,r5[0x14]

800058b8 <vTareaAudioLuces>:
			while(!tpa6130_dac_output(NULL, 0));
			//xSemaphoreGive(xMutexAudio);
		//}
	}
}
void vTareaAudioLuces( void *pvParameters ){
800058b8:	eb cd 40 f8 	pushm	r3-r7,lr
800058bc:	30 08       	mov	r8,0
800058be:	10 96       	mov	r6,r8
	int count=0;
	while(true){
		//if(xSemaphoreTake(xMutexAudio,0xFFFFFFFF)==1){
			count=0;
			while(count < (SOUND_SAMPLES)){
				samples[count++] = ((uint8_t)lucesEncendidos[i]+0x80) << 8;
800058c0:	49 24       	lddpc	r4,80005908 <vTareaAudioLuces+0x50>
800058c2:	49 35       	lddpc	r5,8000590c <vTareaAudioLuces+0x54>
				samples[count++] = ((uint8_t)lucesEncendidos[i]+0x80) << 8;
				i++;
				if (i >= sizeof(lucesEncendidos)) i = 0;
			}
			tpa6130_dac_output((void *) samples,SOUND_SAMPLES/2);
800058c4:	e0 63 00 80 	mov	r3,128
			while(!tpa6130_dac_output(NULL, 0));
800058c8:	10 97       	mov	r7,r8
800058ca:	c1 08       	rjmp	800058ea <vTareaAudioLuces+0x32>
	int count=0;
	while(true){
		//if(xSemaphoreTake(xMutexAudio,0xFFFFFFFF)==1){
			count=0;
			while(count < (SOUND_SAMPLES)){
				samples[count++] = ((uint8_t)lucesEncendidos[i]+0x80) << 8;
800058cc:	e8 06 07 09 	ld.ub	r9,r4[r6]
800058d0:	28 09       	sub	r9,-128
800058d2:	a9 69       	lsl	r9,0x8
800058d4:	ea 08 0a 19 	st.h	r5[r8<<0x1],r9
800058d8:	2f f8       	sub	r8,-1
				samples[count++] = ((uint8_t)lucesEncendidos[i]+0x80) << 8;
800058da:	ea 08 0a 19 	st.h	r5[r8<<0x1],r9
800058de:	2f f8       	sub	r8,-1
				i++;
800058e0:	2f f6       	sub	r6,-1
				if (i >= sizeof(lucesEncendidos)) i = 0;
800058e2:	e0 46 cd 0e 	cp.w	r6,52494
800058e6:	f9 b6 02 00 	movhs	r6,0
	int i=0;
	int count=0;
	while(true){
		//if(xSemaphoreTake(xMutexAudio,0xFFFFFFFF)==1){
			count=0;
			while(count < (SOUND_SAMPLES)){
800058ea:	e0 48 00 ff 	cp.w	r8,255
800058ee:	fe 9a ff ef 	brle	800058cc <vTareaAudioLuces+0x14>
				samples[count++] = ((uint8_t)lucesEncendidos[i]+0x80) << 8;
				samples[count++] = ((uint8_t)lucesEncendidos[i]+0x80) << 8;
				i++;
				if (i >= sizeof(lucesEncendidos)) i = 0;
			}
			tpa6130_dac_output((void *) samples,SOUND_SAMPLES/2);
800058f2:	06 9b       	mov	r11,r3
800058f4:	0a 9c       	mov	r12,r5
800058f6:	f0 1f 00 07 	mcall	80005910 <vTareaAudioLuces+0x58>
			while(!tpa6130_dac_output(NULL, 0));
800058fa:	0e 9b       	mov	r11,r7
800058fc:	0e 9c       	mov	r12,r7
800058fe:	f0 1f 00 05 	mcall	80005910 <vTareaAudioLuces+0x58>
80005902:	cf c0       	breq	800058fa <vTareaAudioLuces+0x42>
80005904:	0e 98       	mov	r8,r7
80005906:	cf 2b       	rjmp	800058ea <vTareaAudioLuces+0x32>
80005908:	80 02       	ld.sh	r2,r0[0x0]
8000590a:	28 24       	sub	r4,-126
8000590c:	00 00       	add	r0,r0
8000590e:	0e 5c       	eor	r12,r7
80005910:	80 00       	ld.sh	r0,r0[0x0]
80005912:	2e 4c       	sub	r12,-28

80005914 <vTareaAudioGas>:
			//xSemaphoreGive(xMutexAudio);
		//}
		
	}
}
void vTareaAudioGas( void *pvParameters ){
80005914:	eb cd 40 f8 	pushm	r3-r7,lr
80005918:	30 08       	mov	r8,0
8000591a:	10 96       	mov	r6,r8
	int count=0;
	while(true){
		//if(xSemaphoreTake(xMutexAudio,0xFFFFFFFF)==1){
			count=0;
			while(count < (SOUND_SAMPLES)){
				samples[count++] = ((uint8_t)gasDetectado[i]+0x80) << 8;
8000591c:	49 24       	lddpc	r4,80005964 <vTareaAudioGas+0x50>
8000591e:	49 35       	lddpc	r5,80005968 <vTareaAudioGas+0x54>
				samples[count++] = ((uint8_t)gasDetectado[i]+0x80) << 8;
				i++;
				if (i >= sizeof(gasDetectado)) i = 0;
			}
			tpa6130_dac_output((void *) samples,SOUND_SAMPLES/2);
80005920:	e0 63 00 80 	mov	r3,128
			while(!tpa6130_dac_output(NULL, 0));
80005924:	10 97       	mov	r7,r8
80005926:	c1 08       	rjmp	80005946 <vTareaAudioGas+0x32>
	int count=0;
	while(true){
		//if(xSemaphoreTake(xMutexAudio,0xFFFFFFFF)==1){
			count=0;
			while(count < (SOUND_SAMPLES)){
				samples[count++] = ((uint8_t)gasDetectado[i]+0x80) << 8;
80005928:	e8 06 07 09 	ld.ub	r9,r4[r6]
8000592c:	28 09       	sub	r9,-128
8000592e:	a9 69       	lsl	r9,0x8
80005930:	ea 08 0a 19 	st.h	r5[r8<<0x1],r9
80005934:	2f f8       	sub	r8,-1
				samples[count++] = ((uint8_t)gasDetectado[i]+0x80) << 8;
80005936:	ea 08 0a 19 	st.h	r5[r8<<0x1],r9
8000593a:	2f f8       	sub	r8,-1
				i++;
8000593c:	2f f6       	sub	r6,-1
				if (i >= sizeof(gasDetectado)) i = 0;
8000593e:	e0 46 ac 8e 	cp.w	r6,44174
80005942:	f9 b6 02 00 	movhs	r6,0
	int i=0;
	int count=0;
	while(true){
		//if(xSemaphoreTake(xMutexAudio,0xFFFFFFFF)==1){
			count=0;
			while(count < (SOUND_SAMPLES)){
80005946:	e0 48 00 ff 	cp.w	r8,255
8000594a:	fe 9a ff ef 	brle	80005928 <vTareaAudioGas+0x14>
				samples[count++] = ((uint8_t)gasDetectado[i]+0x80) << 8;
				samples[count++] = ((uint8_t)gasDetectado[i]+0x80) << 8;
				i++;
				if (i >= sizeof(gasDetectado)) i = 0;
			}
			tpa6130_dac_output((void *) samples,SOUND_SAMPLES/2);
8000594e:	06 9b       	mov	r11,r3
80005950:	0a 9c       	mov	r12,r5
80005952:	f0 1f 00 07 	mcall	8000596c <vTareaAudioGas+0x58>
			while(!tpa6130_dac_output(NULL, 0));
80005956:	0e 9b       	mov	r11,r7
80005958:	0e 9c       	mov	r12,r7
8000595a:	f0 1f 00 05 	mcall	8000596c <vTareaAudioGas+0x58>
8000595e:	cf c0       	breq	80005956 <vTareaAudioGas+0x42>
80005960:	0e 98       	mov	r8,r7
80005962:	cf 2b       	rjmp	80005946 <vTareaAudioGas+0x32>
80005964:	80 00       	ld.sh	r0,r0[0x0]
80005966:	d0 80       	acall	0x8
80005968:	00 00       	add	r0,r0
8000596a:	0e 5c       	eor	r12,r7
8000596c:	80 00       	ld.sh	r0,r0[0x0]
8000596e:	2e 4c       	sub	r12,-28

80005970 <vTareaAudioTemperatura>:
			xSemaphoreGive(xMutex);
		}
		vTaskDelay(1000);
	}
}
void vTareaAudioTemperatura( void *pvParameters ){
80005970:	eb cd 40 f8 	pushm	r3-r7,lr
80005974:	30 08       	mov	r8,0
80005976:	10 96       	mov	r6,r8
	int count=0;
	while(true){
		//if(xSemaphoreTake(xMutexAudio,0xFFFFFFFF)==1){
			count=0;
			while(count < (SOUND_SAMPLES)){
				samples[count++] = ((uint8_t)temperaturaAlta[i]+0x80) << 8;
80005978:	49 24       	lddpc	r4,800059c0 <vTareaAudioTemperatura+0x50>
8000597a:	49 35       	lddpc	r5,800059c4 <vTareaAudioTemperatura+0x54>
				samples[count++] = ((uint8_t)temperaturaAlta[i]+0x80) << 8;
				i++;
				if (i >= sizeof(temperaturaAlta)) i = 0;
			}
			tpa6130_dac_output((void *) samples,SOUND_SAMPLES/2);
8000597c:	e0 63 00 80 	mov	r3,128
			while(!tpa6130_dac_output(NULL, 0));
80005980:	10 97       	mov	r7,r8
80005982:	c1 08       	rjmp	800059a2 <vTareaAudioTemperatura+0x32>
	int count=0;
	while(true){
		//if(xSemaphoreTake(xMutexAudio,0xFFFFFFFF)==1){
			count=0;
			while(count < (SOUND_SAMPLES)){
				samples[count++] = ((uint8_t)temperaturaAlta[i]+0x80) << 8;
80005984:	e8 06 07 09 	ld.ub	r9,r4[r6]
80005988:	28 09       	sub	r9,-128
8000598a:	a9 69       	lsl	r9,0x8
8000598c:	ea 08 0a 19 	st.h	r5[r8<<0x1],r9
80005990:	2f f8       	sub	r8,-1
				samples[count++] = ((uint8_t)temperaturaAlta[i]+0x80) << 8;
80005992:	ea 08 0a 19 	st.h	r5[r8<<0x1],r9
80005996:	2f f8       	sub	r8,-1
				i++;
80005998:	2f f6       	sub	r6,-1
				if (i >= sizeof(temperaturaAlta)) i = 0;
8000599a:	e0 46 aa 0e 	cp.w	r6,43534
8000599e:	f9 b6 02 00 	movhs	r6,0
	int i=0;
	int count=0;
	while(true){
		//if(xSemaphoreTake(xMutexAudio,0xFFFFFFFF)==1){
			count=0;
			while(count < (SOUND_SAMPLES)){
800059a2:	e0 48 00 ff 	cp.w	r8,255
800059a6:	fe 9a ff ef 	brle	80005984 <vTareaAudioTemperatura+0x14>
				samples[count++] = ((uint8_t)temperaturaAlta[i]+0x80) << 8;
				samples[count++] = ((uint8_t)temperaturaAlta[i]+0x80) << 8;
				i++;
				if (i >= sizeof(temperaturaAlta)) i = 0;
			}
			tpa6130_dac_output((void *) samples,SOUND_SAMPLES/2);
800059aa:	06 9b       	mov	r11,r3
800059ac:	0a 9c       	mov	r12,r5
800059ae:	f0 1f 00 07 	mcall	800059c8 <vTareaAudioTemperatura+0x58>
			while(!tpa6130_dac_output(NULL, 0));
800059b2:	0e 9b       	mov	r11,r7
800059b4:	0e 9c       	mov	r12,r7
800059b6:	f0 1f 00 05 	mcall	800059c8 <vTareaAudioTemperatura+0x58>
800059ba:	cf c0       	breq	800059b2 <vTareaAudioTemperatura+0x42>
800059bc:	0e 98       	mov	r8,r7
800059be:	cf 2b       	rjmp	800059a2 <vTareaAudioTemperatura+0x32>
800059c0:	80 01       	ld.sh	r1,r0[0x0]
800059c2:	7d 10       	ld.w	r0,lr[0x44]
800059c4:	00 00       	add	r0,r0
800059c6:	0e 5c       	eor	r12,r7
800059c8:	80 00       	ld.sh	r0,r0[0x0]
800059ca:	2e 4c       	sub	r12,-28

800059cc <vTareaADC>:
void adc_underrun_callback(void);
void adc_reload_callback(void);
void left_right_enter_isr(void);
void EIC(void);

void vTareaADC( void *pvParameters ){
800059cc:	d4 31       	pushm	r0-r7,lr
800059ce:	20 3d       	sub	sp,12
	//const char *pcTaskName = "Task 1 is running\r\n";
	int sensorTemperatura;
	int sensorgas;
	int sensorIluminosidad;
	int sensorContador=0;
	temperaturaQueue=xQueueCreate(5,sizeof(sensorTemperatura));
800059d0:	30 4b       	mov	r11,4
800059d2:	30 5c       	mov	r12,5
800059d4:	f0 1f 00 7e 	mcall	80005bcc <vTareaADC+0x200>
800059d8:	4f e8       	lddpc	r8,80005bd0 <vTareaADC+0x204>
800059da:	91 0c       	st.w	r8[0x0],r12
	gasQueue=xQueueCreate(5,sizeof(sensorgas));
800059dc:	30 4b       	mov	r11,4
800059de:	30 5c       	mov	r12,5
800059e0:	f0 1f 00 7b 	mcall	80005bcc <vTareaADC+0x200>
800059e4:	4f c8       	lddpc	r8,80005bd4 <vTareaADC+0x208>
800059e6:	91 0c       	st.w	r8[0x0],r12
	iluminosidadQueue=xQueueCreate(5,sizeof(sensorIluminosidad));
800059e8:	30 4b       	mov	r11,4
800059ea:	30 5c       	mov	r12,5
800059ec:	f0 1f 00 78 	mcall	80005bcc <vTareaADC+0x200>
800059f0:	4f a8       	lddpc	r8,80005bd8 <vTareaADC+0x20c>
800059f2:	91 0c       	st.w	r8[0x0],r12
	temperaturaSDQueue=xQueueCreate(5,sizeof(sensorTemperatura));
800059f4:	30 4b       	mov	r11,4
800059f6:	30 5c       	mov	r12,5
800059f8:	f0 1f 00 75 	mcall	80005bcc <vTareaADC+0x200>
800059fc:	4f 88       	lddpc	r8,80005bdc <vTareaADC+0x210>
800059fe:	91 0c       	st.w	r8[0x0],r12
	gasSDQueue=xQueueCreate(5,sizeof(sensorgas));
80005a00:	30 4b       	mov	r11,4
80005a02:	30 5c       	mov	r12,5
80005a04:	f0 1f 00 72 	mcall	80005bcc <vTareaADC+0x200>
80005a08:	4f 68       	lddpc	r8,80005be0 <vTareaADC+0x214>
80005a0a:	91 0c       	st.w	r8[0x0],r12
	iluminosidadSDQueue=xQueueCreate(5,sizeof(sensorIluminosidad));
80005a0c:	30 4b       	mov	r11,4
80005a0e:	30 5c       	mov	r12,5
80005a10:	f0 1f 00 6f 	mcall	80005bcc <vTareaADC+0x200>
80005a14:	4f 48       	lddpc	r8,80005be4 <vTareaADC+0x218>
80005a16:	91 0c       	st.w	r8[0x0],r12
80005a18:	30 04       	mov	r4,0
80005a1a:	08 93       	mov	r3,r4
	int qq=0;
	while(1){
		if(xSemaphoreTake(xMutex,0xFFFFFFFF)==1){
80005a1c:	4f 36       	lddpc	r6,80005be8 <vTareaADC+0x21c>
80005a1e:	08 97       	mov	r7,r4
80005a20:	3f f5       	mov	r5,-1
				xQueueSend(gasSDQueue,&sensorgas,0);
			}
			else if(sensorContador==2){
				gpio_clr_gpio_pin(62);
				gpio_set_gpio_pin(63);
				vTaskDelay(100);
80005a22:	36 42       	mov	r2,100
				//usart_write_line(&AVR32_USART0, pcTaskName);
				adc_start(&AVR32_ADC);
80005a24:	fe 71 3c 00 	mov	r1,-50176
	temperaturaSDQueue=xQueueCreate(5,sizeof(sensorTemperatura));
	gasSDQueue=xQueueCreate(5,sizeof(sensorgas));
	iluminosidadSDQueue=xQueueCreate(5,sizeof(sensorIluminosidad));
	int qq=0;
	while(1){
		if(xSemaphoreTake(xMutex,0xFFFFFFFF)==1){
80005a28:	0e 99       	mov	r9,r7
80005a2a:	0a 9a       	mov	r10,r5
80005a2c:	0e 9b       	mov	r11,r7
80005a2e:	6c 0c       	ld.w	r12,r6[0x0]
80005a30:	f0 1f 00 6f 	mcall	80005bec <vTareaADC+0x220>
80005a34:	58 1c       	cp.w	r12,1
80005a36:	e0 81 00 c5 	brne	80005bc0 <vTareaADC+0x1f4>
			if(sensorContador==0){
80005a3a:	58 03       	cp.w	r3,0
80005a3c:	c4 81       	brne	80005acc <vTareaADC+0x100>
				gpio_clr_gpio_pin(62);
80005a3e:	33 ec       	mov	r12,62
80005a40:	f0 1f 00 6c 	mcall	80005bf0 <vTareaADC+0x224>
				gpio_clr_gpio_pin(63);
80005a44:	33 fc       	mov	r12,63
80005a46:	f0 1f 00 6b 	mcall	80005bf0 <vTareaADC+0x224>
				vTaskDelay(100);
80005a4a:	04 9c       	mov	r12,r2
80005a4c:	f0 1f 00 6a 	mcall	80005bf4 <vTareaADC+0x228>
				//usart_write_line(&AVR32_USART0, pcTaskName);
				adc_start(&AVR32_ADC);
80005a50:	02 9c       	mov	r12,r1
80005a52:	f0 1f 00 6a 	mcall	80005bf8 <vTareaADC+0x22c>
				//adc_value_temp = adc_get_value(&AVR32_ADC,0);
				sensorTemperatura = adc_get_value(&AVR32_ADC,0);
80005a56:	0e 9b       	mov	r11,r7
80005a58:	02 9c       	mov	r12,r1
80005a5a:	f0 1f 00 69 	mcall	80005bfc <vTareaADC+0x230>
80005a5e:	50 2c       	stdsp	sp[0x8],r12
				//gpio_clr_gpio_pin(23);
				sensorContador=1;
				usart_write_line(&AVR32_USART0,"Temperatura:");
80005a60:	4e 8b       	lddpc	r11,80005c00 <vTareaADC+0x234>
80005a62:	fe 7c 14 00 	mov	r12,-60416
80005a66:	f0 1f 00 68 	mcall	80005c04 <vTareaADC+0x238>
				//usart_write_line(&AVR32_USART0,sensorTemperatura);
				//sensorTemperatura=sensorTemperatura/1023*50000/10;
				float temperatura=(float)sensorTemperatura;
				//const char *pcTaskName = "Task 1 is running\r\n";
				print_dbg_ulong(temperatura/80*11);
80005a6a:	fa c3 ff f4 	sub	r3,sp,-12
80005a6e:	07 4c       	ld.w	r12,--r3
80005a70:	f0 1f 00 66 	mcall	80005c08 <vTareaADC+0x23c>
80005a74:	fc 1b 42 a0 	movh	r11,0x42a0
80005a78:	f0 1f 00 65 	mcall	80005c0c <vTareaADC+0x240>
80005a7c:	fc 1b 41 30 	movh	r11,0x4130
80005a80:	f0 1f 00 64 	mcall	80005c10 <vTareaADC+0x244>
80005a84:	18 90       	mov	r0,r12
80005a86:	f0 1f 00 64 	mcall	80005c14 <vTareaADC+0x248>
80005a8a:	f0 1f 00 64 	mcall	80005c18 <vTareaADC+0x24c>
				datos[qq]=10000+(int)(temperatura/80*11);
80005a8e:	00 9c       	mov	r12,r0
80005a90:	f0 1f 00 63 	mcall	80005c1c <vTareaADC+0x250>
80005a94:	f8 c9 ff f0 	sub	r9,r12,-16
80005a98:	4e 28       	lddpc	r8,80005c20 <vTareaADC+0x254>
80005a9a:	f0 04 0b 09 	st.b	r8[r4],r9
				qq++;
80005a9e:	2f f4       	sub	r4,-1
				if(qq>=20)
80005aa0:	59 44       	cp.w	r4,20
80005aa2:	f9 b4 04 00 	movge	r4,0
					qq=0;
				//usart_write_line(&AVR32_USART0,"\r\n");
				xQueueSend(temperaturaQueue,&sensorTemperatura,0);
80005aa6:	0e 99       	mov	r9,r7
80005aa8:	0e 9a       	mov	r10,r7
80005aaa:	06 9b       	mov	r11,r3
80005aac:	4c 98       	lddpc	r8,80005bd0 <vTareaADC+0x204>
80005aae:	70 0c       	ld.w	r12,r8[0x0]
80005ab0:	f0 1f 00 5d 	mcall	80005c24 <vTareaADC+0x258>
				vTaskDelay(100);
80005ab4:	04 9c       	mov	r12,r2
80005ab6:	f0 1f 00 50 	mcall	80005bf4 <vTareaADC+0x228>
				xQueueSend(temperaturaSDQueue,&sensorTemperatura,0);
80005aba:	0e 99       	mov	r9,r7
80005abc:	0e 9a       	mov	r10,r7
80005abe:	06 9b       	mov	r11,r3
80005ac0:	4c 78       	lddpc	r8,80005bdc <vTareaADC+0x210>
80005ac2:	70 0c       	ld.w	r12,r8[0x0]
80005ac4:	f0 1f 00 58 	mcall	80005c24 <vTareaADC+0x258>
80005ac8:	30 13       	mov	r3,1
80005aca:	c7 58       	rjmp	80005bb4 <vTareaADC+0x1e8>
				temperatura=sensorTemperatura;
			}
			else if(sensorContador==1){
80005acc:	58 13       	cp.w	r3,1
80005ace:	c3 81       	brne	80005b3e <vTareaADC+0x172>
				gpio_set_gpio_pin(62);
80005ad0:	33 ec       	mov	r12,62
80005ad2:	f0 1f 00 56 	mcall	80005c28 <vTareaADC+0x25c>
				gpio_clr_gpio_pin(63);
80005ad6:	33 fc       	mov	r12,63
80005ad8:	f0 1f 00 46 	mcall	80005bf0 <vTareaADC+0x224>
				vTaskDelay(100);
80005adc:	04 9c       	mov	r12,r2
80005ade:	f0 1f 00 46 	mcall	80005bf4 <vTareaADC+0x228>
				//usart_write_line(&AVR32_USART0, pcTaskName);
				adc_start(&AVR32_ADC);
80005ae2:	02 9c       	mov	r12,r1
80005ae4:	f0 1f 00 45 	mcall	80005bf8 <vTareaADC+0x22c>
				//adc_value_temp = adc_get_value(&AVR32_ADC,0);
				sensorgas = adc_get_value(&AVR32_ADC,0);
80005ae8:	0e 9b       	mov	r11,r7
80005aea:	02 9c       	mov	r12,r1
80005aec:	f0 1f 00 44 	mcall	80005bfc <vTareaADC+0x230>
80005af0:	50 1c       	stdsp	sp[0x4],r12
				//gpio_clr_gpio_pin(21);
				sensorContador=2;
				usart_write_line(&AVR32_USART0,"    Gas:");
80005af2:	4c fb       	lddpc	r11,80005c2c <vTareaADC+0x260>
80005af4:	fe 7c 14 00 	mov	r12,-60416
80005af8:	f0 1f 00 43 	mcall	80005c04 <vTareaADC+0x238>
				//usart_write_line(&AVR32_USART0,sensorgas);
				print_dbg_ulong(sensorgas);
80005afc:	40 1c       	lddsp	r12,sp[0x4]
80005afe:	f0 1f 00 47 	mcall	80005c18 <vTareaADC+0x24c>
				//usart_write_line(&AVR32_USART0,"\r\n");
				datos[qq]=20000+sensorgas;
80005b02:	40 19       	lddsp	r9,sp[0x4]
80005b04:	2e 09       	sub	r9,-32
80005b06:	4c 78       	lddpc	r8,80005c20 <vTareaADC+0x254>
80005b08:	f0 04 0b 09 	st.b	r8[r4],r9
				qq++;
80005b0c:	2f f4       	sub	r4,-1
				if(qq>=15)
80005b0e:	58 f4       	cp.w	r4,15
80005b10:	f9 b4 04 00 	movge	r4,0
				qq=0;
				xQueueSend(gasQueue,&sensorgas,0);
80005b14:	fa c3 ff fc 	sub	r3,sp,-4
80005b18:	0e 99       	mov	r9,r7
80005b1a:	0e 9a       	mov	r10,r7
80005b1c:	06 9b       	mov	r11,r3
80005b1e:	4a e8       	lddpc	r8,80005bd4 <vTareaADC+0x208>
80005b20:	70 0c       	ld.w	r12,r8[0x0]
80005b22:	f0 1f 00 41 	mcall	80005c24 <vTareaADC+0x258>
				vTaskDelay(100);
80005b26:	04 9c       	mov	r12,r2
80005b28:	f0 1f 00 33 	mcall	80005bf4 <vTareaADC+0x228>
				xQueueSend(gasSDQueue,&sensorgas,0);
80005b2c:	0e 99       	mov	r9,r7
80005b2e:	0e 9a       	mov	r10,r7
80005b30:	06 9b       	mov	r11,r3
80005b32:	4a c8       	lddpc	r8,80005be0 <vTareaADC+0x214>
80005b34:	70 0c       	ld.w	r12,r8[0x0]
80005b36:	f0 1f 00 3c 	mcall	80005c24 <vTareaADC+0x258>
80005b3a:	30 23       	mov	r3,2
80005b3c:	c3 c8       	rjmp	80005bb4 <vTareaADC+0x1e8>
			}
			else if(sensorContador==2){
80005b3e:	58 23       	cp.w	r3,2
80005b40:	c3 a1       	brne	80005bb4 <vTareaADC+0x1e8>
				gpio_clr_gpio_pin(62);
80005b42:	33 ec       	mov	r12,62
80005b44:	f0 1f 00 2b 	mcall	80005bf0 <vTareaADC+0x224>
				gpio_set_gpio_pin(63);
80005b48:	33 fc       	mov	r12,63
80005b4a:	f0 1f 00 38 	mcall	80005c28 <vTareaADC+0x25c>
				vTaskDelay(100);
80005b4e:	04 9c       	mov	r12,r2
80005b50:	f0 1f 00 29 	mcall	80005bf4 <vTareaADC+0x228>
				//usart_write_line(&AVR32_USART0, pcTaskName);
				adc_start(&AVR32_ADC);
80005b54:	02 9c       	mov	r12,r1
80005b56:	f0 1f 00 29 	mcall	80005bf8 <vTareaADC+0x22c>
				//adc_value_temp = adc_get_value(&AVR32_ADC,0);
				sensorIluminosidad = adc_get_value(&AVR32_ADC,0);
80005b5a:	0e 9b       	mov	r11,r7
80005b5c:	02 9c       	mov	r12,r1
80005b5e:	f0 1f 00 28 	mcall	80005bfc <vTareaADC+0x230>
80005b62:	50 0c       	stdsp	sp[0x0],r12
				//gpio_clr_gpio_pin(21);
				sensorContador=0;
				usart_write_line(&AVR32_USART0,"    Iluminosidad:");
80005b64:	4b 3b       	lddpc	r11,80005c30 <vTareaADC+0x264>
80005b66:	fe 7c 14 00 	mov	r12,-60416
80005b6a:	f0 1f 00 27 	mcall	80005c04 <vTareaADC+0x238>
				datos[qq]=30000+sensorIluminosidad;
80005b6e:	40 09       	lddsp	r9,sp[0x0]
80005b70:	2d 09       	sub	r9,-48
80005b72:	4a c8       	lddpc	r8,80005c20 <vTareaADC+0x254>
80005b74:	f0 04 0b 09 	st.b	r8[r4],r9
				qq++;
80005b78:	2f f4       	sub	r4,-1
				if(qq>=15)
80005b7a:	58 f4       	cp.w	r4,15
80005b7c:	f9 b4 04 00 	movge	r4,0
					qq=0;
				//usart_write_line(&AVR32_USART0,sensorgas);
				print_dbg_ulong(sensorIluminosidad);
80005b80:	40 0c       	lddsp	r12,sp[0x0]
80005b82:	f0 1f 00 26 	mcall	80005c18 <vTareaADC+0x24c>
				usart_write_line(&AVR32_USART0,"\r\n");
80005b86:	4a cb       	lddpc	r11,80005c34 <vTareaADC+0x268>
80005b88:	fe 7c 14 00 	mov	r12,-60416
80005b8c:	f0 1f 00 1e 	mcall	80005c04 <vTareaADC+0x238>
				xQueueSend(iluminosidadQueue,&sensorIluminosidad,0);
80005b90:	0e 99       	mov	r9,r7
80005b92:	0e 9a       	mov	r10,r7
80005b94:	1a 9b       	mov	r11,sp
80005b96:	49 18       	lddpc	r8,80005bd8 <vTareaADC+0x20c>
80005b98:	70 0c       	ld.w	r12,r8[0x0]
80005b9a:	f0 1f 00 23 	mcall	80005c24 <vTareaADC+0x258>
				vTaskDelay(100);
80005b9e:	04 9c       	mov	r12,r2
80005ba0:	f0 1f 00 15 	mcall	80005bf4 <vTareaADC+0x228>
				xQueueSend(iluminosidadSDQueue,&sensorIluminosidad,0);
80005ba4:	0e 99       	mov	r9,r7
80005ba6:	0e 9a       	mov	r10,r7
80005ba8:	1a 9b       	mov	r11,sp
80005baa:	48 f8       	lddpc	r8,80005be4 <vTareaADC+0x218>
80005bac:	70 0c       	ld.w	r12,r8[0x0]
80005bae:	f0 1f 00 1e 	mcall	80005c24 <vTareaADC+0x258>
80005bb2:	0e 93       	mov	r3,r7
			}
			xSemaphoreGive(xMutex);
80005bb4:	0e 99       	mov	r9,r7
80005bb6:	0e 9a       	mov	r10,r7
80005bb8:	0e 9b       	mov	r11,r7
80005bba:	6c 0c       	ld.w	r12,r6[0x0]
80005bbc:	f0 1f 00 1a 	mcall	80005c24 <vTareaADC+0x258>
		}
		vTaskDelay(1000);
80005bc0:	e0 6c 03 e8 	mov	r12,1000
80005bc4:	f0 1f 00 0c 	mcall	80005bf4 <vTareaADC+0x228>
	}
80005bc8:	c3 0b       	rjmp	80005a28 <vTareaADC+0x5c>
80005bca:	00 00       	add	r0,r0
80005bcc:	80 00       	ld.sh	r0,r0[0x0]
80005bce:	63 d4       	ld.w	r4,r1[0x74]
80005bd0:	00 00       	add	r0,r0
80005bd2:	0e 58       	eor	r8,r7
80005bd4:	00 00       	add	r0,r0
80005bd6:	0a 3c       	cp.w	r12,r5
80005bd8:	00 00       	add	r0,r0
80005bda:	0e 3c       	cp.w	r12,r7
80005bdc:	00 00       	add	r0,r0
80005bde:	0e 4c       	or	r12,r7
80005be0:	00 00       	add	r0,r0
80005be2:	10 5c       	eor	r12,r8
80005be4:	00 00       	add	r0,r0
80005be6:	0a 50       	eor	r0,r5
80005be8:	00 00       	add	r0,r0
80005bea:	0e 44       	or	r4,r7
80005bec:	80 00       	ld.sh	r0,r0[0x0]
80005bee:	60 c0       	ld.w	r0,r0[0x30]
80005bf0:	80 00       	ld.sh	r0,r0[0x0]
80005bf2:	41 4e       	lddsp	lr,sp[0x50]
80005bf4:	80 00       	ld.sh	r0,r0[0x0]
80005bf6:	6a 5c       	ld.w	r12,r5[0x14]
80005bf8:	80 00       	ld.sh	r0,r0[0x0]
80005bfa:	3e e6       	mov	r6,-18
80005bfc:	80 00       	ld.sh	r0,r0[0x0]
80005bfe:	3f 08       	mov	r8,-16
80005c00:	80 02       	ld.sh	r2,r0[0x0]
80005c02:	27 84       	sub	r4,120
80005c04:	80 00       	ld.sh	r0,r0[0x0]
80005c06:	49 c8       	lddpc	r8,80005c74 <vListInsert+0x6>
80005c08:	80 00       	ld.sh	r0,r0[0x0]
80005c0a:	79 12       	ld.w	r2,r12[0x44]
80005c0c:	80 00       	ld.sh	r0,r0[0x0]
80005c0e:	76 d0       	ld.w	r0,r11[0x34]
80005c10:	80 00       	ld.sh	r0,r0[0x0]
80005c12:	78 30       	ld.w	r0,r12[0xc]
80005c14:	80 00       	ld.sh	r0,r0[0x0]
80005c16:	79 a4       	ld.w	r4,r12[0x68]
80005c18:	80 00       	ld.sh	r0,r0[0x0]
80005c1a:	4b 38       	lddpc	r8,80005ce4 <pxPortInitialiseStack+0x1c>
80005c1c:	80 00       	ld.sh	r0,r0[0x0]
80005c1e:	79 86       	ld.w	r6,r12[0x60]
80005c20:	00 00       	add	r0,r0
80005c22:	0a 40       	or	r0,r5
80005c24:	80 00       	ld.sh	r0,r0[0x0]
80005c26:	62 7c       	ld.w	r12,r1[0x1c]
80005c28:	80 00       	ld.sh	r0,r0[0x0]
80005c2a:	41 32       	lddsp	r2,sp[0x4c]
80005c2c:	80 02       	ld.sh	r2,r0[0x0]
80005c2e:	27 94       	sub	r4,121
80005c30:	80 02       	ld.sh	r2,r0[0x0]
80005c32:	27 a0       	sub	r0,122
80005c34:	80 02       	ld.sh	r2,r0[0x0]
80005c36:	27 b4       	sub	r4,123

80005c38 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005c38:	f8 c8 ff f8 	sub	r8,r12,-8
80005c3c:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80005c3e:	3f f9       	mov	r9,-1
80005c40:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005c42:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005c44:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005c46:	30 08       	mov	r8,0
80005c48:	99 08       	st.w	r12[0x0],r8
}
80005c4a:	5e fc       	retal	r12

80005c4c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005c4c:	30 08       	mov	r8,0
80005c4e:	99 48       	st.w	r12[0x10],r8
}
80005c50:	5e fc       	retal	r12

80005c52 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005c52:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005c54:	70 19       	ld.w	r9,r8[0x4]
80005c56:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005c58:	78 19       	ld.w	r9,r12[0x4]
80005c5a:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005c5c:	70 19       	ld.w	r9,r8[0x4]
80005c5e:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005c60:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005c62:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005c64:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005c66:	78 08       	ld.w	r8,r12[0x0]
80005c68:	2f f8       	sub	r8,-1
80005c6a:	99 08       	st.w	r12[0x0],r8
}
80005c6c:	5e fc       	retal	r12

80005c6e <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005c6e:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005c70:	5b fa       	cp.w	r10,-1
80005c72:	c0 31       	brne	80005c78 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005c74:	78 48       	ld.w	r8,r12[0x10]
80005c76:	c0 c8       	rjmp	80005c8e <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005c78:	f8 c8 ff f8 	sub	r8,r12,-8
80005c7c:	70 19       	ld.w	r9,r8[0x4]
80005c7e:	72 09       	ld.w	r9,r9[0x0]
80005c80:	12 3a       	cp.w	r10,r9
80005c82:	c0 63       	brcs	80005c8e <vListInsert+0x20>
80005c84:	70 18       	ld.w	r8,r8[0x4]
80005c86:	70 19       	ld.w	r9,r8[0x4]
80005c88:	72 09       	ld.w	r9,r9[0x0]
80005c8a:	12 3a       	cp.w	r10,r9
80005c8c:	cf c2       	brcc	80005c84 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005c8e:	70 19       	ld.w	r9,r8[0x4]
80005c90:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005c92:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005c94:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005c96:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005c98:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005c9a:	78 08       	ld.w	r8,r12[0x0]
80005c9c:	2f f8       	sub	r8,-1
80005c9e:	99 08       	st.w	r12[0x0],r8
}
80005ca0:	5e fc       	retal	r12

80005ca2 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005ca2:	78 18       	ld.w	r8,r12[0x4]
80005ca4:	78 29       	ld.w	r9,r12[0x8]
80005ca6:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005ca8:	78 28       	ld.w	r8,r12[0x8]
80005caa:	78 19       	ld.w	r9,r12[0x4]
80005cac:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005cae:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005cb0:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005cb2:	18 39       	cp.w	r9,r12
80005cb4:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005cb8:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005cbc:	30 09       	mov	r9,0
80005cbe:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005cc0:	70 09       	ld.w	r9,r8[0x0]
80005cc2:	20 19       	sub	r9,1
80005cc4:	91 09       	st.w	r8[0x0],r9
}
80005cc6:	5e fc       	retal	r12

80005cc8 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005cc8:	e0 68 08 08 	mov	r8,2056
80005ccc:	ea 18 08 08 	orh	r8,0x808
80005cd0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005cd2:	e0 68 09 09 	mov	r8,2313
80005cd6:	ea 18 09 09 	orh	r8,0x909
80005cda:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005cdc:	e0 68 0a 0a 	mov	r8,2570
80005ce0:	ea 18 0a 0a 	orh	r8,0xa0a
80005ce4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005ce6:	e0 68 0b 0b 	mov	r8,2827
80005cea:	ea 18 0b 0b 	orh	r8,0xb0b
80005cee:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005cf0:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005cf2:	e0 68 be ef 	mov	r8,48879
80005cf6:	ea 18 de ad 	orh	r8,0xdead
80005cfa:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005cfc:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005cfe:	fc 18 00 40 	movh	r8,0x40
80005d02:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005d04:	e0 68 00 ff 	mov	r8,255
80005d08:	ea 18 ff 00 	orh	r8,0xff00
80005d0c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005d0e:	e0 68 01 01 	mov	r8,257
80005d12:	ea 18 01 01 	orh	r8,0x101
80005d16:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005d18:	e0 68 02 02 	mov	r8,514
80005d1c:	ea 18 02 02 	orh	r8,0x202
80005d20:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005d22:	e0 68 03 03 	mov	r8,771
80005d26:	ea 18 03 03 	orh	r8,0x303
80005d2a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005d2c:	e0 68 04 04 	mov	r8,1028
80005d30:	ea 18 04 04 	orh	r8,0x404
80005d34:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005d36:	e0 68 05 05 	mov	r8,1285
80005d3a:	ea 18 05 05 	orh	r8,0x505
80005d3e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005d40:	e0 68 06 06 	mov	r8,1542
80005d44:	ea 18 06 06 	orh	r8,0x606
80005d48:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005d4a:	e0 68 07 07 	mov	r8,1799
80005d4e:	ea 18 07 07 	orh	r8,0x707
80005d52:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005d54:	30 08       	mov	r8,0
80005d56:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005d58:	5e fc       	retal	r12
80005d5a:	d7 03       	nop

80005d5c <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005d5c:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005d5e:	48 38       	lddpc	r8,80005d68 <vPortEnterCritical+0xc>
80005d60:	70 09       	ld.w	r9,r8[0x0]
80005d62:	2f f9       	sub	r9,-1
80005d64:	91 09       	st.w	r8[0x0],r9
}
80005d66:	5e fc       	retal	r12
80005d68:	00 00       	add	r0,r0
80005d6a:	00 2c       	rsub	r12,r0

80005d6c <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005d6c:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005d6e:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005d70:	30 0a       	mov	r10,0
80005d72:	14 9b       	mov	r11,r10
80005d74:	49 2c       	lddpc	r12,80005dbc <xPortStartScheduler+0x50>
80005d76:	f0 1f 00 13 	mcall	80005dc0 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);
80005d7a:	e0 68 2e e0 	mov	r8,12000
80005d7e:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005d82:	30 08       	mov	r8,0
80005d84:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005d88:	e0 68 07 68 	mov	r8,1896
80005d8c:	ea 18 00 00 	orh	r8,0x0
80005d90:	70 00       	ld.w	r0,r8[0x0]
80005d92:	60 0d       	ld.w	sp,r0[0x0]
80005d94:	1b 00       	ld.w	r0,sp++
80005d96:	e0 68 00 2c 	mov	r8,44
80005d9a:	ea 18 00 00 	orh	r8,0x0
80005d9e:	91 00       	st.w	r8[0x0],r0
80005da0:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005da4:	2f ed       	sub	sp,-8
80005da6:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005daa:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005dae:	e3 b0 00 00 	mtsr	0x0,r0
80005db2:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005db6:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80005dba:	d8 0a       	popm	pc,r12=0
80005dbc:	80 00       	ld.sh	r0,r0[0x0]
80005dbe:	5e 88       	retls	r8
80005dc0:	80 00       	ld.sh	r0,r0[0x0]
80005dc2:	41 6c       	lddsp	r12,sp[0x58]

80005dc4 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005dc4:	20 6d       	sub	sp,24
80005dc6:	eb cd 00 ff 	pushm	r0-r7
80005dca:	fa c7 ff c0 	sub	r7,sp,-64
80005dce:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005dd2:	ef 40 ff e0 	st.w	r7[-32],r0
80005dd6:	ee f0 ff fc 	ld.w	r0,r7[-4]
80005dda:	ef 40 ff e4 	st.w	r7[-28],r0
80005dde:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005de2:	e0 68 00 2c 	mov	r8,44
80005de6:	ea 18 00 00 	orh	r8,0x0
80005dea:	70 00       	ld.w	r0,r8[0x0]
80005dec:	1a d0       	st.w	--sp,r0
80005dee:	f0 1f 00 1a 	mcall	80005e54 <LABEL_RET_SCALL_260+0x14>
80005df2:	e0 68 07 68 	mov	r8,1896
80005df6:	ea 18 00 00 	orh	r8,0x0
80005dfa:	70 00       	ld.w	r0,r8[0x0]
80005dfc:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005dfe:	f0 1f 00 17 	mcall	80005e58 <LABEL_RET_SCALL_260+0x18>
	portRESTORE_CONTEXT_SCALL();
80005e02:	e0 68 07 68 	mov	r8,1896
80005e06:	ea 18 00 00 	orh	r8,0x0
80005e0a:	70 00       	ld.w	r0,r8[0x0]
80005e0c:	60 0d       	ld.w	sp,r0[0x0]
80005e0e:	1b 00       	ld.w	r0,sp++
80005e10:	e0 68 00 2c 	mov	r8,44
80005e14:	ea 18 00 00 	orh	r8,0x0
80005e18:	91 00       	st.w	r8[0x0],r0
80005e1a:	fa c7 ff d8 	sub	r7,sp,-40
80005e1e:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005e22:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005e26:	e0 61 00 2c 	mov	r1,44
80005e2a:	ea 11 00 00 	orh	r1,0x0
80005e2e:	62 02       	ld.w	r2,r1[0x0]
80005e30:	58 02       	cp.w	r2,0
80005e32:	c0 70       	breq	80005e40 <LABEL_RET_SCALL_260>
80005e34:	e4 c2 00 01 	sub	r2,r2,1
80005e38:	83 02       	st.w	r1[0x0],r2
80005e3a:	58 02       	cp.w	r2,0
80005e3c:	c0 21       	brne	80005e40 <LABEL_RET_SCALL_260>
80005e3e:	b1 c0       	cbr	r0,0x10

80005e40 <LABEL_RET_SCALL_260>:
80005e40:	ef 40 ff f8 	st.w	r7[-8],r0
80005e44:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005e48:	ef 40 ff fc 	st.w	r7[-4],r0
80005e4c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005e50:	2f ad       	sub	sp,-24
80005e52:	d6 13       	rets
80005e54:	80 00       	ld.sh	r0,r0[0x0]
80005e56:	5d 5c       	*unknown*
80005e58:	80 00       	ld.sh	r0,r0[0x0]
80005e5a:	64 78       	ld.w	r8,r2[0x1c]

80005e5c <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005e5c:	e1 b8 00 43 	mfsr	r8,0x10c
80005e60:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005e64:	5e fc       	retal	r12
80005e66:	d7 03       	nop

80005e68 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005e68:	48 78       	lddpc	r8,80005e84 <vPortExitCritical+0x1c>
80005e6a:	70 08       	ld.w	r8,r8[0x0]
80005e6c:	58 08       	cp.w	r8,0
80005e6e:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005e70:	48 58       	lddpc	r8,80005e84 <vPortExitCritical+0x1c>
80005e72:	70 09       	ld.w	r9,r8[0x0]
80005e74:	20 19       	sub	r9,1
80005e76:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005e78:	70 08       	ld.w	r8,r8[0x0]
80005e7a:	58 08       	cp.w	r8,0
80005e7c:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005e7e:	d5 03       	csrf	0x10
80005e80:	5e fc       	retal	r12
80005e82:	00 00       	add	r0,r0
80005e84:	00 00       	add	r0,r0
80005e86:	00 2c       	rsub	r12,r0

80005e88 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005e88:	eb cd 00 ff 	pushm	r0-r7
80005e8c:	e0 68 00 2c 	mov	r8,44
80005e90:	ea 18 00 00 	orh	r8,0x0
80005e94:	70 00       	ld.w	r0,r8[0x0]
80005e96:	1a d0       	st.w	--sp,r0
80005e98:	7a 90       	ld.w	r0,sp[0x24]
80005e9a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005e9e:	58 10       	cp.w	r0,1
80005ea0:	e0 8b 00 08 	brhi	80005eb0 <LABEL_INT_SKIP_SAVE_CONTEXT_234>
80005ea4:	e0 68 07 68 	mov	r8,1896
80005ea8:	ea 18 00 00 	orh	r8,0x0
80005eac:	70 00       	ld.w	r0,r8[0x0]
80005eae:	81 0d       	st.w	r0[0x0],sp

80005eb0 <LABEL_INT_SKIP_SAVE_CONTEXT_234>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005eb0:	f0 1f 00 12 	mcall	80005ef8 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005eb4:	f0 1f 00 12 	mcall	80005efc <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x18>
		vTaskIncrementTick();
80005eb8:	f0 1f 00 12 	mcall	80005f00 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x1c>
	portEXIT_CRITICAL();
80005ebc:	f0 1f 00 12 	mcall	80005f04 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005ec0:	7a 90       	ld.w	r0,sp[0x24]
80005ec2:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005ec6:	58 10       	cp.w	r0,1
80005ec8:	e0 8b 00 0e 	brhi	80005ee4 <LABEL_INT_SKIP_RESTORE_CONTEXT_251>
80005ecc:	f0 1f 00 0c 	mcall	80005efc <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x18>
80005ed0:	f0 1f 00 0e 	mcall	80005f08 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x24>
80005ed4:	f0 1f 00 0c 	mcall	80005f04 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x20>
80005ed8:	e0 68 07 68 	mov	r8,1896
80005edc:	ea 18 00 00 	orh	r8,0x0
80005ee0:	70 00       	ld.w	r0,r8[0x0]
80005ee2:	60 0d       	ld.w	sp,r0[0x0]

80005ee4 <LABEL_INT_SKIP_RESTORE_CONTEXT_251>:
80005ee4:	1b 00       	ld.w	r0,sp++
80005ee6:	e0 68 00 2c 	mov	r8,44
80005eea:	ea 18 00 00 	orh	r8,0x0
80005eee:	91 00       	st.w	r8[0x0],r0
80005ef0:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005ef4:	d6 03       	rete
80005ef6:	00 00       	add	r0,r0
80005ef8:	80 00       	ld.sh	r0,r0[0x0]
80005efa:	5e 5c       	retlt	r12
80005efc:	80 00       	ld.sh	r0,r0[0x0]
80005efe:	5d 5c       	*unknown*
80005f00:	80 00       	ld.sh	r0,r0[0x0]
80005f02:	66 7c       	ld.w	r12,r3[0x1c]
80005f04:	80 00       	ld.sh	r0,r0[0x0]
80005f06:	5e 68       	retmi	r8
80005f08:	80 00       	ld.sh	r0,r0[0x0]
80005f0a:	64 78       	ld.w	r8,r2[0x1c]

80005f0c <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005f0c:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005f0e:	f0 1f 00 02 	mcall	80005f14 <__malloc_lock+0x8>
}
80005f12:	d8 02       	popm	pc
80005f14:	80 00       	ld.sh	r0,r0[0x0]
80005f16:	64 68       	ld.w	r8,r2[0x18]

80005f18 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005f18:	d4 01       	pushm	lr
	xTaskResumeAll();
80005f1a:	f0 1f 00 02 	mcall	80005f20 <__malloc_unlock+0x8>
}
80005f1e:	d8 02       	popm	pc
80005f20:	80 00       	ld.sh	r0,r0[0x0]
80005f22:	68 00       	ld.w	r0,r4[0x0]

80005f24 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005f24:	d4 21       	pushm	r4-r7,lr
80005f26:	16 95       	mov	r5,r11
80005f28:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80005f2a:	58 0c       	cp.w	r12,0
80005f2c:	c0 30       	breq	80005f32 <_read+0xe>
80005f2e:	3f f7       	mov	r7,-1
80005f30:	c1 48       	rjmp	80005f58 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005f32:	58 0a       	cp.w	r10,0
80005f34:	e0 89 00 04 	brgt	80005f3c <_read+0x18>
80005f38:	30 07       	mov	r7,0
80005f3a:	c0 f8       	rjmp	80005f58 <_read+0x34>
80005f3c:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005f3e:	48 84       	lddpc	r4,80005f5c <_read+0x38>
80005f40:	68 0c       	ld.w	r12,r4[0x0]
80005f42:	f0 1f 00 08 	mcall	80005f60 <_read+0x3c>
    if (c < 0)
80005f46:	c0 95       	brlt	80005f58 <_read+0x34>
      break;

    *ptr++ = c;
80005f48:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005f4c:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005f4e:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005f52:	58 08       	cp.w	r8,0
80005f54:	fe 99 ff f6 	brgt	80005f40 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80005f58:	0e 9c       	mov	r12,r7
80005f5a:	d8 22       	popm	r4-r7,pc
80005f5c:	00 00       	add	r0,r0
80005f5e:	10 68       	and	r8,r8
80005f60:	80 00       	ld.sh	r0,r0[0x0]
80005f62:	49 9c       	lddpc	r12,80005fc4 <vPortFree+0x24>

80005f64 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005f64:	d4 21       	pushm	r4-r7,lr
80005f66:	16 95       	mov	r5,r11
80005f68:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80005f6a:	20 1c       	sub	r12,1
80005f6c:	58 2c       	cp.w	r12,2
80005f6e:	e0 8b 00 12 	brhi	80005f92 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005f72:	58 0a       	cp.w	r10,0
80005f74:	c0 31       	brne	80005f7a <_write+0x16>
80005f76:	30 07       	mov	r7,0
80005f78:	c0 e8       	rjmp	80005f94 <_write+0x30>
80005f7a:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005f7c:	48 74       	lddpc	r4,80005f98 <_write+0x34>
80005f7e:	68 0c       	ld.w	r12,r4[0x0]
80005f80:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005f84:	f0 1f 00 06 	mcall	80005f9c <_write+0x38>
80005f88:	c0 55       	brlt	80005f92 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80005f8a:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005f8c:	0e 36       	cp.w	r6,r7
80005f8e:	cf 81       	brne	80005f7e <_write+0x1a>
80005f90:	c0 28       	rjmp	80005f94 <_write+0x30>
80005f92:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005f94:	0e 9c       	mov	r12,r7
80005f96:	d8 22       	popm	r4-r7,pc
80005f98:	00 00       	add	r0,r0
80005f9a:	10 68       	and	r8,r8
80005f9c:	80 00       	ld.sh	r0,r0[0x0]
80005f9e:	49 4c       	lddpc	r12,80005fec <pvPortMalloc+0x24>

80005fa0 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005fa0:	eb cd 40 80 	pushm	r7,lr
80005fa4:	18 97       	mov	r7,r12
	if( pv )
80005fa6:	58 0c       	cp.w	r12,0
80005fa8:	c0 80       	breq	80005fb8 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80005faa:	f0 1f 00 05 	mcall	80005fbc <vPortFree+0x1c>
		{
			free( pv );
80005fae:	0e 9c       	mov	r12,r7
80005fb0:	f0 1f 00 04 	mcall	80005fc0 <vPortFree+0x20>
		}
		xTaskResumeAll();
80005fb4:	f0 1f 00 04 	mcall	80005fc4 <vPortFree+0x24>
80005fb8:	e3 cd 80 80 	ldm	sp++,r7,pc
80005fbc:	80 00       	ld.sh	r0,r0[0x0]
80005fbe:	64 68       	ld.w	r8,r2[0x18]
80005fc0:	80 00       	ld.sh	r0,r0[0x0]
80005fc2:	7c 24       	ld.w	r4,lr[0x8]
80005fc4:	80 00       	ld.sh	r0,r0[0x0]
80005fc6:	68 00       	ld.w	r0,r4[0x0]

80005fc8 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80005fc8:	eb cd 40 80 	pushm	r7,lr
80005fcc:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80005fce:	f0 1f 00 06 	mcall	80005fe4 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80005fd2:	0e 9c       	mov	r12,r7
80005fd4:	f0 1f 00 05 	mcall	80005fe8 <pvPortMalloc+0x20>
80005fd8:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80005fda:	f0 1f 00 05 	mcall	80005fec <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80005fde:	0e 9c       	mov	r12,r7
80005fe0:	e3 cd 80 80 	ldm	sp++,r7,pc
80005fe4:	80 00       	ld.sh	r0,r0[0x0]
80005fe6:	64 68       	ld.w	r8,r2[0x18]
80005fe8:	80 00       	ld.sh	r0,r0[0x0]
80005fea:	7c 34       	ld.w	r4,lr[0xc]
80005fec:	80 00       	ld.sh	r0,r0[0x0]
80005fee:	68 00       	ld.w	r0,r4[0x0]

80005ff0 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005ff0:	d4 01       	pushm	lr
80005ff2:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005ff4:	78 09       	ld.w	r9,r12[0x0]
80005ff6:	58 09       	cp.w	r9,0
80005ff8:	c1 10       	breq	8000601a <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80005ffa:	78 3a       	ld.w	r10,r12[0xc]
80005ffc:	79 09       	ld.w	r9,r12[0x40]
80005ffe:	f4 09 00 09 	add	r9,r10,r9
80006002:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80006004:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80006006:	14 39       	cp.w	r9,r10
80006008:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
8000600c:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80006010:	79 0a       	ld.w	r10,r12[0x40]
80006012:	78 3b       	ld.w	r11,r12[0xc]
80006014:	10 9c       	mov	r12,r8
80006016:	f0 1f 00 02 	mcall	8000601c <prvCopyDataFromQueue+0x2c>
8000601a:	d8 02       	popm	pc
8000601c:	80 00       	ld.sh	r0,r0[0x0]
8000601e:	80 70       	ld.sh	r0,r0[0xe]

80006020 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80006020:	eb cd 40 c0 	pushm	r6-r7,lr
80006024:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80006026:	f0 1f 00 23 	mcall	800060b0 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000602a:	6f 28       	ld.w	r8,r7[0x48]
8000602c:	58 08       	cp.w	r8,0
8000602e:	e0 8a 00 18 	brle	8000605e <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006032:	6e 98       	ld.w	r8,r7[0x24]
80006034:	58 08       	cp.w	r8,0
80006036:	c1 40       	breq	8000605e <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006038:	ee c6 ff dc 	sub	r6,r7,-36
8000603c:	c0 48       	rjmp	80006044 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000603e:	6e 98       	ld.w	r8,r7[0x24]
80006040:	58 08       	cp.w	r8,0
80006042:	c0 e0       	breq	8000605e <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006044:	0c 9c       	mov	r12,r6
80006046:	f0 1f 00 1c 	mcall	800060b4 <prvUnlockQueue+0x94>
8000604a:	c0 30       	breq	80006050 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
8000604c:	f0 1f 00 1b 	mcall	800060b8 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80006050:	6f 28       	ld.w	r8,r7[0x48]
80006052:	20 18       	sub	r8,1
80006054:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80006058:	58 08       	cp.w	r8,0
8000605a:	fe 99 ff f2 	brgt	8000603e <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
8000605e:	3f f8       	mov	r8,-1
80006060:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80006064:	f0 1f 00 16 	mcall	800060bc <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80006068:	f0 1f 00 12 	mcall	800060b0 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000606c:	6f 18       	ld.w	r8,r7[0x44]
8000606e:	58 08       	cp.w	r8,0
80006070:	e0 8a 00 18 	brle	800060a0 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006074:	6e 48       	ld.w	r8,r7[0x10]
80006076:	58 08       	cp.w	r8,0
80006078:	c1 40       	breq	800060a0 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000607a:	ee c6 ff f0 	sub	r6,r7,-16
8000607e:	c0 48       	rjmp	80006086 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006080:	6e 48       	ld.w	r8,r7[0x10]
80006082:	58 08       	cp.w	r8,0
80006084:	c0 e0       	breq	800060a0 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80006086:	0c 9c       	mov	r12,r6
80006088:	f0 1f 00 0b 	mcall	800060b4 <prvUnlockQueue+0x94>
8000608c:	c0 30       	breq	80006092 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
8000608e:	f0 1f 00 0b 	mcall	800060b8 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80006092:	6f 18       	ld.w	r8,r7[0x44]
80006094:	20 18       	sub	r8,1
80006096:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000609a:	58 08       	cp.w	r8,0
8000609c:	fe 99 ff f2 	brgt	80006080 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
800060a0:	3f f8       	mov	r8,-1
800060a2:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
800060a6:	f0 1f 00 06 	mcall	800060bc <prvUnlockQueue+0x9c>
}
800060aa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800060ae:	00 00       	add	r0,r0
800060b0:	80 00       	ld.sh	r0,r0[0x0]
800060b2:	5d 5c       	*unknown*
800060b4:	80 00       	ld.sh	r0,r0[0x0]
800060b6:	66 00       	ld.w	r0,r3[0x0]
800060b8:	80 00       	ld.sh	r0,r0[0x0]
800060ba:	65 0c       	ld.w	r12,r2[0x40]
800060bc:	80 00       	ld.sh	r0,r0[0x0]
800060be:	5e 68       	retmi	r8

800060c0 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
800060c0:	d4 31       	pushm	r0-r7,lr
800060c2:	20 5d       	sub	sp,20
800060c4:	18 97       	mov	r7,r12
800060c6:	50 0b       	stdsp	sp[0x0],r11
800060c8:	50 2a       	stdsp	sp[0x8],r10
800060ca:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800060cc:	f8 c2 ff dc 	sub	r2,r12,-36
800060d0:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800060d2:	fa c4 ff f4 	sub	r4,sp,-12
800060d6:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800060d8:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800060da:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
800060de:	f0 1f 00 3e 	mcall	800061d4 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800060e2:	6e e8       	ld.w	r8,r7[0x38]
800060e4:	58 08       	cp.w	r8,0
800060e6:	c2 a0       	breq	8000613a <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
800060e8:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
800060ea:	40 0b       	lddsp	r11,sp[0x0]
800060ec:	0e 9c       	mov	r12,r7
800060ee:	f0 1f 00 3b 	mcall	800061d8 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
800060f2:	40 18       	lddsp	r8,sp[0x4]
800060f4:	58 08       	cp.w	r8,0
800060f6:	c1 51       	brne	80006120 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
800060f8:	6e e8       	ld.w	r8,r7[0x38]
800060fa:	20 18       	sub	r8,1
800060fc:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800060fe:	6e 08       	ld.w	r8,r7[0x0]
80006100:	58 08       	cp.w	r8,0
80006102:	c0 41       	brne	8000610a <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80006104:	f0 1f 00 36 	mcall	800061dc <xQueueGenericReceive+0x11c>
80006108:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000610a:	6e 48       	ld.w	r8,r7[0x10]
8000610c:	58 08       	cp.w	r8,0
8000610e:	c1 20       	breq	80006132 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80006110:	ee cc ff f0 	sub	r12,r7,-16
80006114:	f0 1f 00 33 	mcall	800061e0 <xQueueGenericReceive+0x120>
80006118:	58 1c       	cp.w	r12,1
8000611a:	c0 c1       	brne	80006132 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
8000611c:	d7 33       	scall
8000611e:	c0 a8       	rjmp	80006132 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80006120:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006122:	6e 98       	ld.w	r8,r7[0x24]
80006124:	58 08       	cp.w	r8,0
80006126:	c0 60       	breq	80006132 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006128:	04 9c       	mov	r12,r2
8000612a:	f0 1f 00 2e 	mcall	800061e0 <xQueueGenericReceive+0x120>
8000612e:	c0 20       	breq	80006132 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80006130:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80006132:	f0 1f 00 2d 	mcall	800061e4 <xQueueGenericReceive+0x124>
80006136:	30 1c       	mov	r12,1
				return pdPASS;
80006138:	c4 c8       	rjmp	800061d0 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000613a:	40 28       	lddsp	r8,sp[0x8]
8000613c:	58 08       	cp.w	r8,0
8000613e:	c0 51       	brne	80006148 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80006140:	f0 1f 00 29 	mcall	800061e4 <xQueueGenericReceive+0x124>
80006144:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80006146:	c4 58       	rjmp	800061d0 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80006148:	58 05       	cp.w	r5,0
8000614a:	c0 51       	brne	80006154 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000614c:	08 9c       	mov	r12,r4
8000614e:	f0 1f 00 27 	mcall	800061e8 <xQueueGenericReceive+0x128>
80006152:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006154:	f0 1f 00 24 	mcall	800061e4 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80006158:	f0 1f 00 25 	mcall	800061ec <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
8000615c:	f0 1f 00 1e 	mcall	800061d4 <xQueueGenericReceive+0x114>
80006160:	6f 18       	ld.w	r8,r7[0x44]
80006162:	5b f8       	cp.w	r8,-1
80006164:	ef f1 0a 11 	st.weq	r7[0x44],r1
80006168:	6f 28       	ld.w	r8,r7[0x48]
8000616a:	5b f8       	cp.w	r8,-1
8000616c:	ef f1 0a 12 	st.weq	r7[0x48],r1
80006170:	f0 1f 00 1d 	mcall	800061e4 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006174:	06 9b       	mov	r11,r3
80006176:	08 9c       	mov	r12,r4
80006178:	f0 1f 00 1e 	mcall	800061f0 <xQueueGenericReceive+0x130>
8000617c:	c2 41       	brne	800061c4 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000617e:	f0 1f 00 16 	mcall	800061d4 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80006182:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80006184:	f0 1f 00 18 	mcall	800061e4 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80006188:	58 06       	cp.w	r6,0
8000618a:	c1 71       	brne	800061b8 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000618c:	6e 08       	ld.w	r8,r7[0x0]
8000618e:	58 08       	cp.w	r8,0
80006190:	c0 81       	brne	800061a0 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80006192:	f0 1f 00 11 	mcall	800061d4 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80006196:	6e 1c       	ld.w	r12,r7[0x4]
80006198:	f0 1f 00 17 	mcall	800061f4 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
8000619c:	f0 1f 00 12 	mcall	800061e4 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800061a0:	40 2b       	lddsp	r11,sp[0x8]
800061a2:	04 9c       	mov	r12,r2
800061a4:	f0 1f 00 15 	mcall	800061f8 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
800061a8:	0e 9c       	mov	r12,r7
800061aa:	f0 1f 00 15 	mcall	800061fc <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
800061ae:	f0 1f 00 15 	mcall	80006200 <xQueueGenericReceive+0x140>
800061b2:	c9 61       	brne	800060de <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
800061b4:	d7 33       	scall
800061b6:	c9 4b       	rjmp	800060de <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800061b8:	0e 9c       	mov	r12,r7
800061ba:	f0 1f 00 11 	mcall	800061fc <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
800061be:	f0 1f 00 11 	mcall	80006200 <xQueueGenericReceive+0x140>
800061c2:	c8 eb       	rjmp	800060de <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
800061c4:	0e 9c       	mov	r12,r7
800061c6:	f0 1f 00 0e 	mcall	800061fc <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
800061ca:	f0 1f 00 0e 	mcall	80006200 <xQueueGenericReceive+0x140>
800061ce:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
800061d0:	2f bd       	sub	sp,-20
800061d2:	d8 32       	popm	r0-r7,pc
800061d4:	80 00       	ld.sh	r0,r0[0x0]
800061d6:	5d 5c       	*unknown*
800061d8:	80 00       	ld.sh	r0,r0[0x0]
800061da:	5f f0       	sral	r0
800061dc:	80 00       	ld.sh	r0,r0[0x0]
800061de:	65 18       	ld.w	r8,r2[0x44]
800061e0:	80 00       	ld.sh	r0,r0[0x0]
800061e2:	66 00       	ld.w	r0,r3[0x0]
800061e4:	80 00       	ld.sh	r0,r0[0x0]
800061e6:	5e 68       	retmi	r8
800061e8:	80 00       	ld.sh	r0,r0[0x0]
800061ea:	64 f4       	ld.w	r4,r2[0x3c]
800061ec:	80 00       	ld.sh	r0,r0[0x0]
800061ee:	64 68       	ld.w	r8,r2[0x18]
800061f0:	80 00       	ld.sh	r0,r0[0x0]
800061f2:	67 90       	ld.w	r0,r3[0x64]
800061f4:	80 00       	ld.sh	r0,r0[0x0]
800061f6:	65 7c       	ld.w	r12,r2[0x5c]
800061f8:	80 00       	ld.sh	r0,r0[0x0]
800061fa:	6a a4       	ld.w	r4,r5[0x28]
800061fc:	80 00       	ld.sh	r0,r0[0x0]
800061fe:	60 20       	ld.w	r0,r0[0x8]
80006200:	80 00       	ld.sh	r0,r0[0x0]
80006202:	68 00       	ld.w	r0,r4[0x0]

80006204 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80006204:	eb cd 40 80 	pushm	r7,lr
80006208:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
8000620a:	79 08       	ld.w	r8,r12[0x40]
8000620c:	58 08       	cp.w	r8,0
8000620e:	c0 a1       	brne	80006222 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006210:	78 08       	ld.w	r8,r12[0x0]
80006212:	58 08       	cp.w	r8,0
80006214:	c2 b1       	brne	8000626a <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80006216:	78 1c       	ld.w	r12,r12[0x4]
80006218:	f0 1f 00 17 	mcall	80006274 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
8000621c:	30 08       	mov	r8,0
8000621e:	8f 18       	st.w	r7[0x4],r8
80006220:	c2 58       	rjmp	8000626a <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80006222:	58 0a       	cp.w	r10,0
80006224:	c1 01       	brne	80006244 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80006226:	10 9a       	mov	r10,r8
80006228:	78 2c       	ld.w	r12,r12[0x8]
8000622a:	f0 1f 00 14 	mcall	80006278 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
8000622e:	6e 29       	ld.w	r9,r7[0x8]
80006230:	6f 08       	ld.w	r8,r7[0x40]
80006232:	f2 08 00 08 	add	r8,r9,r8
80006236:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80006238:	6e 19       	ld.w	r9,r7[0x4]
8000623a:	12 38       	cp.w	r8,r9
8000623c:	c1 73       	brcs	8000626a <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
8000623e:	6e 08       	ld.w	r8,r7[0x0]
80006240:	8f 28       	st.w	r7[0x8],r8
80006242:	c1 48       	rjmp	8000626a <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80006244:	10 9a       	mov	r10,r8
80006246:	78 3c       	ld.w	r12,r12[0xc]
80006248:	f0 1f 00 0c 	mcall	80006278 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
8000624c:	6f 08       	ld.w	r8,r7[0x40]
8000624e:	6e 39       	ld.w	r9,r7[0xc]
80006250:	f2 08 01 08 	sub	r8,r9,r8
80006254:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80006256:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80006258:	12 38       	cp.w	r8,r9
8000625a:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
8000625e:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80006262:	f3 d8 e3 19 	subcs	r9,r9,r8
80006266:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
8000626a:	6e e8       	ld.w	r8,r7[0x38]
8000626c:	2f f8       	sub	r8,-1
8000626e:	8f e8       	st.w	r7[0x38],r8
}
80006270:	e3 cd 80 80 	ldm	sp++,r7,pc
80006274:	80 00       	ld.sh	r0,r0[0x0]
80006276:	65 24       	ld.w	r4,r2[0x48]
80006278:	80 00       	ld.sh	r0,r0[0x0]
8000627a:	80 70       	ld.sh	r0,r0[0xe]

8000627c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
8000627c:	d4 31       	pushm	r0-r7,lr
8000627e:	20 5d       	sub	sp,20
80006280:	18 97       	mov	r7,r12
80006282:	50 0b       	stdsp	sp[0x0],r11
80006284:	50 2a       	stdsp	sp[0x8],r10
80006286:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80006288:	f8 c0 ff f0 	sub	r0,r12,-16
8000628c:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000628e:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80006292:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006294:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80006298:	f0 1f 00 2f 	mcall	80006354 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
8000629c:	6e e9       	ld.w	r9,r7[0x38]
8000629e:	6e f8       	ld.w	r8,r7[0x3c]
800062a0:	10 39       	cp.w	r9,r8
800062a2:	c1 42       	brcc	800062ca <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800062a4:	40 1a       	lddsp	r10,sp[0x4]
800062a6:	40 0b       	lddsp	r11,sp[0x0]
800062a8:	0e 9c       	mov	r12,r7
800062aa:	f0 1f 00 2c 	mcall	80006358 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800062ae:	6e 98       	ld.w	r8,r7[0x24]
800062b0:	58 08       	cp.w	r8,0
800062b2:	c0 80       	breq	800062c2 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
800062b4:	ee cc ff dc 	sub	r12,r7,-36
800062b8:	f0 1f 00 29 	mcall	8000635c <xQueueGenericSend+0xe0>
800062bc:	58 1c       	cp.w	r12,1
800062be:	c0 21       	brne	800062c2 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
800062c0:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
800062c2:	f0 1f 00 28 	mcall	80006360 <xQueueGenericSend+0xe4>
800062c6:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
800062c8:	c4 38       	rjmp	8000634e <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800062ca:	40 28       	lddsp	r8,sp[0x8]
800062cc:	58 08       	cp.w	r8,0
800062ce:	c0 51       	brne	800062d8 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800062d0:	f0 1f 00 24 	mcall	80006360 <xQueueGenericSend+0xe4>
800062d4:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
800062d6:	c3 c8       	rjmp	8000634e <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
800062d8:	58 04       	cp.w	r4,0
800062da:	c0 51       	brne	800062e4 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800062dc:	06 9c       	mov	r12,r3
800062de:	f0 1f 00 22 	mcall	80006364 <xQueueGenericSend+0xe8>
800062e2:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800062e4:	f0 1f 00 1f 	mcall	80006360 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800062e8:	f0 1f 00 20 	mcall	80006368 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
800062ec:	f0 1f 00 1a 	mcall	80006354 <xQueueGenericSend+0xd8>
800062f0:	6f 18       	ld.w	r8,r7[0x44]
800062f2:	5b f8       	cp.w	r8,-1
800062f4:	ef f1 0a 11 	st.weq	r7[0x44],r1
800062f8:	6f 28       	ld.w	r8,r7[0x48]
800062fa:	5b f8       	cp.w	r8,-1
800062fc:	ef f1 0a 12 	st.weq	r7[0x48],r1
80006300:	f0 1f 00 18 	mcall	80006360 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006304:	04 9b       	mov	r11,r2
80006306:	06 9c       	mov	r12,r3
80006308:	f0 1f 00 19 	mcall	8000636c <xQueueGenericSend+0xf0>
8000630c:	c1 b1       	brne	80006342 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000630e:	f0 1f 00 12 	mcall	80006354 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80006312:	6e e5       	ld.w	r5,r7[0x38]
80006314:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80006316:	f0 1f 00 13 	mcall	80006360 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
8000631a:	0c 35       	cp.w	r5,r6
8000631c:	c0 d1       	brne	80006336 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000631e:	40 2b       	lddsp	r11,sp[0x8]
80006320:	00 9c       	mov	r12,r0
80006322:	f0 1f 00 14 	mcall	80006370 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80006326:	0e 9c       	mov	r12,r7
80006328:	f0 1f 00 13 	mcall	80006374 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
8000632c:	f0 1f 00 13 	mcall	80006378 <xQueueGenericSend+0xfc>
80006330:	cb 41       	brne	80006298 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80006332:	d7 33       	scall
80006334:	cb 2b       	rjmp	80006298 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80006336:	0e 9c       	mov	r12,r7
80006338:	f0 1f 00 0f 	mcall	80006374 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
8000633c:	f0 1f 00 0f 	mcall	80006378 <xQueueGenericSend+0xfc>
80006340:	ca cb       	rjmp	80006298 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80006342:	0e 9c       	mov	r12,r7
80006344:	f0 1f 00 0c 	mcall	80006374 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80006348:	f0 1f 00 0c 	mcall	80006378 <xQueueGenericSend+0xfc>
8000634c:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
8000634e:	2f bd       	sub	sp,-20
80006350:	d8 32       	popm	r0-r7,pc
80006352:	00 00       	add	r0,r0
80006354:	80 00       	ld.sh	r0,r0[0x0]
80006356:	5d 5c       	*unknown*
80006358:	80 00       	ld.sh	r0,r0[0x0]
8000635a:	62 04       	ld.w	r4,r1[0x0]
8000635c:	80 00       	ld.sh	r0,r0[0x0]
8000635e:	66 00       	ld.w	r0,r3[0x0]
80006360:	80 00       	ld.sh	r0,r0[0x0]
80006362:	5e 68       	retmi	r8
80006364:	80 00       	ld.sh	r0,r0[0x0]
80006366:	64 f4       	ld.w	r4,r2[0x3c]
80006368:	80 00       	ld.sh	r0,r0[0x0]
8000636a:	64 68       	ld.w	r8,r2[0x18]
8000636c:	80 00       	ld.sh	r0,r0[0x0]
8000636e:	67 90       	ld.w	r0,r3[0x64]
80006370:	80 00       	ld.sh	r0,r0[0x0]
80006372:	6a a4       	ld.w	r4,r5[0x28]
80006374:	80 00       	ld.sh	r0,r0[0x0]
80006376:	60 20       	ld.w	r0,r0[0x8]
80006378:	80 00       	ld.sh	r0,r0[0x0]
8000637a:	68 00       	ld.w	r0,r4[0x0]

8000637c <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
8000637c:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80006380:	34 cc       	mov	r12,76
80006382:	f0 1f 00 12 	mcall	800063c8 <xQueueCreateMutex+0x4c>
80006386:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
80006388:	c1 d0       	breq	800063c2 <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
8000638a:	30 06       	mov	r6,0
8000638c:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
8000638e:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
80006390:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
80006392:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80006394:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
80006396:	30 18       	mov	r8,1
80006398:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
8000639a:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
8000639e:	3f f8       	mov	r8,-1
800063a0:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
800063a4:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800063a8:	2f 0c       	sub	r12,-16
800063aa:	f0 1f 00 09 	mcall	800063cc <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800063ae:	ee cc ff dc 	sub	r12,r7,-36
800063b2:	f0 1f 00 07 	mcall	800063cc <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
800063b6:	0c 99       	mov	r9,r6
800063b8:	0c 9a       	mov	r10,r6
800063ba:	0c 9b       	mov	r11,r6
800063bc:	0e 9c       	mov	r12,r7
800063be:	f0 1f 00 05 	mcall	800063d0 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
800063c2:	0e 9c       	mov	r12,r7
800063c4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800063c8:	80 00       	ld.sh	r0,r0[0x0]
800063ca:	5f c8       	srvs	r8
800063cc:	80 00       	ld.sh	r0,r0[0x0]
800063ce:	5c 38       	neg	r8
800063d0:	80 00       	ld.sh	r0,r0[0x0]
800063d2:	62 7c       	ld.w	r12,r1[0x1c]

800063d4 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
800063d4:	d4 21       	pushm	r4-r7,lr
800063d6:	18 97       	mov	r7,r12
800063d8:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
800063da:	58 0c       	cp.w	r12,0
800063dc:	c2 f0       	breq	8000643a <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800063de:	34 cc       	mov	r12,76
800063e0:	f0 1f 00 17 	mcall	8000643c <xQueueCreate+0x68>
800063e4:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
800063e6:	c2 a0       	breq	8000643a <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
800063e8:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
800063ec:	e8 cc ff ff 	sub	r12,r4,-1
800063f0:	f0 1f 00 13 	mcall	8000643c <xQueueCreate+0x68>
800063f4:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
800063f6:	c1 e0       	breq	80006432 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
800063f8:	f8 04 00 04 	add	r4,r12,r4
800063fc:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800063fe:	30 08       	mov	r8,0
80006400:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80006402:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80006404:	ee c8 00 01 	sub	r8,r7,1
80006408:	ad 38       	mul	r8,r6
8000640a:	10 0c       	add	r12,r8
8000640c:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
8000640e:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80006410:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80006414:	3f f8       	mov	r8,-1
80006416:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
8000641a:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
8000641e:	ea cc ff f0 	sub	r12,r5,-16
80006422:	f0 1f 00 08 	mcall	80006440 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80006426:	ea cc ff dc 	sub	r12,r5,-36
8000642a:	f0 1f 00 06 	mcall	80006440 <xQueueCreate+0x6c>
8000642e:	0a 9c       	mov	r12,r5
80006430:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80006432:	0a 9c       	mov	r12,r5
80006434:	f0 1f 00 04 	mcall	80006444 <xQueueCreate+0x70>
80006438:	d8 2a       	popm	r4-r7,pc,r12=0
8000643a:	d8 2a       	popm	r4-r7,pc,r12=0
8000643c:	80 00       	ld.sh	r0,r0[0x0]
8000643e:	5f c8       	srvs	r8
80006440:	80 00       	ld.sh	r0,r0[0x0]
80006442:	5c 38       	neg	r8
80006444:	80 00       	ld.sh	r0,r0[0x0]
80006446:	5f a0       	srle	r0

80006448 <xTaskIsTaskSuspended>:
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
80006448:	78 59       	ld.w	r9,r12[0x14]
8000644a:	48 68       	lddpc	r8,80006460 <xTaskIsTaskSuspended+0x18>
8000644c:	10 39       	cp.w	r9,r8
8000644e:	c0 81       	brne	8000645e <xTaskIsTaskSuspended+0x16>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
80006450:	78 a8       	ld.w	r8,r12[0x28]
80006452:	48 59       	lddpc	r9,80006464 <xTaskIsTaskSuspended+0x1c>
80006454:	12 38       	cp.w	r8,r9
80006456:	c0 40       	breq	8000645e <xTaskIsTaskSuspended+0x16>
80006458:	58 08       	cp.w	r8,0
8000645a:	5f 0c       	sreq	r12
8000645c:	5e fc       	retal	r12
8000645e:	5e fd       	retal	0
80006460:	00 00       	add	r0,r0
80006462:	07 bc       	ld.ub	r12,r3[0x3]
80006464:	00 00       	add	r0,r0
80006466:	07 6c       	ld.uh	r12,--r3

80006468 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80006468:	48 38       	lddpc	r8,80006474 <vTaskSuspendAll+0xc>
8000646a:	70 09       	ld.w	r9,r8[0x0]
8000646c:	2f f9       	sub	r9,-1
8000646e:	91 09       	st.w	r8[0x0],r9
}
80006470:	5e fc       	retal	r12
80006472:	00 00       	add	r0,r0
80006474:	00 00       	add	r0,r0
80006476:	07 98       	ld.ub	r8,r3[0x1]

80006478 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80006478:	49 a8       	lddpc	r8,800064e0 <vTaskSwitchContext+0x68>
8000647a:	70 08       	ld.w	r8,r8[0x0]
8000647c:	58 08       	cp.w	r8,0
8000647e:	c0 b1       	brne	80006494 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006480:	49 98       	lddpc	r8,800064e4 <vTaskSwitchContext+0x6c>
80006482:	70 08       	ld.w	r8,r8[0x0]
80006484:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006488:	49 89       	lddpc	r9,800064e8 <vTaskSwitchContext+0x70>
8000648a:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
8000648e:	58 08       	cp.w	r8,0
80006490:	c0 60       	breq	8000649c <vTaskSwitchContext+0x24>
80006492:	c1 18       	rjmp	800064b4 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80006494:	30 19       	mov	r9,1
80006496:	49 68       	lddpc	r8,800064ec <vTaskSwitchContext+0x74>
80006498:	91 09       	st.w	r8[0x0],r9
8000649a:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
8000649c:	49 28       	lddpc	r8,800064e4 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000649e:	49 3a       	lddpc	r10,800064e8 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800064a0:	70 09       	ld.w	r9,r8[0x0]
800064a2:	20 19       	sub	r9,1
800064a4:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800064a6:	70 09       	ld.w	r9,r8[0x0]
800064a8:	f2 09 00 29 	add	r9,r9,r9<<0x2
800064ac:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800064b0:	58 09       	cp.w	r9,0
800064b2:	cf 70       	breq	800064a0 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800064b4:	48 c8       	lddpc	r8,800064e4 <vTaskSwitchContext+0x6c>
800064b6:	70 08       	ld.w	r8,r8[0x0]
800064b8:	f0 08 00 28 	add	r8,r8,r8<<0x2
800064bc:	48 b9       	lddpc	r9,800064e8 <vTaskSwitchContext+0x70>
800064be:	f2 08 00 28 	add	r8,r9,r8<<0x2
800064c2:	70 19       	ld.w	r9,r8[0x4]
800064c4:	72 19       	ld.w	r9,r9[0x4]
800064c6:	91 19       	st.w	r8[0x4],r9
800064c8:	f0 ca ff f8 	sub	r10,r8,-8
800064cc:	14 39       	cp.w	r9,r10
800064ce:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
800064d2:	f1 f9 0a 01 	st.weq	r8[0x4],r9
800064d6:	70 18       	ld.w	r8,r8[0x4]
800064d8:	70 39       	ld.w	r9,r8[0xc]
800064da:	48 68       	lddpc	r8,800064f0 <vTaskSwitchContext+0x78>
800064dc:	91 09       	st.w	r8[0x0],r9
800064de:	5e fc       	retal	r12
800064e0:	00 00       	add	r0,r0
800064e2:	07 98       	ld.ub	r8,r3[0x1]
800064e4:	00 00       	add	r0,r0
800064e6:	07 d0       	ld.ub	r0,r3[0x5]
800064e8:	00 00       	add	r0,r0
800064ea:	06 b4       	st.h	r3++,r4
800064ec:	00 00       	add	r0,r0
800064ee:	07 b8       	ld.ub	r8,r3[0x3]
800064f0:	00 00       	add	r0,r0
800064f2:	07 68       	ld.uh	r8,--r3

800064f4 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
800064f4:	48 48       	lddpc	r8,80006504 <vTaskSetTimeOutState+0x10>
800064f6:	70 08       	ld.w	r8,r8[0x0]
800064f8:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
800064fa:	48 48       	lddpc	r8,80006508 <vTaskSetTimeOutState+0x14>
800064fc:	70 08       	ld.w	r8,r8[0x0]
800064fe:	99 18       	st.w	r12[0x4],r8
}
80006500:	5e fc       	retal	r12
80006502:	00 00       	add	r0,r0
80006504:	00 00       	add	r0,r0
80006506:	06 ac       	st.w	r3++,r12
80006508:	00 00       	add	r0,r0
8000650a:	07 94       	ld.ub	r4,r3[0x1]

8000650c <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
8000650c:	30 19       	mov	r9,1
8000650e:	48 28       	lddpc	r8,80006514 <vTaskMissedYield+0x8>
80006510:	91 09       	st.w	r8[0x0],r9
}
80006512:	5e fc       	retal	r12
80006514:	00 00       	add	r0,r0
80006516:	07 b8       	ld.ub	r8,r3[0x3]

80006518 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80006518:	48 28       	lddpc	r8,80006520 <xTaskGetCurrentTaskHandle+0x8>
8000651a:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
8000651c:	5e fc       	retal	r12
8000651e:	00 00       	add	r0,r0
80006520:	00 00       	add	r0,r0
80006522:	07 68       	ld.uh	r8,--r3

80006524 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80006524:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80006528:	58 0c       	cp.w	r12,0
8000652a:	c1 f0       	breq	80006568 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
8000652c:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
8000652e:	78 b9       	ld.w	r9,r12[0x2c]
80006530:	79 18       	ld.w	r8,r12[0x44]
80006532:	10 39       	cp.w	r9,r8
80006534:	c1 a0       	breq	80006568 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80006536:	f8 c6 ff fc 	sub	r6,r12,-4
8000653a:	0c 9c       	mov	r12,r6
8000653c:	f0 1f 00 0c 	mcall	8000656c <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80006540:	6f 1c       	ld.w	r12,r7[0x44]
80006542:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80006544:	f8 08 11 08 	rsub	r8,r12,8
80006548:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
8000654a:	48 a8       	lddpc	r8,80006570 <vTaskPriorityDisinherit+0x4c>
8000654c:	70 08       	ld.w	r8,r8[0x0]
8000654e:	10 3c       	cp.w	r12,r8
80006550:	e0 88 00 04 	brls	80006558 <vTaskPriorityDisinherit+0x34>
80006554:	48 78       	lddpc	r8,80006570 <vTaskPriorityDisinherit+0x4c>
80006556:	91 0c       	st.w	r8[0x0],r12
80006558:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000655c:	0c 9b       	mov	r11,r6
8000655e:	48 68       	lddpc	r8,80006574 <vTaskPriorityDisinherit+0x50>
80006560:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006564:	f0 1f 00 05 	mcall	80006578 <vTaskPriorityDisinherit+0x54>
80006568:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000656c:	80 00       	ld.sh	r0,r0[0x0]
8000656e:	5c a2       	swap.h	r2
80006570:	00 00       	add	r0,r0
80006572:	07 d0       	ld.ub	r0,r3[0x5]
80006574:	00 00       	add	r0,r0
80006576:	06 b4       	st.h	r3++,r4
80006578:	80 00       	ld.sh	r0,r0[0x0]
8000657a:	5c 52       	castu.b	r2

8000657c <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
8000657c:	eb cd 40 c0 	pushm	r6-r7,lr
80006580:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80006582:	49 b8       	lddpc	r8,800065ec <vTaskPriorityInherit+0x70>
80006584:	70 08       	ld.w	r8,r8[0x0]
80006586:	78 b9       	ld.w	r9,r12[0x2c]
80006588:	70 b8       	ld.w	r8,r8[0x2c]
8000658a:	10 39       	cp.w	r9,r8
8000658c:	c2 d2       	brcc	800065e6 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
8000658e:	49 88       	lddpc	r8,800065ec <vTaskPriorityInherit+0x70>
80006590:	70 08       	ld.w	r8,r8[0x0]
80006592:	70 b8       	ld.w	r8,r8[0x2c]
80006594:	f0 08 11 08 	rsub	r8,r8,8
80006598:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
8000659a:	f2 09 00 28 	add	r8,r9,r9<<0x2
8000659e:	49 59       	lddpc	r9,800065f0 <vTaskPriorityInherit+0x74>
800065a0:	f2 08 00 28 	add	r8,r9,r8<<0x2
800065a4:	78 59       	ld.w	r9,r12[0x14]
800065a6:	10 39       	cp.w	r9,r8
800065a8:	c1 b1       	brne	800065de <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
800065aa:	f8 c6 ff fc 	sub	r6,r12,-4
800065ae:	0c 9c       	mov	r12,r6
800065b0:	f0 1f 00 11 	mcall	800065f4 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800065b4:	48 e8       	lddpc	r8,800065ec <vTaskPriorityInherit+0x70>
800065b6:	70 08       	ld.w	r8,r8[0x0]
800065b8:	70 bc       	ld.w	r12,r8[0x2c]
800065ba:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800065bc:	48 f8       	lddpc	r8,800065f8 <vTaskPriorityInherit+0x7c>
800065be:	70 08       	ld.w	r8,r8[0x0]
800065c0:	10 3c       	cp.w	r12,r8
800065c2:	e0 88 00 04 	brls	800065ca <vTaskPriorityInherit+0x4e>
800065c6:	48 d8       	lddpc	r8,800065f8 <vTaskPriorityInherit+0x7c>
800065c8:	91 0c       	st.w	r8[0x0],r12
800065ca:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800065ce:	0c 9b       	mov	r11,r6
800065d0:	48 88       	lddpc	r8,800065f0 <vTaskPriorityInherit+0x74>
800065d2:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800065d6:	f0 1f 00 0a 	mcall	800065fc <vTaskPriorityInherit+0x80>
800065da:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800065de:	48 48       	lddpc	r8,800065ec <vTaskPriorityInherit+0x70>
800065e0:	70 08       	ld.w	r8,r8[0x0]
800065e2:	70 b8       	ld.w	r8,r8[0x2c]
800065e4:	99 b8       	st.w	r12[0x2c],r8
800065e6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800065ea:	00 00       	add	r0,r0
800065ec:	00 00       	add	r0,r0
800065ee:	07 68       	ld.uh	r8,--r3
800065f0:	00 00       	add	r0,r0
800065f2:	06 b4       	st.h	r3++,r4
800065f4:	80 00       	ld.sh	r0,r0[0x0]
800065f6:	5c a2       	swap.h	r2
800065f8:	00 00       	add	r0,r0
800065fa:	07 d0       	ld.ub	r0,r3[0x5]
800065fc:	80 00       	ld.sh	r0,r0[0x0]
800065fe:	5c 52       	castu.b	r2

80006600 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80006600:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80006604:	78 38       	ld.w	r8,r12[0xc]
80006606:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80006608:	ee c6 ff e8 	sub	r6,r7,-24
8000660c:	0c 9c       	mov	r12,r6
8000660e:	f0 1f 00 15 	mcall	80006660 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006612:	49 58       	lddpc	r8,80006664 <xTaskRemoveFromEventList+0x64>
80006614:	70 08       	ld.w	r8,r8[0x0]
80006616:	58 08       	cp.w	r8,0
80006618:	c1 71       	brne	80006646 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
8000661a:	ee c6 ff fc 	sub	r6,r7,-4
8000661e:	0c 9c       	mov	r12,r6
80006620:	f0 1f 00 10 	mcall	80006660 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80006624:	6e bc       	ld.w	r12,r7[0x2c]
80006626:	49 18       	lddpc	r8,80006668 <xTaskRemoveFromEventList+0x68>
80006628:	70 08       	ld.w	r8,r8[0x0]
8000662a:	10 3c       	cp.w	r12,r8
8000662c:	e0 88 00 04 	brls	80006634 <xTaskRemoveFromEventList+0x34>
80006630:	48 e8       	lddpc	r8,80006668 <xTaskRemoveFromEventList+0x68>
80006632:	91 0c       	st.w	r8[0x0],r12
80006634:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006638:	0c 9b       	mov	r11,r6
8000663a:	48 d8       	lddpc	r8,8000666c <xTaskRemoveFromEventList+0x6c>
8000663c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006640:	f0 1f 00 0c 	mcall	80006670 <xTaskRemoveFromEventList+0x70>
80006644:	c0 58       	rjmp	8000664e <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80006646:	0c 9b       	mov	r11,r6
80006648:	48 bc       	lddpc	r12,80006674 <xTaskRemoveFromEventList+0x74>
8000664a:	f0 1f 00 0a 	mcall	80006670 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000664e:	48 b8       	lddpc	r8,80006678 <xTaskRemoveFromEventList+0x78>
80006650:	70 08       	ld.w	r8,r8[0x0]
80006652:	6e b9       	ld.w	r9,r7[0x2c]
80006654:	70 b8       	ld.w	r8,r8[0x2c]
80006656:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80006658:	5f 2c       	srhs	r12
8000665a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000665e:	00 00       	add	r0,r0
80006660:	80 00       	ld.sh	r0,r0[0x0]
80006662:	5c a2       	swap.h	r2
80006664:	00 00       	add	r0,r0
80006666:	07 98       	ld.ub	r8,r3[0x1]
80006668:	00 00       	add	r0,r0
8000666a:	07 d0       	ld.ub	r0,r3[0x5]
8000666c:	00 00       	add	r0,r0
8000666e:	06 b4       	st.h	r3++,r4
80006670:	80 00       	ld.sh	r0,r0[0x0]
80006672:	5c 52       	castu.b	r2
80006674:	00 00       	add	r0,r0
80006676:	07 6c       	ld.uh	r12,--r3
80006678:	00 00       	add	r0,r0
8000667a:	07 68       	ld.uh	r8,--r3

8000667c <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
8000667c:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006680:	4b 98       	lddpc	r8,80006764 <vTaskIncrementTick+0xe8>
80006682:	70 08       	ld.w	r8,r8[0x0]
80006684:	58 08       	cp.w	r8,0
80006686:	c6 91       	brne	80006758 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80006688:	4b 88       	lddpc	r8,80006768 <vTaskIncrementTick+0xec>
8000668a:	70 09       	ld.w	r9,r8[0x0]
8000668c:	2f f9       	sub	r9,-1
8000668e:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80006690:	70 08       	ld.w	r8,r8[0x0]
80006692:	58 08       	cp.w	r8,0
80006694:	c1 a1       	brne	800066c8 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80006696:	4b 68       	lddpc	r8,8000676c <vTaskIncrementTick+0xf0>
80006698:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
8000669a:	4b 69       	lddpc	r9,80006770 <vTaskIncrementTick+0xf4>
8000669c:	72 0b       	ld.w	r11,r9[0x0]
8000669e:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800066a0:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800066a2:	4b 59       	lddpc	r9,80006774 <vTaskIncrementTick+0xf8>
800066a4:	72 0a       	ld.w	r10,r9[0x0]
800066a6:	2f fa       	sub	r10,-1
800066a8:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800066aa:	70 08       	ld.w	r8,r8[0x0]
800066ac:	70 08       	ld.w	r8,r8[0x0]
800066ae:	58 08       	cp.w	r8,0
800066b0:	c0 51       	brne	800066ba <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800066b2:	3f f9       	mov	r9,-1
800066b4:	4b 18       	lddpc	r8,80006778 <vTaskIncrementTick+0xfc>
800066b6:	91 09       	st.w	r8[0x0],r9
800066b8:	c0 88       	rjmp	800066c8 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800066ba:	4a d8       	lddpc	r8,8000676c <vTaskIncrementTick+0xf0>
800066bc:	70 08       	ld.w	r8,r8[0x0]
800066be:	70 38       	ld.w	r8,r8[0xc]
800066c0:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800066c2:	70 19       	ld.w	r9,r8[0x4]
800066c4:	4a d8       	lddpc	r8,80006778 <vTaskIncrementTick+0xfc>
800066c6:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800066c8:	4a 88       	lddpc	r8,80006768 <vTaskIncrementTick+0xec>
800066ca:	70 09       	ld.w	r9,r8[0x0]
800066cc:	4a b8       	lddpc	r8,80006778 <vTaskIncrementTick+0xfc>
800066ce:	70 08       	ld.w	r8,r8[0x0]
800066d0:	10 39       	cp.w	r9,r8
800066d2:	c4 73       	brcs	80006760 <vTaskIncrementTick+0xe4>
800066d4:	4a 68       	lddpc	r8,8000676c <vTaskIncrementTick+0xf0>
800066d6:	70 08       	ld.w	r8,r8[0x0]
800066d8:	70 08       	ld.w	r8,r8[0x0]
800066da:	58 08       	cp.w	r8,0
800066dc:	c0 c0       	breq	800066f4 <vTaskIncrementTick+0x78>
800066de:	4a 48       	lddpc	r8,8000676c <vTaskIncrementTick+0xf0>
800066e0:	70 08       	ld.w	r8,r8[0x0]
800066e2:	70 38       	ld.w	r8,r8[0xc]
800066e4:	70 37       	ld.w	r7,r8[0xc]
800066e6:	6e 18       	ld.w	r8,r7[0x4]
800066e8:	4a 09       	lddpc	r9,80006768 <vTaskIncrementTick+0xec>
800066ea:	72 09       	ld.w	r9,r9[0x0]
800066ec:	12 38       	cp.w	r8,r9
800066ee:	e0 88 00 14 	brls	80006716 <vTaskIncrementTick+0x9a>
800066f2:	c0 e8       	rjmp	8000670e <vTaskIncrementTick+0x92>
800066f4:	3f f9       	mov	r9,-1
800066f6:	4a 18       	lddpc	r8,80006778 <vTaskIncrementTick+0xfc>
800066f8:	91 09       	st.w	r8[0x0],r9
800066fa:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800066fe:	6a 08       	ld.w	r8,r5[0x0]
80006700:	70 38       	ld.w	r8,r8[0xc]
80006702:	70 37       	ld.w	r7,r8[0xc]
80006704:	6e 18       	ld.w	r8,r7[0x4]
80006706:	64 09       	ld.w	r9,r2[0x0]
80006708:	12 38       	cp.w	r8,r9
8000670a:	e0 88 00 0a 	brls	8000671e <vTaskIncrementTick+0xa2>
8000670e:	49 b9       	lddpc	r9,80006778 <vTaskIncrementTick+0xfc>
80006710:	93 08       	st.w	r9[0x0],r8
80006712:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006716:	49 a4       	lddpc	r4,8000677c <vTaskIncrementTick+0x100>
80006718:	49 a3       	lddpc	r3,80006780 <vTaskIncrementTick+0x104>
8000671a:	49 55       	lddpc	r5,8000676c <vTaskIncrementTick+0xf0>
8000671c:	49 32       	lddpc	r2,80006768 <vTaskIncrementTick+0xec>
8000671e:	ee c6 ff fc 	sub	r6,r7,-4
80006722:	0c 9c       	mov	r12,r6
80006724:	f0 1f 00 18 	mcall	80006784 <vTaskIncrementTick+0x108>
80006728:	6e a8       	ld.w	r8,r7[0x28]
8000672a:	58 08       	cp.w	r8,0
8000672c:	c0 50       	breq	80006736 <vTaskIncrementTick+0xba>
8000672e:	ee cc ff e8 	sub	r12,r7,-24
80006732:	f0 1f 00 15 	mcall	80006784 <vTaskIncrementTick+0x108>
80006736:	6e bc       	ld.w	r12,r7[0x2c]
80006738:	68 08       	ld.w	r8,r4[0x0]
8000673a:	10 3c       	cp.w	r12,r8
8000673c:	e9 fc ba 00 	st.whi	r4[0x0],r12
80006740:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006744:	0c 9b       	mov	r11,r6
80006746:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
8000674a:	f0 1f 00 10 	mcall	80006788 <vTaskIncrementTick+0x10c>
8000674e:	6a 08       	ld.w	r8,r5[0x0]
80006750:	70 08       	ld.w	r8,r8[0x0]
80006752:	58 08       	cp.w	r8,0
80006754:	cd 51       	brne	800066fe <vTaskIncrementTick+0x82>
80006756:	cc fb       	rjmp	800066f4 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80006758:	48 d8       	lddpc	r8,8000678c <vTaskIncrementTick+0x110>
8000675a:	70 09       	ld.w	r9,r8[0x0]
8000675c:	2f f9       	sub	r9,-1
8000675e:	91 09       	st.w	r8[0x0],r9
80006760:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006764:	00 00       	add	r0,r0
80006766:	07 98       	ld.ub	r8,r3[0x1]
80006768:	00 00       	add	r0,r0
8000676a:	07 94       	ld.ub	r4,r3[0x1]
8000676c:	00 00       	add	r0,r0
8000676e:	06 a0       	st.w	r3++,r0
80006770:	00 00       	add	r0,r0
80006772:	06 b0       	st.h	r3++,r0
80006774:	00 00       	add	r0,r0
80006776:	06 ac       	st.w	r3++,r12
80006778:	00 00       	add	r0,r0
8000677a:	00 30       	cp.w	r0,r0
8000677c:	00 00       	add	r0,r0
8000677e:	07 d0       	ld.ub	r0,r3[0x5]
80006780:	00 00       	add	r0,r0
80006782:	06 b4       	st.h	r3++,r4
80006784:	80 00       	ld.sh	r0,r0[0x0]
80006786:	5c a2       	swap.h	r2
80006788:	80 00       	ld.sh	r0,r0[0x0]
8000678a:	5c 52       	castu.b	r2
8000678c:	00 00       	add	r0,r0
8000678e:	06 98       	mov	r8,r3

80006790 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80006790:	eb cd 40 c0 	pushm	r6-r7,lr
80006794:	18 97       	mov	r7,r12
80006796:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80006798:	f0 1f 00 15 	mcall	800067ec <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
8000679c:	6c 08       	ld.w	r8,r6[0x0]
8000679e:	5b f8       	cp.w	r8,-1
800067a0:	c0 31       	brne	800067a6 <xTaskCheckForTimeOut+0x16>
800067a2:	30 07       	mov	r7,0
800067a4:	c1 f8       	rjmp	800067e2 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800067a6:	49 39       	lddpc	r9,800067f0 <xTaskCheckForTimeOut+0x60>
800067a8:	72 09       	ld.w	r9,r9[0x0]
800067aa:	6e 0a       	ld.w	r10,r7[0x0]
800067ac:	12 3a       	cp.w	r10,r9
800067ae:	c0 70       	breq	800067bc <xTaskCheckForTimeOut+0x2c>
800067b0:	49 19       	lddpc	r9,800067f4 <xTaskCheckForTimeOut+0x64>
800067b2:	72 09       	ld.w	r9,r9[0x0]
800067b4:	6e 1a       	ld.w	r10,r7[0x4]
800067b6:	12 3a       	cp.w	r10,r9
800067b8:	e0 88 00 14 	brls	800067e0 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800067bc:	48 e9       	lddpc	r9,800067f4 <xTaskCheckForTimeOut+0x64>
800067be:	72 0a       	ld.w	r10,r9[0x0]
800067c0:	6e 19       	ld.w	r9,r7[0x4]
800067c2:	12 1a       	sub	r10,r9
800067c4:	14 38       	cp.w	r8,r10
800067c6:	e0 88 00 0d 	brls	800067e0 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
800067ca:	48 ba       	lddpc	r10,800067f4 <xTaskCheckForTimeOut+0x64>
800067cc:	74 0a       	ld.w	r10,r10[0x0]
800067ce:	14 19       	sub	r9,r10
800067d0:	f2 08 00 08 	add	r8,r9,r8
800067d4:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
800067d6:	0e 9c       	mov	r12,r7
800067d8:	f0 1f 00 08 	mcall	800067f8 <xTaskCheckForTimeOut+0x68>
800067dc:	30 07       	mov	r7,0
800067de:	c0 28       	rjmp	800067e2 <xTaskCheckForTimeOut+0x52>
800067e0:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
800067e2:	f0 1f 00 07 	mcall	800067fc <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
800067e6:	0e 9c       	mov	r12,r7
800067e8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800067ec:	80 00       	ld.sh	r0,r0[0x0]
800067ee:	5d 5c       	*unknown*
800067f0:	00 00       	add	r0,r0
800067f2:	06 ac       	st.w	r3++,r12
800067f4:	00 00       	add	r0,r0
800067f6:	07 94       	ld.ub	r4,r3[0x1]
800067f8:	80 00       	ld.sh	r0,r0[0x0]
800067fa:	64 f4       	ld.w	r4,r2[0x3c]
800067fc:	80 00       	ld.sh	r0,r0[0x0]
800067fe:	5e 68       	retmi	r8

80006800 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80006800:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80006804:	f0 1f 00 2c 	mcall	800068b4 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80006808:	4a c8       	lddpc	r8,800068b8 <xTaskResumeAll+0xb8>
8000680a:	70 09       	ld.w	r9,r8[0x0]
8000680c:	20 19       	sub	r9,1
8000680e:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006810:	70 08       	ld.w	r8,r8[0x0]
80006812:	58 08       	cp.w	r8,0
80006814:	c4 91       	brne	800068a6 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80006816:	4a a8       	lddpc	r8,800068bc <xTaskResumeAll+0xbc>
80006818:	70 08       	ld.w	r8,r8[0x0]
8000681a:	58 08       	cp.w	r8,0
8000681c:	c4 50       	breq	800068a6 <xTaskResumeAll+0xa6>
8000681e:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006820:	4a 85       	lddpc	r5,800068c0 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80006822:	4a 93       	lddpc	r3,800068c4 <xTaskResumeAll+0xc4>
80006824:	4a 92       	lddpc	r2,800068c8 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006826:	4a a1       	lddpc	r1,800068cc <xTaskResumeAll+0xcc>
80006828:	c1 e8       	rjmp	80006864 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
8000682a:	6a 38       	ld.w	r8,r5[0xc]
8000682c:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
8000682e:	ee cc ff e8 	sub	r12,r7,-24
80006832:	f0 1f 00 28 	mcall	800068d0 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80006836:	ee c6 ff fc 	sub	r6,r7,-4
8000683a:	0c 9c       	mov	r12,r6
8000683c:	f0 1f 00 25 	mcall	800068d0 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80006840:	6e bc       	ld.w	r12,r7[0x2c]
80006842:	66 08       	ld.w	r8,r3[0x0]
80006844:	10 3c       	cp.w	r12,r8
80006846:	e7 fc ba 00 	st.whi	r3[0x0],r12
8000684a:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000684e:	0c 9b       	mov	r11,r6
80006850:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80006854:	f0 1f 00 20 	mcall	800068d4 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006858:	62 08       	ld.w	r8,r1[0x0]
8000685a:	6e b9       	ld.w	r9,r7[0x2c]
8000685c:	70 b8       	ld.w	r8,r8[0x2c]
8000685e:	10 39       	cp.w	r9,r8
80006860:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006864:	6a 08       	ld.w	r8,r5[0x0]
80006866:	58 08       	cp.w	r8,0
80006868:	ce 11       	brne	8000682a <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000686a:	49 c8       	lddpc	r8,800068d8 <xTaskResumeAll+0xd8>
8000686c:	70 08       	ld.w	r8,r8[0x0]
8000686e:	58 08       	cp.w	r8,0
80006870:	c0 f0       	breq	8000688e <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006872:	49 a8       	lddpc	r8,800068d8 <xTaskResumeAll+0xd8>
80006874:	70 08       	ld.w	r8,r8[0x0]
80006876:	58 08       	cp.w	r8,0
80006878:	c1 10       	breq	8000689a <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
8000687a:	49 87       	lddpc	r7,800068d8 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
8000687c:	f0 1f 00 18 	mcall	800068dc <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80006880:	6e 08       	ld.w	r8,r7[0x0]
80006882:	20 18       	sub	r8,1
80006884:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006886:	6e 08       	ld.w	r8,r7[0x0]
80006888:	58 08       	cp.w	r8,0
8000688a:	cf 91       	brne	8000687c <xTaskResumeAll+0x7c>
8000688c:	c0 78       	rjmp	8000689a <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
8000688e:	58 14       	cp.w	r4,1
80006890:	c0 50       	breq	8000689a <xTaskResumeAll+0x9a>
80006892:	49 48       	lddpc	r8,800068e0 <xTaskResumeAll+0xe0>
80006894:	70 08       	ld.w	r8,r8[0x0]
80006896:	58 18       	cp.w	r8,1
80006898:	c0 71       	brne	800068a6 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
8000689a:	30 09       	mov	r9,0
8000689c:	49 18       	lddpc	r8,800068e0 <xTaskResumeAll+0xe0>
8000689e:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800068a0:	d7 33       	scall
800068a2:	30 17       	mov	r7,1
800068a4:	c0 28       	rjmp	800068a8 <xTaskResumeAll+0xa8>
800068a6:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
800068a8:	f0 1f 00 0f 	mcall	800068e4 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
800068ac:	0e 9c       	mov	r12,r7
800068ae:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800068b2:	00 00       	add	r0,r0
800068b4:	80 00       	ld.sh	r0,r0[0x0]
800068b6:	5d 5c       	*unknown*
800068b8:	00 00       	add	r0,r0
800068ba:	07 98       	ld.ub	r8,r3[0x1]
800068bc:	00 00       	add	r0,r0
800068be:	07 b4       	ld.ub	r4,r3[0x3]
800068c0:	00 00       	add	r0,r0
800068c2:	07 6c       	ld.uh	r12,--r3
800068c4:	00 00       	add	r0,r0
800068c6:	07 d0       	ld.ub	r0,r3[0x5]
800068c8:	00 00       	add	r0,r0
800068ca:	06 b4       	st.h	r3++,r4
800068cc:	00 00       	add	r0,r0
800068ce:	07 68       	ld.uh	r8,--r3
800068d0:	80 00       	ld.sh	r0,r0[0x0]
800068d2:	5c a2       	swap.h	r2
800068d4:	80 00       	ld.sh	r0,r0[0x0]
800068d6:	5c 52       	castu.b	r2
800068d8:	00 00       	add	r0,r0
800068da:	06 98       	mov	r8,r3
800068dc:	80 00       	ld.sh	r0,r0[0x0]
800068de:	66 7c       	ld.w	r12,r3[0x1c]
800068e0:	00 00       	add	r0,r0
800068e2:	07 b8       	ld.ub	r8,r3[0x3]
800068e4:	80 00       	ld.sh	r0,r0[0x0]
800068e6:	5e 68       	retmi	r8

800068e8 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
800068e8:	eb cd 40 c0 	pushm	r6-r7,lr
800068ec:	18 97       	mov	r7,r12
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
800068ee:	58 0c       	cp.w	r12,0
800068f0:	c2 a0       	breq	80006944 <vTaskResume+0x5c>
800068f2:	49 68       	lddpc	r8,80006948 <vTaskResume+0x60>
800068f4:	70 08       	ld.w	r8,r8[0x0]
800068f6:	10 3c       	cp.w	r12,r8
800068f8:	c2 60       	breq	80006944 <vTaskResume+0x5c>
		{
			taskENTER_CRITICAL();
800068fa:	f0 1f 00 15 	mcall	8000694c <vTaskResume+0x64>
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
800068fe:	0e 9c       	mov	r12,r7
80006900:	f0 1f 00 14 	mcall	80006950 <vTaskResume+0x68>
80006904:	58 1c       	cp.w	r12,1
80006906:	c1 d1       	brne	80006940 <vTaskResume+0x58>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
80006908:	ee c6 ff fc 	sub	r6,r7,-4
8000690c:	0c 9c       	mov	r12,r6
8000690e:	f0 1f 00 12 	mcall	80006954 <vTaskResume+0x6c>
					prvAddTaskToReadyQueue( pxTCB );
80006912:	6e bc       	ld.w	r12,r7[0x2c]
80006914:	49 18       	lddpc	r8,80006958 <vTaskResume+0x70>
80006916:	70 08       	ld.w	r8,r8[0x0]
80006918:	10 3c       	cp.w	r12,r8
8000691a:	e0 88 00 04 	brls	80006922 <vTaskResume+0x3a>
8000691e:	48 f8       	lddpc	r8,80006958 <vTaskResume+0x70>
80006920:	91 0c       	st.w	r8[0x0],r12
80006922:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006926:	0c 9b       	mov	r11,r6
80006928:	48 d8       	lddpc	r8,8000695c <vTaskResume+0x74>
8000692a:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000692e:	f0 1f 00 0d 	mcall	80006960 <vTaskResume+0x78>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006932:	48 68       	lddpc	r8,80006948 <vTaskResume+0x60>
80006934:	70 08       	ld.w	r8,r8[0x0]
80006936:	6e b9       	ld.w	r9,r7[0x2c]
80006938:	70 b8       	ld.w	r8,r8[0x2c]
8000693a:	10 39       	cp.w	r9,r8
8000693c:	c0 23       	brcs	80006940 <vTaskResume+0x58>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
8000693e:	d7 33       	scall
					}
				}
			}
			taskEXIT_CRITICAL();
80006940:	f0 1f 00 09 	mcall	80006964 <vTaskResume+0x7c>
80006944:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006948:	00 00       	add	r0,r0
8000694a:	07 68       	ld.uh	r8,--r3
8000694c:	80 00       	ld.sh	r0,r0[0x0]
8000694e:	5d 5c       	*unknown*
80006950:	80 00       	ld.sh	r0,r0[0x0]
80006952:	64 48       	ld.w	r8,r2[0x10]
80006954:	80 00       	ld.sh	r0,r0[0x0]
80006956:	5c a2       	swap.h	r2
80006958:	00 00       	add	r0,r0
8000695a:	07 d0       	ld.ub	r0,r3[0x5]
8000695c:	00 00       	add	r0,r0
8000695e:	06 b4       	st.h	r3++,r4
80006960:	80 00       	ld.sh	r0,r0[0x0]
80006962:	5c 52       	castu.b	r2
80006964:	80 00       	ld.sh	r0,r0[0x0]
80006966:	5e 68       	retmi	r8

80006968 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
80006968:	eb cd 40 e0 	pushm	r5-r7,lr
8000696c:	18 97       	mov	r7,r12
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
8000696e:	f0 1f 00 1c 	mcall	800069dc <vTaskSuspend+0x74>
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
80006972:	49 c8       	lddpc	r8,800069e0 <vTaskSuspend+0x78>
80006974:	70 08       	ld.w	r8,r8[0x0]
80006976:	10 37       	cp.w	r7,r8
80006978:	c0 31       	brne	8000697e <vTaskSuspend+0x16>
8000697a:	30 07       	mov	r7,0
8000697c:	c0 38       	rjmp	80006982 <vTaskSuspend+0x1a>
			{
				pxTaskToSuspend = NULL;
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
8000697e:	58 07       	cp.w	r7,0
80006980:	c0 41       	brne	80006988 <vTaskSuspend+0x20>
80006982:	49 88       	lddpc	r8,800069e0 <vTaskSuspend+0x78>
80006984:	70 06       	ld.w	r6,r8[0x0]
80006986:	c0 28       	rjmp	8000698a <vTaskSuspend+0x22>
80006988:	0e 96       	mov	r6,r7

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			vListRemove( &( pxTCB->xGenericListItem ) );
8000698a:	ec c5 ff fc 	sub	r5,r6,-4
8000698e:	0a 9c       	mov	r12,r5
80006990:	f0 1f 00 15 	mcall	800069e4 <vTaskSuspend+0x7c>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer )
80006994:	6c a8       	ld.w	r8,r6[0x28]
80006996:	58 08       	cp.w	r8,0
80006998:	c0 50       	breq	800069a2 <vTaskSuspend+0x3a>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
8000699a:	ec cc ff e8 	sub	r12,r6,-24
8000699e:	f0 1f 00 12 	mcall	800069e4 <vTaskSuspend+0x7c>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
800069a2:	0a 9b       	mov	r11,r5
800069a4:	49 1c       	lddpc	r12,800069e8 <vTaskSuspend+0x80>
800069a6:	f0 1f 00 12 	mcall	800069ec <vTaskSuspend+0x84>
		}
		taskEXIT_CRITICAL();
800069aa:	f0 1f 00 12 	mcall	800069f0 <vTaskSuspend+0x88>

		if( ( void * ) pxTaskToSuspend == NULL )
800069ae:	58 07       	cp.w	r7,0
800069b0:	c1 31       	brne	800069d6 <vTaskSuspend+0x6e>
		{
			if( xSchedulerRunning != pdFALSE )
800069b2:	49 18       	lddpc	r8,800069f4 <vTaskSuspend+0x8c>
800069b4:	70 08       	ld.w	r8,r8[0x0]
800069b6:	58 08       	cp.w	r8,0
800069b8:	c0 40       	breq	800069c0 <vTaskSuspend+0x58>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
800069ba:	d7 33       	scall
800069bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1U )
800069c0:	48 e8       	lddpc	r8,800069f8 <vTaskSuspend+0x90>
800069c2:	70 08       	ld.w	r8,r8[0x0]
800069c4:	58 18       	cp.w	r8,1
800069c6:	c0 61       	brne	800069d2 <vTaskSuspend+0x6a>
				{
					/* No other tasks are defined, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
800069c8:	30 09       	mov	r9,0
800069ca:	48 68       	lddpc	r8,800069e0 <vTaskSuspend+0x78>
800069cc:	91 09       	st.w	r8[0x0],r9
800069ce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				}
				else
				{
					vTaskSwitchContext();
800069d2:	f0 1f 00 0b 	mcall	800069fc <vTaskSuspend+0x94>
800069d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800069da:	00 00       	add	r0,r0
800069dc:	80 00       	ld.sh	r0,r0[0x0]
800069de:	5d 5c       	*unknown*
800069e0:	00 00       	add	r0,r0
800069e2:	07 68       	ld.uh	r8,--r3
800069e4:	80 00       	ld.sh	r0,r0[0x0]
800069e6:	5c a2       	swap.h	r2
800069e8:	00 00       	add	r0,r0
800069ea:	07 bc       	ld.ub	r12,r3[0x3]
800069ec:	80 00       	ld.sh	r0,r0[0x0]
800069ee:	5c 52       	castu.b	r2
800069f0:	80 00       	ld.sh	r0,r0[0x0]
800069f2:	5e 68       	retmi	r8
800069f4:	00 00       	add	r0,r0
800069f6:	06 a4       	st.w	r3++,r4
800069f8:	00 00       	add	r0,r0
800069fa:	07 b4       	ld.ub	r4,r3[0x3]
800069fc:	80 00       	ld.sh	r0,r0[0x0]
800069fe:	64 78       	ld.w	r8,r2[0x1c]

80006a00 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80006a00:	eb cd 40 80 	pushm	r7,lr
80006a04:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80006a06:	49 08       	lddpc	r8,80006a44 <prvAddCurrentTaskToDelayedList+0x44>
80006a08:	70 08       	ld.w	r8,r8[0x0]
80006a0a:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80006a0c:	48 f8       	lddpc	r8,80006a48 <prvAddCurrentTaskToDelayedList+0x48>
80006a0e:	70 08       	ld.w	r8,r8[0x0]
80006a10:	10 3c       	cp.w	r12,r8
80006a12:	c0 a2       	brcc	80006a26 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006a14:	48 c8       	lddpc	r8,80006a44 <prvAddCurrentTaskToDelayedList+0x44>
80006a16:	70 0b       	ld.w	r11,r8[0x0]
80006a18:	48 d8       	lddpc	r8,80006a4c <prvAddCurrentTaskToDelayedList+0x4c>
80006a1a:	70 0c       	ld.w	r12,r8[0x0]
80006a1c:	2f cb       	sub	r11,-4
80006a1e:	f0 1f 00 0d 	mcall	80006a50 <prvAddCurrentTaskToDelayedList+0x50>
80006a22:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006a26:	48 88       	lddpc	r8,80006a44 <prvAddCurrentTaskToDelayedList+0x44>
80006a28:	70 0b       	ld.w	r11,r8[0x0]
80006a2a:	48 b8       	lddpc	r8,80006a54 <prvAddCurrentTaskToDelayedList+0x54>
80006a2c:	70 0c       	ld.w	r12,r8[0x0]
80006a2e:	2f cb       	sub	r11,-4
80006a30:	f0 1f 00 08 	mcall	80006a50 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80006a34:	48 98       	lddpc	r8,80006a58 <prvAddCurrentTaskToDelayedList+0x58>
80006a36:	70 08       	ld.w	r8,r8[0x0]
80006a38:	10 37       	cp.w	r7,r8
80006a3a:	c0 32       	brcc	80006a40 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80006a3c:	48 78       	lddpc	r8,80006a58 <prvAddCurrentTaskToDelayedList+0x58>
80006a3e:	91 07       	st.w	r8[0x0],r7
80006a40:	e3 cd 80 80 	ldm	sp++,r7,pc
80006a44:	00 00       	add	r0,r0
80006a46:	07 68       	ld.uh	r8,--r3
80006a48:	00 00       	add	r0,r0
80006a4a:	07 94       	ld.ub	r4,r3[0x1]
80006a4c:	00 00       	add	r0,r0
80006a4e:	06 b0       	st.h	r3++,r0
80006a50:	80 00       	ld.sh	r0,r0[0x0]
80006a52:	5c 6e       	casts.b	lr
80006a54:	00 00       	add	r0,r0
80006a56:	06 a0       	st.w	r3++,r0
80006a58:	00 00       	add	r0,r0
80006a5a:	00 30       	cp.w	r0,r0

80006a5c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80006a5c:	eb cd 40 c0 	pushm	r6-r7,lr
80006a60:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80006a62:	58 0c       	cp.w	r12,0
80006a64:	c1 10       	breq	80006a86 <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
80006a66:	f0 1f 00 0a 	mcall	80006a8c <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
80006a6a:	48 a8       	lddpc	r8,80006a90 <vTaskDelay+0x34>
80006a6c:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006a6e:	48 a8       	lddpc	r8,80006a94 <vTaskDelay+0x38>
80006a70:	70 0c       	ld.w	r12,r8[0x0]
80006a72:	2f cc       	sub	r12,-4
80006a74:	f0 1f 00 09 	mcall	80006a98 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006a78:	ee 06 00 0c 	add	r12,r7,r6
80006a7c:	f0 1f 00 08 	mcall	80006a9c <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
80006a80:	f0 1f 00 08 	mcall	80006aa0 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006a84:	c0 21       	brne	80006a88 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
80006a86:	d7 33       	scall
80006a88:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006a8c:	80 00       	ld.sh	r0,r0[0x0]
80006a8e:	64 68       	ld.w	r8,r2[0x18]
80006a90:	00 00       	add	r0,r0
80006a92:	07 94       	ld.ub	r4,r3[0x1]
80006a94:	00 00       	add	r0,r0
80006a96:	07 68       	ld.uh	r8,--r3
80006a98:	80 00       	ld.sh	r0,r0[0x0]
80006a9a:	5c a2       	swap.h	r2
80006a9c:	80 00       	ld.sh	r0,r0[0x0]
80006a9e:	6a 00       	ld.w	r0,r5[0x0]
80006aa0:	80 00       	ld.sh	r0,r0[0x0]
80006aa2:	68 00       	ld.w	r0,r4[0x0]

80006aa4 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80006aa4:	eb cd 40 c0 	pushm	r6-r7,lr
80006aa8:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80006aaa:	48 e7       	lddpc	r7,80006ae0 <vTaskPlaceOnEventList+0x3c>
80006aac:	6e 0b       	ld.w	r11,r7[0x0]
80006aae:	2e 8b       	sub	r11,-24
80006ab0:	f0 1f 00 0d 	mcall	80006ae4 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006ab4:	6e 0c       	ld.w	r12,r7[0x0]
80006ab6:	2f cc       	sub	r12,-4
80006ab8:	f0 1f 00 0c 	mcall	80006ae8 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006abc:	5b f6       	cp.w	r6,-1
80006abe:	c0 81       	brne	80006ace <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006ac0:	6e 0b       	ld.w	r11,r7[0x0]
80006ac2:	2f cb       	sub	r11,-4
80006ac4:	48 ac       	lddpc	r12,80006aec <vTaskPlaceOnEventList+0x48>
80006ac6:	f0 1f 00 0b 	mcall	80006af0 <vTaskPlaceOnEventList+0x4c>
80006aca:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80006ace:	48 a8       	lddpc	r8,80006af4 <vTaskPlaceOnEventList+0x50>
80006ad0:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80006ad2:	ec 0c 00 0c 	add	r12,r6,r12
80006ad6:	f0 1f 00 09 	mcall	80006af8 <vTaskPlaceOnEventList+0x54>
80006ada:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006ade:	00 00       	add	r0,r0
80006ae0:	00 00       	add	r0,r0
80006ae2:	07 68       	ld.uh	r8,--r3
80006ae4:	80 00       	ld.sh	r0,r0[0x0]
80006ae6:	5c 6e       	casts.b	lr
80006ae8:	80 00       	ld.sh	r0,r0[0x0]
80006aea:	5c a2       	swap.h	r2
80006aec:	00 00       	add	r0,r0
80006aee:	07 bc       	ld.ub	r12,r3[0x3]
80006af0:	80 00       	ld.sh	r0,r0[0x0]
80006af2:	5c 52       	castu.b	r2
80006af4:	00 00       	add	r0,r0
80006af6:	07 94       	ld.ub	r4,r3[0x1]
80006af8:	80 00       	ld.sh	r0,r0[0x0]
80006afa:	6a 00       	ld.w	r0,r5[0x0]

80006afc <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80006afc:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006b00:	49 57       	lddpc	r7,80006b54 <prvIdleTask+0x58>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006b02:	49 64       	lddpc	r4,80006b58 <prvIdleTask+0x5c>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80006b04:	49 63       	lddpc	r3,80006b5c <prvIdleTask+0x60>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006b06:	49 75       	lddpc	r5,80006b60 <prvIdleTask+0x64>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006b08:	6e 08       	ld.w	r8,r7[0x0]
80006b0a:	58 08       	cp.w	r8,0
80006b0c:	c1 e0       	breq	80006b48 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80006b0e:	f0 1f 00 16 	mcall	80006b64 <prvIdleTask+0x68>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006b12:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80006b14:	f0 1f 00 15 	mcall	80006b68 <prvIdleTask+0x6c>

			if( xListIsEmpty == pdFALSE )
80006b18:	58 06       	cp.w	r6,0
80006b1a:	c1 70       	breq	80006b48 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80006b1c:	f0 1f 00 14 	mcall	80006b6c <prvIdleTask+0x70>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80006b20:	68 38       	ld.w	r8,r4[0xc]
80006b22:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80006b24:	ec cc ff fc 	sub	r12,r6,-4
80006b28:	f0 1f 00 12 	mcall	80006b70 <prvIdleTask+0x74>
					--uxCurrentNumberOfTasks;
80006b2c:	66 08       	ld.w	r8,r3[0x0]
80006b2e:	20 18       	sub	r8,1
80006b30:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80006b32:	6e 08       	ld.w	r8,r7[0x0]
80006b34:	20 18       	sub	r8,1
80006b36:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80006b38:	f0 1f 00 0f 	mcall	80006b74 <prvIdleTask+0x78>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006b3c:	6c cc       	ld.w	r12,r6[0x30]
80006b3e:	f0 1f 00 0f 	mcall	80006b78 <prvIdleTask+0x7c>
		vPortFree( pxTCB );
80006b42:	0c 9c       	mov	r12,r6
80006b44:	f0 1f 00 0d 	mcall	80006b78 <prvIdleTask+0x7c>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006b48:	6a 08       	ld.w	r8,r5[0x0]
80006b4a:	58 18       	cp.w	r8,1
80006b4c:	fe 98 ff de 	brls	80006b08 <prvIdleTask+0xc>
			{
				taskYIELD();
80006b50:	d7 33       	scall
80006b52:	cd bb       	rjmp	80006b08 <prvIdleTask+0xc>
80006b54:	00 00       	add	r0,r0
80006b56:	06 a8       	st.w	r3++,r8
80006b58:	00 00       	add	r0,r0
80006b5a:	07 54       	ld.sh	r4,--r3
80006b5c:	00 00       	add	r0,r0
80006b5e:	07 b4       	ld.ub	r4,r3[0x3]
80006b60:	00 00       	add	r0,r0
80006b62:	06 b4       	st.h	r3++,r4
80006b64:	80 00       	ld.sh	r0,r0[0x0]
80006b66:	64 68       	ld.w	r8,r2[0x18]
80006b68:	80 00       	ld.sh	r0,r0[0x0]
80006b6a:	68 00       	ld.w	r0,r4[0x0]
80006b6c:	80 00       	ld.sh	r0,r0[0x0]
80006b6e:	5d 5c       	*unknown*
80006b70:	80 00       	ld.sh	r0,r0[0x0]
80006b72:	5c a2       	swap.h	r2
80006b74:	80 00       	ld.sh	r0,r0[0x0]
80006b76:	5e 68       	retmi	r8
80006b78:	80 00       	ld.sh	r0,r0[0x0]
80006b7a:	5f a0       	srle	r0

80006b7c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80006b7c:	d4 31       	pushm	r0-r7,lr
80006b7e:	20 1d       	sub	sp,4
80006b80:	fa c4 ff d8 	sub	r4,sp,-40
80006b84:	50 0c       	stdsp	sp[0x0],r12
80006b86:	16 91       	mov	r1,r11
80006b88:	14 97       	mov	r7,r10
80006b8a:	12 90       	mov	r0,r9
80006b8c:	10 93       	mov	r3,r8
80006b8e:	68 02       	ld.w	r2,r4[0x0]
80006b90:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006b92:	34 8c       	mov	r12,72
80006b94:	f0 1f 00 5c 	mcall	80006d04 <xTaskGenericCreate+0x188>
80006b98:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80006b9a:	c0 31       	brne	80006ba0 <xTaskGenericCreate+0x24>
80006b9c:	3f fc       	mov	r12,-1
80006b9e:	ca f8       	rjmp	80006cfc <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006ba0:	58 06       	cp.w	r6,0
80006ba2:	e0 81 00 af 	brne	80006d00 <xTaskGenericCreate+0x184>
80006ba6:	0e 9c       	mov	r12,r7
80006ba8:	5c 7c       	castu.h	r12
80006baa:	a3 6c       	lsl	r12,0x2
80006bac:	f0 1f 00 56 	mcall	80006d04 <xTaskGenericCreate+0x188>
80006bb0:	18 96       	mov	r6,r12
80006bb2:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006bb4:	c0 61       	brne	80006bc0 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80006bb6:	0a 9c       	mov	r12,r5
80006bb8:	f0 1f 00 54 	mcall	80006d08 <xTaskGenericCreate+0x18c>
80006bbc:	3f fc       	mov	r12,-1
80006bbe:	c9 f8       	rjmp	80006cfc <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006bc0:	5c 77       	castu.h	r7
80006bc2:	ee 0a 15 02 	lsl	r10,r7,0x2
80006bc6:	e0 6b 00 a5 	mov	r11,165
80006bca:	0c 9c       	mov	r12,r6
80006bcc:	f0 1f 00 50 	mcall	80006d0c <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006bd0:	ee c6 00 01 	sub	r6,r7,1
80006bd4:	6a c8       	ld.w	r8,r5[0x30]
80006bd6:	f0 06 00 26 	add	r6,r8,r6<<0x2
80006bda:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80006bde:	31 0a       	mov	r10,16
80006be0:	02 9b       	mov	r11,r1
80006be2:	ea cc ff cc 	sub	r12,r5,-52
80006be6:	f0 1f 00 4b 	mcall	80006d10 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80006bea:	30 08       	mov	r8,0
80006bec:	eb 68 00 43 	st.b	r5[67],r8
80006bf0:	58 73       	cp.w	r3,7
80006bf2:	e6 07 17 80 	movls	r7,r3
80006bf6:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80006bfa:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006bfc:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006c00:	ea c4 ff fc 	sub	r4,r5,-4
80006c04:	08 9c       	mov	r12,r4
80006c06:	f0 1f 00 44 	mcall	80006d14 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80006c0a:	ea cc ff e8 	sub	r12,r5,-24
80006c0e:	f0 1f 00 42 	mcall	80006d14 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80006c12:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006c14:	ee 07 11 08 	rsub	r7,r7,8
80006c18:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006c1a:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006c1c:	00 9a       	mov	r10,r0
80006c1e:	40 0b       	lddsp	r11,sp[0x0]
80006c20:	0c 9c       	mov	r12,r6
80006c22:	f0 1f 00 3e 	mcall	80006d18 <xTaskGenericCreate+0x19c>
80006c26:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006c28:	58 02       	cp.w	r2,0
80006c2a:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80006c2e:	f0 1f 00 3c 	mcall	80006d1c <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006c32:	4b c8       	lddpc	r8,80006d20 <xTaskGenericCreate+0x1a4>
80006c34:	70 09       	ld.w	r9,r8[0x0]
80006c36:	2f f9       	sub	r9,-1
80006c38:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80006c3a:	4b b8       	lddpc	r8,80006d24 <xTaskGenericCreate+0x1a8>
80006c3c:	70 08       	ld.w	r8,r8[0x0]
80006c3e:	58 08       	cp.w	r8,0
80006c40:	c2 61       	brne	80006c8c <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80006c42:	4b 98       	lddpc	r8,80006d24 <xTaskGenericCreate+0x1a8>
80006c44:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006c46:	4b 78       	lddpc	r8,80006d20 <xTaskGenericCreate+0x1a4>
80006c48:	70 08       	ld.w	r8,r8[0x0]
80006c4a:	58 18       	cp.w	r8,1
80006c4c:	c2 b1       	brne	80006ca2 <xTaskGenericCreate+0x126>
80006c4e:	4b 77       	lddpc	r7,80006d28 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006c50:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006c54:	0e 9c       	mov	r12,r7
80006c56:	f0 1f 00 36 	mcall	80006d2c <xTaskGenericCreate+0x1b0>
80006c5a:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006c5c:	0c 37       	cp.w	r7,r6
80006c5e:	cf b1       	brne	80006c54 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006c60:	4b 47       	lddpc	r7,80006d30 <xTaskGenericCreate+0x1b4>
80006c62:	0e 9c       	mov	r12,r7
80006c64:	f0 1f 00 32 	mcall	80006d2c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006c68:	4b 36       	lddpc	r6,80006d34 <xTaskGenericCreate+0x1b8>
80006c6a:	0c 9c       	mov	r12,r6
80006c6c:	f0 1f 00 30 	mcall	80006d2c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006c70:	4b 2c       	lddpc	r12,80006d38 <xTaskGenericCreate+0x1bc>
80006c72:	f0 1f 00 2f 	mcall	80006d2c <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006c76:	4b 2c       	lddpc	r12,80006d3c <xTaskGenericCreate+0x1c0>
80006c78:	f0 1f 00 2d 	mcall	80006d2c <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006c7c:	4b 1c       	lddpc	r12,80006d40 <xTaskGenericCreate+0x1c4>
80006c7e:	f0 1f 00 2c 	mcall	80006d2c <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006c82:	4b 18       	lddpc	r8,80006d44 <xTaskGenericCreate+0x1c8>
80006c84:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006c86:	4b 18       	lddpc	r8,80006d48 <xTaskGenericCreate+0x1cc>
80006c88:	91 06       	st.w	r8[0x0],r6
80006c8a:	c0 c8       	rjmp	80006ca2 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006c8c:	4b 08       	lddpc	r8,80006d4c <xTaskGenericCreate+0x1d0>
80006c8e:	70 08       	ld.w	r8,r8[0x0]
80006c90:	58 08       	cp.w	r8,0
80006c92:	c0 81       	brne	80006ca2 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006c94:	4a 48       	lddpc	r8,80006d24 <xTaskGenericCreate+0x1a8>
80006c96:	70 08       	ld.w	r8,r8[0x0]
80006c98:	70 b8       	ld.w	r8,r8[0x2c]
80006c9a:	10 33       	cp.w	r3,r8
80006c9c:	c0 33       	brcs	80006ca2 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006c9e:	4a 28       	lddpc	r8,80006d24 <xTaskGenericCreate+0x1a8>
80006ca0:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006ca2:	6a b8       	ld.w	r8,r5[0x2c]
80006ca4:	4a b9       	lddpc	r9,80006d50 <xTaskGenericCreate+0x1d4>
80006ca6:	72 09       	ld.w	r9,r9[0x0]
80006ca8:	12 38       	cp.w	r8,r9
80006caa:	e0 88 00 04 	brls	80006cb2 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006cae:	4a 99       	lddpc	r9,80006d50 <xTaskGenericCreate+0x1d4>
80006cb0:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006cb2:	4a 98       	lddpc	r8,80006d54 <xTaskGenericCreate+0x1d8>
80006cb4:	70 09       	ld.w	r9,r8[0x0]
80006cb6:	2f f9       	sub	r9,-1
80006cb8:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80006cba:	6a b8       	ld.w	r8,r5[0x2c]
80006cbc:	4a 79       	lddpc	r9,80006d58 <xTaskGenericCreate+0x1dc>
80006cbe:	72 09       	ld.w	r9,r9[0x0]
80006cc0:	12 38       	cp.w	r8,r9
80006cc2:	e0 88 00 04 	brls	80006cca <xTaskGenericCreate+0x14e>
80006cc6:	4a 59       	lddpc	r9,80006d58 <xTaskGenericCreate+0x1dc>
80006cc8:	93 08       	st.w	r9[0x0],r8
80006cca:	6a bc       	ld.w	r12,r5[0x2c]
80006ccc:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006cd0:	08 9b       	mov	r11,r4
80006cd2:	49 68       	lddpc	r8,80006d28 <xTaskGenericCreate+0x1ac>
80006cd4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006cd8:	f0 1f 00 21 	mcall	80006d5c <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006cdc:	f0 1f 00 21 	mcall	80006d60 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006ce0:	49 b8       	lddpc	r8,80006d4c <xTaskGenericCreate+0x1d0>
80006ce2:	70 08       	ld.w	r8,r8[0x0]
80006ce4:	58 08       	cp.w	r8,0
80006ce6:	c0 a0       	breq	80006cfa <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006ce8:	48 f8       	lddpc	r8,80006d24 <xTaskGenericCreate+0x1a8>
80006cea:	70 08       	ld.w	r8,r8[0x0]
80006cec:	70 b8       	ld.w	r8,r8[0x2c]
80006cee:	10 33       	cp.w	r3,r8
80006cf0:	e0 88 00 05 	brls	80006cfa <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006cf4:	d7 33       	scall
80006cf6:	30 1c       	mov	r12,1
80006cf8:	c0 28       	rjmp	80006cfc <xTaskGenericCreate+0x180>
80006cfa:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006cfc:	2f fd       	sub	sp,-4
80006cfe:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006d00:	99 c6       	st.w	r12[0x30],r6
80006d02:	c5 fb       	rjmp	80006bc0 <xTaskGenericCreate+0x44>
80006d04:	80 00       	ld.sh	r0,r0[0x0]
80006d06:	5f c8       	srvs	r8
80006d08:	80 00       	ld.sh	r0,r0[0x0]
80006d0a:	5f a0       	srle	r0
80006d0c:	80 00       	ld.sh	r0,r0[0x0]
80006d0e:	81 b8       	st.w	r0[0x2c],r8
80006d10:	80 00       	ld.sh	r0,r0[0x0]
80006d12:	84 e4       	ld.uh	r4,r2[0xc]
80006d14:	80 00       	ld.sh	r0,r0[0x0]
80006d16:	5c 4c       	abs	r12
80006d18:	80 00       	ld.sh	r0,r0[0x0]
80006d1a:	5c c8       	swap.bh	r8
80006d1c:	80 00       	ld.sh	r0,r0[0x0]
80006d1e:	5d 5c       	*unknown*
80006d20:	00 00       	add	r0,r0
80006d22:	07 b4       	ld.ub	r4,r3[0x3]
80006d24:	00 00       	add	r0,r0
80006d26:	07 68       	ld.uh	r8,--r3
80006d28:	00 00       	add	r0,r0
80006d2a:	06 b4       	st.h	r3++,r4
80006d2c:	80 00       	ld.sh	r0,r0[0x0]
80006d2e:	5c 38       	neg	r8
80006d30:	00 00       	add	r0,r0
80006d32:	07 80       	ld.ub	r0,r3[0x0]
80006d34:	00 00       	add	r0,r0
80006d36:	07 9c       	ld.ub	r12,r3[0x1]
80006d38:	00 00       	add	r0,r0
80006d3a:	07 6c       	ld.uh	r12,--r3
80006d3c:	00 00       	add	r0,r0
80006d3e:	07 54       	ld.sh	r4,--r3
80006d40:	00 00       	add	r0,r0
80006d42:	07 bc       	ld.ub	r12,r3[0x3]
80006d44:	00 00       	add	r0,r0
80006d46:	06 a0       	st.w	r3++,r0
80006d48:	00 00       	add	r0,r0
80006d4a:	06 b0       	st.h	r3++,r0
80006d4c:	00 00       	add	r0,r0
80006d4e:	06 a4       	st.w	r3++,r4
80006d50:	00 00       	add	r0,r0
80006d52:	06 9c       	mov	r12,r3
80006d54:	00 00       	add	r0,r0
80006d56:	07 b0       	ld.ub	r0,r3[0x3]
80006d58:	00 00       	add	r0,r0
80006d5a:	07 d0       	ld.ub	r0,r3[0x5]
80006d5c:	80 00       	ld.sh	r0,r0[0x0]
80006d5e:	5c 52       	castu.b	r2
80006d60:	80 00       	ld.sh	r0,r0[0x0]
80006d62:	5e 68       	retmi	r8

80006d64 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006d64:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006d66:	30 09       	mov	r9,0
80006d68:	1a d9       	st.w	--sp,r9
80006d6a:	1a d9       	st.w	--sp,r9
80006d6c:	1a d9       	st.w	--sp,r9
80006d6e:	12 98       	mov	r8,r9
80006d70:	e0 6a 01 00 	mov	r10,256
80006d74:	48 9b       	lddpc	r11,80006d98 <vTaskStartScheduler+0x34>
80006d76:	48 ac       	lddpc	r12,80006d9c <vTaskStartScheduler+0x38>
80006d78:	f0 1f 00 0a 	mcall	80006da0 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006d7c:	2f dd       	sub	sp,-12
80006d7e:	58 1c       	cp.w	r12,1
80006d80:	c0 a1       	brne	80006d94 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006d82:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006d84:	30 19       	mov	r9,1
80006d86:	48 88       	lddpc	r8,80006da4 <vTaskStartScheduler+0x40>
80006d88:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80006d8a:	30 09       	mov	r9,0
80006d8c:	48 78       	lddpc	r8,80006da8 <vTaskStartScheduler+0x44>
80006d8e:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006d90:	f0 1f 00 07 	mcall	80006dac <vTaskStartScheduler+0x48>
80006d94:	d8 02       	popm	pc
80006d96:	00 00       	add	r0,r0
80006d98:	80 02       	ld.sh	r2,r0[0x0]
80006d9a:	f5 34 80 00 	ld.ub	r4,r10[-32768]
80006d9e:	6a fc       	ld.w	r12,r5[0x3c]
80006da0:	80 00       	ld.sh	r0,r0[0x0]
80006da2:	6b 7c       	ld.w	r12,r5[0x5c]
80006da4:	00 00       	add	r0,r0
80006da6:	06 a4       	st.w	r3++,r4
80006da8:	00 00       	add	r0,r0
80006daa:	07 94       	ld.ub	r4,r3[0x1]
80006dac:	80 00       	ld.sh	r0,r0[0x0]
80006dae:	5d 6c       	*unknown*

80006db0 <__avr32_f64_mul>:
80006db0:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
80006db4:	e0 80 00 dc 	breq	80006f6c <__avr32_f64_mul_op1_zero>
80006db8:	d4 21       	pushm	r4-r7,lr
80006dba:	f7 e9 20 0e 	eor	lr,r11,r9
80006dbe:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
80006dc2:	30 15       	mov	r5,1
80006dc4:	c4 30       	breq	80006e4a <__avr32_f64_mul_op1_subnormal>
80006dc6:	ab 6b       	lsl	r11,0xa
80006dc8:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
80006dcc:	ab 6a       	lsl	r10,0xa
80006dce:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
80006dd2:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
80006dd6:	c5 c0       	breq	80006e8e <__avr32_f64_mul_op2_subnormal>
80006dd8:	a1 78       	lsl	r8,0x1
80006dda:	5c f9       	rol	r9
80006ddc:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
80006de0:	e0 47 07 ff 	cp.w	r7,2047
80006de4:	c7 70       	breq	80006ed2 <__avr32_f64_mul_op_nan_or_inf>
80006de6:	e0 46 07 ff 	cp.w	r6,2047
80006dea:	c7 40       	breq	80006ed2 <__avr32_f64_mul_op_nan_or_inf>
80006dec:	ee 06 00 0c 	add	r12,r7,r6
80006df0:	e0 2c 03 fe 	sub	r12,1022
80006df4:	f6 08 06 44 	mulu.d	r4,r11,r8
80006df8:	f4 09 07 44 	macu.d	r4,r10,r9
80006dfc:	f4 08 06 46 	mulu.d	r6,r10,r8
80006e00:	f6 09 06 4a 	mulu.d	r10,r11,r9
80006e04:	08 07       	add	r7,r4
80006e06:	f4 05 00 4a 	adc	r10,r10,r5
80006e0a:	5c 0b       	acr	r11
80006e0c:	ed bb 00 14 	bld	r11,0x14
80006e10:	c0 50       	breq	80006e1a <__avr32_f64_mul+0x6a>
80006e12:	a1 77       	lsl	r7,0x1
80006e14:	5c fa       	rol	r10
80006e16:	5c fb       	rol	r11
80006e18:	20 1c       	sub	r12,1
80006e1a:	58 0c       	cp.w	r12,0
80006e1c:	e0 8a 00 6f 	brle	80006efa <__avr32_f64_mul_res_subnormal>
80006e20:	e0 4c 07 ff 	cp.w	r12,2047
80006e24:	e0 84 00 9c 	brge	80006f5c <__avr32_f64_mul_res_inf>
80006e28:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
80006e2c:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
80006e30:	ef e6 12 17 	or	r7,r7,r6>>0x1
80006e34:	ee 17 80 00 	eorh	r7,0x8000
80006e38:	f1 b7 04 20 	satu	r7,0x1
80006e3c:	0e 0a       	add	r10,r7
80006e3e:	5c 0b       	acr	r11
80006e40:	ed be 00 1f 	bld	lr,0x1f
80006e44:	ef bb 00 1f 	bst	r11,0x1f
80006e48:	d8 22       	popm	r4-r7,pc

80006e4a <__avr32_f64_mul_op1_subnormal>:
80006e4a:	e4 1b 00 0f 	andh	r11,0xf
80006e4e:	f4 0c 12 00 	clz	r12,r10
80006e52:	f6 06 12 00 	clz	r6,r11
80006e56:	f7 bc 03 e1 	sublo	r12,-31
80006e5a:	f8 06 17 30 	movlo	r6,r12
80006e5e:	f7 b6 02 01 	subhs	r6,1
80006e62:	e0 46 00 20 	cp.w	r6,32
80006e66:	c0 d4       	brge	80006e80 <__avr32_f64_mul_op1_subnormal+0x36>
80006e68:	ec 0c 11 20 	rsub	r12,r6,32
80006e6c:	f6 06 09 4b 	lsl	r11,r11,r6
80006e70:	f4 0c 0a 4c 	lsr	r12,r10,r12
80006e74:	18 4b       	or	r11,r12
80006e76:	f4 06 09 4a 	lsl	r10,r10,r6
80006e7a:	20 b6       	sub	r6,11
80006e7c:	0c 17       	sub	r7,r6
80006e7e:	ca ab       	rjmp	80006dd2 <__avr32_f64_mul+0x22>
80006e80:	f4 06 09 4b 	lsl	r11,r10,r6
80006e84:	c6 40       	breq	80006f4c <__avr32_f64_mul_res_zero>
80006e86:	30 0a       	mov	r10,0
80006e88:	20 b6       	sub	r6,11
80006e8a:	0c 17       	sub	r7,r6
80006e8c:	ca 3b       	rjmp	80006dd2 <__avr32_f64_mul+0x22>

80006e8e <__avr32_f64_mul_op2_subnormal>:
80006e8e:	e4 19 00 0f 	andh	r9,0xf
80006e92:	f0 0c 12 00 	clz	r12,r8
80006e96:	f2 05 12 00 	clz	r5,r9
80006e9a:	f7 bc 03 ea 	sublo	r12,-22
80006e9e:	f8 05 17 30 	movlo	r5,r12
80006ea2:	f7 b5 02 0a 	subhs	r5,10
80006ea6:	e0 45 00 20 	cp.w	r5,32
80006eaa:	c0 d4       	brge	80006ec4 <__avr32_f64_mul_op2_subnormal+0x36>
80006eac:	ea 0c 11 20 	rsub	r12,r5,32
80006eb0:	f2 05 09 49 	lsl	r9,r9,r5
80006eb4:	f0 0c 0a 4c 	lsr	r12,r8,r12
80006eb8:	18 49       	or	r9,r12
80006eba:	f0 05 09 48 	lsl	r8,r8,r5
80006ebe:	20 25       	sub	r5,2
80006ec0:	0a 16       	sub	r6,r5
80006ec2:	c8 fb       	rjmp	80006de0 <__avr32_f64_mul+0x30>
80006ec4:	f0 05 09 49 	lsl	r9,r8,r5
80006ec8:	c4 20       	breq	80006f4c <__avr32_f64_mul_res_zero>
80006eca:	30 08       	mov	r8,0
80006ecc:	20 25       	sub	r5,2
80006ece:	0a 16       	sub	r6,r5
80006ed0:	c8 8b       	rjmp	80006de0 <__avr32_f64_mul+0x30>

80006ed2 <__avr32_f64_mul_op_nan_or_inf>:
80006ed2:	e4 19 00 0f 	andh	r9,0xf
80006ed6:	e4 1b 00 0f 	andh	r11,0xf
80006eda:	14 4b       	or	r11,r10
80006edc:	10 49       	or	r9,r8
80006ede:	e0 47 07 ff 	cp.w	r7,2047
80006ee2:	c0 91       	brne	80006ef4 <__avr32_f64_mul_op1_not_naninf>
80006ee4:	58 0b       	cp.w	r11,0
80006ee6:	c3 81       	brne	80006f56 <__avr32_f64_mul_res_nan>
80006ee8:	e0 46 07 ff 	cp.w	r6,2047
80006eec:	c3 81       	brne	80006f5c <__avr32_f64_mul_res_inf>
80006eee:	58 09       	cp.w	r9,0
80006ef0:	c3 60       	breq	80006f5c <__avr32_f64_mul_res_inf>
80006ef2:	c3 28       	rjmp	80006f56 <__avr32_f64_mul_res_nan>

80006ef4 <__avr32_f64_mul_op1_not_naninf>:
80006ef4:	58 09       	cp.w	r9,0
80006ef6:	c3 30       	breq	80006f5c <__avr32_f64_mul_res_inf>
80006ef8:	c2 f8       	rjmp	80006f56 <__avr32_f64_mul_res_nan>

80006efa <__avr32_f64_mul_res_subnormal>:
80006efa:	5c 3c       	neg	r12
80006efc:	2f fc       	sub	r12,-1
80006efe:	f1 bc 04 c0 	satu	r12,0x6
80006f02:	e0 4c 00 20 	cp.w	r12,32
80006f06:	c1 14       	brge	80006f28 <__avr32_f64_mul_res_subnormal+0x2e>
80006f08:	f8 08 11 20 	rsub	r8,r12,32
80006f0c:	0e 46       	or	r6,r7
80006f0e:	ee 0c 0a 47 	lsr	r7,r7,r12
80006f12:	f4 08 09 49 	lsl	r9,r10,r8
80006f16:	12 47       	or	r7,r9
80006f18:	f4 0c 0a 4a 	lsr	r10,r10,r12
80006f1c:	f6 08 09 49 	lsl	r9,r11,r8
80006f20:	12 4a       	or	r10,r9
80006f22:	f6 0c 0a 4b 	lsr	r11,r11,r12
80006f26:	c8 3b       	rjmp	80006e2c <__avr32_f64_mul+0x7c>
80006f28:	f8 08 11 20 	rsub	r8,r12,32
80006f2c:	f9 b9 00 00 	moveq	r9,0
80006f30:	c0 30       	breq	80006f36 <__avr32_f64_mul_res_subnormal+0x3c>
80006f32:	f6 08 09 49 	lsl	r9,r11,r8
80006f36:	0e 46       	or	r6,r7
80006f38:	ed ea 10 16 	or	r6,r6,r10<<0x1
80006f3c:	f4 0c 0a 4a 	lsr	r10,r10,r12
80006f40:	f3 ea 10 07 	or	r7,r9,r10
80006f44:	f6 0c 0a 4a 	lsr	r10,r11,r12
80006f48:	30 0b       	mov	r11,0
80006f4a:	c7 1b       	rjmp	80006e2c <__avr32_f64_mul+0x7c>

80006f4c <__avr32_f64_mul_res_zero>:
80006f4c:	1c 9b       	mov	r11,lr
80006f4e:	e6 1b 80 00 	andh	r11,0x8000,COH
80006f52:	30 0a       	mov	r10,0
80006f54:	d8 22       	popm	r4-r7,pc

80006f56 <__avr32_f64_mul_res_nan>:
80006f56:	3f fb       	mov	r11,-1
80006f58:	3f fa       	mov	r10,-1
80006f5a:	d8 22       	popm	r4-r7,pc

80006f5c <__avr32_f64_mul_res_inf>:
80006f5c:	f0 6b 00 00 	mov	r11,-1048576
80006f60:	ed be 00 1f 	bld	lr,0x1f
80006f64:	ef bb 00 1f 	bst	r11,0x1f
80006f68:	30 0a       	mov	r10,0
80006f6a:	d8 22       	popm	r4-r7,pc

80006f6c <__avr32_f64_mul_op1_zero>:
80006f6c:	f7 e9 20 0b 	eor	r11,r11,r9
80006f70:	e6 1b 80 00 	andh	r11,0x8000,COH
80006f74:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
80006f78:	e0 4c 07 ff 	cp.w	r12,2047
80006f7c:	5e 1c       	retne	r12
80006f7e:	3f fa       	mov	r10,-1
80006f80:	3f fb       	mov	r11,-1
80006f82:	5e fc       	retal	r12

80006f84 <__avr32_f64_sub_from_add>:
80006f84:	ee 19 80 00 	eorh	r9,0x8000

80006f88 <__avr32_f64_sub>:
80006f88:	f7 e9 20 0c 	eor	r12,r11,r9
80006f8c:	e0 86 00 ca 	brmi	80007120 <__avr32_f64_add_from_sub>
80006f90:	eb cd 40 e0 	pushm	r5-r7,lr
80006f94:	16 9c       	mov	r12,r11
80006f96:	e6 1c 80 00 	andh	r12,0x8000,COH
80006f9a:	bf db       	cbr	r11,0x1f
80006f9c:	bf d9       	cbr	r9,0x1f
80006f9e:	10 3a       	cp.w	r10,r8
80006fa0:	f2 0b 13 00 	cpc	r11,r9
80006fa4:	c0 92       	brcc	80006fb6 <__avr32_f64_sub+0x2e>
80006fa6:	16 97       	mov	r7,r11
80006fa8:	12 9b       	mov	r11,r9
80006faa:	0e 99       	mov	r9,r7
80006fac:	14 97       	mov	r7,r10
80006fae:	10 9a       	mov	r10,r8
80006fb0:	0e 98       	mov	r8,r7
80006fb2:	ee 1c 80 00 	eorh	r12,0x8000
80006fb6:	f6 07 16 14 	lsr	r7,r11,0x14
80006fba:	ab 7b       	lsl	r11,0xb
80006fbc:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
80006fc0:	ab 7a       	lsl	r10,0xb
80006fc2:	bf bb       	sbr	r11,0x1f
80006fc4:	f2 06 16 14 	lsr	r6,r9,0x14
80006fc8:	c4 40       	breq	80007050 <__avr32_f64_sub_opL_subnormal>
80006fca:	ab 79       	lsl	r9,0xb
80006fcc:	f3 e8 13 59 	or	r9,r9,r8>>0x15
80006fd0:	ab 78       	lsl	r8,0xb
80006fd2:	bf b9       	sbr	r9,0x1f

80006fd4 <__avr32_f64_sub_opL_subnormal_done>:
80006fd4:	e0 47 07 ff 	cp.w	r7,2047
80006fd8:	c4 f0       	breq	80007076 <__avr32_f64_sub_opH_nan_or_inf>
80006fda:	0e 26       	rsub	r6,r7
80006fdc:	c1 20       	breq	80007000 <__avr32_f64_sub_shift_done>
80006fde:	ec 05 11 20 	rsub	r5,r6,32
80006fe2:	e0 46 00 20 	cp.w	r6,32
80006fe6:	c7 c2       	brcc	800070de <__avr32_f64_sub_longshift>
80006fe8:	f0 05 09 4e 	lsl	lr,r8,r5
80006fec:	f2 05 09 45 	lsl	r5,r9,r5
80006ff0:	f0 06 0a 48 	lsr	r8,r8,r6
80006ff4:	f2 06 0a 49 	lsr	r9,r9,r6
80006ff8:	0a 48       	or	r8,r5
80006ffa:	58 0e       	cp.w	lr,0
80006ffc:	5f 1e       	srne	lr
80006ffe:	1c 48       	or	r8,lr

80007000 <__avr32_f64_sub_shift_done>:
80007000:	10 1a       	sub	r10,r8
80007002:	f6 09 01 4b 	sbc	r11,r11,r9
80007006:	f6 06 12 00 	clz	r6,r11
8000700a:	c0 e0       	breq	80007026 <__avr32_f64_sub_longnormalize_done>
8000700c:	c7 83       	brcs	800070fc <__avr32_f64_sub_longnormalize>
8000700e:	ec 0e 11 20 	rsub	lr,r6,32
80007012:	f6 06 09 4b 	lsl	r11,r11,r6
80007016:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000701a:	1c 4b       	or	r11,lr
8000701c:	f4 06 09 4a 	lsl	r10,r10,r6
80007020:	0c 17       	sub	r7,r6
80007022:	e0 8a 00 39 	brle	80007094 <__avr32_f64_sub_subnormal_result>

80007026 <__avr32_f64_sub_longnormalize_done>:
80007026:	f4 09 15 15 	lsl	r9,r10,0x15
8000702a:	ab 9a       	lsr	r10,0xb
8000702c:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
80007030:	ab 9b       	lsr	r11,0xb
80007032:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
80007036:	18 4b       	or	r11,r12

80007038 <__avr32_f64_sub_round>:
80007038:	fc 17 80 00 	movh	r7,0x8000
8000703c:	ed ba 00 00 	bld	r10,0x0
80007040:	f7 b7 01 ff 	subne	r7,-1
80007044:	0e 39       	cp.w	r9,r7
80007046:	5f 29       	srhs	r9
80007048:	12 0a       	add	r10,r9
8000704a:	5c 0b       	acr	r11
8000704c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80007050 <__avr32_f64_sub_opL_subnormal>:
80007050:	ab 79       	lsl	r9,0xb
80007052:	f3 e8 13 59 	or	r9,r9,r8>>0x15
80007056:	ab 78       	lsl	r8,0xb
80007058:	f3 e8 10 0e 	or	lr,r9,r8
8000705c:	f9 b6 01 01 	movne	r6,1
80007060:	ee 0e 11 00 	rsub	lr,r7,0
80007064:	f9 b7 00 01 	moveq	r7,1
80007068:	ef bb 00 1f 	bst	r11,0x1f
8000706c:	f7 ea 10 0e 	or	lr,r11,r10
80007070:	f9 b7 00 00 	moveq	r7,0
80007074:	cb 0b       	rjmp	80006fd4 <__avr32_f64_sub_opL_subnormal_done>

80007076 <__avr32_f64_sub_opH_nan_or_inf>:
80007076:	bf db       	cbr	r11,0x1f
80007078:	f7 ea 10 0e 	or	lr,r11,r10
8000707c:	c0 81       	brne	8000708c <__avr32_f64_sub_return_nan>
8000707e:	e0 46 07 ff 	cp.w	r6,2047
80007082:	c0 50       	breq	8000708c <__avr32_f64_sub_return_nan>
80007084:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
80007088:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000708c <__avr32_f64_sub_return_nan>:
8000708c:	3f fa       	mov	r10,-1
8000708e:	3f fb       	mov	r11,-1
80007090:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80007094 <__avr32_f64_sub_subnormal_result>:
80007094:	5c 37       	neg	r7
80007096:	2f f7       	sub	r7,-1
80007098:	f1 b7 04 c0 	satu	r7,0x6
8000709c:	e0 47 00 20 	cp.w	r7,32
800070a0:	c1 14       	brge	800070c2 <__avr32_f64_sub_subnormal_result+0x2e>
800070a2:	ee 08 11 20 	rsub	r8,r7,32
800070a6:	f4 08 09 49 	lsl	r9,r10,r8
800070aa:	5f 16       	srne	r6
800070ac:	f4 07 0a 4a 	lsr	r10,r10,r7
800070b0:	0c 4a       	or	r10,r6
800070b2:	f6 08 09 49 	lsl	r9,r11,r8
800070b6:	f5 e9 10 0a 	or	r10,r10,r9
800070ba:	f4 07 0a 4b 	lsr	r11,r10,r7
800070be:	30 07       	mov	r7,0
800070c0:	cb 3b       	rjmp	80007026 <__avr32_f64_sub_longnormalize_done>
800070c2:	ee 08 11 40 	rsub	r8,r7,64
800070c6:	f6 08 09 49 	lsl	r9,r11,r8
800070ca:	14 49       	or	r9,r10
800070cc:	5f 16       	srne	r6
800070ce:	f6 07 0a 4a 	lsr	r10,r11,r7
800070d2:	0c 4a       	or	r10,r6
800070d4:	30 0b       	mov	r11,0
800070d6:	30 07       	mov	r7,0
800070d8:	ca 7b       	rjmp	80007026 <__avr32_f64_sub_longnormalize_done>
800070da:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

800070de <__avr32_f64_sub_longshift>:
800070de:	f1 b6 04 c0 	satu	r6,0x6
800070e2:	f0 0e 17 00 	moveq	lr,r8
800070e6:	c0 40       	breq	800070ee <__avr32_f64_sub_longshift+0x10>
800070e8:	f2 05 09 4e 	lsl	lr,r9,r5
800070ec:	10 4e       	or	lr,r8
800070ee:	f2 06 0a 48 	lsr	r8,r9,r6
800070f2:	30 09       	mov	r9,0
800070f4:	58 0e       	cp.w	lr,0
800070f6:	5f 1e       	srne	lr
800070f8:	1c 48       	or	r8,lr
800070fa:	c8 3b       	rjmp	80007000 <__avr32_f64_sub_shift_done>

800070fc <__avr32_f64_sub_longnormalize>:
800070fc:	f4 06 12 00 	clz	r6,r10
80007100:	f9 b7 03 00 	movlo	r7,0
80007104:	f9 b6 03 00 	movlo	r6,0
80007108:	f9 bc 03 00 	movlo	r12,0
8000710c:	f7 b6 02 e0 	subhs	r6,-32
80007110:	f4 06 09 4b 	lsl	r11,r10,r6
80007114:	30 0a       	mov	r10,0
80007116:	0c 17       	sub	r7,r6
80007118:	fe 9a ff be 	brle	80007094 <__avr32_f64_sub_subnormal_result>
8000711c:	c8 5b       	rjmp	80007026 <__avr32_f64_sub_longnormalize_done>
8000711e:	d7 03       	nop

80007120 <__avr32_f64_add_from_sub>:
80007120:	ee 19 80 00 	eorh	r9,0x8000

80007124 <__avr32_f64_add>:
80007124:	f7 e9 20 0c 	eor	r12,r11,r9
80007128:	fe 96 ff 2e 	brmi	80006f84 <__avr32_f64_sub_from_add>
8000712c:	eb cd 40 e0 	pushm	r5-r7,lr
80007130:	16 9c       	mov	r12,r11
80007132:	e6 1c 80 00 	andh	r12,0x8000,COH
80007136:	bf db       	cbr	r11,0x1f
80007138:	bf d9       	cbr	r9,0x1f
8000713a:	12 3b       	cp.w	r11,r9
8000713c:	c0 72       	brcc	8000714a <__avr32_f64_add+0x26>
8000713e:	16 97       	mov	r7,r11
80007140:	12 9b       	mov	r11,r9
80007142:	0e 99       	mov	r9,r7
80007144:	14 97       	mov	r7,r10
80007146:	10 9a       	mov	r10,r8
80007148:	0e 98       	mov	r8,r7
8000714a:	30 0e       	mov	lr,0
8000714c:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
80007150:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
80007154:	b5 ab       	sbr	r11,0x14
80007156:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000715a:	c6 20       	breq	8000721e <__avr32_f64_add_op2_subnormal>
8000715c:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
80007160:	b5 a9       	sbr	r9,0x14
80007162:	e0 47 07 ff 	cp.w	r7,2047
80007166:	c2 80       	breq	800071b6 <__avr32_f64_add_opH_nan_or_inf>
80007168:	0e 26       	rsub	r6,r7
8000716a:	c1 20       	breq	8000718e <__avr32_f64_add_shift_done>
8000716c:	e0 46 00 36 	cp.w	r6,54
80007170:	c1 52       	brcc	8000719a <__avr32_f64_add_res_of_done>
80007172:	ec 05 11 20 	rsub	r5,r6,32
80007176:	e0 46 00 20 	cp.w	r6,32
8000717a:	c3 52       	brcc	800071e4 <__avr32_f64_add_longshift>
8000717c:	f0 05 09 4e 	lsl	lr,r8,r5
80007180:	f2 05 09 45 	lsl	r5,r9,r5
80007184:	f0 06 0a 48 	lsr	r8,r8,r6
80007188:	f2 06 0a 49 	lsr	r9,r9,r6
8000718c:	0a 48       	or	r8,r5

8000718e <__avr32_f64_add_shift_done>:
8000718e:	10 0a       	add	r10,r8
80007190:	f6 09 00 4b 	adc	r11,r11,r9
80007194:	ed bb 00 15 	bld	r11,0x15
80007198:	c3 40       	breq	80007200 <__avr32_f64_add_res_of>

8000719a <__avr32_f64_add_res_of_done>:
8000719a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000719e:	18 4b       	or	r11,r12

800071a0 <__avr32_f64_add_round>:
800071a0:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
800071a4:	18 4e       	or	lr,r12
800071a6:	ee 1e 80 00 	eorh	lr,0x8000
800071aa:	f1 be 04 20 	satu	lr,0x1
800071ae:	1c 0a       	add	r10,lr
800071b0:	5c 0b       	acr	r11
800071b2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

800071b6 <__avr32_f64_add_opH_nan_or_inf>:
800071b6:	b5 cb       	cbr	r11,0x14
800071b8:	f7 ea 10 0e 	or	lr,r11,r10
800071bc:	c1 01       	brne	800071dc <__avr32_f64_add_return_nan>
800071be:	e0 46 07 ff 	cp.w	r6,2047
800071c2:	c0 30       	breq	800071c8 <__avr32_f64_add_opL_nan_or_inf>
800071c4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

800071c8 <__avr32_f64_add_opL_nan_or_inf>:
800071c8:	b5 c9       	cbr	r9,0x14
800071ca:	f3 e8 10 0e 	or	lr,r9,r8
800071ce:	c0 71       	brne	800071dc <__avr32_f64_add_return_nan>
800071d0:	30 0a       	mov	r10,0
800071d2:	fc 1b 7f f0 	movh	r11,0x7ff0
800071d6:	18 4b       	or	r11,r12
800071d8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

800071dc <__avr32_f64_add_return_nan>:
800071dc:	3f fa       	mov	r10,-1
800071de:	3f fb       	mov	r11,-1
800071e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

800071e4 <__avr32_f64_add_longshift>:
800071e4:	f1 b6 04 c0 	satu	r6,0x6
800071e8:	f0 0e 17 00 	moveq	lr,r8
800071ec:	c0 60       	breq	800071f8 <__avr32_f64_add_longshift+0x14>
800071ee:	f2 05 09 4e 	lsl	lr,r9,r5
800071f2:	58 08       	cp.w	r8,0
800071f4:	5f 18       	srne	r8
800071f6:	10 4e       	or	lr,r8
800071f8:	f2 06 0a 48 	lsr	r8,r9,r6
800071fc:	30 09       	mov	r9,0
800071fe:	cc 8b       	rjmp	8000718e <__avr32_f64_add_shift_done>

80007200 <__avr32_f64_add_res_of>:
80007200:	fd ee 10 1e 	or	lr,lr,lr<<0x1
80007204:	a1 9b       	lsr	r11,0x1
80007206:	5d 0a       	ror	r10
80007208:	5d 0e       	ror	lr
8000720a:	2f f7       	sub	r7,-1
8000720c:	e0 47 07 ff 	cp.w	r7,2047
80007210:	f9 ba 00 00 	moveq	r10,0
80007214:	f9 bb 00 00 	moveq	r11,0
80007218:	f9 be 00 00 	moveq	lr,0
8000721c:	cb fb       	rjmp	8000719a <__avr32_f64_add_res_of_done>

8000721e <__avr32_f64_add_op2_subnormal>:
8000721e:	30 16       	mov	r6,1
80007220:	58 07       	cp.w	r7,0
80007222:	ca 01       	brne	80007162 <__avr32_f64_add+0x3e>
80007224:	b5 cb       	cbr	r11,0x14
80007226:	10 0a       	add	r10,r8
80007228:	f6 09 00 4b 	adc	r11,r11,r9
8000722c:	18 4b       	or	r11,r12
8000722e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80007232:	d7 03       	nop

80007234 <__avr32_u32_to_f64>:
80007234:	f8 cb 00 00 	sub	r11,r12,0
80007238:	30 0c       	mov	r12,0
8000723a:	c0 38       	rjmp	80007240 <__avr32_s32_to_f64+0x4>

8000723c <__avr32_s32_to_f64>:
8000723c:	18 9b       	mov	r11,r12
8000723e:	5c 4b       	abs	r11
80007240:	30 0a       	mov	r10,0
80007242:	5e 0b       	reteq	r11
80007244:	d4 01       	pushm	lr
80007246:	e0 69 04 1e 	mov	r9,1054
8000724a:	f6 08 12 00 	clz	r8,r11
8000724e:	c1 70       	breq	8000727c <__avr32_s32_to_f64+0x40>
80007250:	c0 c3       	brcs	80007268 <__avr32_s32_to_f64+0x2c>
80007252:	f0 0e 11 20 	rsub	lr,r8,32
80007256:	f6 08 09 4b 	lsl	r11,r11,r8
8000725a:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000725e:	1c 4b       	or	r11,lr
80007260:	f4 08 09 4a 	lsl	r10,r10,r8
80007264:	10 19       	sub	r9,r8
80007266:	c0 b8       	rjmp	8000727c <__avr32_s32_to_f64+0x40>
80007268:	f4 08 12 00 	clz	r8,r10
8000726c:	f9 b8 03 00 	movlo	r8,0
80007270:	f7 b8 02 e0 	subhs	r8,-32
80007274:	f4 08 09 4b 	lsl	r11,r10,r8
80007278:	30 0a       	mov	r10,0
8000727a:	10 19       	sub	r9,r8
8000727c:	58 09       	cp.w	r9,0
8000727e:	e0 89 00 30 	brgt	800072de <__avr32_s32_to_f64+0xa2>
80007282:	5c 39       	neg	r9
80007284:	2f f9       	sub	r9,-1
80007286:	e0 49 00 36 	cp.w	r9,54
8000728a:	c0 43       	brcs	80007292 <__avr32_s32_to_f64+0x56>
8000728c:	30 0b       	mov	r11,0
8000728e:	30 0a       	mov	r10,0
80007290:	c2 68       	rjmp	800072dc <__avr32_s32_to_f64+0xa0>
80007292:	2f 69       	sub	r9,-10
80007294:	f2 08 11 20 	rsub	r8,r9,32
80007298:	e0 49 00 20 	cp.w	r9,32
8000729c:	c0 b2       	brcc	800072b2 <__avr32_s32_to_f64+0x76>
8000729e:	f4 08 09 4e 	lsl	lr,r10,r8
800072a2:	f6 08 09 48 	lsl	r8,r11,r8
800072a6:	f4 09 0a 4a 	lsr	r10,r10,r9
800072aa:	f6 09 0a 4b 	lsr	r11,r11,r9
800072ae:	10 4b       	or	r11,r8
800072b0:	c0 88       	rjmp	800072c0 <__avr32_s32_to_f64+0x84>
800072b2:	f6 08 09 4e 	lsl	lr,r11,r8
800072b6:	14 4e       	or	lr,r10
800072b8:	16 9a       	mov	r10,r11
800072ba:	30 0b       	mov	r11,0
800072bc:	f4 09 0a 4a 	lsr	r10,r10,r9
800072c0:	ed ba 00 00 	bld	r10,0x0
800072c4:	c0 92       	brcc	800072d6 <__avr32_s32_to_f64+0x9a>
800072c6:	1c 7e       	tst	lr,lr
800072c8:	c0 41       	brne	800072d0 <__avr32_s32_to_f64+0x94>
800072ca:	ed ba 00 01 	bld	r10,0x1
800072ce:	c0 42       	brcc	800072d6 <__avr32_s32_to_f64+0x9a>
800072d0:	2f fa       	sub	r10,-1
800072d2:	f7 bb 02 ff 	subhs	r11,-1
800072d6:	5c fc       	rol	r12
800072d8:	5d 0b       	ror	r11
800072da:	5d 0a       	ror	r10
800072dc:	d8 02       	popm	pc
800072de:	e0 68 03 ff 	mov	r8,1023
800072e2:	ed ba 00 0b 	bld	r10,0xb
800072e6:	f7 b8 00 ff 	subeq	r8,-1
800072ea:	10 0a       	add	r10,r8
800072ec:	5c 0b       	acr	r11
800072ee:	f7 b9 03 fe 	sublo	r9,-2
800072f2:	e0 49 07 ff 	cp.w	r9,2047
800072f6:	c0 55       	brlt	80007300 <__avr32_s32_to_f64+0xc4>
800072f8:	30 0a       	mov	r10,0
800072fa:	fc 1b ff e0 	movh	r11,0xffe0
800072fe:	c0 c8       	rjmp	80007316 <__floatsidf_return_op1>
80007300:	ed bb 00 1f 	bld	r11,0x1f
80007304:	f7 b9 01 01 	subne	r9,1
80007308:	ab 9a       	lsr	r10,0xb
8000730a:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000730e:	a1 7b       	lsl	r11,0x1
80007310:	ab 9b       	lsr	r11,0xb
80007312:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

80007316 <__floatsidf_return_op1>:
80007316:	a1 7c       	lsl	r12,0x1
80007318:	5d 0b       	ror	r11
8000731a:	d8 02       	popm	pc

8000731c <__avr32_f64_cmp_lt>:
8000731c:	1a de       	st.w	--sp,lr
8000731e:	1a d7       	st.w	--sp,r7
80007320:	a1 7b       	lsl	r11,0x1
80007322:	5f 3c       	srlo	r12
80007324:	a1 79       	lsl	r9,0x1
80007326:	5f 37       	srlo	r7
80007328:	5c fc       	rol	r12
8000732a:	fc 1e ff e0 	movh	lr,0xffe0
8000732e:	58 0a       	cp.w	r10,0
80007330:	fc 0b 13 00 	cpc	r11,lr
80007334:	e0 8b 00 1d 	brhi	8000736e <__avr32_f64_cmp_lt+0x52>
80007338:	58 08       	cp.w	r8,0
8000733a:	fc 09 13 00 	cpc	r9,lr
8000733e:	e0 8b 00 18 	brhi	8000736e <__avr32_f64_cmp_lt+0x52>
80007342:	58 0b       	cp.w	r11,0
80007344:	f5 ba 00 00 	subfeq	r10,0
80007348:	c1 50       	breq	80007372 <__avr32_f64_cmp_lt+0x56>
8000734a:	1b 07       	ld.w	r7,sp++
8000734c:	1b 0e       	ld.w	lr,sp++
8000734e:	58 3c       	cp.w	r12,3
80007350:	c0 a0       	breq	80007364 <__avr32_f64_cmp_lt+0x48>
80007352:	58 1c       	cp.w	r12,1
80007354:	c0 33       	brcs	8000735a <__avr32_f64_cmp_lt+0x3e>
80007356:	5e 0d       	reteq	0
80007358:	5e 1f       	retne	1
8000735a:	10 3a       	cp.w	r10,r8
8000735c:	f2 0b 13 00 	cpc	r11,r9
80007360:	5e 2d       	reths	0
80007362:	5e 3f       	retlo	1
80007364:	14 38       	cp.w	r8,r10
80007366:	f6 09 13 00 	cpc	r9,r11
8000736a:	5e 2d       	reths	0
8000736c:	5e 3f       	retlo	1
8000736e:	1b 07       	ld.w	r7,sp++
80007370:	d8 0a       	popm	pc,r12=0
80007372:	58 17       	cp.w	r7,1
80007374:	5f 1c       	srne	r12
80007376:	58 09       	cp.w	r9,0
80007378:	f5 b8 00 00 	subfeq	r8,0
8000737c:	1b 07       	ld.w	r7,sp++
8000737e:	1b 0e       	ld.w	lr,sp++
80007380:	5e 0d       	reteq	0
80007382:	5e fc       	retal	r12

80007384 <__avr32_f32_cmp_ge>:
80007384:	f8 0a 15 01 	lsl	r10,r12,0x1
80007388:	f6 09 15 01 	lsl	r9,r11,0x1
8000738c:	f5 ba 00 00 	subfeq	r10,0
80007390:	5e 0f       	reteq	1
80007392:	fc 18 ff 00 	movh	r8,0xff00
80007396:	10 3a       	cp.w	r10,r8
80007398:	5e bd       	rethi	0
8000739a:	10 39       	cp.w	r9,r8
8000739c:	5e bd       	rethi	0
8000739e:	f7 ec 20 08 	eor	r8,r11,r12
800073a2:	ed bc 00 1f 	bld	r12,0x1f
800073a6:	5f 28       	srhs	r8
800073a8:	5e 68       	retmi	r8
800073aa:	c0 43       	brcs	800073b2 <__avr32_f32_cmp_ge+0x2e>
800073ac:	16 3c       	cp.w	r12,r11
800073ae:	5e 2f       	reths	1
800073b0:	5e 3d       	retlo	0
800073b2:	18 3b       	cp.w	r11,r12
800073b4:	5e 2f       	reths	1
800073b6:	5e 3d       	retlo	0

800073b8 <__avr32_f64_div>:
800073b8:	eb cd 40 ff 	pushm	r0-r7,lr
800073bc:	f7 e9 20 0e 	eor	lr,r11,r9
800073c0:	f6 07 16 14 	lsr	r7,r11,0x14
800073c4:	a9 7b       	lsl	r11,0x9
800073c6:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
800073ca:	a9 7a       	lsl	r10,0x9
800073cc:	bd bb       	sbr	r11,0x1d
800073ce:	e4 1b 3f ff 	andh	r11,0x3fff
800073d2:	ab d7       	cbr	r7,0xb
800073d4:	e0 80 00 cc 	breq	8000756c <__avr32_f64_div_round_subnormal+0x54>
800073d8:	e0 47 07 ff 	cp.w	r7,2047
800073dc:	e0 84 00 b5 	brge	80007546 <__avr32_f64_div_round_subnormal+0x2e>
800073e0:	f2 06 16 14 	lsr	r6,r9,0x14
800073e4:	a9 79       	lsl	r9,0x9
800073e6:	f3 e8 13 79 	or	r9,r9,r8>>0x17
800073ea:	a9 78       	lsl	r8,0x9
800073ec:	bd b9       	sbr	r9,0x1d
800073ee:	e4 19 3f ff 	andh	r9,0x3fff
800073f2:	ab d6       	cbr	r6,0xb
800073f4:	e0 80 00 e2 	breq	800075b8 <__avr32_f64_div_round_subnormal+0xa0>
800073f8:	e0 46 07 ff 	cp.w	r6,2047
800073fc:	e0 84 00 b2 	brge	80007560 <__avr32_f64_div_round_subnormal+0x48>
80007400:	0c 17       	sub	r7,r6
80007402:	fe 37 fc 01 	sub	r7,-1023
80007406:	fc 1c 80 00 	movh	r12,0x8000
8000740a:	f8 03 16 01 	lsr	r3,r12,0x1
8000740e:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
80007412:	5c d4       	com	r4
80007414:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
80007418:	e6 09 06 44 	mulu.d	r4,r3,r9
8000741c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
80007420:	e6 05 06 44 	mulu.d	r4,r3,r5
80007424:	ea 03 15 02 	lsl	r3,r5,0x2
80007428:	e6 09 06 44 	mulu.d	r4,r3,r9
8000742c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
80007430:	e6 05 06 44 	mulu.d	r4,r3,r5
80007434:	ea 03 15 02 	lsl	r3,r5,0x2
80007438:	e6 09 06 44 	mulu.d	r4,r3,r9
8000743c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
80007440:	e6 05 06 44 	mulu.d	r4,r3,r5
80007444:	ea 03 15 02 	lsl	r3,r5,0x2
80007448:	e6 08 06 40 	mulu.d	r0,r3,r8
8000744c:	e4 09 07 40 	macu.d	r0,r2,r9
80007450:	e6 09 06 44 	mulu.d	r4,r3,r9
80007454:	02 04       	add	r4,r1
80007456:	5c 05       	acr	r5
80007458:	a3 65       	lsl	r5,0x2
8000745a:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000745e:	a3 64       	lsl	r4,0x2
80007460:	5c 34       	neg	r4
80007462:	f8 05 01 45 	sbc	r5,r12,r5
80007466:	e6 04 06 40 	mulu.d	r0,r3,r4
8000746a:	e4 05 07 40 	macu.d	r0,r2,r5
8000746e:	e6 05 06 44 	mulu.d	r4,r3,r5
80007472:	02 04       	add	r4,r1
80007474:	5c 05       	acr	r5
80007476:	ea 03 15 02 	lsl	r3,r5,0x2
8000747a:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000747e:	e8 02 15 02 	lsl	r2,r4,0x2
80007482:	e6 08 06 40 	mulu.d	r0,r3,r8
80007486:	e4 09 07 40 	macu.d	r0,r2,r9
8000748a:	e6 09 06 44 	mulu.d	r4,r3,r9
8000748e:	02 04       	add	r4,r1
80007490:	5c 05       	acr	r5
80007492:	a3 65       	lsl	r5,0x2
80007494:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
80007498:	a3 64       	lsl	r4,0x2
8000749a:	5c 34       	neg	r4
8000749c:	f8 05 01 45 	sbc	r5,r12,r5
800074a0:	e6 04 06 40 	mulu.d	r0,r3,r4
800074a4:	e4 05 07 40 	macu.d	r0,r2,r5
800074a8:	e6 05 06 44 	mulu.d	r4,r3,r5
800074ac:	02 04       	add	r4,r1
800074ae:	5c 05       	acr	r5
800074b0:	ea 03 15 02 	lsl	r3,r5,0x2
800074b4:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
800074b8:	e8 02 15 02 	lsl	r2,r4,0x2
800074bc:	e6 0a 06 40 	mulu.d	r0,r3,r10
800074c0:	e4 0b 07 40 	macu.d	r0,r2,r11
800074c4:	e6 0b 06 42 	mulu.d	r2,r3,r11
800074c8:	02 02       	add	r2,r1
800074ca:	5c 03       	acr	r3
800074cc:	ed b3 00 1c 	bld	r3,0x1c
800074d0:	c0 90       	breq	800074e2 <__avr32_f64_div+0x12a>
800074d2:	a1 72       	lsl	r2,0x1
800074d4:	5c f3       	rol	r3
800074d6:	20 17       	sub	r7,1
800074d8:	a3 9a       	lsr	r10,0x3
800074da:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
800074de:	a3 9b       	lsr	r11,0x3
800074e0:	c0 58       	rjmp	800074ea <__avr32_f64_div+0x132>
800074e2:	a5 8a       	lsr	r10,0x4
800074e4:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
800074e8:	a5 8b       	lsr	r11,0x4
800074ea:	58 07       	cp.w	r7,0
800074ec:	e0 8a 00 8b 	brle	80007602 <__avr32_f64_div_res_subnormal>
800074f0:	e0 12 ff 00 	andl	r2,0xff00
800074f4:	e8 12 00 80 	orl	r2,0x80
800074f8:	e6 08 06 40 	mulu.d	r0,r3,r8
800074fc:	e4 09 07 40 	macu.d	r0,r2,r9
80007500:	e4 08 06 44 	mulu.d	r4,r2,r8
80007504:	e6 09 06 48 	mulu.d	r8,r3,r9
80007508:	00 05       	add	r5,r0
8000750a:	f0 01 00 48 	adc	r8,r8,r1
8000750e:	5c 09       	acr	r9
80007510:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
80007514:	58 04       	cp.w	r4,0
80007516:	5c 25       	cpc	r5

80007518 <__avr32_f64_div_round_subnormal>:
80007518:	f4 08 13 00 	cpc	r8,r10
8000751c:	f6 09 13 00 	cpc	r9,r11
80007520:	5f 36       	srlo	r6
80007522:	f8 06 17 00 	moveq	r6,r12
80007526:	e4 0a 16 08 	lsr	r10,r2,0x8
8000752a:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000752e:	e6 0b 16 08 	lsr	r11,r3,0x8
80007532:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
80007536:	ed be 00 1f 	bld	lr,0x1f
8000753a:	ef bb 00 1f 	bst	r11,0x1f
8000753e:	0c 0a       	add	r10,r6
80007540:	5c 0b       	acr	r11
80007542:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
80007546:	e4 1b 00 0f 	andh	r11,0xf
8000754a:	14 4b       	or	r11,r10
8000754c:	e0 81 00 a7 	brne	8000769a <__avr32_f64_div_res_subnormal+0x98>
80007550:	f2 06 16 14 	lsr	r6,r9,0x14
80007554:	ab d6       	cbr	r6,0xb
80007556:	e0 46 07 ff 	cp.w	r6,2047
8000755a:	e0 81 00 a4 	brne	800076a2 <__avr32_f64_div_res_subnormal+0xa0>
8000755e:	c9 e8       	rjmp	8000769a <__avr32_f64_div_res_subnormal+0x98>
80007560:	e4 19 00 0f 	andh	r9,0xf
80007564:	10 49       	or	r9,r8
80007566:	e0 81 00 9a 	brne	8000769a <__avr32_f64_div_res_subnormal+0x98>
8000756a:	c9 28       	rjmp	8000768e <__avr32_f64_div_res_subnormal+0x8c>
8000756c:	a3 7b       	lsl	r11,0x3
8000756e:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
80007572:	a3 7a       	lsl	r10,0x3
80007574:	f5 eb 10 04 	or	r4,r10,r11
80007578:	e0 80 00 a0 	breq	800076b8 <__avr32_f64_div_op1_zero>
8000757c:	f6 04 12 00 	clz	r4,r11
80007580:	c1 70       	breq	800075ae <__avr32_f64_div_round_subnormal+0x96>
80007582:	c0 c3       	brcs	8000759a <__avr32_f64_div_round_subnormal+0x82>
80007584:	e8 05 11 20 	rsub	r5,r4,32
80007588:	f6 04 09 4b 	lsl	r11,r11,r4
8000758c:	f4 05 0a 45 	lsr	r5,r10,r5
80007590:	0a 4b       	or	r11,r5
80007592:	f4 04 09 4a 	lsl	r10,r10,r4
80007596:	08 17       	sub	r7,r4
80007598:	c0 b8       	rjmp	800075ae <__avr32_f64_div_round_subnormal+0x96>
8000759a:	f4 04 12 00 	clz	r4,r10
8000759e:	f9 b4 03 00 	movlo	r4,0
800075a2:	f7 b4 02 e0 	subhs	r4,-32
800075a6:	f4 04 09 4b 	lsl	r11,r10,r4
800075aa:	30 0a       	mov	r10,0
800075ac:	08 17       	sub	r7,r4
800075ae:	a3 8a       	lsr	r10,0x2
800075b0:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
800075b4:	a3 8b       	lsr	r11,0x2
800075b6:	c1 1b       	rjmp	800073d8 <__avr32_f64_div+0x20>
800075b8:	a3 79       	lsl	r9,0x3
800075ba:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
800075be:	a3 78       	lsl	r8,0x3
800075c0:	f3 e8 10 04 	or	r4,r9,r8
800075c4:	c6 f0       	breq	800076a2 <__avr32_f64_div_res_subnormal+0xa0>
800075c6:	f2 04 12 00 	clz	r4,r9
800075ca:	c1 70       	breq	800075f8 <__avr32_f64_div_round_subnormal+0xe0>
800075cc:	c0 c3       	brcs	800075e4 <__avr32_f64_div_round_subnormal+0xcc>
800075ce:	e8 05 11 20 	rsub	r5,r4,32
800075d2:	f2 04 09 49 	lsl	r9,r9,r4
800075d6:	f0 05 0a 45 	lsr	r5,r8,r5
800075da:	0a 49       	or	r9,r5
800075dc:	f0 04 09 48 	lsl	r8,r8,r4
800075e0:	08 16       	sub	r6,r4
800075e2:	c0 b8       	rjmp	800075f8 <__avr32_f64_div_round_subnormal+0xe0>
800075e4:	f0 04 12 00 	clz	r4,r8
800075e8:	f9 b4 03 00 	movlo	r4,0
800075ec:	f7 b4 02 e0 	subhs	r4,-32
800075f0:	f0 04 09 49 	lsl	r9,r8,r4
800075f4:	30 08       	mov	r8,0
800075f6:	08 16       	sub	r6,r4
800075f8:	a3 88       	lsr	r8,0x2
800075fa:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
800075fe:	a3 89       	lsr	r9,0x2
80007600:	cf ca       	rjmp	800073f8 <__avr32_f64_div+0x40>

80007602 <__avr32_f64_div_res_subnormal>:
80007602:	5c 37       	neg	r7
80007604:	2f f7       	sub	r7,-1
80007606:	f1 b7 04 c0 	satu	r7,0x6
8000760a:	e0 47 00 20 	cp.w	r7,32
8000760e:	c1 54       	brge	80007638 <__avr32_f64_div_res_subnormal+0x36>
80007610:	ee 06 11 20 	rsub	r6,r7,32
80007614:	e4 07 0a 42 	lsr	r2,r2,r7
80007618:	e6 06 09 4c 	lsl	r12,r3,r6
8000761c:	18 42       	or	r2,r12
8000761e:	e6 07 0a 43 	lsr	r3,r3,r7
80007622:	f4 06 09 41 	lsl	r1,r10,r6
80007626:	f4 07 0a 4a 	lsr	r10,r10,r7
8000762a:	f6 06 09 4c 	lsl	r12,r11,r6
8000762e:	18 4a       	or	r10,r12
80007630:	f6 07 0a 4b 	lsr	r11,r11,r7
80007634:	30 00       	mov	r0,0
80007636:	c1 58       	rjmp	80007660 <__avr32_f64_div_res_subnormal+0x5e>
80007638:	ee 06 11 20 	rsub	r6,r7,32
8000763c:	f9 b0 00 00 	moveq	r0,0
80007640:	f9 bc 00 00 	moveq	r12,0
80007644:	c0 50       	breq	8000764e <__avr32_f64_div_res_subnormal+0x4c>
80007646:	f4 06 09 40 	lsl	r0,r10,r6
8000764a:	f6 06 09 4c 	lsl	r12,r11,r6
8000764e:	e6 07 0a 42 	lsr	r2,r3,r7
80007652:	30 03       	mov	r3,0
80007654:	f4 07 0a 41 	lsr	r1,r10,r7
80007658:	18 41       	or	r1,r12
8000765a:	f6 07 0a 4a 	lsr	r10,r11,r7
8000765e:	30 0b       	mov	r11,0
80007660:	e0 12 ff 00 	andl	r2,0xff00
80007664:	e8 12 00 80 	orl	r2,0x80
80007668:	e6 08 06 46 	mulu.d	r6,r3,r8
8000766c:	e4 09 07 46 	macu.d	r6,r2,r9
80007670:	e4 08 06 44 	mulu.d	r4,r2,r8
80007674:	e6 09 06 48 	mulu.d	r8,r3,r9
80007678:	0c 05       	add	r5,r6
8000767a:	f0 07 00 48 	adc	r8,r8,r7
8000767e:	5c 09       	acr	r9
80007680:	30 07       	mov	r7,0
80007682:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
80007686:	00 34       	cp.w	r4,r0
80007688:	e2 05 13 00 	cpc	r5,r1
8000768c:	c4 6b       	rjmp	80007518 <__avr32_f64_div_round_subnormal>
8000768e:	1c 9b       	mov	r11,lr
80007690:	e6 1b 80 00 	andh	r11,0x8000,COH
80007694:	30 0a       	mov	r10,0
80007696:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000769a:	3f fb       	mov	r11,-1
8000769c:	30 0a       	mov	r10,0
8000769e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
800076a2:	f5 eb 10 04 	or	r4,r10,r11
800076a6:	c0 90       	breq	800076b8 <__avr32_f64_div_op1_zero>
800076a8:	1c 9b       	mov	r11,lr
800076aa:	e6 1b 80 00 	andh	r11,0x8000,COH
800076ae:	ea 1b 7f f0 	orh	r11,0x7ff0
800076b2:	30 0a       	mov	r10,0
800076b4:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

800076b8 <__avr32_f64_div_op1_zero>:
800076b8:	f1 e9 10 15 	or	r5,r8,r9<<0x1
800076bc:	ce f0       	breq	8000769a <__avr32_f64_div_res_subnormal+0x98>
800076be:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
800076c2:	e0 44 07 ff 	cp.w	r4,2047
800076c6:	ce 41       	brne	8000768e <__avr32_f64_div_res_subnormal+0x8c>
800076c8:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
800076cc:	ce 10       	breq	8000768e <__avr32_f64_div_res_subnormal+0x8c>
800076ce:	ce 6b       	rjmp	8000769a <__avr32_f64_div_res_subnormal+0x98>

800076d0 <__avr32_f32_div>:
800076d0:	f7 ec 20 08 	eor	r8,r11,r12
800076d4:	a1 7c       	lsl	r12,0x1
800076d6:	a1 7b       	lsl	r11,0x1
800076d8:	c7 a0       	breq	800077cc <__divsf_return_op1+0x16>
800076da:	18 7c       	tst	r12,r12
800076dc:	f9 b9 00 00 	moveq	r9,0
800076e0:	c0 90       	breq	800076f2 <__avr32_f32_div+0x22>
800076e2:	f8 09 16 18 	lsr	r9,r12,0x18
800076e6:	c7 e0       	breq	800077e2 <__divsf_return_op1+0x2c>
800076e8:	e0 49 00 ff 	cp.w	r9,255
800076ec:	c6 82       	brcc	800077bc <__divsf_return_op1+0x6>
800076ee:	a7 7c       	lsl	r12,0x7
800076f0:	bf bc       	sbr	r12,0x1f
800076f2:	f6 0a 16 18 	lsr	r10,r11,0x18
800076f6:	c7 e0       	breq	800077f2 <__divsf_return_op1+0x3c>
800076f8:	e0 4a 00 ff 	cp.w	r10,255
800076fc:	c6 62       	brcc	800077c8 <__divsf_return_op1+0x12>
800076fe:	a7 7b       	lsl	r11,0x7
80007700:	bf bb       	sbr	r11,0x1f
80007702:	58 09       	cp.w	r9,0
80007704:	f5 bc 00 00 	subfeq	r12,0
80007708:	5e 0d       	reteq	0
8000770a:	1a d5       	st.w	--sp,r5
8000770c:	bb 27       	st.d	--sp,r6
8000770e:	14 19       	sub	r9,r10
80007710:	28 19       	sub	r9,-127
80007712:	fc 1a 80 00 	movh	r10,0x8000
80007716:	a3 8c       	lsr	r12,0x2
80007718:	f6 05 16 02 	lsr	r5,r11,0x2
8000771c:	f4 0b 16 01 	lsr	r11,r10,0x1
80007720:	ed d5 c3 62 	bfextu	r6,r5,0x1b,0x2
80007724:	5c d6       	com	r6
80007726:	f7 d6 d3 82 	bfins	r11,r6,0x1c,0x2
8000772a:	f6 05 06 46 	mulu.d	r6,r11,r5
8000772e:	f4 07 01 27 	sub	r7,r10,r7<<0x2
80007732:	f6 07 06 46 	mulu.d	r6,r11,r7
80007736:	ee 0b 15 02 	lsl	r11,r7,0x2
8000773a:	f6 05 06 46 	mulu.d	r6,r11,r5
8000773e:	f4 07 01 27 	sub	r7,r10,r7<<0x2
80007742:	f6 07 06 46 	mulu.d	r6,r11,r7
80007746:	ee 0b 15 02 	lsl	r11,r7,0x2
8000774a:	f6 05 06 46 	mulu.d	r6,r11,r5
8000774e:	f4 07 01 27 	sub	r7,r10,r7<<0x2
80007752:	f6 07 06 46 	mulu.d	r6,r11,r7
80007756:	ee 0b 15 02 	lsl	r11,r7,0x2
8000775a:	f6 05 06 46 	mulu.d	r6,r11,r5
8000775e:	f4 07 01 27 	sub	r7,r10,r7<<0x2
80007762:	f6 07 06 46 	mulu.d	r6,r11,r7
80007766:	ee 0b 15 02 	lsl	r11,r7,0x2
8000776a:	f6 0c 06 46 	mulu.d	r6,r11,r12
8000776e:	a5 8c       	lsr	r12,0x4
80007770:	ed b7 00 1c 	bld	r7,0x1c
80007774:	c0 40       	breq	8000777c <__avr32_f32_div+0xac>
80007776:	a1 77       	lsl	r7,0x1
80007778:	20 19       	sub	r9,1
8000777a:	a1 7c       	lsl	r12,0x1
8000777c:	58 09       	cp.w	r9,0
8000777e:	e0 8a 00 42 	brle	80007802 <__avr32_f32_div_res_subnormal>
80007782:	e0 17 ff e0 	andl	r7,0xffe0
80007786:	e8 17 00 10 	orl	r7,0x10
8000778a:	ea 07 06 4a 	mulu.d	r10,r5,r7
8000778e:	eb d7 c0 a1 	bfextu	r5,r7,0x5,0x1
80007792:	58 0a       	cp.w	r10,0

80007794 <__avr32_f32_div_round_subnormal>:
80007794:	f8 0b 13 00 	cpc	r11,r12
80007798:	5f 3b       	srlo	r11
8000779a:	ea 0b 17 00 	moveq	r11,r5
8000779e:	ee 0c 16 05 	lsr	r12,r7,0x5
800077a2:	f9 d9 d2 e8 	bfins	r12,r9,0x17,0x8
800077a6:	bb 07       	ld.d	r6,sp++
800077a8:	1b 05       	ld.w	r5,sp++
800077aa:	ed b8 00 1f 	bld	r8,0x1f
800077ae:	ef bc 00 1f 	bst	r12,0x1f
800077b2:	16 0c       	add	r12,r11
800077b4:	5e fc       	retal	r12

800077b6 <__divsf_return_op1>:
800077b6:	a1 78       	lsl	r8,0x1
800077b8:	5d 0c       	ror	r12
800077ba:	5e fc       	retal	r12
800077bc:	5e 1e       	retne	-1
800077be:	fc 19 ff 00 	movh	r9,0xff00
800077c2:	12 3b       	cp.w	r11,r9
800077c4:	cf 93       	brcs	800077b6 <__divsf_return_op1>
800077c6:	5e fe       	retal	-1
800077c8:	5e 0d       	reteq	0
800077ca:	5e fe       	retal	-1
800077cc:	18 7c       	tst	r12,r12
800077ce:	5e 0e       	reteq	-1
800077d0:	f8 09 16 18 	lsr	r9,r12,0x18
800077d4:	c0 70       	breq	800077e2 <__divsf_return_op1+0x2c>
800077d6:	e0 49 00 ff 	cp.w	r9,255
800077da:	cf 12       	brcc	800077bc <__divsf_return_op1+0x6>
800077dc:	fc 1c ff 00 	movh	r12,0xff00
800077e0:	ce bb       	rjmp	800077b6 <__divsf_return_op1>
800077e2:	a7 7c       	lsl	r12,0x7
800077e4:	f8 09 12 00 	clz	r9,r12
800077e8:	f8 09 09 4c 	lsl	r12,r12,r9
800077ec:	f2 09 11 01 	rsub	r9,r9,1
800077f0:	c8 1b       	rjmp	800076f2 <__avr32_f32_div+0x22>
800077f2:	a7 7b       	lsl	r11,0x7
800077f4:	f6 0a 12 00 	clz	r10,r11
800077f8:	f6 0a 09 4b 	lsl	r11,r11,r10
800077fc:	f4 0a 11 01 	rsub	r10,r10,1
80007800:	c8 5b       	rjmp	8000770a <__avr32_f32_div+0x3a>

80007802 <__avr32_f32_div_res_subnormal>:
80007802:	5c 39       	neg	r9
80007804:	2f f9       	sub	r9,-1
80007806:	f1 b9 04 a0 	satu	r9,0x5
8000780a:	f2 0a 11 20 	rsub	r10,r9,32
8000780e:	ee 09 0a 47 	lsr	r7,r7,r9
80007812:	f8 0a 09 46 	lsl	r6,r12,r10
80007816:	f8 09 0a 4c 	lsr	r12,r12,r9
8000781a:	e0 17 ff e0 	andl	r7,0xffe0
8000781e:	e8 17 00 10 	orl	r7,0x10
80007822:	ea 07 06 4a 	mulu.d	r10,r5,r7
80007826:	30 09       	mov	r9,0
80007828:	eb d7 c0 a1 	bfextu	r5,r7,0x5,0x1
8000782c:	0c 3a       	cp.w	r10,r6
8000782e:	cb 3b       	rjmp	80007794 <__avr32_f32_div_round_subnormal>

80007830 <__avr32_f32_mul>:
80007830:	18 98       	mov	r8,r12
80007832:	16 5c       	eor	r12,r11
80007834:	e6 1c 80 00 	andh	r12,0x8000,COH
80007838:	bf d8       	cbr	r8,0x1f
8000783a:	c6 60       	breq	80007906 <__avr32_f32_mul_op1_zero>
8000783c:	bf db       	cbr	r11,0x1f
8000783e:	f0 0b 0c 4a 	max	r10,r8,r11
80007842:	f0 0b 0d 49 	min	r9,r8,r11
80007846:	f4 08 15 08 	lsl	r8,r10,0x8
8000784a:	bf b8       	sbr	r8,0x1f
8000784c:	b7 9a       	lsr	r10,0x17
8000784e:	e0 4a 00 ff 	cp.w	r10,255
80007852:	c3 d0       	breq	800078cc <__avr32_f32_mul_op1_nan_or_inf>
80007854:	f2 0b 15 08 	lsl	r11,r9,0x8
80007858:	bf bb       	sbr	r11,0x1f
8000785a:	b7 99       	lsr	r9,0x17
8000785c:	c2 40       	breq	800078a4 <__avr32_f32_mul_op2_subnormal>
8000785e:	14 09       	add	r9,r10
80007860:	f0 0b 06 4a 	mulu.d	r10,r8,r11
80007864:	f6 08 15 01 	lsl	r8,r11,0x1
80007868:	f0 0b 17 20 	movhs	r11,r8
8000786c:	f7 b9 02 01 	subhs	r9,1
80007870:	a9 8a       	lsr	r10,0x8
80007872:	f5 db d3 08 	bfins	r10,r11,0x18,0x8
80007876:	27 e9       	sub	r9,126
80007878:	e0 8a 00 39 	brle	800078ea <__avr32_f32_mul_res_subnormal>
8000787c:	e0 49 00 ff 	cp.w	r9,255
80007880:	c0 f4       	brge	8000789e <__avr32_f32_mul_round+0x14>
80007882:	f9 eb 12 8c 	or	r12,r12,r11>>0x8
80007886:	f9 d9 d2 e8 	bfins	r12,r9,0x17,0x8

8000788a <__avr32_f32_mul_round>:
8000788a:	fc 18 80 00 	movh	r8,0x8000
8000788e:	ed bc 00 00 	bld	r12,0x0
80007892:	f7 b8 01 ff 	subne	r8,-1
80007896:	10 3a       	cp.w	r10,r8
80007898:	f7 bc 02 ff 	subhs	r12,-1
8000789c:	5e fc       	retal	r12
8000789e:	ea 1c 7f 80 	orh	r12,0x7f80
800078a2:	5e fc       	retal	r12

800078a4 <__avr32_f32_mul_op2_subnormal>:
800078a4:	bf db       	cbr	r11,0x1f
800078a6:	f6 09 12 00 	clz	r9,r11
800078aa:	5e 3d       	retlo	0
800078ac:	20 89       	sub	r9,8
800078ae:	f6 09 09 4b 	lsl	r11,r11,r9
800078b2:	f2 09 11 01 	rsub	r9,r9,1
800078b6:	14 7a       	tst	r10,r10
800078b8:	cd 31       	brne	8000785e <__avr32_f32_mul+0x2e>
800078ba:	bf d8       	cbr	r8,0x1f
800078bc:	f6 0a 12 00 	clz	r10,r11
800078c0:	5e 3d       	retlo	0
800078c2:	f0 0a 09 48 	lsl	r8,r8,r10
800078c6:	f4 0a 11 01 	rsub	r10,r10,1
800078ca:	cc ab       	rjmp	8000785e <__avr32_f32_mul+0x2e>

800078cc <__avr32_f32_mul_op1_nan_or_inf>:
800078cc:	f0 0b 15 01 	lsl	r11,r8,0x1
800078d0:	5e 1e       	retne	-1
800078d2:	12 79       	tst	r9,r9
800078d4:	5e 0e       	reteq	-1
800078d6:	f9 da d2 e8 	bfins	r12,r10,0x17,0x8
800078da:	f2 0b 16 17 	lsr	r11,r9,0x17
800078de:	e0 4b 00 ff 	cp.w	r11,255
800078e2:	5e 1c       	retne	r12
800078e4:	a9 79       	lsl	r9,0x9
800078e6:	5e 0c       	reteq	r12
800078e8:	5e fe       	retal	-1

800078ea <__avr32_f32_mul_res_subnormal>:
800078ea:	f2 09 11 09 	rsub	r9,r9,9
800078ee:	f2 08 11 20 	rsub	r8,r9,32
800078f2:	5e 3d       	retlo	0
800078f4:	f6 09 0a 49 	lsr	r9,r11,r9
800078f8:	12 4c       	or	r12,r9
800078fa:	f6 08 09 4b 	lsl	r11,r11,r8
800078fe:	e4 1a 00 ff 	andh	r10,0xff
80007902:	16 4a       	or	r10,r11
80007904:	cc 3b       	rjmp	8000788a <__avr32_f32_mul_round>

80007906 <__avr32_f32_mul_op1_zero>:
80007906:	f5 db c2 e8 	bfextu	r10,r11,0x17,0x8
8000790a:	e0 4a 00 ff 	cp.w	r10,255
8000790e:	5e 1c       	retne	r12
80007910:	5e 0e       	reteq	-1

80007912 <__avr32_s32_to_f32>:
80007912:	58 0c       	cp.w	r12,0
80007914:	5e 0c       	reteq	r12
80007916:	18 9b       	mov	r11,r12
80007918:	5c 4c       	abs	r12
8000791a:	e0 6a 00 9e 	mov	r10,158
8000791e:	f8 09 12 00 	clz	r9,r12
80007922:	12 1a       	sub	r10,r9
80007924:	f8 09 09 4c 	lsl	r12,r12,r9
80007928:	58 0a       	cp.w	r10,0
8000792a:	e0 8a 00 15 	brle	80007954 <__avr32_s32_to_f32_subnormal>
8000792e:	37 f9       	mov	r9,127
80007930:	ed bc 00 08 	bld	r12,0x8
80007934:	f7 b9 00 ff 	subeq	r9,-1
80007938:	12 0c       	add	r12,r9
8000793a:	f7 ba 03 fe 	sublo	r10,-2
8000793e:	ed bc 00 1f 	bld	r12,0x1f
80007942:	f7 ba 01 01 	subne	r10,1
80007946:	f8 0c 16 07 	lsr	r12,r12,0x7
8000794a:	f9 da d3 08 	bfins	r12,r10,0x18,0x8
8000794e:	a1 7b       	lsl	r11,0x1
80007950:	5d 0c       	ror	r12
80007952:	5e fc       	retal	r12

80007954 <__avr32_s32_to_f32_subnormal>:
80007954:	f4 0a 11 01 	rsub	r10,r10,1
80007958:	59 9a       	cp.w	r10,25
8000795a:	f9 bc 02 00 	movhs	r12,0
8000795e:	c1 32       	brcc	80007984 <__avr32_s32_to_f32_subnormal+0x30>
80007960:	f4 09 11 20 	rsub	r9,r10,32
80007964:	f8 09 09 49 	lsl	r9,r12,r9
80007968:	5f 19       	srne	r9
8000796a:	f8 0a 0a 4c 	lsr	r12,r12,r10
8000796e:	12 4c       	or	r12,r9
80007970:	37 f9       	mov	r9,127
80007972:	ed bc 00 08 	bld	r12,0x8
80007976:	f7 b9 00 ff 	subeq	r9,-1
8000797a:	12 0c       	add	r12,r9
8000797c:	f8 0c 16 07 	lsr	r12,r12,0x7
80007980:	a1 7b       	lsl	r11,0x1
80007982:	5d 0c       	ror	r12
80007984:	5e fc       	retal	r12

80007986 <__avr32_f32_to_s32>:
80007986:	f7 dc c2 e8 	bfextu	r11,r12,0x17,0x8
8000798a:	27 fb       	sub	r11,127
8000798c:	5e 3d       	retlo	0
8000798e:	f6 0b 11 1f 	rsub	r11,r11,31
80007992:	f8 0a 15 08 	lsl	r10,r12,0x8
80007996:	bf ba       	sbr	r10,0x1f
80007998:	f4 0b 0a 4a 	lsr	r10,r10,r11
8000799c:	a1 7c       	lsl	r12,0x1
8000799e:	5e 2a       	reths	r10
800079a0:	5c 3a       	neg	r10
800079a2:	5e fa       	retal	r10

800079a4 <__avr32_f32_to_u32>:
800079a4:	58 0c       	cp.w	r12,0
800079a6:	5e 6d       	retmi	0
800079a8:	f7 dc c2 e8 	bfextu	r11,r12,0x17,0x8
800079ac:	27 fb       	sub	r11,127
800079ae:	5e 3d       	retlo	0
800079b0:	f6 0b 11 1f 	rsub	r11,r11,31
800079b4:	a9 6c       	lsl	r12,0x8
800079b6:	bf bc       	sbr	r12,0x1f
800079b8:	f8 0b 0a 4c 	lsr	r12,r12,r11
800079bc:	5e fc       	retal	r12

800079be <__avr32_udiv64>:
800079be:	d4 31       	pushm	r0-r7,lr
800079c0:	1a 97       	mov	r7,sp
800079c2:	20 3d       	sub	sp,12
800079c4:	10 9c       	mov	r12,r8
800079c6:	12 9e       	mov	lr,r9
800079c8:	14 93       	mov	r3,r10
800079ca:	58 09       	cp.w	r9,0
800079cc:	e0 81 00 bd 	brne	80007b46 <__avr32_udiv64+0x188>
800079d0:	16 38       	cp.w	r8,r11
800079d2:	e0 88 00 40 	brls	80007a52 <__avr32_udiv64+0x94>
800079d6:	f0 08 12 00 	clz	r8,r8
800079da:	c0 d0       	breq	800079f4 <__avr32_udiv64+0x36>
800079dc:	f6 08 09 4b 	lsl	r11,r11,r8
800079e0:	f0 09 11 20 	rsub	r9,r8,32
800079e4:	f8 08 09 4c 	lsl	r12,r12,r8
800079e8:	f4 09 0a 49 	lsr	r9,r10,r9
800079ec:	f4 08 09 43 	lsl	r3,r10,r8
800079f0:	f3 eb 10 0b 	or	r11,r9,r11
800079f4:	f8 0e 16 10 	lsr	lr,r12,0x10
800079f8:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
800079fc:	f6 0e 0d 00 	divu	r0,r11,lr
80007a00:	e6 0b 16 10 	lsr	r11,r3,0x10
80007a04:	00 99       	mov	r9,r0
80007a06:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80007a0a:	e0 0a 02 48 	mul	r8,r0,r10
80007a0e:	10 3b       	cp.w	r11,r8
80007a10:	c0 a2       	brcc	80007a24 <__avr32_udiv64+0x66>
80007a12:	20 19       	sub	r9,1
80007a14:	18 0b       	add	r11,r12
80007a16:	18 3b       	cp.w	r11,r12
80007a18:	c0 63       	brcs	80007a24 <__avr32_udiv64+0x66>
80007a1a:	10 3b       	cp.w	r11,r8
80007a1c:	f7 b9 03 01 	sublo	r9,1
80007a20:	f7 dc e3 0b 	addcs	r11,r11,r12
80007a24:	f6 08 01 01 	sub	r1,r11,r8
80007a28:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
80007a2c:	e2 0e 0d 00 	divu	r0,r1,lr
80007a30:	e7 e1 11 03 	or	r3,r3,r1<<0x10
80007a34:	00 98       	mov	r8,r0
80007a36:	e0 0a 02 4a 	mul	r10,r0,r10
80007a3a:	14 33       	cp.w	r3,r10
80007a3c:	c0 82       	brcc	80007a4c <__avr32_udiv64+0x8e>
80007a3e:	20 18       	sub	r8,1
80007a40:	18 03       	add	r3,r12
80007a42:	18 33       	cp.w	r3,r12
80007a44:	c0 43       	brcs	80007a4c <__avr32_udiv64+0x8e>
80007a46:	14 33       	cp.w	r3,r10
80007a48:	f7 b8 03 01 	sublo	r8,1
80007a4c:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80007a50:	cd f8       	rjmp	80007c0e <__avr32_udiv64+0x250>
80007a52:	58 08       	cp.w	r8,0
80007a54:	c0 51       	brne	80007a5e <__avr32_udiv64+0xa0>
80007a56:	30 19       	mov	r9,1
80007a58:	f2 08 0d 08 	divu	r8,r9,r8
80007a5c:	10 9c       	mov	r12,r8
80007a5e:	f8 06 12 00 	clz	r6,r12
80007a62:	c0 41       	brne	80007a6a <__avr32_udiv64+0xac>
80007a64:	18 1b       	sub	r11,r12
80007a66:	30 19       	mov	r9,1
80007a68:	c4 08       	rjmp	80007ae8 <__avr32_udiv64+0x12a>
80007a6a:	ec 01 11 20 	rsub	r1,r6,32
80007a6e:	f4 01 0a 49 	lsr	r9,r10,r1
80007a72:	f8 06 09 4c 	lsl	r12,r12,r6
80007a76:	f6 06 09 48 	lsl	r8,r11,r6
80007a7a:	f6 01 0a 41 	lsr	r1,r11,r1
80007a7e:	f3 e8 10 08 	or	r8,r9,r8
80007a82:	f8 03 16 10 	lsr	r3,r12,0x10
80007a86:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
80007a8a:	e2 03 0d 00 	divu	r0,r1,r3
80007a8e:	f0 0b 16 10 	lsr	r11,r8,0x10
80007a92:	00 9e       	mov	lr,r0
80007a94:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80007a98:	e0 05 02 49 	mul	r9,r0,r5
80007a9c:	12 3b       	cp.w	r11,r9
80007a9e:	c0 a2       	brcc	80007ab2 <__avr32_udiv64+0xf4>
80007aa0:	20 1e       	sub	lr,1
80007aa2:	18 0b       	add	r11,r12
80007aa4:	18 3b       	cp.w	r11,r12
80007aa6:	c0 63       	brcs	80007ab2 <__avr32_udiv64+0xf4>
80007aa8:	12 3b       	cp.w	r11,r9
80007aaa:	f7 be 03 01 	sublo	lr,1
80007aae:	f7 dc e3 0b 	addcs	r11,r11,r12
80007ab2:	12 1b       	sub	r11,r9
80007ab4:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
80007ab8:	f6 03 0d 02 	divu	r2,r11,r3
80007abc:	f1 e3 11 08 	or	r8,r8,r3<<0x10
80007ac0:	04 99       	mov	r9,r2
80007ac2:	e4 05 02 4b 	mul	r11,r2,r5
80007ac6:	16 38       	cp.w	r8,r11
80007ac8:	c0 a2       	brcc	80007adc <__avr32_udiv64+0x11e>
80007aca:	20 19       	sub	r9,1
80007acc:	18 08       	add	r8,r12
80007ace:	18 38       	cp.w	r8,r12
80007ad0:	c0 63       	brcs	80007adc <__avr32_udiv64+0x11e>
80007ad2:	16 38       	cp.w	r8,r11
80007ad4:	f7 b9 03 01 	sublo	r9,1
80007ad8:	f1 dc e3 08 	addcs	r8,r8,r12
80007adc:	f4 06 09 43 	lsl	r3,r10,r6
80007ae0:	f0 0b 01 0b 	sub	r11,r8,r11
80007ae4:	f3 ee 11 09 	or	r9,r9,lr<<0x10
80007ae8:	f8 06 16 10 	lsr	r6,r12,0x10
80007aec:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
80007af0:	f6 06 0d 00 	divu	r0,r11,r6
80007af4:	e6 0b 16 10 	lsr	r11,r3,0x10
80007af8:	00 9a       	mov	r10,r0
80007afa:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80007afe:	e0 0e 02 48 	mul	r8,r0,lr
80007b02:	10 3b       	cp.w	r11,r8
80007b04:	c0 a2       	brcc	80007b18 <__avr32_udiv64+0x15a>
80007b06:	20 1a       	sub	r10,1
80007b08:	18 0b       	add	r11,r12
80007b0a:	18 3b       	cp.w	r11,r12
80007b0c:	c0 63       	brcs	80007b18 <__avr32_udiv64+0x15a>
80007b0e:	10 3b       	cp.w	r11,r8
80007b10:	f7 ba 03 01 	sublo	r10,1
80007b14:	f7 dc e3 0b 	addcs	r11,r11,r12
80007b18:	f6 08 01 01 	sub	r1,r11,r8
80007b1c:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
80007b20:	e2 06 0d 00 	divu	r0,r1,r6
80007b24:	e7 e1 11 03 	or	r3,r3,r1<<0x10
80007b28:	00 98       	mov	r8,r0
80007b2a:	e0 0e 02 4b 	mul	r11,r0,lr
80007b2e:	16 33       	cp.w	r3,r11
80007b30:	c0 82       	brcc	80007b40 <__avr32_udiv64+0x182>
80007b32:	20 18       	sub	r8,1
80007b34:	18 03       	add	r3,r12
80007b36:	18 33       	cp.w	r3,r12
80007b38:	c0 43       	brcs	80007b40 <__avr32_udiv64+0x182>
80007b3a:	16 33       	cp.w	r3,r11
80007b3c:	f7 b8 03 01 	sublo	r8,1
80007b40:	f1 ea 11 08 	or	r8,r8,r10<<0x10
80007b44:	c6 98       	rjmp	80007c16 <__avr32_udiv64+0x258>
80007b46:	16 39       	cp.w	r9,r11
80007b48:	e0 8b 00 65 	brhi	80007c12 <__avr32_udiv64+0x254>
80007b4c:	f2 09 12 00 	clz	r9,r9
80007b50:	c0 b1       	brne	80007b66 <__avr32_udiv64+0x1a8>
80007b52:	10 3a       	cp.w	r10,r8
80007b54:	5f 2a       	srhs	r10
80007b56:	1c 3b       	cp.w	r11,lr
80007b58:	5f b8       	srhi	r8
80007b5a:	10 4a       	or	r10,r8
80007b5c:	f2 0a 18 00 	cp.b	r10,r9
80007b60:	c5 90       	breq	80007c12 <__avr32_udiv64+0x254>
80007b62:	30 18       	mov	r8,1
80007b64:	c5 98       	rjmp	80007c16 <__avr32_udiv64+0x258>
80007b66:	f0 09 09 46 	lsl	r6,r8,r9
80007b6a:	f2 03 11 20 	rsub	r3,r9,32
80007b6e:	fc 09 09 4e 	lsl	lr,lr,r9
80007b72:	f0 03 0a 48 	lsr	r8,r8,r3
80007b76:	f6 09 09 4c 	lsl	r12,r11,r9
80007b7a:	f4 03 0a 42 	lsr	r2,r10,r3
80007b7e:	ef 46 ff f4 	st.w	r7[-12],r6
80007b82:	f6 03 0a 43 	lsr	r3,r11,r3
80007b86:	18 42       	or	r2,r12
80007b88:	f1 ee 10 0c 	or	r12,r8,lr
80007b8c:	f8 01 16 10 	lsr	r1,r12,0x10
80007b90:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
80007b94:	e6 01 0d 04 	divu	r4,r3,r1
80007b98:	e4 03 16 10 	lsr	r3,r2,0x10
80007b9c:	08 9e       	mov	lr,r4
80007b9e:	e7 e5 11 03 	or	r3,r3,r5<<0x10
80007ba2:	e8 06 02 48 	mul	r8,r4,r6
80007ba6:	10 33       	cp.w	r3,r8
80007ba8:	c0 a2       	brcc	80007bbc <__avr32_udiv64+0x1fe>
80007baa:	20 1e       	sub	lr,1
80007bac:	18 03       	add	r3,r12
80007bae:	18 33       	cp.w	r3,r12
80007bb0:	c0 63       	brcs	80007bbc <__avr32_udiv64+0x1fe>
80007bb2:	10 33       	cp.w	r3,r8
80007bb4:	f7 be 03 01 	sublo	lr,1
80007bb8:	e7 dc e3 03 	addcs	r3,r3,r12
80007bbc:	10 13       	sub	r3,r8
80007bbe:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
80007bc2:	e6 01 0d 00 	divu	r0,r3,r1
80007bc6:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80007bca:	00 98       	mov	r8,r0
80007bcc:	e0 06 02 46 	mul	r6,r0,r6
80007bd0:	0c 3b       	cp.w	r11,r6
80007bd2:	c0 a2       	brcc	80007be6 <__avr32_udiv64+0x228>
80007bd4:	20 18       	sub	r8,1
80007bd6:	18 0b       	add	r11,r12
80007bd8:	18 3b       	cp.w	r11,r12
80007bda:	c0 63       	brcs	80007be6 <__avr32_udiv64+0x228>
80007bdc:	0c 3b       	cp.w	r11,r6
80007bde:	f7 dc e3 0b 	addcs	r11,r11,r12
80007be2:	f7 b8 03 01 	sublo	r8,1
80007be6:	f1 ee 11 08 	or	r8,r8,lr<<0x10
80007bea:	ee f4 ff f4 	ld.w	r4,r7[-12]
80007bee:	0c 1b       	sub	r11,r6
80007bf0:	f0 04 06 42 	mulu.d	r2,r8,r4
80007bf4:	06 95       	mov	r5,r3
80007bf6:	16 35       	cp.w	r5,r11
80007bf8:	e0 8b 00 0a 	brhi	80007c0c <__avr32_udiv64+0x24e>
80007bfc:	5f 0b       	sreq	r11
80007bfe:	f4 09 09 49 	lsl	r9,r10,r9
80007c02:	12 32       	cp.w	r2,r9
80007c04:	5f b9       	srhi	r9
80007c06:	f7 e9 00 09 	and	r9,r11,r9
80007c0a:	c0 60       	breq	80007c16 <__avr32_udiv64+0x258>
80007c0c:	20 18       	sub	r8,1
80007c0e:	30 09       	mov	r9,0
80007c10:	c0 38       	rjmp	80007c16 <__avr32_udiv64+0x258>
80007c12:	30 09       	mov	r9,0
80007c14:	12 98       	mov	r8,r9
80007c16:	10 9a       	mov	r10,r8
80007c18:	12 93       	mov	r3,r9
80007c1a:	10 92       	mov	r2,r8
80007c1c:	12 9b       	mov	r11,r9
80007c1e:	2f dd       	sub	sp,-12
80007c20:	d8 32       	popm	r0-r7,pc
80007c22:	d7 03       	nop

80007c24 <free>:
80007c24:	d4 01       	pushm	lr
80007c26:	e0 68 05 34 	mov	r8,1332
80007c2a:	18 9b       	mov	r11,r12
80007c2c:	70 0c       	ld.w	r12,r8[0x0]
80007c2e:	e0 a0 1e 73 	rcall	8000b914 <_free_r>
80007c32:	d8 02       	popm	pc

80007c34 <malloc>:
80007c34:	d4 01       	pushm	lr
80007c36:	e0 68 05 34 	mov	r8,1332
80007c3a:	18 9b       	mov	r11,r12
80007c3c:	70 0c       	ld.w	r12,r8[0x0]
80007c3e:	c0 3c       	rcall	80007c44 <_malloc_r>
80007c40:	d8 02       	popm	pc
80007c42:	d7 03       	nop

80007c44 <_malloc_r>:
80007c44:	d4 31       	pushm	r0-r7,lr
80007c46:	f6 c8 ff f5 	sub	r8,r11,-11
80007c4a:	18 95       	mov	r5,r12
80007c4c:	10 97       	mov	r7,r8
80007c4e:	e0 17 ff f8 	andl	r7,0xfff8
80007c52:	59 68       	cp.w	r8,22
80007c54:	f9 b7 08 10 	movls	r7,16
80007c58:	16 37       	cp.w	r7,r11
80007c5a:	5f 38       	srlo	r8
80007c5c:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80007c60:	c0 50       	breq	80007c6a <_malloc_r+0x26>
80007c62:	30 c8       	mov	r8,12
80007c64:	99 38       	st.w	r12[0xc],r8
80007c66:	e0 8f 01 f4 	bral	8000804e <_malloc_r+0x40a>
80007c6a:	fe b0 f1 51 	rcall	80005f0c <__malloc_lock>
80007c6e:	e0 47 01 f7 	cp.w	r7,503
80007c72:	e0 8b 00 1c 	brhi	80007caa <_malloc_r+0x66>
80007c76:	ee 03 16 03 	lsr	r3,r7,0x3
80007c7a:	33 48       	mov	r8,52
80007c7c:	f0 03 00 38 	add	r8,r8,r3<<0x3
80007c80:	70 36       	ld.w	r6,r8[0xc]
80007c82:	10 36       	cp.w	r6,r8
80007c84:	c0 61       	brne	80007c90 <_malloc_r+0x4c>
80007c86:	ec c8 ff f8 	sub	r8,r6,-8
80007c8a:	70 36       	ld.w	r6,r8[0xc]
80007c8c:	10 36       	cp.w	r6,r8
80007c8e:	c0 c0       	breq	80007ca6 <_malloc_r+0x62>
80007c90:	6c 18       	ld.w	r8,r6[0x4]
80007c92:	e0 18 ff fc 	andl	r8,0xfffc
80007c96:	6c 3a       	ld.w	r10,r6[0xc]
80007c98:	ec 08 00 09 	add	r9,r6,r8
80007c9c:	0a 9c       	mov	r12,r5
80007c9e:	6c 28       	ld.w	r8,r6[0x8]
80007ca0:	95 28       	st.w	r10[0x8],r8
80007ca2:	91 3a       	st.w	r8[0xc],r10
80007ca4:	c4 68       	rjmp	80007d30 <_malloc_r+0xec>
80007ca6:	2f e3       	sub	r3,-2
80007ca8:	c4 c8       	rjmp	80007d40 <_malloc_r+0xfc>
80007caa:	ee 03 16 09 	lsr	r3,r7,0x9
80007cae:	c0 41       	brne	80007cb6 <_malloc_r+0x72>
80007cb0:	ee 03 16 03 	lsr	r3,r7,0x3
80007cb4:	c2 68       	rjmp	80007d00 <_malloc_r+0xbc>
80007cb6:	58 43       	cp.w	r3,4
80007cb8:	e0 8b 00 06 	brhi	80007cc4 <_malloc_r+0x80>
80007cbc:	ee 03 16 06 	lsr	r3,r7,0x6
80007cc0:	2c 83       	sub	r3,-56
80007cc2:	c1 f8       	rjmp	80007d00 <_malloc_r+0xbc>
80007cc4:	59 43       	cp.w	r3,20
80007cc6:	e0 8b 00 04 	brhi	80007cce <_malloc_r+0x8a>
80007cca:	2a 53       	sub	r3,-91
80007ccc:	c1 a8       	rjmp	80007d00 <_malloc_r+0xbc>
80007cce:	e0 43 00 54 	cp.w	r3,84
80007cd2:	e0 8b 00 06 	brhi	80007cde <_malloc_r+0x9a>
80007cd6:	ee 03 16 0c 	lsr	r3,r7,0xc
80007cda:	29 23       	sub	r3,-110
80007cdc:	c1 28       	rjmp	80007d00 <_malloc_r+0xbc>
80007cde:	e0 43 01 54 	cp.w	r3,340
80007ce2:	e0 8b 00 06 	brhi	80007cee <_malloc_r+0xaa>
80007ce6:	ee 03 16 0f 	lsr	r3,r7,0xf
80007cea:	28 93       	sub	r3,-119
80007cec:	c0 a8       	rjmp	80007d00 <_malloc_r+0xbc>
80007cee:	e0 43 05 54 	cp.w	r3,1364
80007cf2:	e0 88 00 04 	brls	80007cfa <_malloc_r+0xb6>
80007cf6:	37 e3       	mov	r3,126
80007cf8:	c0 48       	rjmp	80007d00 <_malloc_r+0xbc>
80007cfa:	ee 03 16 12 	lsr	r3,r7,0x12
80007cfe:	28 43       	sub	r3,-124
80007d00:	33 4a       	mov	r10,52
80007d02:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80007d06:	74 36       	ld.w	r6,r10[0xc]
80007d08:	c1 98       	rjmp	80007d3a <_malloc_r+0xf6>
80007d0a:	6c 19       	ld.w	r9,r6[0x4]
80007d0c:	e0 19 ff fc 	andl	r9,0xfffc
80007d10:	f2 07 01 0b 	sub	r11,r9,r7
80007d14:	58 fb       	cp.w	r11,15
80007d16:	e0 8a 00 04 	brle	80007d1e <_malloc_r+0xda>
80007d1a:	20 13       	sub	r3,1
80007d1c:	c1 18       	rjmp	80007d3e <_malloc_r+0xfa>
80007d1e:	6c 38       	ld.w	r8,r6[0xc]
80007d20:	58 0b       	cp.w	r11,0
80007d22:	c0 b5       	brlt	80007d38 <_malloc_r+0xf4>
80007d24:	6c 2a       	ld.w	r10,r6[0x8]
80007d26:	ec 09 00 09 	add	r9,r6,r9
80007d2a:	0a 9c       	mov	r12,r5
80007d2c:	91 2a       	st.w	r8[0x8],r10
80007d2e:	95 38       	st.w	r10[0xc],r8
80007d30:	72 18       	ld.w	r8,r9[0x4]
80007d32:	a1 a8       	sbr	r8,0x0
80007d34:	93 18       	st.w	r9[0x4],r8
80007d36:	cb 88       	rjmp	80007ea6 <_malloc_r+0x262>
80007d38:	10 96       	mov	r6,r8
80007d3a:	14 36       	cp.w	r6,r10
80007d3c:	ce 71       	brne	80007d0a <_malloc_r+0xc6>
80007d3e:	2f f3       	sub	r3,-1
80007d40:	33 4a       	mov	r10,52
80007d42:	f4 cc ff f8 	sub	r12,r10,-8
80007d46:	78 26       	ld.w	r6,r12[0x8]
80007d48:	18 36       	cp.w	r6,r12
80007d4a:	c6 a0       	breq	80007e1e <_malloc_r+0x1da>
80007d4c:	6c 19       	ld.w	r9,r6[0x4]
80007d4e:	e0 19 ff fc 	andl	r9,0xfffc
80007d52:	f2 07 01 08 	sub	r8,r9,r7
80007d56:	58 f8       	cp.w	r8,15
80007d58:	e0 89 00 8c 	brgt	80007e70 <_malloc_r+0x22c>
80007d5c:	99 3c       	st.w	r12[0xc],r12
80007d5e:	99 2c       	st.w	r12[0x8],r12
80007d60:	58 08       	cp.w	r8,0
80007d62:	c0 55       	brlt	80007d6c <_malloc_r+0x128>
80007d64:	ec 09 00 09 	add	r9,r6,r9
80007d68:	0a 9c       	mov	r12,r5
80007d6a:	ce 3b       	rjmp	80007d30 <_malloc_r+0xec>
80007d6c:	e0 49 01 ff 	cp.w	r9,511
80007d70:	e0 8b 00 13 	brhi	80007d96 <_malloc_r+0x152>
80007d74:	a3 99       	lsr	r9,0x3
80007d76:	f4 09 00 38 	add	r8,r10,r9<<0x3
80007d7a:	70 2b       	ld.w	r11,r8[0x8]
80007d7c:	8d 38       	st.w	r6[0xc],r8
80007d7e:	8d 2b       	st.w	r6[0x8],r11
80007d80:	97 36       	st.w	r11[0xc],r6
80007d82:	91 26       	st.w	r8[0x8],r6
80007d84:	a3 49       	asr	r9,0x2
80007d86:	74 18       	ld.w	r8,r10[0x4]
80007d88:	30 1b       	mov	r11,1
80007d8a:	f6 09 09 49 	lsl	r9,r11,r9
80007d8e:	f1 e9 10 09 	or	r9,r8,r9
80007d92:	95 19       	st.w	r10[0x4],r9
80007d94:	c4 58       	rjmp	80007e1e <_malloc_r+0x1da>
80007d96:	f2 0a 16 09 	lsr	r10,r9,0x9
80007d9a:	58 4a       	cp.w	r10,4
80007d9c:	e0 8b 00 06 	brhi	80007da8 <_malloc_r+0x164>
80007da0:	f2 0a 16 06 	lsr	r10,r9,0x6
80007da4:	2c 8a       	sub	r10,-56
80007da6:	c1 f8       	rjmp	80007de4 <_malloc_r+0x1a0>
80007da8:	59 4a       	cp.w	r10,20
80007daa:	e0 8b 00 04 	brhi	80007db2 <_malloc_r+0x16e>
80007dae:	2a 5a       	sub	r10,-91
80007db0:	c1 a8       	rjmp	80007de4 <_malloc_r+0x1a0>
80007db2:	e0 4a 00 54 	cp.w	r10,84
80007db6:	e0 8b 00 06 	brhi	80007dc2 <_malloc_r+0x17e>
80007dba:	f2 0a 16 0c 	lsr	r10,r9,0xc
80007dbe:	29 2a       	sub	r10,-110
80007dc0:	c1 28       	rjmp	80007de4 <_malloc_r+0x1a0>
80007dc2:	e0 4a 01 54 	cp.w	r10,340
80007dc6:	e0 8b 00 06 	brhi	80007dd2 <_malloc_r+0x18e>
80007dca:	f2 0a 16 0f 	lsr	r10,r9,0xf
80007dce:	28 9a       	sub	r10,-119
80007dd0:	c0 a8       	rjmp	80007de4 <_malloc_r+0x1a0>
80007dd2:	e0 4a 05 54 	cp.w	r10,1364
80007dd6:	e0 88 00 04 	brls	80007dde <_malloc_r+0x19a>
80007dda:	37 ea       	mov	r10,126
80007ddc:	c0 48       	rjmp	80007de4 <_malloc_r+0x1a0>
80007dde:	f2 0a 16 12 	lsr	r10,r9,0x12
80007de2:	28 4a       	sub	r10,-124
80007de4:	33 4b       	mov	r11,52
80007de6:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80007dea:	68 28       	ld.w	r8,r4[0x8]
80007dec:	08 38       	cp.w	r8,r4
80007dee:	c0 e1       	brne	80007e0a <_malloc_r+0x1c6>
80007df0:	76 19       	ld.w	r9,r11[0x4]
80007df2:	a3 4a       	asr	r10,0x2
80007df4:	30 1e       	mov	lr,1
80007df6:	fc 0a 09 4a 	lsl	r10,lr,r10
80007dfa:	f3 ea 10 0a 	or	r10,r9,r10
80007dfe:	10 99       	mov	r9,r8
80007e00:	97 1a       	st.w	r11[0x4],r10
80007e02:	c0 a8       	rjmp	80007e16 <_malloc_r+0x1d2>
80007e04:	70 28       	ld.w	r8,r8[0x8]
80007e06:	08 38       	cp.w	r8,r4
80007e08:	c0 60       	breq	80007e14 <_malloc_r+0x1d0>
80007e0a:	70 1a       	ld.w	r10,r8[0x4]
80007e0c:	e0 1a ff fc 	andl	r10,0xfffc
80007e10:	14 39       	cp.w	r9,r10
80007e12:	cf 93       	brcs	80007e04 <_malloc_r+0x1c0>
80007e14:	70 39       	ld.w	r9,r8[0xc]
80007e16:	8d 39       	st.w	r6[0xc],r9
80007e18:	8d 28       	st.w	r6[0x8],r8
80007e1a:	91 36       	st.w	r8[0xc],r6
80007e1c:	93 26       	st.w	r9[0x8],r6
80007e1e:	e6 08 14 02 	asr	r8,r3,0x2
80007e22:	30 1b       	mov	r11,1
80007e24:	33 44       	mov	r4,52
80007e26:	f6 08 09 4b 	lsl	r11,r11,r8
80007e2a:	68 18       	ld.w	r8,r4[0x4]
80007e2c:	10 3b       	cp.w	r11,r8
80007e2e:	e0 8b 00 6b 	brhi	80007f04 <_malloc_r+0x2c0>
80007e32:	f7 e8 00 09 	and	r9,r11,r8
80007e36:	c0 b1       	brne	80007e4c <_malloc_r+0x208>
80007e38:	e0 13 ff fc 	andl	r3,0xfffc
80007e3c:	a1 7b       	lsl	r11,0x1
80007e3e:	2f c3       	sub	r3,-4
80007e40:	c0 38       	rjmp	80007e46 <_malloc_r+0x202>
80007e42:	2f c3       	sub	r3,-4
80007e44:	a1 7b       	lsl	r11,0x1
80007e46:	f7 e8 00 09 	and	r9,r11,r8
80007e4a:	cf c0       	breq	80007e42 <_malloc_r+0x1fe>
80007e4c:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80007e50:	06 92       	mov	r2,r3
80007e52:	1c 91       	mov	r1,lr
80007e54:	62 36       	ld.w	r6,r1[0xc]
80007e56:	c2 e8       	rjmp	80007eb2 <_malloc_r+0x26e>
80007e58:	6c 1a       	ld.w	r10,r6[0x4]
80007e5a:	e0 1a ff fc 	andl	r10,0xfffc
80007e5e:	f4 07 01 08 	sub	r8,r10,r7
80007e62:	58 f8       	cp.w	r8,15
80007e64:	e0 8a 00 15 	brle	80007e8e <_malloc_r+0x24a>
80007e68:	6c 3a       	ld.w	r10,r6[0xc]
80007e6a:	6c 29       	ld.w	r9,r6[0x8]
80007e6c:	95 29       	st.w	r10[0x8],r9
80007e6e:	93 3a       	st.w	r9[0xc],r10
80007e70:	0e 99       	mov	r9,r7
80007e72:	ec 07 00 07 	add	r7,r6,r7
80007e76:	a1 a9       	sbr	r9,0x0
80007e78:	99 37       	st.w	r12[0xc],r7
80007e7a:	99 27       	st.w	r12[0x8],r7
80007e7c:	8d 19       	st.w	r6[0x4],r9
80007e7e:	ee 08 09 08 	st.w	r7[r8],r8
80007e82:	8f 2c       	st.w	r7[0x8],r12
80007e84:	8f 3c       	st.w	r7[0xc],r12
80007e86:	a1 a8       	sbr	r8,0x0
80007e88:	0a 9c       	mov	r12,r5
80007e8a:	8f 18       	st.w	r7[0x4],r8
80007e8c:	c0 d8       	rjmp	80007ea6 <_malloc_r+0x262>
80007e8e:	6c 39       	ld.w	r9,r6[0xc]
80007e90:	58 08       	cp.w	r8,0
80007e92:	c0 f5       	brlt	80007eb0 <_malloc_r+0x26c>
80007e94:	ec 0a 00 0a 	add	r10,r6,r10
80007e98:	74 18       	ld.w	r8,r10[0x4]
80007e9a:	a1 a8       	sbr	r8,0x0
80007e9c:	0a 9c       	mov	r12,r5
80007e9e:	95 18       	st.w	r10[0x4],r8
80007ea0:	6c 28       	ld.w	r8,r6[0x8]
80007ea2:	93 28       	st.w	r9[0x8],r8
80007ea4:	91 39       	st.w	r8[0xc],r9
80007ea6:	fe b0 f0 39 	rcall	80005f18 <__malloc_unlock>
80007eaa:	ec cc ff f8 	sub	r12,r6,-8
80007eae:	d8 32       	popm	r0-r7,pc
80007eb0:	12 96       	mov	r6,r9
80007eb2:	02 36       	cp.w	r6,r1
80007eb4:	cd 21       	brne	80007e58 <_malloc_r+0x214>
80007eb6:	2f f2       	sub	r2,-1
80007eb8:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80007ebc:	c0 30       	breq	80007ec2 <_malloc_r+0x27e>
80007ebe:	2f 81       	sub	r1,-8
80007ec0:	cc ab       	rjmp	80007e54 <_malloc_r+0x210>
80007ec2:	1c 98       	mov	r8,lr
80007ec4:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80007ec8:	c0 81       	brne	80007ed8 <_malloc_r+0x294>
80007eca:	68 19       	ld.w	r9,r4[0x4]
80007ecc:	f6 08 11 ff 	rsub	r8,r11,-1
80007ed0:	f3 e8 00 08 	and	r8,r9,r8
80007ed4:	89 18       	st.w	r4[0x4],r8
80007ed6:	c0 78       	rjmp	80007ee4 <_malloc_r+0x2a0>
80007ed8:	f0 c9 00 08 	sub	r9,r8,8
80007edc:	20 13       	sub	r3,1
80007ede:	70 08       	ld.w	r8,r8[0x0]
80007ee0:	12 38       	cp.w	r8,r9
80007ee2:	cf 10       	breq	80007ec4 <_malloc_r+0x280>
80007ee4:	a1 7b       	lsl	r11,0x1
80007ee6:	68 18       	ld.w	r8,r4[0x4]
80007ee8:	10 3b       	cp.w	r11,r8
80007eea:	e0 8b 00 0d 	brhi	80007f04 <_malloc_r+0x2c0>
80007eee:	58 0b       	cp.w	r11,0
80007ef0:	c0 a0       	breq	80007f04 <_malloc_r+0x2c0>
80007ef2:	04 93       	mov	r3,r2
80007ef4:	c0 38       	rjmp	80007efa <_malloc_r+0x2b6>
80007ef6:	2f c3       	sub	r3,-4
80007ef8:	a1 7b       	lsl	r11,0x1
80007efa:	f7 e8 00 09 	and	r9,r11,r8
80007efe:	ca 71       	brne	80007e4c <_malloc_r+0x208>
80007f00:	cf bb       	rjmp	80007ef6 <_malloc_r+0x2b2>
80007f02:	d7 03       	nop
80007f04:	68 23       	ld.w	r3,r4[0x8]
80007f06:	66 12       	ld.w	r2,r3[0x4]
80007f08:	e0 12 ff fc 	andl	r2,0xfffc
80007f0c:	0e 32       	cp.w	r2,r7
80007f0e:	5f 39       	srlo	r9
80007f10:	e4 07 01 08 	sub	r8,r2,r7
80007f14:	58 f8       	cp.w	r8,15
80007f16:	5f aa       	srle	r10
80007f18:	f5 e9 10 09 	or	r9,r10,r9
80007f1c:	e0 80 00 9a 	breq	80008050 <_malloc_r+0x40c>
80007f20:	e0 68 07 dc 	mov	r8,2012
80007f24:	70 01       	ld.w	r1,r8[0x0]
80007f26:	e0 68 04 40 	mov	r8,1088
80007f2a:	2f 01       	sub	r1,-16
80007f2c:	70 08       	ld.w	r8,r8[0x0]
80007f2e:	0e 01       	add	r1,r7
80007f30:	5b f8       	cp.w	r8,-1
80007f32:	c0 40       	breq	80007f3a <_malloc_r+0x2f6>
80007f34:	28 11       	sub	r1,-127
80007f36:	e0 11 ff 80 	andl	r1,0xff80
80007f3a:	02 9b       	mov	r11,r1
80007f3c:	0a 9c       	mov	r12,r5
80007f3e:	e0 a0 02 a5 	rcall	80008488 <_sbrk_r>
80007f42:	18 96       	mov	r6,r12
80007f44:	5b fc       	cp.w	r12,-1
80007f46:	c7 50       	breq	80008030 <_malloc_r+0x3ec>
80007f48:	e6 02 00 08 	add	r8,r3,r2
80007f4c:	10 3c       	cp.w	r12,r8
80007f4e:	c0 32       	brcc	80007f54 <_malloc_r+0x310>
80007f50:	08 33       	cp.w	r3,r4
80007f52:	c6 f1       	brne	80008030 <_malloc_r+0x3ec>
80007f54:	e0 6a 07 e0 	mov	r10,2016
80007f58:	74 09       	ld.w	r9,r10[0x0]
80007f5a:	e2 09 00 09 	add	r9,r1,r9
80007f5e:	95 09       	st.w	r10[0x0],r9
80007f60:	10 36       	cp.w	r6,r8
80007f62:	c0 a1       	brne	80007f76 <_malloc_r+0x332>
80007f64:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80007f68:	c0 71       	brne	80007f76 <_malloc_r+0x332>
80007f6a:	e2 02 00 02 	add	r2,r1,r2
80007f6e:	68 28       	ld.w	r8,r4[0x8]
80007f70:	a1 a2       	sbr	r2,0x0
80007f72:	91 12       	st.w	r8[0x4],r2
80007f74:	c4 f8       	rjmp	80008012 <_malloc_r+0x3ce>
80007f76:	e0 6a 04 40 	mov	r10,1088
80007f7a:	74 0b       	ld.w	r11,r10[0x0]
80007f7c:	5b fb       	cp.w	r11,-1
80007f7e:	c0 31       	brne	80007f84 <_malloc_r+0x340>
80007f80:	95 06       	st.w	r10[0x0],r6
80007f82:	c0 78       	rjmp	80007f90 <_malloc_r+0x34c>
80007f84:	ec 09 00 09 	add	r9,r6,r9
80007f88:	e0 6a 07 e0 	mov	r10,2016
80007f8c:	10 19       	sub	r9,r8
80007f8e:	95 09       	st.w	r10[0x0],r9
80007f90:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80007f94:	f0 09 11 08 	rsub	r9,r8,8
80007f98:	58 08       	cp.w	r8,0
80007f9a:	f2 08 17 10 	movne	r8,r9
80007f9e:	ed d8 e1 06 	addne	r6,r6,r8
80007fa2:	28 08       	sub	r8,-128
80007fa4:	ec 01 00 01 	add	r1,r6,r1
80007fa8:	0a 9c       	mov	r12,r5
80007faa:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80007fae:	f0 01 01 01 	sub	r1,r8,r1
80007fb2:	02 9b       	mov	r11,r1
80007fb4:	e0 a0 02 6a 	rcall	80008488 <_sbrk_r>
80007fb8:	e0 68 07 e0 	mov	r8,2016
80007fbc:	5b fc       	cp.w	r12,-1
80007fbe:	ec 0c 17 00 	moveq	r12,r6
80007fc2:	f9 b1 00 00 	moveq	r1,0
80007fc6:	70 09       	ld.w	r9,r8[0x0]
80007fc8:	0c 1c       	sub	r12,r6
80007fca:	89 26       	st.w	r4[0x8],r6
80007fcc:	02 0c       	add	r12,r1
80007fce:	12 01       	add	r1,r9
80007fd0:	a1 ac       	sbr	r12,0x0
80007fd2:	91 01       	st.w	r8[0x0],r1
80007fd4:	8d 1c       	st.w	r6[0x4],r12
80007fd6:	08 33       	cp.w	r3,r4
80007fd8:	c1 d0       	breq	80008012 <_malloc_r+0x3ce>
80007fda:	58 f2       	cp.w	r2,15
80007fdc:	e0 8b 00 05 	brhi	80007fe6 <_malloc_r+0x3a2>
80007fe0:	30 18       	mov	r8,1
80007fe2:	8d 18       	st.w	r6[0x4],r8
80007fe4:	c2 68       	rjmp	80008030 <_malloc_r+0x3ec>
80007fe6:	30 59       	mov	r9,5
80007fe8:	20 c2       	sub	r2,12
80007fea:	e0 12 ff f8 	andl	r2,0xfff8
80007fee:	e6 02 00 08 	add	r8,r3,r2
80007ff2:	91 29       	st.w	r8[0x8],r9
80007ff4:	91 19       	st.w	r8[0x4],r9
80007ff6:	66 18       	ld.w	r8,r3[0x4]
80007ff8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007ffc:	e5 e8 10 08 	or	r8,r2,r8
80008000:	87 18       	st.w	r3[0x4],r8
80008002:	58 f2       	cp.w	r2,15
80008004:	e0 88 00 07 	brls	80008012 <_malloc_r+0x3ce>
80008008:	e6 cb ff f8 	sub	r11,r3,-8
8000800c:	0a 9c       	mov	r12,r5
8000800e:	e0 a0 1c 83 	rcall	8000b914 <_free_r>
80008012:	e0 69 07 d8 	mov	r9,2008
80008016:	72 0a       	ld.w	r10,r9[0x0]
80008018:	e0 68 07 e0 	mov	r8,2016
8000801c:	70 08       	ld.w	r8,r8[0x0]
8000801e:	14 38       	cp.w	r8,r10
80008020:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80008024:	e0 69 07 d4 	mov	r9,2004
80008028:	72 0a       	ld.w	r10,r9[0x0]
8000802a:	14 38       	cp.w	r8,r10
8000802c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80008030:	68 28       	ld.w	r8,r4[0x8]
80008032:	70 18       	ld.w	r8,r8[0x4]
80008034:	e0 18 ff fc 	andl	r8,0xfffc
80008038:	0e 38       	cp.w	r8,r7
8000803a:	5f 39       	srlo	r9
8000803c:	0e 18       	sub	r8,r7
8000803e:	58 f8       	cp.w	r8,15
80008040:	5f aa       	srle	r10
80008042:	f5 e9 10 09 	or	r9,r10,r9
80008046:	c0 50       	breq	80008050 <_malloc_r+0x40c>
80008048:	0a 9c       	mov	r12,r5
8000804a:	fe b0 ef 67 	rcall	80005f18 <__malloc_unlock>
8000804e:	d8 3a       	popm	r0-r7,pc,r12=0
80008050:	68 26       	ld.w	r6,r4[0x8]
80008052:	a1 a8       	sbr	r8,0x0
80008054:	0e 99       	mov	r9,r7
80008056:	a1 a9       	sbr	r9,0x0
80008058:	8d 19       	st.w	r6[0x4],r9
8000805a:	ec 07 00 07 	add	r7,r6,r7
8000805e:	0a 9c       	mov	r12,r5
80008060:	89 27       	st.w	r4[0x8],r7
80008062:	8f 18       	st.w	r7[0x4],r8
80008064:	fe b0 ef 5a 	rcall	80005f18 <__malloc_unlock>
80008068:	ec cc ff f8 	sub	r12,r6,-8
8000806c:	d8 32       	popm	r0-r7,pc
8000806e:	d7 03       	nop

80008070 <memcpy>:
80008070:	58 8a       	cp.w	r10,8
80008072:	c2 f5       	brlt	800080d0 <memcpy+0x60>
80008074:	f9 eb 10 09 	or	r9,r12,r11
80008078:	e2 19 00 03 	andl	r9,0x3,COH
8000807c:	e0 81 00 97 	brne	800081aa <memcpy+0x13a>
80008080:	e0 4a 00 20 	cp.w	r10,32
80008084:	c3 b4       	brge	800080fa <memcpy+0x8a>
80008086:	f4 08 14 02 	asr	r8,r10,0x2
8000808a:	f0 09 11 08 	rsub	r9,r8,8
8000808e:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80008092:	76 69       	ld.w	r9,r11[0x18]
80008094:	99 69       	st.w	r12[0x18],r9
80008096:	76 59       	ld.w	r9,r11[0x14]
80008098:	99 59       	st.w	r12[0x14],r9
8000809a:	76 49       	ld.w	r9,r11[0x10]
8000809c:	99 49       	st.w	r12[0x10],r9
8000809e:	76 39       	ld.w	r9,r11[0xc]
800080a0:	99 39       	st.w	r12[0xc],r9
800080a2:	76 29       	ld.w	r9,r11[0x8]
800080a4:	99 29       	st.w	r12[0x8],r9
800080a6:	76 19       	ld.w	r9,r11[0x4]
800080a8:	99 19       	st.w	r12[0x4],r9
800080aa:	76 09       	ld.w	r9,r11[0x0]
800080ac:	99 09       	st.w	r12[0x0],r9
800080ae:	f6 08 00 2b 	add	r11,r11,r8<<0x2
800080b2:	f8 08 00 28 	add	r8,r12,r8<<0x2
800080b6:	e0 1a 00 03 	andl	r10,0x3
800080ba:	f4 0a 11 04 	rsub	r10,r10,4
800080be:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800080c2:	17 a9       	ld.ub	r9,r11[0x2]
800080c4:	b0 a9       	st.b	r8[0x2],r9
800080c6:	17 99       	ld.ub	r9,r11[0x1]
800080c8:	b0 99       	st.b	r8[0x1],r9
800080ca:	17 89       	ld.ub	r9,r11[0x0]
800080cc:	b0 89       	st.b	r8[0x0],r9
800080ce:	5e fc       	retal	r12
800080d0:	f4 0a 11 09 	rsub	r10,r10,9
800080d4:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800080d8:	17 f9       	ld.ub	r9,r11[0x7]
800080da:	b8 f9       	st.b	r12[0x7],r9
800080dc:	17 e9       	ld.ub	r9,r11[0x6]
800080de:	b8 e9       	st.b	r12[0x6],r9
800080e0:	17 d9       	ld.ub	r9,r11[0x5]
800080e2:	b8 d9       	st.b	r12[0x5],r9
800080e4:	17 c9       	ld.ub	r9,r11[0x4]
800080e6:	b8 c9       	st.b	r12[0x4],r9
800080e8:	17 b9       	ld.ub	r9,r11[0x3]
800080ea:	b8 b9       	st.b	r12[0x3],r9
800080ec:	17 a9       	ld.ub	r9,r11[0x2]
800080ee:	b8 a9       	st.b	r12[0x2],r9
800080f0:	17 99       	ld.ub	r9,r11[0x1]
800080f2:	b8 99       	st.b	r12[0x1],r9
800080f4:	17 89       	ld.ub	r9,r11[0x0]
800080f6:	b8 89       	st.b	r12[0x0],r9
800080f8:	5e fc       	retal	r12
800080fa:	eb cd 40 c0 	pushm	r6-r7,lr
800080fe:	18 99       	mov	r9,r12
80008100:	22 0a       	sub	r10,32
80008102:	b7 07       	ld.d	r6,r11++
80008104:	b3 26       	st.d	r9++,r6
80008106:	b7 07       	ld.d	r6,r11++
80008108:	b3 26       	st.d	r9++,r6
8000810a:	b7 07       	ld.d	r6,r11++
8000810c:	b3 26       	st.d	r9++,r6
8000810e:	b7 07       	ld.d	r6,r11++
80008110:	b3 26       	st.d	r9++,r6
80008112:	22 0a       	sub	r10,32
80008114:	cf 74       	brge	80008102 <memcpy+0x92>
80008116:	2f 0a       	sub	r10,-16
80008118:	c0 65       	brlt	80008124 <memcpy+0xb4>
8000811a:	b7 07       	ld.d	r6,r11++
8000811c:	b3 26       	st.d	r9++,r6
8000811e:	b7 07       	ld.d	r6,r11++
80008120:	b3 26       	st.d	r9++,r6
80008122:	21 0a       	sub	r10,16
80008124:	5c 3a       	neg	r10
80008126:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
8000812a:	d7 03       	nop
8000812c:	d7 03       	nop
8000812e:	f7 36 00 0e 	ld.ub	r6,r11[14]
80008132:	f3 66 00 0e 	st.b	r9[14],r6
80008136:	f7 36 00 0d 	ld.ub	r6,r11[13]
8000813a:	f3 66 00 0d 	st.b	r9[13],r6
8000813e:	f7 36 00 0c 	ld.ub	r6,r11[12]
80008142:	f3 66 00 0c 	st.b	r9[12],r6
80008146:	f7 36 00 0b 	ld.ub	r6,r11[11]
8000814a:	f3 66 00 0b 	st.b	r9[11],r6
8000814e:	f7 36 00 0a 	ld.ub	r6,r11[10]
80008152:	f3 66 00 0a 	st.b	r9[10],r6
80008156:	f7 36 00 09 	ld.ub	r6,r11[9]
8000815a:	f3 66 00 09 	st.b	r9[9],r6
8000815e:	f7 36 00 08 	ld.ub	r6,r11[8]
80008162:	f3 66 00 08 	st.b	r9[8],r6
80008166:	f7 36 00 07 	ld.ub	r6,r11[7]
8000816a:	f3 66 00 07 	st.b	r9[7],r6
8000816e:	f7 36 00 06 	ld.ub	r6,r11[6]
80008172:	f3 66 00 06 	st.b	r9[6],r6
80008176:	f7 36 00 05 	ld.ub	r6,r11[5]
8000817a:	f3 66 00 05 	st.b	r9[5],r6
8000817e:	f7 36 00 04 	ld.ub	r6,r11[4]
80008182:	f3 66 00 04 	st.b	r9[4],r6
80008186:	f7 36 00 03 	ld.ub	r6,r11[3]
8000818a:	f3 66 00 03 	st.b	r9[3],r6
8000818e:	f7 36 00 02 	ld.ub	r6,r11[2]
80008192:	f3 66 00 02 	st.b	r9[2],r6
80008196:	f7 36 00 01 	ld.ub	r6,r11[1]
8000819a:	f3 66 00 01 	st.b	r9[1],r6
8000819e:	f7 36 00 00 	ld.ub	r6,r11[0]
800081a2:	f3 66 00 00 	st.b	r9[0],r6
800081a6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800081aa:	20 1a       	sub	r10,1
800081ac:	f6 0a 07 09 	ld.ub	r9,r11[r10]
800081b0:	f8 0a 0b 09 	st.b	r12[r10],r9
800081b4:	cf b1       	brne	800081aa <memcpy+0x13a>
800081b6:	5e fc       	retal	r12

800081b8 <memset>:
800081b8:	18 98       	mov	r8,r12
800081ba:	c0 38       	rjmp	800081c0 <memset+0x8>
800081bc:	10 cb       	st.b	r8++,r11
800081be:	20 1a       	sub	r10,1
800081c0:	58 0a       	cp.w	r10,0
800081c2:	cf d1       	brne	800081bc <memset+0x4>
800081c4:	5e fc       	retal	r12
800081c6:	d7 03       	nop

800081c8 <_realloc_r>:
800081c8:	d4 31       	pushm	r0-r7,lr
800081ca:	20 1d       	sub	sp,4
800081cc:	16 94       	mov	r4,r11
800081ce:	18 92       	mov	r2,r12
800081d0:	14 9b       	mov	r11,r10
800081d2:	58 04       	cp.w	r4,0
800081d4:	c0 51       	brne	800081de <_realloc_r+0x16>
800081d6:	fe b0 fd 37 	rcall	80007c44 <_malloc_r>
800081da:	18 95       	mov	r5,r12
800081dc:	c5 39       	rjmp	80008482 <_realloc_r+0x2ba>
800081de:	50 0a       	stdsp	sp[0x0],r10
800081e0:	fe b0 ee 96 	rcall	80005f0c <__malloc_lock>
800081e4:	40 0b       	lddsp	r11,sp[0x0]
800081e6:	f6 c8 ff f5 	sub	r8,r11,-11
800081ea:	e8 c1 00 08 	sub	r1,r4,8
800081ee:	10 96       	mov	r6,r8
800081f0:	62 1c       	ld.w	r12,r1[0x4]
800081f2:	e0 16 ff f8 	andl	r6,0xfff8
800081f6:	59 68       	cp.w	r8,22
800081f8:	f9 b6 08 10 	movls	r6,16
800081fc:	16 36       	cp.w	r6,r11
800081fe:	5f 38       	srlo	r8
80008200:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80008204:	c0 50       	breq	8000820e <_realloc_r+0x46>
80008206:	30 c8       	mov	r8,12
80008208:	30 05       	mov	r5,0
8000820a:	85 38       	st.w	r2[0xc],r8
8000820c:	c3 b9       	rjmp	80008482 <_realloc_r+0x2ba>
8000820e:	18 90       	mov	r0,r12
80008210:	e0 10 ff fc 	andl	r0,0xfffc
80008214:	0c 30       	cp.w	r0,r6
80008216:	e0 84 01 0b 	brge	8000842c <_realloc_r+0x264>
8000821a:	33 48       	mov	r8,52
8000821c:	e2 00 00 09 	add	r9,r1,r0
80008220:	70 25       	ld.w	r5,r8[0x8]
80008222:	0a 39       	cp.w	r9,r5
80008224:	c0 90       	breq	80008236 <_realloc_r+0x6e>
80008226:	72 1a       	ld.w	r10,r9[0x4]
80008228:	a1 ca       	cbr	r10,0x0
8000822a:	f2 0a 00 0a 	add	r10,r9,r10
8000822e:	74 1a       	ld.w	r10,r10[0x4]
80008230:	ed ba 00 00 	bld	r10,0x0
80008234:	c2 20       	breq	80008278 <_realloc_r+0xb0>
80008236:	72 1a       	ld.w	r10,r9[0x4]
80008238:	e0 1a ff fc 	andl	r10,0xfffc
8000823c:	f4 00 00 03 	add	r3,r10,r0
80008240:	0a 39       	cp.w	r9,r5
80008242:	c1 31       	brne	80008268 <_realloc_r+0xa0>
80008244:	ec c7 ff f0 	sub	r7,r6,-16
80008248:	0e 33       	cp.w	r3,r7
8000824a:	c1 95       	brlt	8000827c <_realloc_r+0xb4>
8000824c:	e2 06 00 09 	add	r9,r1,r6
80008250:	0c 13       	sub	r3,r6
80008252:	a1 a3       	sbr	r3,0x0
80008254:	93 13       	st.w	r9[0x4],r3
80008256:	91 29       	st.w	r8[0x8],r9
80008258:	04 9c       	mov	r12,r2
8000825a:	62 18       	ld.w	r8,r1[0x4]
8000825c:	08 95       	mov	r5,r4
8000825e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008262:	10 46       	or	r6,r8
80008264:	83 16       	st.w	r1[0x4],r6
80008266:	c0 c9       	rjmp	8000847e <_realloc_r+0x2b6>
80008268:	0c 33       	cp.w	r3,r6
8000826a:	c0 95       	brlt	8000827c <_realloc_r+0xb4>
8000826c:	72 28       	ld.w	r8,r9[0x8]
8000826e:	02 97       	mov	r7,r1
80008270:	72 39       	ld.w	r9,r9[0xc]
80008272:	93 28       	st.w	r9[0x8],r8
80008274:	91 39       	st.w	r8[0xc],r9
80008276:	cd d8       	rjmp	80008430 <_realloc_r+0x268>
80008278:	30 0a       	mov	r10,0
8000827a:	14 99       	mov	r9,r10
8000827c:	ed bc 00 00 	bld	r12,0x0
80008280:	e0 80 00 96 	breq	800083ac <_realloc_r+0x1e4>
80008284:	62 07       	ld.w	r7,r1[0x0]
80008286:	e2 07 01 07 	sub	r7,r1,r7
8000828a:	6e 1c       	ld.w	r12,r7[0x4]
8000828c:	e0 1c ff fc 	andl	r12,0xfffc
80008290:	58 09       	cp.w	r9,0
80008292:	c5 70       	breq	80008340 <_realloc_r+0x178>
80008294:	f8 00 00 03 	add	r3,r12,r0
80008298:	0a 39       	cp.w	r9,r5
8000829a:	c4 81       	brne	8000832a <_realloc_r+0x162>
8000829c:	14 03       	add	r3,r10
8000829e:	ec c9 ff f0 	sub	r9,r6,-16
800082a2:	12 33       	cp.w	r3,r9
800082a4:	c4 e5       	brlt	80008340 <_realloc_r+0x178>
800082a6:	6e 3a       	ld.w	r10,r7[0xc]
800082a8:	6e 29       	ld.w	r9,r7[0x8]
800082aa:	95 29       	st.w	r10[0x8],r9
800082ac:	93 3a       	st.w	r9[0xc],r10
800082ae:	ee c5 ff f8 	sub	r5,r7,-8
800082b2:	e0 ca 00 04 	sub	r10,r0,4
800082b6:	e0 4a 00 24 	cp.w	r10,36
800082ba:	e0 8b 00 25 	brhi	80008304 <_realloc_r+0x13c>
800082be:	0a 99       	mov	r9,r5
800082c0:	59 3a       	cp.w	r10,19
800082c2:	e0 88 00 1a 	brls	800082f6 <_realloc_r+0x12e>
800082c6:	09 09       	ld.w	r9,r4++
800082c8:	8b 09       	st.w	r5[0x0],r9
800082ca:	09 09       	ld.w	r9,r4++
800082cc:	8f 39       	st.w	r7[0xc],r9
800082ce:	ee c9 ff f0 	sub	r9,r7,-16
800082d2:	59 ba       	cp.w	r10,27
800082d4:	e0 88 00 11 	brls	800082f6 <_realloc_r+0x12e>
800082d8:	09 0b       	ld.w	r11,r4++
800082da:	93 0b       	st.w	r9[0x0],r11
800082dc:	09 09       	ld.w	r9,r4++
800082de:	8f 59       	st.w	r7[0x14],r9
800082e0:	ee c9 ff e8 	sub	r9,r7,-24
800082e4:	e0 4a 00 24 	cp.w	r10,36
800082e8:	c0 71       	brne	800082f6 <_realloc_r+0x12e>
800082ea:	09 0a       	ld.w	r10,r4++
800082ec:	93 0a       	st.w	r9[0x0],r10
800082ee:	ee c9 ff e0 	sub	r9,r7,-32
800082f2:	09 0a       	ld.w	r10,r4++
800082f4:	8f 7a       	st.w	r7[0x1c],r10
800082f6:	09 0a       	ld.w	r10,r4++
800082f8:	12 aa       	st.w	r9++,r10
800082fa:	68 0a       	ld.w	r10,r4[0x0]
800082fc:	93 0a       	st.w	r9[0x0],r10
800082fe:	68 1a       	ld.w	r10,r4[0x4]
80008300:	93 1a       	st.w	r9[0x4],r10
80008302:	c0 78       	rjmp	80008310 <_realloc_r+0x148>
80008304:	50 08       	stdsp	sp[0x0],r8
80008306:	08 9b       	mov	r11,r4
80008308:	0a 9c       	mov	r12,r5
8000830a:	e0 a0 1d a6 	rcall	8000be56 <memmove>
8000830e:	40 08       	lddsp	r8,sp[0x0]
80008310:	ee 06 00 09 	add	r9,r7,r6
80008314:	0c 13       	sub	r3,r6
80008316:	a1 a3       	sbr	r3,0x0
80008318:	93 13       	st.w	r9[0x4],r3
8000831a:	91 29       	st.w	r8[0x8],r9
8000831c:	04 9c       	mov	r12,r2
8000831e:	6e 18       	ld.w	r8,r7[0x4]
80008320:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008324:	10 46       	or	r6,r8
80008326:	8f 16       	st.w	r7[0x4],r6
80008328:	ca b8       	rjmp	8000847e <_realloc_r+0x2b6>
8000832a:	14 03       	add	r3,r10
8000832c:	0c 33       	cp.w	r3,r6
8000832e:	c0 95       	brlt	80008340 <_realloc_r+0x178>
80008330:	72 28       	ld.w	r8,r9[0x8]
80008332:	72 39       	ld.w	r9,r9[0xc]
80008334:	93 28       	st.w	r9[0x8],r8
80008336:	91 39       	st.w	r8[0xc],r9
80008338:	6e 28       	ld.w	r8,r7[0x8]
8000833a:	6e 39       	ld.w	r9,r7[0xc]
8000833c:	c0 88       	rjmp	8000834c <_realloc_r+0x184>
8000833e:	d7 03       	nop
80008340:	f8 00 00 03 	add	r3,r12,r0
80008344:	0c 33       	cp.w	r3,r6
80008346:	c3 35       	brlt	800083ac <_realloc_r+0x1e4>
80008348:	6e 39       	ld.w	r9,r7[0xc]
8000834a:	6e 28       	ld.w	r8,r7[0x8]
8000834c:	93 28       	st.w	r9[0x8],r8
8000834e:	91 39       	st.w	r8[0xc],r9
80008350:	e0 ca 00 04 	sub	r10,r0,4
80008354:	ee cc ff f8 	sub	r12,r7,-8
80008358:	e0 4a 00 24 	cp.w	r10,36
8000835c:	e0 8b 00 24 	brhi	800083a4 <_realloc_r+0x1dc>
80008360:	59 3a       	cp.w	r10,19
80008362:	e0 88 00 1a 	brls	80008396 <_realloc_r+0x1ce>
80008366:	09 08       	ld.w	r8,r4++
80008368:	99 08       	st.w	r12[0x0],r8
8000836a:	09 08       	ld.w	r8,r4++
8000836c:	8f 38       	st.w	r7[0xc],r8
8000836e:	ee cc ff f0 	sub	r12,r7,-16
80008372:	59 ba       	cp.w	r10,27
80008374:	e0 88 00 11 	brls	80008396 <_realloc_r+0x1ce>
80008378:	09 08       	ld.w	r8,r4++
8000837a:	99 08       	st.w	r12[0x0],r8
8000837c:	09 08       	ld.w	r8,r4++
8000837e:	8f 58       	st.w	r7[0x14],r8
80008380:	ee cc ff e8 	sub	r12,r7,-24
80008384:	e0 4a 00 24 	cp.w	r10,36
80008388:	c0 71       	brne	80008396 <_realloc_r+0x1ce>
8000838a:	09 08       	ld.w	r8,r4++
8000838c:	99 08       	st.w	r12[0x0],r8
8000838e:	ee cc ff e0 	sub	r12,r7,-32
80008392:	09 08       	ld.w	r8,r4++
80008394:	8f 78       	st.w	r7[0x1c],r8
80008396:	09 08       	ld.w	r8,r4++
80008398:	18 a8       	st.w	r12++,r8
8000839a:	68 08       	ld.w	r8,r4[0x0]
8000839c:	99 08       	st.w	r12[0x0],r8
8000839e:	68 18       	ld.w	r8,r4[0x4]
800083a0:	99 18       	st.w	r12[0x4],r8
800083a2:	c4 78       	rjmp	80008430 <_realloc_r+0x268>
800083a4:	08 9b       	mov	r11,r4
800083a6:	e0 a0 1d 58 	rcall	8000be56 <memmove>
800083aa:	c4 38       	rjmp	80008430 <_realloc_r+0x268>
800083ac:	04 9c       	mov	r12,r2
800083ae:	fe b0 fc 4b 	rcall	80007c44 <_malloc_r>
800083b2:	18 95       	mov	r5,r12
800083b4:	c3 a0       	breq	80008428 <_realloc_r+0x260>
800083b6:	62 18       	ld.w	r8,r1[0x4]
800083b8:	f8 c9 00 08 	sub	r9,r12,8
800083bc:	a1 c8       	cbr	r8,0x0
800083be:	e2 08 00 08 	add	r8,r1,r8
800083c2:	10 39       	cp.w	r9,r8
800083c4:	c0 71       	brne	800083d2 <_realloc_r+0x20a>
800083c6:	72 13       	ld.w	r3,r9[0x4]
800083c8:	02 97       	mov	r7,r1
800083ca:	e0 13 ff fc 	andl	r3,0xfffc
800083ce:	00 03       	add	r3,r0
800083d0:	c3 08       	rjmp	80008430 <_realloc_r+0x268>
800083d2:	e0 ca 00 04 	sub	r10,r0,4
800083d6:	e0 4a 00 24 	cp.w	r10,36
800083da:	e0 8b 00 20 	brhi	8000841a <_realloc_r+0x252>
800083de:	08 99       	mov	r9,r4
800083e0:	18 98       	mov	r8,r12
800083e2:	59 3a       	cp.w	r10,19
800083e4:	e0 88 00 14 	brls	8000840c <_realloc_r+0x244>
800083e8:	13 0b       	ld.w	r11,r9++
800083ea:	10 ab       	st.w	r8++,r11
800083ec:	13 0b       	ld.w	r11,r9++
800083ee:	10 ab       	st.w	r8++,r11
800083f0:	59 ba       	cp.w	r10,27
800083f2:	e0 88 00 0d 	brls	8000840c <_realloc_r+0x244>
800083f6:	13 0b       	ld.w	r11,r9++
800083f8:	10 ab       	st.w	r8++,r11
800083fa:	13 0b       	ld.w	r11,r9++
800083fc:	10 ab       	st.w	r8++,r11
800083fe:	e0 4a 00 24 	cp.w	r10,36
80008402:	c0 51       	brne	8000840c <_realloc_r+0x244>
80008404:	13 0a       	ld.w	r10,r9++
80008406:	10 aa       	st.w	r8++,r10
80008408:	13 0a       	ld.w	r10,r9++
8000840a:	10 aa       	st.w	r8++,r10
8000840c:	13 0a       	ld.w	r10,r9++
8000840e:	10 aa       	st.w	r8++,r10
80008410:	72 0a       	ld.w	r10,r9[0x0]
80008412:	91 0a       	st.w	r8[0x0],r10
80008414:	72 19       	ld.w	r9,r9[0x4]
80008416:	91 19       	st.w	r8[0x4],r9
80008418:	c0 48       	rjmp	80008420 <_realloc_r+0x258>
8000841a:	08 9b       	mov	r11,r4
8000841c:	e0 a0 1d 1d 	rcall	8000be56 <memmove>
80008420:	08 9b       	mov	r11,r4
80008422:	04 9c       	mov	r12,r2
80008424:	e0 a0 1a 78 	rcall	8000b914 <_free_r>
80008428:	04 9c       	mov	r12,r2
8000842a:	c2 a8       	rjmp	8000847e <_realloc_r+0x2b6>
8000842c:	00 93       	mov	r3,r0
8000842e:	02 97       	mov	r7,r1
80008430:	e6 06 01 09 	sub	r9,r3,r6
80008434:	6e 18       	ld.w	r8,r7[0x4]
80008436:	58 f9       	cp.w	r9,15
80008438:	e0 88 00 16 	brls	80008464 <_realloc_r+0x29c>
8000843c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008440:	ed e8 10 08 	or	r8,r6,r8
80008444:	8f 18       	st.w	r7[0x4],r8
80008446:	12 98       	mov	r8,r9
80008448:	a1 a8       	sbr	r8,0x0
8000844a:	ee 06 00 0b 	add	r11,r7,r6
8000844e:	f6 09 00 09 	add	r9,r11,r9
80008452:	97 18       	st.w	r11[0x4],r8
80008454:	72 18       	ld.w	r8,r9[0x4]
80008456:	a1 a8       	sbr	r8,0x0
80008458:	2f 8b       	sub	r11,-8
8000845a:	93 18       	st.w	r9[0x4],r8
8000845c:	04 9c       	mov	r12,r2
8000845e:	e0 a0 1a 5b 	rcall	8000b914 <_free_r>
80008462:	c0 b8       	rjmp	80008478 <_realloc_r+0x2b0>
80008464:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008468:	e7 e8 10 08 	or	r8,r3,r8
8000846c:	8f 18       	st.w	r7[0x4],r8
8000846e:	ee 03 00 03 	add	r3,r7,r3
80008472:	66 18       	ld.w	r8,r3[0x4]
80008474:	a1 a8       	sbr	r8,0x0
80008476:	87 18       	st.w	r3[0x4],r8
80008478:	04 9c       	mov	r12,r2
8000847a:	ee c5 ff f8 	sub	r5,r7,-8
8000847e:	fe b0 ed 4d 	rcall	80005f18 <__malloc_unlock>
80008482:	0a 9c       	mov	r12,r5
80008484:	2f fd       	sub	sp,-4
80008486:	d8 32       	popm	r0-r7,pc

80008488 <_sbrk_r>:
80008488:	d4 21       	pushm	r4-r7,lr
8000848a:	30 08       	mov	r8,0
8000848c:	18 97       	mov	r7,r12
8000848e:	e0 66 10 6c 	mov	r6,4204
80008492:	16 9c       	mov	r12,r11
80008494:	8d 08       	st.w	r6[0x0],r8
80008496:	c8 5c       	rcall	800085a0 <_sbrk>
80008498:	5b fc       	cp.w	r12,-1
8000849a:	c0 51       	brne	800084a4 <_sbrk_r+0x1c>
8000849c:	6c 08       	ld.w	r8,r6[0x0]
8000849e:	58 08       	cp.w	r8,0
800084a0:	ef f8 1a 03 	st.wne	r7[0xc],r8
800084a4:	d8 22       	popm	r4-r7,pc
800084a6:	d7 03       	nop

800084a8 <sprintf>:
800084a8:	d4 01       	pushm	lr
800084aa:	21 7d       	sub	sp,92
800084ac:	e0 68 ff ff 	mov	r8,65535
800084b0:	ea 18 7f ff 	orh	r8,0x7fff
800084b4:	50 58       	stdsp	sp[0x14],r8
800084b6:	50 28       	stdsp	sp[0x8],r8
800084b8:	e0 68 02 08 	mov	r8,520
800084bc:	ba 68       	st.h	sp[0xc],r8
800084be:	3f f8       	mov	r8,-1
800084c0:	ba 78       	st.h	sp[0xe],r8
800084c2:	e0 68 05 34 	mov	r8,1332
800084c6:	50 4c       	stdsp	sp[0x10],r12
800084c8:	16 9a       	mov	r10,r11
800084ca:	50 0c       	stdsp	sp[0x0],r12
800084cc:	fa c9 ff a0 	sub	r9,sp,-96
800084d0:	70 0c       	ld.w	r12,r8[0x0]
800084d2:	1a 9b       	mov	r11,sp
800084d4:	e0 a0 02 20 	rcall	80008914 <_vfprintf_r>
800084d8:	30 09       	mov	r9,0
800084da:	40 08       	lddsp	r8,sp[0x0]
800084dc:	b0 89       	st.b	r8[0x0],r9
800084de:	2e 9d       	sub	sp,-92
800084e0:	d8 02       	popm	pc
800084e2:	d7 03       	nop

800084e4 <strncpy>:
800084e4:	30 08       	mov	r8,0
800084e6:	10 3a       	cp.w	r10,r8
800084e8:	5e 0c       	reteq	r12
800084ea:	f6 08 07 09 	ld.ub	r9,r11[r8]
800084ee:	f8 08 0b 09 	st.b	r12[r8],r9
800084f2:	2f f8       	sub	r8,-1
800084f4:	58 09       	cp.w	r9,0
800084f6:	cf 81       	brne	800084e6 <strncpy+0x2>
800084f8:	10 3a       	cp.w	r10,r8
800084fa:	5e 0c       	reteq	r12
800084fc:	f8 08 0b 09 	st.b	r12[r8],r9
80008500:	2f f8       	sub	r8,-1
80008502:	cf bb       	rjmp	800084f8 <strncpy+0x14>

80008504 <_close>:
80008504:	30 28       	mov	r8,2
80008506:	d6 73       	breakpoint
80008508:	3f fc       	mov	r12,-1
8000850a:	35 8b       	mov	r11,88
8000850c:	58 0c       	cp.w	r12,0
8000850e:	5e 4c       	retge	r12
80008510:	e0 6a 10 6c 	mov	r10,4204
80008514:	95 0b       	st.w	r10[0x0],r11
80008516:	5e fc       	retal	r12

80008518 <_lseek>:
80008518:	30 58       	mov	r8,5
8000851a:	d6 73       	breakpoint
8000851c:	3f fc       	mov	r12,-1
8000851e:	35 8b       	mov	r11,88
80008520:	58 0c       	cp.w	r12,0
80008522:	5e 4c       	retge	r12
80008524:	e0 6a 10 6c 	mov	r10,4204
80008528:	95 0b       	st.w	r10[0x0],r11
8000852a:	5e fc       	retal	r12

8000852c <isatty>:
8000852c:	30 b8       	mov	r8,11
8000852e:	d6 73       	breakpoint
80008530:	3f fc       	mov	r12,-1
80008532:	35 8b       	mov	r11,88
80008534:	58 0c       	cp.w	r12,0
80008536:	5e 4c       	retge	r12
80008538:	e0 6a 10 6c 	mov	r10,4204
8000853c:	95 0b       	st.w	r10[0x0],r11
8000853e:	5e fc       	retal	r12

80008540 <_fstat_host>:
80008540:	30 98       	mov	r8,9
80008542:	d6 73       	breakpoint
80008544:	3f fc       	mov	r12,-1
80008546:	35 8b       	mov	r11,88
80008548:	58 0c       	cp.w	r12,0
8000854a:	5e 4c       	retge	r12
8000854c:	e0 6a 10 6c 	mov	r10,4204
80008550:	95 0b       	st.w	r10[0x0],r11
80008552:	5e fc       	retal	r12

80008554 <_fstat>:
80008554:	d4 21       	pushm	r4-r7,lr
80008556:	21 0d       	sub	sp,64
80008558:	16 97       	mov	r7,r11
8000855a:	1a 9b       	mov	r11,sp
8000855c:	cf 2f       	rcall	80008540 <_fstat_host>
8000855e:	c0 34       	brge	80008564 <_fstat+0x10>
80008560:	3f fc       	mov	r12,-1
80008562:	c1 c8       	rjmp	8000859a <_fstat+0x46>
80008564:	40 08       	lddsp	r8,sp[0x0]
80008566:	ae 08       	st.h	r7[0x0],r8
80008568:	40 18       	lddsp	r8,sp[0x4]
8000856a:	ae 18       	st.h	r7[0x2],r8
8000856c:	40 28       	lddsp	r8,sp[0x8]
8000856e:	8f 18       	st.w	r7[0x4],r8
80008570:	40 38       	lddsp	r8,sp[0xc]
80008572:	ae 48       	st.h	r7[0x8],r8
80008574:	40 48       	lddsp	r8,sp[0x10]
80008576:	ae 58       	st.h	r7[0xa],r8
80008578:	40 58       	lddsp	r8,sp[0x14]
8000857a:	ae 68       	st.h	r7[0xc],r8
8000857c:	40 68       	lddsp	r8,sp[0x18]
8000857e:	ae 78       	st.h	r7[0xe],r8
80008580:	40 88       	lddsp	r8,sp[0x20]
80008582:	8f 48       	st.w	r7[0x10],r8
80008584:	40 a8       	lddsp	r8,sp[0x28]
80008586:	8f b8       	st.w	r7[0x2c],r8
80008588:	40 c8       	lddsp	r8,sp[0x30]
8000858a:	8f c8       	st.w	r7[0x30],r8
8000858c:	40 d8       	lddsp	r8,sp[0x34]
8000858e:	8f 58       	st.w	r7[0x14],r8
80008590:	40 e8       	lddsp	r8,sp[0x38]
80008592:	30 0c       	mov	r12,0
80008594:	8f 78       	st.w	r7[0x1c],r8
80008596:	40 f8       	lddsp	r8,sp[0x3c]
80008598:	8f 98       	st.w	r7[0x24],r8
8000859a:	2f 0d       	sub	sp,-64
8000859c:	d8 22       	popm	r4-r7,pc
8000859e:	d7 03       	nop

800085a0 <_sbrk>:
800085a0:	d4 01       	pushm	lr
800085a2:	e0 68 08 08 	mov	r8,2056
800085a6:	70 09       	ld.w	r9,r8[0x0]
800085a8:	58 09       	cp.w	r9,0
800085aa:	c0 41       	brne	800085b2 <_sbrk+0x12>
800085ac:	e0 69 10 70 	mov	r9,4208
800085b0:	91 09       	st.w	r8[0x0],r9
800085b2:	e0 69 08 08 	mov	r9,2056
800085b6:	e0 6a f0 00 	mov	r10,61440
800085ba:	72 08       	ld.w	r8,r9[0x0]
800085bc:	f0 0c 00 0c 	add	r12,r8,r12
800085c0:	14 3c       	cp.w	r12,r10
800085c2:	e0 8b 00 04 	brhi	800085ca <_sbrk+0x2a>
800085c6:	93 0c       	st.w	r9[0x0],r12
800085c8:	c0 68       	rjmp	800085d4 <_sbrk+0x34>
800085ca:	e0 a0 18 2b 	rcall	8000b620 <__errno>
800085ce:	30 c8       	mov	r8,12
800085d0:	99 08       	st.w	r12[0x0],r8
800085d2:	3f f8       	mov	r8,-1
800085d4:	10 9c       	mov	r12,r8
800085d6:	d8 02       	popm	pc

800085d8 <get_arg>:
800085d8:	d4 31       	pushm	r0-r7,lr
800085da:	20 8d       	sub	sp,32
800085dc:	fa c4 ff bc 	sub	r4,sp,-68
800085e0:	50 4b       	stdsp	sp[0x10],r11
800085e2:	68 2e       	ld.w	lr,r4[0x8]
800085e4:	50 58       	stdsp	sp[0x14],r8
800085e6:	12 96       	mov	r6,r9
800085e8:	7c 0b       	ld.w	r11,lr[0x0]
800085ea:	70 05       	ld.w	r5,r8[0x0]
800085ec:	50 6e       	stdsp	sp[0x18],lr
800085ee:	58 0b       	cp.w	r11,0
800085f0:	f4 0b 17 00 	moveq	r11,r10
800085f4:	68 03       	ld.w	r3,r4[0x0]
800085f6:	68 11       	ld.w	r1,r4[0x4]
800085f8:	40 49       	lddsp	r9,sp[0x10]
800085fa:	30 08       	mov	r8,0
800085fc:	c2 e9       	rjmp	80008858 <get_arg+0x280>
800085fe:	2f fb       	sub	r11,-1
80008600:	32 5c       	mov	r12,37
80008602:	17 8a       	ld.ub	r10,r11[0x0]
80008604:	f8 0a 18 00 	cp.b	r10,r12
80008608:	5f 1e       	srne	lr
8000860a:	f0 0a 18 00 	cp.b	r10,r8
8000860e:	5f 1c       	srne	r12
80008610:	fd ec 00 0c 	and	r12,lr,r12
80008614:	f0 0c 18 00 	cp.b	r12,r8
80008618:	cf 31       	brne	800085fe <get_arg+0x26>
8000861a:	58 0a       	cp.w	r10,0
8000861c:	e0 80 01 2b 	breq	80008872 <get_arg+0x29a>
80008620:	30 0c       	mov	r12,0
80008622:	3f fa       	mov	r10,-1
80008624:	18 90       	mov	r0,r12
80008626:	50 3a       	stdsp	sp[0xc],r10
80008628:	18 94       	mov	r4,r12
8000862a:	18 92       	mov	r2,r12
8000862c:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80008630:	16 97       	mov	r7,r11
80008632:	50 7c       	stdsp	sp[0x1c],r12
80008634:	4c ec       	lddpc	r12,8000876c <get_arg+0x194>
80008636:	0f 3a       	ld.ub	r10,r7++
80008638:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
8000863c:	40 7c       	lddsp	r12,sp[0x1c]
8000863e:	1c 0c       	add	r12,lr
80008640:	4c ce       	lddpc	lr,80008770 <get_arg+0x198>
80008642:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80008646:	20 1e       	sub	lr,1
80008648:	50 0e       	stdsp	sp[0x0],lr
8000864a:	4c be       	lddpc	lr,80008774 <get_arg+0x19c>
8000864c:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80008650:	50 7c       	stdsp	sp[0x1c],r12
80008652:	40 0c       	lddsp	r12,sp[0x0]
80008654:	58 7c       	cp.w	r12,7
80008656:	e0 8b 00 fa 	brhi	8000884a <get_arg+0x272>
8000865a:	4c 8e       	lddpc	lr,80008778 <get_arg+0x1a0>
8000865c:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80008660:	36 8b       	mov	r11,104
80008662:	f6 0a 18 00 	cp.b	r10,r11
80008666:	e0 80 00 f2 	breq	8000884a <get_arg+0x272>
8000866a:	37 1b       	mov	r11,113
8000866c:	f6 0a 18 00 	cp.b	r10,r11
80008670:	c0 70       	breq	8000867e <get_arg+0xa6>
80008672:	34 cb       	mov	r11,76
80008674:	f6 0a 18 00 	cp.b	r10,r11
80008678:	c0 51       	brne	80008682 <get_arg+0xaa>
8000867a:	a3 b4       	sbr	r4,0x3
8000867c:	ce 78       	rjmp	8000884a <get_arg+0x272>
8000867e:	a5 b4       	sbr	r4,0x5
80008680:	ce 58       	rjmp	8000884a <get_arg+0x272>
80008682:	08 9a       	mov	r10,r4
80008684:	0e 9b       	mov	r11,r7
80008686:	a5 aa       	sbr	r10,0x4
80008688:	17 3c       	ld.ub	r12,r11++
8000868a:	a5 b4       	sbr	r4,0x5
8000868c:	36 ce       	mov	lr,108
8000868e:	fc 0c 18 00 	cp.b	r12,lr
80008692:	e0 80 00 dd 	breq	8000884c <get_arg+0x274>
80008696:	14 94       	mov	r4,r10
80008698:	cd 98       	rjmp	8000884a <get_arg+0x272>
8000869a:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
8000869e:	36 7c       	mov	r12,103
800086a0:	f8 0a 18 00 	cp.b	r10,r12
800086a4:	e0 8b 00 27 	brhi	800086f2 <get_arg+0x11a>
800086a8:	36 5b       	mov	r11,101
800086aa:	f6 0a 18 00 	cp.b	r10,r11
800086ae:	c4 82       	brcc	8000873e <get_arg+0x166>
800086b0:	34 fb       	mov	r11,79
800086b2:	f6 0a 18 00 	cp.b	r10,r11
800086b6:	c4 80       	breq	80008746 <get_arg+0x16e>
800086b8:	e0 8b 00 0c 	brhi	800086d0 <get_arg+0xf8>
800086bc:	34 5b       	mov	r11,69
800086be:	f6 0a 18 00 	cp.b	r10,r11
800086c2:	c3 e0       	breq	8000873e <get_arg+0x166>
800086c4:	34 7b       	mov	r11,71
800086c6:	f6 0a 18 00 	cp.b	r10,r11
800086ca:	c3 a0       	breq	8000873e <get_arg+0x166>
800086cc:	34 4b       	mov	r11,68
800086ce:	c0 88       	rjmp	800086de <get_arg+0x106>
800086d0:	35 8b       	mov	r11,88
800086d2:	f6 0a 18 00 	cp.b	r10,r11
800086d6:	c2 c0       	breq	8000872e <get_arg+0x156>
800086d8:	e0 8b 00 07 	brhi	800086e6 <get_arg+0x10e>
800086dc:	35 5b       	mov	r11,85
800086de:	f6 0a 18 00 	cp.b	r10,r11
800086e2:	c3 51       	brne	8000874c <get_arg+0x174>
800086e4:	c3 18       	rjmp	80008746 <get_arg+0x16e>
800086e6:	36 3b       	mov	r11,99
800086e8:	f6 0a 18 00 	cp.b	r10,r11
800086ec:	c2 f0       	breq	8000874a <get_arg+0x172>
800086ee:	36 4b       	mov	r11,100
800086f0:	c0 e8       	rjmp	8000870c <get_arg+0x134>
800086f2:	37 0b       	mov	r11,112
800086f4:	f6 0a 18 00 	cp.b	r10,r11
800086f8:	c2 50       	breq	80008742 <get_arg+0x16a>
800086fa:	e0 8b 00 0d 	brhi	80008714 <get_arg+0x13c>
800086fe:	36 eb       	mov	r11,110
80008700:	f6 0a 18 00 	cp.b	r10,r11
80008704:	c1 f0       	breq	80008742 <get_arg+0x16a>
80008706:	e0 8b 00 14 	brhi	8000872e <get_arg+0x156>
8000870a:	36 9b       	mov	r11,105
8000870c:	f6 0a 18 00 	cp.b	r10,r11
80008710:	c1 e1       	brne	8000874c <get_arg+0x174>
80008712:	c0 e8       	rjmp	8000872e <get_arg+0x156>
80008714:	37 5b       	mov	r11,117
80008716:	f6 0a 18 00 	cp.b	r10,r11
8000871a:	c0 a0       	breq	8000872e <get_arg+0x156>
8000871c:	37 8b       	mov	r11,120
8000871e:	f6 0a 18 00 	cp.b	r10,r11
80008722:	c0 60       	breq	8000872e <get_arg+0x156>
80008724:	37 3b       	mov	r11,115
80008726:	f6 0a 18 00 	cp.b	r10,r11
8000872a:	c1 11       	brne	8000874c <get_arg+0x174>
8000872c:	c0 b8       	rjmp	80008742 <get_arg+0x16a>
8000872e:	ed b4 00 04 	bld	r4,0x4
80008732:	c0 a0       	breq	80008746 <get_arg+0x16e>
80008734:	ed b4 00 05 	bld	r4,0x5
80008738:	c0 91       	brne	8000874a <get_arg+0x172>
8000873a:	30 20       	mov	r0,2
8000873c:	c0 88       	rjmp	8000874c <get_arg+0x174>
8000873e:	30 40       	mov	r0,4
80008740:	c0 68       	rjmp	8000874c <get_arg+0x174>
80008742:	30 30       	mov	r0,3
80008744:	c0 48       	rjmp	8000874c <get_arg+0x174>
80008746:	30 10       	mov	r0,1
80008748:	c0 28       	rjmp	8000874c <get_arg+0x174>
8000874a:	30 00       	mov	r0,0
8000874c:	40 3b       	lddsp	r11,sp[0xc]
8000874e:	5b fb       	cp.w	r11,-1
80008750:	c0 40       	breq	80008758 <get_arg+0x180>
80008752:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80008756:	c7 a8       	rjmp	8000884a <get_arg+0x272>
80008758:	58 60       	cp.w	r0,6
8000875a:	e0 8b 00 78 	brhi	8000884a <get_arg+0x272>
8000875e:	6c 0a       	ld.w	r10,r6[0x0]
80008760:	ea cc ff ff 	sub	r12,r5,-1
80008764:	48 6e       	lddpc	lr,8000877c <get_arg+0x1a4>
80008766:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
8000876a:	d7 03       	nop
8000876c:	80 02       	ld.sh	r2,r0[0x0]
8000876e:	f8 10 80 02 	mems	8,0x1
80008772:	f7 48 80 02 	st.w	r11[-32766],r8
80008776:	f6 dc 80 02 	satsub.w	r12,r11,-32766
8000877a:	f5 3c 80 02 	ld.ub	r12,r10[-32766]
8000877e:	f5 5c f4 cb 	st.h	r10[-2869],r12
80008782:	ff f8 8d 0b 	st.hls	pc[0x216],r8
80008786:	f4 ea 00 00 	ld.d	r10,r10[0]
8000878a:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000878e:	c0 f8       	rjmp	800087ac <get_arg+0x1d4>
80008790:	f4 cb ff fc 	sub	r11,r10,-4
80008794:	8d 0b       	st.w	r6[0x0],r11
80008796:	74 0a       	ld.w	r10,r10[0x0]
80008798:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000879c:	c0 88       	rjmp	800087ac <get_arg+0x1d4>
8000879e:	f4 cb ff f8 	sub	r11,r10,-8
800087a2:	8d 0b       	st.w	r6[0x0],r11
800087a4:	f4 ea 00 00 	ld.d	r10,r10[0]
800087a8:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
800087ac:	0e 9b       	mov	r11,r7
800087ae:	18 95       	mov	r5,r12
800087b0:	c4 e8       	rjmp	8000884c <get_arg+0x274>
800087b2:	62 0a       	ld.w	r10,r1[0x0]
800087b4:	5b fa       	cp.w	r10,-1
800087b6:	c0 b1       	brne	800087cc <get_arg+0x1f4>
800087b8:	50 19       	stdsp	sp[0x4],r9
800087ba:	50 28       	stdsp	sp[0x8],r8
800087bc:	e0 6a 00 80 	mov	r10,128
800087c0:	30 0b       	mov	r11,0
800087c2:	02 9c       	mov	r12,r1
800087c4:	fe b0 fc fa 	rcall	800081b8 <memset>
800087c8:	40 28       	lddsp	r8,sp[0x8]
800087ca:	40 19       	lddsp	r9,sp[0x4]
800087cc:	e4 cc 00 01 	sub	r12,r2,1
800087d0:	0e 9b       	mov	r11,r7
800087d2:	50 3c       	stdsp	sp[0xc],r12
800087d4:	f2 0c 0c 49 	max	r9,r9,r12
800087d8:	c3 a8       	rjmp	8000884c <get_arg+0x274>
800087da:	62 0a       	ld.w	r10,r1[0x0]
800087dc:	5b fa       	cp.w	r10,-1
800087de:	c0 b1       	brne	800087f4 <get_arg+0x21c>
800087e0:	50 19       	stdsp	sp[0x4],r9
800087e2:	50 28       	stdsp	sp[0x8],r8
800087e4:	e0 6a 00 80 	mov	r10,128
800087e8:	30 0b       	mov	r11,0
800087ea:	02 9c       	mov	r12,r1
800087ec:	fe b0 fc e6 	rcall	800081b8 <memset>
800087f0:	40 28       	lddsp	r8,sp[0x8]
800087f2:	40 19       	lddsp	r9,sp[0x4]
800087f4:	20 12       	sub	r2,1
800087f6:	30 0a       	mov	r10,0
800087f8:	0e 9b       	mov	r11,r7
800087fa:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
800087fe:	f2 02 0c 49 	max	r9,r9,r2
80008802:	c2 58       	rjmp	8000884c <get_arg+0x274>
80008804:	16 97       	mov	r7,r11
80008806:	6c 0a       	ld.w	r10,r6[0x0]
80008808:	f4 cb ff fc 	sub	r11,r10,-4
8000880c:	8d 0b       	st.w	r6[0x0],r11
8000880e:	74 0a       	ld.w	r10,r10[0x0]
80008810:	0e 9b       	mov	r11,r7
80008812:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80008816:	2f f5       	sub	r5,-1
80008818:	c1 a8       	rjmp	8000884c <get_arg+0x274>
8000881a:	f4 c2 00 30 	sub	r2,r10,48
8000881e:	c0 68       	rjmp	8000882a <get_arg+0x252>
80008820:	e4 02 00 22 	add	r2,r2,r2<<0x2
80008824:	2f f7       	sub	r7,-1
80008826:	f4 02 00 12 	add	r2,r10,r2<<0x1
8000882a:	0f 8a       	ld.ub	r10,r7[0x0]
8000882c:	58 0a       	cp.w	r10,0
8000882e:	c0 e0       	breq	8000884a <get_arg+0x272>
80008830:	23 0a       	sub	r10,48
80008832:	58 9a       	cp.w	r10,9
80008834:	fe 98 ff f6 	brls	80008820 <get_arg+0x248>
80008838:	c0 98       	rjmp	8000884a <get_arg+0x272>
8000883a:	2f f7       	sub	r7,-1
8000883c:	0f 8a       	ld.ub	r10,r7[0x0]
8000883e:	58 0a       	cp.w	r10,0
80008840:	c0 50       	breq	8000884a <get_arg+0x272>
80008842:	23 0a       	sub	r10,48
80008844:	58 9a       	cp.w	r10,9
80008846:	fe 98 ff fa 	brls	8000883a <get_arg+0x262>
8000884a:	0e 9b       	mov	r11,r7
8000884c:	40 7c       	lddsp	r12,sp[0x1c]
8000884e:	30 ba       	mov	r10,11
80008850:	f4 0c 18 00 	cp.b	r12,r10
80008854:	fe 91 fe ec 	brne	8000862c <get_arg+0x54>
80008858:	40 42       	lddsp	r2,sp[0x10]
8000885a:	17 8c       	ld.ub	r12,r11[0x0]
8000885c:	0a 32       	cp.w	r2,r5
8000885e:	5f 4a       	srge	r10
80008860:	f0 0c 18 00 	cp.b	r12,r8
80008864:	5f 1c       	srne	r12
80008866:	f9 ea 00 0a 	and	r10,r12,r10
8000886a:	f0 0a 18 00 	cp.b	r10,r8
8000886e:	fe 91 fe c9 	brne	80008600 <get_arg+0x28>
80008872:	30 08       	mov	r8,0
80008874:	40 4e       	lddsp	lr,sp[0x10]
80008876:	17 8a       	ld.ub	r10,r11[0x0]
80008878:	e2 05 00 21 	add	r1,r1,r5<<0x2
8000887c:	f0 0a 18 00 	cp.b	r10,r8
80008880:	fc 09 17 10 	movne	r9,lr
80008884:	e6 05 00 38 	add	r8,r3,r5<<0x3
80008888:	06 9e       	mov	lr,r3
8000888a:	c2 a8       	rjmp	800088de <get_arg+0x306>
8000888c:	62 0a       	ld.w	r10,r1[0x0]
8000888e:	58 3a       	cp.w	r10,3
80008890:	c1 e0       	breq	800088cc <get_arg+0x2f4>
80008892:	e0 89 00 07 	brgt	800088a0 <get_arg+0x2c8>
80008896:	58 1a       	cp.w	r10,1
80008898:	c1 a0       	breq	800088cc <get_arg+0x2f4>
8000889a:	58 2a       	cp.w	r10,2
8000889c:	c1 81       	brne	800088cc <get_arg+0x2f4>
8000889e:	c0 58       	rjmp	800088a8 <get_arg+0x2d0>
800088a0:	58 5a       	cp.w	r10,5
800088a2:	c0 c0       	breq	800088ba <get_arg+0x2e2>
800088a4:	c0 b5       	brlt	800088ba <get_arg+0x2e2>
800088a6:	c1 38       	rjmp	800088cc <get_arg+0x2f4>
800088a8:	6c 0a       	ld.w	r10,r6[0x0]
800088aa:	f4 cc ff f8 	sub	r12,r10,-8
800088ae:	8d 0c       	st.w	r6[0x0],r12
800088b0:	f4 e2 00 00 	ld.d	r2,r10[0]
800088b4:	f0 e3 00 00 	st.d	r8[0],r2
800088b8:	c1 08       	rjmp	800088d8 <get_arg+0x300>
800088ba:	6c 0a       	ld.w	r10,r6[0x0]
800088bc:	f4 cc ff f8 	sub	r12,r10,-8
800088c0:	8d 0c       	st.w	r6[0x0],r12
800088c2:	f4 e2 00 00 	ld.d	r2,r10[0]
800088c6:	f0 e3 00 00 	st.d	r8[0],r2
800088ca:	c0 78       	rjmp	800088d8 <get_arg+0x300>
800088cc:	6c 0a       	ld.w	r10,r6[0x0]
800088ce:	f4 cc ff fc 	sub	r12,r10,-4
800088d2:	8d 0c       	st.w	r6[0x0],r12
800088d4:	74 0a       	ld.w	r10,r10[0x0]
800088d6:	91 0a       	st.w	r8[0x0],r10
800088d8:	2f f5       	sub	r5,-1
800088da:	2f 88       	sub	r8,-8
800088dc:	2f c1       	sub	r1,-4
800088de:	12 35       	cp.w	r5,r9
800088e0:	fe 9a ff d6 	brle	8000888c <get_arg+0x2b4>
800088e4:	1c 93       	mov	r3,lr
800088e6:	40 52       	lddsp	r2,sp[0x14]
800088e8:	40 6e       	lddsp	lr,sp[0x18]
800088ea:	85 05       	st.w	r2[0x0],r5
800088ec:	9d 0b       	st.w	lr[0x0],r11
800088ee:	40 4b       	lddsp	r11,sp[0x10]
800088f0:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
800088f4:	2f 8d       	sub	sp,-32
800088f6:	d8 32       	popm	r0-r7,pc

800088f8 <__sprint_r>:
800088f8:	d4 21       	pushm	r4-r7,lr
800088fa:	14 97       	mov	r7,r10
800088fc:	74 28       	ld.w	r8,r10[0x8]
800088fe:	58 08       	cp.w	r8,0
80008900:	c0 41       	brne	80008908 <__sprint_r+0x10>
80008902:	95 18       	st.w	r10[0x4],r8
80008904:	10 9c       	mov	r12,r8
80008906:	d8 22       	popm	r4-r7,pc
80008908:	e0 a0 18 ca 	rcall	8000ba9c <__sfvwrite_r>
8000890c:	30 08       	mov	r8,0
8000890e:	8f 18       	st.w	r7[0x4],r8
80008910:	8f 28       	st.w	r7[0x8],r8
80008912:	d8 22       	popm	r4-r7,pc

80008914 <_vfprintf_r>:
80008914:	d4 31       	pushm	r0-r7,lr
80008916:	fa cd 06 bc 	sub	sp,sp,1724
8000891a:	51 09       	stdsp	sp[0x40],r9
8000891c:	16 91       	mov	r1,r11
8000891e:	14 97       	mov	r7,r10
80008920:	18 95       	mov	r5,r12
80008922:	e0 a0 1a 2d 	rcall	8000bd7c <_localeconv_r>
80008926:	78 0c       	ld.w	r12,r12[0x0]
80008928:	50 cc       	stdsp	sp[0x30],r12
8000892a:	58 05       	cp.w	r5,0
8000892c:	c0 70       	breq	8000893a <_vfprintf_r+0x26>
8000892e:	6a 68       	ld.w	r8,r5[0x18]
80008930:	58 08       	cp.w	r8,0
80008932:	c0 41       	brne	8000893a <_vfprintf_r+0x26>
80008934:	0a 9c       	mov	r12,r5
80008936:	e0 a0 17 57 	rcall	8000b7e4 <__sinit>
8000893a:	4d 08       	lddpc	r8,80008a78 <_vfprintf_r+0x164>
8000893c:	10 31       	cp.w	r1,r8
8000893e:	c0 31       	brne	80008944 <_vfprintf_r+0x30>
80008940:	6a 01       	ld.w	r1,r5[0x0]
80008942:	c0 a8       	rjmp	80008956 <_vfprintf_r+0x42>
80008944:	4c e8       	lddpc	r8,80008a7c <_vfprintf_r+0x168>
80008946:	10 31       	cp.w	r1,r8
80008948:	c0 31       	brne	8000894e <_vfprintf_r+0x3a>
8000894a:	6a 11       	ld.w	r1,r5[0x4]
8000894c:	c0 58       	rjmp	80008956 <_vfprintf_r+0x42>
8000894e:	4c d8       	lddpc	r8,80008a80 <_vfprintf_r+0x16c>
80008950:	10 31       	cp.w	r1,r8
80008952:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80008956:	82 68       	ld.sh	r8,r1[0xc]
80008958:	ed b8 00 03 	bld	r8,0x3
8000895c:	c0 41       	brne	80008964 <_vfprintf_r+0x50>
8000895e:	62 48       	ld.w	r8,r1[0x10]
80008960:	58 08       	cp.w	r8,0
80008962:	c0 71       	brne	80008970 <_vfprintf_r+0x5c>
80008964:	02 9b       	mov	r11,r1
80008966:	0a 9c       	mov	r12,r5
80008968:	e0 a0 0f 6c 	rcall	8000a840 <__swsetup_r>
8000896c:	e0 81 0f 63 	brne	8000a832 <_vfprintf_r+0x1f1e>
80008970:	82 68       	ld.sh	r8,r1[0xc]
80008972:	10 99       	mov	r9,r8
80008974:	e2 19 00 1a 	andl	r9,0x1a,COH
80008978:	58 a9       	cp.w	r9,10
8000897a:	c3 c1       	brne	800089f2 <_vfprintf_r+0xde>
8000897c:	82 79       	ld.sh	r9,r1[0xe]
8000897e:	30 0a       	mov	r10,0
80008980:	f4 09 19 00 	cp.h	r9,r10
80008984:	c3 75       	brlt	800089f2 <_vfprintf_r+0xde>
80008986:	a1 d8       	cbr	r8,0x1
80008988:	fb 58 05 d0 	st.h	sp[1488],r8
8000898c:	62 88       	ld.w	r8,r1[0x20]
8000898e:	fb 48 05 e4 	st.w	sp[1508],r8
80008992:	62 a8       	ld.w	r8,r1[0x28]
80008994:	fb 48 05 ec 	st.w	sp[1516],r8
80008998:	fa c8 ff bc 	sub	r8,sp,-68
8000899c:	fb 48 05 d4 	st.w	sp[1492],r8
800089a0:	fb 48 05 c4 	st.w	sp[1476],r8
800089a4:	e0 68 04 00 	mov	r8,1024
800089a8:	fb 48 05 d8 	st.w	sp[1496],r8
800089ac:	fb 48 05 cc 	st.w	sp[1484],r8
800089b0:	30 08       	mov	r8,0
800089b2:	fb 59 05 d2 	st.h	sp[1490],r9
800089b6:	0e 9a       	mov	r10,r7
800089b8:	41 09       	lddsp	r9,sp[0x40]
800089ba:	fa c7 fa 3c 	sub	r7,sp,-1476
800089be:	fb 48 05 dc 	st.w	sp[1500],r8
800089c2:	0a 9c       	mov	r12,r5
800089c4:	0e 9b       	mov	r11,r7
800089c6:	ca 7f       	rcall	80008914 <_vfprintf_r>
800089c8:	50 bc       	stdsp	sp[0x2c],r12
800089ca:	c0 95       	brlt	800089dc <_vfprintf_r+0xc8>
800089cc:	0e 9b       	mov	r11,r7
800089ce:	0a 9c       	mov	r12,r5
800089d0:	e0 a0 16 2e 	rcall	8000b62c <_fflush_r>
800089d4:	40 be       	lddsp	lr,sp[0x2c]
800089d6:	f9 be 01 ff 	movne	lr,-1
800089da:	50 be       	stdsp	sp[0x2c],lr
800089dc:	fb 08 05 d0 	ld.sh	r8,sp[1488]
800089e0:	ed b8 00 06 	bld	r8,0x6
800089e4:	e0 81 0f 29 	brne	8000a836 <_vfprintf_r+0x1f22>
800089e8:	82 68       	ld.sh	r8,r1[0xc]
800089ea:	a7 a8       	sbr	r8,0x6
800089ec:	a2 68       	st.h	r1[0xc],r8
800089ee:	e0 8f 0f 24 	bral	8000a836 <_vfprintf_r+0x1f22>
800089f2:	30 08       	mov	r8,0
800089f4:	fb 48 06 b4 	st.w	sp[1716],r8
800089f8:	fb 48 06 90 	st.w	sp[1680],r8
800089fc:	fb 48 06 8c 	st.w	sp[1676],r8
80008a00:	fb 48 06 b0 	st.w	sp[1712],r8
80008a04:	30 08       	mov	r8,0
80008a06:	30 09       	mov	r9,0
80008a08:	50 a7       	stdsp	sp[0x28],r7
80008a0a:	50 78       	stdsp	sp[0x1c],r8
80008a0c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a10:	3f f8       	mov	r8,-1
80008a12:	50 59       	stdsp	sp[0x14],r9
80008a14:	fb 43 06 88 	st.w	sp[1672],r3
80008a18:	fb 48 05 44 	st.w	sp[1348],r8
80008a1c:	12 9c       	mov	r12,r9
80008a1e:	50 69       	stdsp	sp[0x18],r9
80008a20:	50 d9       	stdsp	sp[0x34],r9
80008a22:	50 e9       	stdsp	sp[0x38],r9
80008a24:	50 b9       	stdsp	sp[0x2c],r9
80008a26:	12 97       	mov	r7,r9
80008a28:	0a 94       	mov	r4,r5
80008a2a:	40 a2       	lddsp	r2,sp[0x28]
80008a2c:	32 5a       	mov	r10,37
80008a2e:	30 08       	mov	r8,0
80008a30:	c0 28       	rjmp	80008a34 <_vfprintf_r+0x120>
80008a32:	2f f2       	sub	r2,-1
80008a34:	05 89       	ld.ub	r9,r2[0x0]
80008a36:	f0 09 18 00 	cp.b	r9,r8
80008a3a:	5f 1b       	srne	r11
80008a3c:	f4 09 18 00 	cp.b	r9,r10
80008a40:	5f 19       	srne	r9
80008a42:	f3 eb 00 0b 	and	r11,r9,r11
80008a46:	f0 0b 18 00 	cp.b	r11,r8
80008a4a:	cf 41       	brne	80008a32 <_vfprintf_r+0x11e>
80008a4c:	40 ab       	lddsp	r11,sp[0x28]
80008a4e:	e4 0b 01 06 	sub	r6,r2,r11
80008a52:	c2 50       	breq	80008a9c <_vfprintf_r+0x188>
80008a54:	fa f8 06 90 	ld.w	r8,sp[1680]
80008a58:	0c 08       	add	r8,r6
80008a5a:	87 0b       	st.w	r3[0x0],r11
80008a5c:	fb 48 06 90 	st.w	sp[1680],r8
80008a60:	87 16       	st.w	r3[0x4],r6
80008a62:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008a66:	2f f8       	sub	r8,-1
80008a68:	fb 48 06 8c 	st.w	sp[1676],r8
80008a6c:	58 78       	cp.w	r8,7
80008a6e:	e0 89 00 0b 	brgt	80008a84 <_vfprintf_r+0x170>
80008a72:	2f 83       	sub	r3,-8
80008a74:	c1 18       	rjmp	80008a96 <_vfprintf_r+0x182>
80008a76:	d7 03       	nop
80008a78:	80 02       	ld.sh	r2,r0[0x0]
80008a7a:	f9 20 80 02 	ld.sb	r0,r12[-32766]
80008a7e:	f9 40 80 02 	st.w	r12[-32766],r0
80008a82:	f9 60 fa ca 	st.b	r12[-1334],r0
80008a86:	f9 78 02 9b 	stcond	r12[667],r8
80008a8a:	08 9c       	mov	r12,r4
80008a8c:	c3 6f       	rcall	800088f8 <__sprint_r>
80008a8e:	e0 81 0e ce 	brne	8000a82a <_vfprintf_r+0x1f16>
80008a92:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a96:	40 ba       	lddsp	r10,sp[0x2c]
80008a98:	0c 0a       	add	r10,r6
80008a9a:	50 ba       	stdsp	sp[0x2c],r10
80008a9c:	05 89       	ld.ub	r9,r2[0x0]
80008a9e:	30 08       	mov	r8,0
80008aa0:	f0 09 18 00 	cp.b	r9,r8
80008aa4:	e0 80 0e b2 	breq	8000a808 <_vfprintf_r+0x1ef4>
80008aa8:	30 09       	mov	r9,0
80008aaa:	fb 68 06 bb 	st.b	sp[1723],r8
80008aae:	0e 96       	mov	r6,r7
80008ab0:	e4 c8 ff ff 	sub	r8,r2,-1
80008ab4:	3f fe       	mov	lr,-1
80008ab6:	50 93       	stdsp	sp[0x24],r3
80008ab8:	50 41       	stdsp	sp[0x10],r1
80008aba:	0e 93       	mov	r3,r7
80008abc:	04 91       	mov	r1,r2
80008abe:	50 89       	stdsp	sp[0x20],r9
80008ac0:	50 a8       	stdsp	sp[0x28],r8
80008ac2:	50 2e       	stdsp	sp[0x8],lr
80008ac4:	50 39       	stdsp	sp[0xc],r9
80008ac6:	12 95       	mov	r5,r9
80008ac8:	12 90       	mov	r0,r9
80008aca:	10 97       	mov	r7,r8
80008acc:	08 92       	mov	r2,r4
80008ace:	c0 78       	rjmp	80008adc <_vfprintf_r+0x1c8>
80008ad0:	3f fc       	mov	r12,-1
80008ad2:	08 97       	mov	r7,r4
80008ad4:	50 2c       	stdsp	sp[0x8],r12
80008ad6:	c0 38       	rjmp	80008adc <_vfprintf_r+0x1c8>
80008ad8:	30 0b       	mov	r11,0
80008ada:	50 3b       	stdsp	sp[0xc],r11
80008adc:	0f 38       	ld.ub	r8,r7++
80008ade:	c0 28       	rjmp	80008ae2 <_vfprintf_r+0x1ce>
80008ae0:	12 90       	mov	r0,r9
80008ae2:	f0 c9 00 20 	sub	r9,r8,32
80008ae6:	e0 49 00 58 	cp.w	r9,88
80008aea:	e0 8b 0a 36 	brhi	80009f56 <_vfprintf_r+0x1642>
80008aee:	4d 9a       	lddpc	r10,80008c50 <_vfprintf_r+0x33c>
80008af0:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80008af4:	50 a7       	stdsp	sp[0x28],r7
80008af6:	50 80       	stdsp	sp[0x20],r0
80008af8:	0c 97       	mov	r7,r6
80008afa:	04 94       	mov	r4,r2
80008afc:	06 96       	mov	r6,r3
80008afe:	02 92       	mov	r2,r1
80008b00:	4d 59       	lddpc	r9,80008c54 <_vfprintf_r+0x340>
80008b02:	40 93       	lddsp	r3,sp[0x24]
80008b04:	10 90       	mov	r0,r8
80008b06:	40 41       	lddsp	r1,sp[0x10]
80008b08:	50 d9       	stdsp	sp[0x34],r9
80008b0a:	e0 8f 08 95 	bral	80009c34 <_vfprintf_r+0x1320>
80008b0e:	30 08       	mov	r8,0
80008b10:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80008b14:	f0 09 18 00 	cp.b	r9,r8
80008b18:	ce 21       	brne	80008adc <_vfprintf_r+0x1c8>
80008b1a:	32 08       	mov	r8,32
80008b1c:	c6 e8       	rjmp	80008bf8 <_vfprintf_r+0x2e4>
80008b1e:	a1 a5       	sbr	r5,0x0
80008b20:	cd eb       	rjmp	80008adc <_vfprintf_r+0x1c8>
80008b22:	0f 89       	ld.ub	r9,r7[0x0]
80008b24:	f2 c8 00 30 	sub	r8,r9,48
80008b28:	58 98       	cp.w	r8,9
80008b2a:	e0 8b 00 1d 	brhi	80008b64 <_vfprintf_r+0x250>
80008b2e:	ee c8 ff ff 	sub	r8,r7,-1
80008b32:	30 0b       	mov	r11,0
80008b34:	23 09       	sub	r9,48
80008b36:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80008b3a:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80008b3e:	11 39       	ld.ub	r9,r8++
80008b40:	f2 ca 00 30 	sub	r10,r9,48
80008b44:	58 9a       	cp.w	r10,9
80008b46:	fe 98 ff f7 	brls	80008b34 <_vfprintf_r+0x220>
80008b4a:	e0 49 00 24 	cp.w	r9,36
80008b4e:	cc 51       	brne	80008ad8 <_vfprintf_r+0x1c4>
80008b50:	e0 4b 00 20 	cp.w	r11,32
80008b54:	e0 89 0e 6a 	brgt	8000a828 <_vfprintf_r+0x1f14>
80008b58:	20 1b       	sub	r11,1
80008b5a:	fa f9 06 b4 	ld.w	r9,sp[1716]
80008b5e:	12 3b       	cp.w	r11,r9
80008b60:	c0 95       	brlt	80008b72 <_vfprintf_r+0x25e>
80008b62:	c1 08       	rjmp	80008b82 <_vfprintf_r+0x26e>
80008b64:	fa f9 06 b4 	ld.w	r9,sp[1716]
80008b68:	ec ca ff ff 	sub	r10,r6,-1
80008b6c:	12 36       	cp.w	r6,r9
80008b6e:	c1 f5       	brlt	80008bac <_vfprintf_r+0x298>
80008b70:	c2 68       	rjmp	80008bbc <_vfprintf_r+0x2a8>
80008b72:	fa ce f9 44 	sub	lr,sp,-1724
80008b76:	10 97       	mov	r7,r8
80008b78:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80008b7c:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80008b80:	c3 58       	rjmp	80008bea <_vfprintf_r+0x2d6>
80008b82:	10 97       	mov	r7,r8
80008b84:	fa c8 f9 50 	sub	r8,sp,-1712
80008b88:	1a d8       	st.w	--sp,r8
80008b8a:	fa c8 fa b8 	sub	r8,sp,-1352
80008b8e:	1a d8       	st.w	--sp,r8
80008b90:	fa c8 fb b4 	sub	r8,sp,-1100
80008b94:	02 9a       	mov	r10,r1
80008b96:	1a d8       	st.w	--sp,r8
80008b98:	04 9c       	mov	r12,r2
80008b9a:	fa c8 f9 40 	sub	r8,sp,-1728
80008b9e:	fa c9 ff b4 	sub	r9,sp,-76
80008ba2:	fe b0 fd 1b 	rcall	800085d8 <get_arg>
80008ba6:	2f dd       	sub	sp,-12
80008ba8:	78 00       	ld.w	r0,r12[0x0]
80008baa:	c2 08       	rjmp	80008bea <_vfprintf_r+0x2d6>
80008bac:	fa cc f9 44 	sub	r12,sp,-1724
80008bb0:	14 96       	mov	r6,r10
80008bb2:	f8 03 00 38 	add	r8,r12,r3<<0x3
80008bb6:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80008bba:	c1 88       	rjmp	80008bea <_vfprintf_r+0x2d6>
80008bbc:	41 08       	lddsp	r8,sp[0x40]
80008bbe:	59 f9       	cp.w	r9,31
80008bc0:	e0 89 00 11 	brgt	80008be2 <_vfprintf_r+0x2ce>
80008bc4:	f0 cb ff fc 	sub	r11,r8,-4
80008bc8:	51 0b       	stdsp	sp[0x40],r11
80008bca:	70 00       	ld.w	r0,r8[0x0]
80008bcc:	fa cb f9 44 	sub	r11,sp,-1724
80008bd0:	f6 09 00 38 	add	r8,r11,r9<<0x3
80008bd4:	f1 40 fd 88 	st.w	r8[-632],r0
80008bd8:	2f f9       	sub	r9,-1
80008bda:	14 96       	mov	r6,r10
80008bdc:	fb 49 06 b4 	st.w	sp[1716],r9
80008be0:	c0 58       	rjmp	80008bea <_vfprintf_r+0x2d6>
80008be2:	70 00       	ld.w	r0,r8[0x0]
80008be4:	14 96       	mov	r6,r10
80008be6:	2f c8       	sub	r8,-4
80008be8:	51 08       	stdsp	sp[0x40],r8
80008bea:	58 00       	cp.w	r0,0
80008bec:	fe 94 ff 78 	brge	80008adc <_vfprintf_r+0x1c8>
80008bf0:	5c 30       	neg	r0
80008bf2:	a3 a5       	sbr	r5,0x2
80008bf4:	c7 4b       	rjmp	80008adc <_vfprintf_r+0x1c8>
80008bf6:	32 b8       	mov	r8,43
80008bf8:	fb 68 06 bb 	st.b	sp[1723],r8
80008bfc:	c7 0b       	rjmp	80008adc <_vfprintf_r+0x1c8>
80008bfe:	0f 38       	ld.ub	r8,r7++
80008c00:	e0 48 00 2a 	cp.w	r8,42
80008c04:	c0 30       	breq	80008c0a <_vfprintf_r+0x2f6>
80008c06:	30 09       	mov	r9,0
80008c08:	c7 d8       	rjmp	80008d02 <_vfprintf_r+0x3ee>
80008c0a:	0f 88       	ld.ub	r8,r7[0x0]
80008c0c:	f0 c9 00 30 	sub	r9,r8,48
80008c10:	58 99       	cp.w	r9,9
80008c12:	e0 8b 00 23 	brhi	80008c58 <_vfprintf_r+0x344>
80008c16:	ee c4 ff ff 	sub	r4,r7,-1
80008c1a:	30 0b       	mov	r11,0
80008c1c:	23 08       	sub	r8,48
80008c1e:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80008c22:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80008c26:	09 38       	ld.ub	r8,r4++
80008c28:	f0 c9 00 30 	sub	r9,r8,48
80008c2c:	58 99       	cp.w	r9,9
80008c2e:	fe 98 ff f7 	brls	80008c1c <_vfprintf_r+0x308>
80008c32:	e0 48 00 24 	cp.w	r8,36
80008c36:	fe 91 ff 51 	brne	80008ad8 <_vfprintf_r+0x1c4>
80008c3a:	e0 4b 00 20 	cp.w	r11,32
80008c3e:	e0 89 0d f5 	brgt	8000a828 <_vfprintf_r+0x1f14>
80008c42:	20 1b       	sub	r11,1
80008c44:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c48:	10 3b       	cp.w	r11,r8
80008c4a:	c0 e5       	brlt	80008c66 <_vfprintf_r+0x352>
80008c4c:	c1 58       	rjmp	80008c76 <_vfprintf_r+0x362>
80008c4e:	d7 03       	nop
80008c50:	80 02       	ld.sh	r2,r0[0x0]
80008c52:	f5 78 80 02 	stcond	r10[-32766],r8
80008c56:	f7 b4       	*unknown*
80008c58:	fa fa 06 b4 	ld.w	r10,sp[1716]
80008c5c:	ec c9 ff ff 	sub	r9,r6,-1
80008c60:	14 36       	cp.w	r6,r10
80008c62:	c1 f5       	brlt	80008ca0 <_vfprintf_r+0x38c>
80008c64:	c2 88       	rjmp	80008cb4 <_vfprintf_r+0x3a0>
80008c66:	fa ca f9 44 	sub	r10,sp,-1724
80008c6a:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80008c6e:	f6 fb fd 88 	ld.w	r11,r11[-632]
80008c72:	50 2b       	stdsp	sp[0x8],r11
80008c74:	c3 c8       	rjmp	80008cec <_vfprintf_r+0x3d8>
80008c76:	fa c8 f9 50 	sub	r8,sp,-1712
80008c7a:	1a d8       	st.w	--sp,r8
80008c7c:	fa c8 fa b8 	sub	r8,sp,-1352
80008c80:	1a d8       	st.w	--sp,r8
80008c82:	fa c8 fb b4 	sub	r8,sp,-1100
80008c86:	02 9a       	mov	r10,r1
80008c88:	1a d8       	st.w	--sp,r8
80008c8a:	04 9c       	mov	r12,r2
80008c8c:	fa c8 f9 40 	sub	r8,sp,-1728
80008c90:	fa c9 ff b4 	sub	r9,sp,-76
80008c94:	fe b0 fc a2 	rcall	800085d8 <get_arg>
80008c98:	2f dd       	sub	sp,-12
80008c9a:	78 0c       	ld.w	r12,r12[0x0]
80008c9c:	50 2c       	stdsp	sp[0x8],r12
80008c9e:	c2 78       	rjmp	80008cec <_vfprintf_r+0x3d8>
80008ca0:	12 96       	mov	r6,r9
80008ca2:	0e 94       	mov	r4,r7
80008ca4:	fa c9 f9 44 	sub	r9,sp,-1724
80008ca8:	f2 03 00 38 	add	r8,r9,r3<<0x3
80008cac:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80008cb0:	50 28       	stdsp	sp[0x8],r8
80008cb2:	c1 d8       	rjmp	80008cec <_vfprintf_r+0x3d8>
80008cb4:	41 08       	lddsp	r8,sp[0x40]
80008cb6:	59 fa       	cp.w	r10,31
80008cb8:	e0 89 00 14 	brgt	80008ce0 <_vfprintf_r+0x3cc>
80008cbc:	f0 cb ff fc 	sub	r11,r8,-4
80008cc0:	70 08       	ld.w	r8,r8[0x0]
80008cc2:	51 0b       	stdsp	sp[0x40],r11
80008cc4:	50 28       	stdsp	sp[0x8],r8
80008cc6:	fa c6 f9 44 	sub	r6,sp,-1724
80008cca:	40 2e       	lddsp	lr,sp[0x8]
80008ccc:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80008cd0:	f1 4e fd 88 	st.w	r8[-632],lr
80008cd4:	2f fa       	sub	r10,-1
80008cd6:	0e 94       	mov	r4,r7
80008cd8:	fb 4a 06 b4 	st.w	sp[1716],r10
80008cdc:	12 96       	mov	r6,r9
80008cde:	c0 78       	rjmp	80008cec <_vfprintf_r+0x3d8>
80008ce0:	70 0c       	ld.w	r12,r8[0x0]
80008ce2:	0e 94       	mov	r4,r7
80008ce4:	2f c8       	sub	r8,-4
80008ce6:	50 2c       	stdsp	sp[0x8],r12
80008ce8:	12 96       	mov	r6,r9
80008cea:	51 08       	stdsp	sp[0x40],r8
80008cec:	40 2b       	lddsp	r11,sp[0x8]
80008cee:	58 0b       	cp.w	r11,0
80008cf0:	fe 95 fe f0 	brlt	80008ad0 <_vfprintf_r+0x1bc>
80008cf4:	08 97       	mov	r7,r4
80008cf6:	cf 3a       	rjmp	80008adc <_vfprintf_r+0x1c8>
80008cf8:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008cfc:	0f 38       	ld.ub	r8,r7++
80008cfe:	f4 09 00 19 	add	r9,r10,r9<<0x1
80008d02:	f0 ca 00 30 	sub	r10,r8,48
80008d06:	58 9a       	cp.w	r10,9
80008d08:	fe 98 ff f8 	brls	80008cf8 <_vfprintf_r+0x3e4>
80008d0c:	3f fa       	mov	r10,-1
80008d0e:	f2 0a 0c 49 	max	r9,r9,r10
80008d12:	50 29       	stdsp	sp[0x8],r9
80008d14:	ce 7a       	rjmp	80008ae2 <_vfprintf_r+0x1ce>
80008d16:	a7 b5       	sbr	r5,0x7
80008d18:	ce 2a       	rjmp	80008adc <_vfprintf_r+0x1c8>
80008d1a:	30 09       	mov	r9,0
80008d1c:	23 08       	sub	r8,48
80008d1e:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008d22:	f0 09 00 19 	add	r9,r8,r9<<0x1
80008d26:	0f 38       	ld.ub	r8,r7++
80008d28:	f0 ca 00 30 	sub	r10,r8,48
80008d2c:	58 9a       	cp.w	r10,9
80008d2e:	fe 98 ff f7 	brls	80008d1c <_vfprintf_r+0x408>
80008d32:	e0 48 00 24 	cp.w	r8,36
80008d36:	fe 91 fe d5 	brne	80008ae0 <_vfprintf_r+0x1cc>
80008d3a:	e0 49 00 20 	cp.w	r9,32
80008d3e:	e0 89 0d 75 	brgt	8000a828 <_vfprintf_r+0x1f14>
80008d42:	f2 c3 00 01 	sub	r3,r9,1
80008d46:	30 19       	mov	r9,1
80008d48:	50 39       	stdsp	sp[0xc],r9
80008d4a:	cc 9a       	rjmp	80008adc <_vfprintf_r+0x1c8>
80008d4c:	a3 b5       	sbr	r5,0x3
80008d4e:	cc 7a       	rjmp	80008adc <_vfprintf_r+0x1c8>
80008d50:	a7 a5       	sbr	r5,0x6
80008d52:	cc 5a       	rjmp	80008adc <_vfprintf_r+0x1c8>
80008d54:	0a 98       	mov	r8,r5
80008d56:	a5 b5       	sbr	r5,0x5
80008d58:	a5 a8       	sbr	r8,0x4
80008d5a:	0f 89       	ld.ub	r9,r7[0x0]
80008d5c:	36 ce       	mov	lr,108
80008d5e:	fc 09 18 00 	cp.b	r9,lr
80008d62:	f7 b7 00 ff 	subeq	r7,-1
80008d66:	f0 05 17 10 	movne	r5,r8
80008d6a:	cb 9a       	rjmp	80008adc <_vfprintf_r+0x1c8>
80008d6c:	a5 b5       	sbr	r5,0x5
80008d6e:	cb 7a       	rjmp	80008adc <_vfprintf_r+0x1c8>
80008d70:	50 a7       	stdsp	sp[0x28],r7
80008d72:	50 80       	stdsp	sp[0x20],r0
80008d74:	0c 97       	mov	r7,r6
80008d76:	10 90       	mov	r0,r8
80008d78:	06 96       	mov	r6,r3
80008d7a:	04 94       	mov	r4,r2
80008d7c:	40 93       	lddsp	r3,sp[0x24]
80008d7e:	02 92       	mov	r2,r1
80008d80:	0e 99       	mov	r9,r7
80008d82:	40 41       	lddsp	r1,sp[0x10]
80008d84:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d88:	40 3c       	lddsp	r12,sp[0xc]
80008d8a:	58 0c       	cp.w	r12,0
80008d8c:	c1 d0       	breq	80008dc6 <_vfprintf_r+0x4b2>
80008d8e:	10 36       	cp.w	r6,r8
80008d90:	c0 64       	brge	80008d9c <_vfprintf_r+0x488>
80008d92:	fa cb f9 44 	sub	r11,sp,-1724
80008d96:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d9a:	c1 d8       	rjmp	80008dd4 <_vfprintf_r+0x4c0>
80008d9c:	fa c8 f9 50 	sub	r8,sp,-1712
80008da0:	1a d8       	st.w	--sp,r8
80008da2:	fa c8 fa b8 	sub	r8,sp,-1352
80008da6:	1a d8       	st.w	--sp,r8
80008da8:	fa c8 fb b4 	sub	r8,sp,-1100
80008dac:	1a d8       	st.w	--sp,r8
80008dae:	fa c8 f9 40 	sub	r8,sp,-1728
80008db2:	fa c9 ff b4 	sub	r9,sp,-76
80008db6:	04 9a       	mov	r10,r2
80008db8:	0c 9b       	mov	r11,r6
80008dba:	08 9c       	mov	r12,r4
80008dbc:	fe b0 fc 0e 	rcall	800085d8 <get_arg>
80008dc0:	2f dd       	sub	sp,-12
80008dc2:	19 b8       	ld.ub	r8,r12[0x3]
80008dc4:	c2 28       	rjmp	80008e08 <_vfprintf_r+0x4f4>
80008dc6:	2f f7       	sub	r7,-1
80008dc8:	10 39       	cp.w	r9,r8
80008dca:	c0 84       	brge	80008dda <_vfprintf_r+0x4c6>
80008dcc:	fa ca f9 44 	sub	r10,sp,-1724
80008dd0:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008dd4:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80008dd8:	c1 88       	rjmp	80008e08 <_vfprintf_r+0x4f4>
80008dda:	41 09       	lddsp	r9,sp[0x40]
80008ddc:	59 f8       	cp.w	r8,31
80008dde:	e0 89 00 12 	brgt	80008e02 <_vfprintf_r+0x4ee>
80008de2:	f2 ca ff fc 	sub	r10,r9,-4
80008de6:	51 0a       	stdsp	sp[0x40],r10
80008de8:	72 09       	ld.w	r9,r9[0x0]
80008dea:	fa c6 f9 44 	sub	r6,sp,-1724
80008dee:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008df2:	2f f8       	sub	r8,-1
80008df4:	f5 49 fd 88 	st.w	r10[-632],r9
80008df8:	fb 48 06 b4 	st.w	sp[1716],r8
80008dfc:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80008e00:	c0 48       	rjmp	80008e08 <_vfprintf_r+0x4f4>
80008e02:	13 b8       	ld.ub	r8,r9[0x3]
80008e04:	2f c9       	sub	r9,-4
80008e06:	51 09       	stdsp	sp[0x40],r9
80008e08:	fb 68 06 60 	st.b	sp[1632],r8
80008e0c:	30 0e       	mov	lr,0
80008e0e:	30 08       	mov	r8,0
80008e10:	30 12       	mov	r2,1
80008e12:	fb 68 06 bb 	st.b	sp[1723],r8
80008e16:	50 2e       	stdsp	sp[0x8],lr
80008e18:	e0 8f 08 b1 	bral	80009f7a <_vfprintf_r+0x1666>
80008e1c:	50 a7       	stdsp	sp[0x28],r7
80008e1e:	50 80       	stdsp	sp[0x20],r0
80008e20:	0c 97       	mov	r7,r6
80008e22:	04 94       	mov	r4,r2
80008e24:	06 96       	mov	r6,r3
80008e26:	02 92       	mov	r2,r1
80008e28:	40 93       	lddsp	r3,sp[0x24]
80008e2a:	10 90       	mov	r0,r8
80008e2c:	40 41       	lddsp	r1,sp[0x10]
80008e2e:	a5 a5       	sbr	r5,0x4
80008e30:	c0 a8       	rjmp	80008e44 <_vfprintf_r+0x530>
80008e32:	50 a7       	stdsp	sp[0x28],r7
80008e34:	50 80       	stdsp	sp[0x20],r0
80008e36:	0c 97       	mov	r7,r6
80008e38:	04 94       	mov	r4,r2
80008e3a:	06 96       	mov	r6,r3
80008e3c:	02 92       	mov	r2,r1
80008e3e:	40 93       	lddsp	r3,sp[0x24]
80008e40:	10 90       	mov	r0,r8
80008e42:	40 41       	lddsp	r1,sp[0x10]
80008e44:	ed b5 00 05 	bld	r5,0x5
80008e48:	c5 11       	brne	80008eea <_vfprintf_r+0x5d6>
80008e4a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e4e:	40 3c       	lddsp	r12,sp[0xc]
80008e50:	58 0c       	cp.w	r12,0
80008e52:	c1 e0       	breq	80008e8e <_vfprintf_r+0x57a>
80008e54:	10 36       	cp.w	r6,r8
80008e56:	c0 64       	brge	80008e62 <_vfprintf_r+0x54e>
80008e58:	fa cb f9 44 	sub	r11,sp,-1724
80008e5c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e60:	c2 08       	rjmp	80008ea0 <_vfprintf_r+0x58c>
80008e62:	fa c8 f9 50 	sub	r8,sp,-1712
80008e66:	1a d8       	st.w	--sp,r8
80008e68:	fa c8 fa b8 	sub	r8,sp,-1352
80008e6c:	0c 9b       	mov	r11,r6
80008e6e:	1a d8       	st.w	--sp,r8
80008e70:	fa c8 fb b4 	sub	r8,sp,-1100
80008e74:	1a d8       	st.w	--sp,r8
80008e76:	fa c9 ff b4 	sub	r9,sp,-76
80008e7a:	fa c8 f9 40 	sub	r8,sp,-1728
80008e7e:	04 9a       	mov	r10,r2
80008e80:	08 9c       	mov	r12,r4
80008e82:	fe b0 fb ab 	rcall	800085d8 <get_arg>
80008e86:	2f dd       	sub	sp,-12
80008e88:	78 1b       	ld.w	r11,r12[0x4]
80008e8a:	78 09       	ld.w	r9,r12[0x0]
80008e8c:	c2 b8       	rjmp	80008ee2 <_vfprintf_r+0x5ce>
80008e8e:	ee ca ff ff 	sub	r10,r7,-1
80008e92:	10 37       	cp.w	r7,r8
80008e94:	c0 b4       	brge	80008eaa <_vfprintf_r+0x596>
80008e96:	fa c9 f9 44 	sub	r9,sp,-1724
80008e9a:	14 97       	mov	r7,r10
80008e9c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008ea0:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008ea4:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008ea8:	c1 d8       	rjmp	80008ee2 <_vfprintf_r+0x5ce>
80008eaa:	41 09       	lddsp	r9,sp[0x40]
80008eac:	59 f8       	cp.w	r8,31
80008eae:	e0 89 00 14 	brgt	80008ed6 <_vfprintf_r+0x5c2>
80008eb2:	f2 cb ff f8 	sub	r11,r9,-8
80008eb6:	51 0b       	stdsp	sp[0x40],r11
80008eb8:	fa c6 f9 44 	sub	r6,sp,-1724
80008ebc:	72 1b       	ld.w	r11,r9[0x4]
80008ebe:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80008ec2:	72 09       	ld.w	r9,r9[0x0]
80008ec4:	f9 4b fd 8c 	st.w	r12[-628],r11
80008ec8:	f9 49 fd 88 	st.w	r12[-632],r9
80008ecc:	2f f8       	sub	r8,-1
80008ece:	14 97       	mov	r7,r10
80008ed0:	fb 48 06 b4 	st.w	sp[1716],r8
80008ed4:	c0 78       	rjmp	80008ee2 <_vfprintf_r+0x5ce>
80008ed6:	f2 c8 ff f8 	sub	r8,r9,-8
80008eda:	72 1b       	ld.w	r11,r9[0x4]
80008edc:	14 97       	mov	r7,r10
80008ede:	51 08       	stdsp	sp[0x40],r8
80008ee0:	72 09       	ld.w	r9,r9[0x0]
80008ee2:	16 98       	mov	r8,r11
80008ee4:	fa e9 00 00 	st.d	sp[0],r8
80008ee8:	ca e8       	rjmp	80009044 <_vfprintf_r+0x730>
80008eea:	ed b5 00 04 	bld	r5,0x4
80008eee:	c1 71       	brne	80008f1c <_vfprintf_r+0x608>
80008ef0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ef4:	40 3e       	lddsp	lr,sp[0xc]
80008ef6:	58 0e       	cp.w	lr,0
80008ef8:	c0 80       	breq	80008f08 <_vfprintf_r+0x5f4>
80008efa:	10 36       	cp.w	r6,r8
80008efc:	c6 94       	brge	80008fce <_vfprintf_r+0x6ba>
80008efe:	fa cc f9 44 	sub	r12,sp,-1724
80008f02:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008f06:	c8 28       	rjmp	8000900a <_vfprintf_r+0x6f6>
80008f08:	ee ca ff ff 	sub	r10,r7,-1
80008f0c:	10 37       	cp.w	r7,r8
80008f0e:	e0 84 00 81 	brge	80009010 <_vfprintf_r+0x6fc>
80008f12:	fa cb f9 44 	sub	r11,sp,-1724
80008f16:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f1a:	c7 78       	rjmp	80009008 <_vfprintf_r+0x6f4>
80008f1c:	ed b5 00 06 	bld	r5,0x6
80008f20:	c4 b1       	brne	80008fb6 <_vfprintf_r+0x6a2>
80008f22:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f26:	40 3c       	lddsp	r12,sp[0xc]
80008f28:	58 0c       	cp.w	r12,0
80008f2a:	c1 d0       	breq	80008f64 <_vfprintf_r+0x650>
80008f2c:	10 36       	cp.w	r6,r8
80008f2e:	c0 64       	brge	80008f3a <_vfprintf_r+0x626>
80008f30:	fa cb f9 44 	sub	r11,sp,-1724
80008f34:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f38:	c1 f8       	rjmp	80008f76 <_vfprintf_r+0x662>
80008f3a:	fa c8 f9 50 	sub	r8,sp,-1712
80008f3e:	1a d8       	st.w	--sp,r8
80008f40:	fa c8 fa b8 	sub	r8,sp,-1352
80008f44:	1a d8       	st.w	--sp,r8
80008f46:	fa c8 fb b4 	sub	r8,sp,-1100
80008f4a:	1a d8       	st.w	--sp,r8
80008f4c:	fa c8 f9 40 	sub	r8,sp,-1728
80008f50:	fa c9 ff b4 	sub	r9,sp,-76
80008f54:	04 9a       	mov	r10,r2
80008f56:	0c 9b       	mov	r11,r6
80008f58:	08 9c       	mov	r12,r4
80008f5a:	fe b0 fb 3f 	rcall	800085d8 <get_arg>
80008f5e:	2f dd       	sub	sp,-12
80008f60:	98 18       	ld.sh	r8,r12[0x2]
80008f62:	c2 68       	rjmp	80008fae <_vfprintf_r+0x69a>
80008f64:	ee ca ff ff 	sub	r10,r7,-1
80008f68:	10 37       	cp.w	r7,r8
80008f6a:	c0 94       	brge	80008f7c <_vfprintf_r+0x668>
80008f6c:	fa c9 f9 44 	sub	r9,sp,-1724
80008f70:	14 97       	mov	r7,r10
80008f72:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008f76:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008f7a:	c1 a8       	rjmp	80008fae <_vfprintf_r+0x69a>
80008f7c:	41 09       	lddsp	r9,sp[0x40]
80008f7e:	59 f8       	cp.w	r8,31
80008f80:	e0 89 00 13 	brgt	80008fa6 <_vfprintf_r+0x692>
80008f84:	f2 cb ff fc 	sub	r11,r9,-4
80008f88:	51 0b       	stdsp	sp[0x40],r11
80008f8a:	72 09       	ld.w	r9,r9[0x0]
80008f8c:	fa c6 f9 44 	sub	r6,sp,-1724
80008f90:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008f94:	2f f8       	sub	r8,-1
80008f96:	f7 49 fd 88 	st.w	r11[-632],r9
80008f9a:	fb 48 06 b4 	st.w	sp[1716],r8
80008f9e:	14 97       	mov	r7,r10
80008fa0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008fa4:	c0 58       	rjmp	80008fae <_vfprintf_r+0x69a>
80008fa6:	92 18       	ld.sh	r8,r9[0x2]
80008fa8:	14 97       	mov	r7,r10
80008faa:	2f c9       	sub	r9,-4
80008fac:	51 09       	stdsp	sp[0x40],r9
80008fae:	50 18       	stdsp	sp[0x4],r8
80008fb0:	bf 58       	asr	r8,0x1f
80008fb2:	50 08       	stdsp	sp[0x0],r8
80008fb4:	c4 88       	rjmp	80009044 <_vfprintf_r+0x730>
80008fb6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008fba:	40 3c       	lddsp	r12,sp[0xc]
80008fbc:	58 0c       	cp.w	r12,0
80008fbe:	c1 d0       	breq	80008ff8 <_vfprintf_r+0x6e4>
80008fc0:	10 36       	cp.w	r6,r8
80008fc2:	c0 64       	brge	80008fce <_vfprintf_r+0x6ba>
80008fc4:	fa cb f9 44 	sub	r11,sp,-1724
80008fc8:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008fcc:	c1 f8       	rjmp	8000900a <_vfprintf_r+0x6f6>
80008fce:	fa c8 f9 50 	sub	r8,sp,-1712
80008fd2:	1a d8       	st.w	--sp,r8
80008fd4:	fa c8 fa b8 	sub	r8,sp,-1352
80008fd8:	0c 9b       	mov	r11,r6
80008fda:	1a d8       	st.w	--sp,r8
80008fdc:	fa c8 fb b4 	sub	r8,sp,-1100
80008fe0:	04 9a       	mov	r10,r2
80008fe2:	1a d8       	st.w	--sp,r8
80008fe4:	08 9c       	mov	r12,r4
80008fe6:	fa c8 f9 40 	sub	r8,sp,-1728
80008fea:	fa c9 ff b4 	sub	r9,sp,-76
80008fee:	fe b0 fa f5 	rcall	800085d8 <get_arg>
80008ff2:	2f dd       	sub	sp,-12
80008ff4:	78 0b       	ld.w	r11,r12[0x0]
80008ff6:	c2 48       	rjmp	8000903e <_vfprintf_r+0x72a>
80008ff8:	ee ca ff ff 	sub	r10,r7,-1
80008ffc:	10 37       	cp.w	r7,r8
80008ffe:	c0 94       	brge	80009010 <_vfprintf_r+0x6fc>
80009000:	fa c9 f9 44 	sub	r9,sp,-1724
80009004:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009008:	14 97       	mov	r7,r10
8000900a:	ec fb fd 88 	ld.w	r11,r6[-632]
8000900e:	c1 88       	rjmp	8000903e <_vfprintf_r+0x72a>
80009010:	41 09       	lddsp	r9,sp[0x40]
80009012:	59 f8       	cp.w	r8,31
80009014:	e0 89 00 11 	brgt	80009036 <_vfprintf_r+0x722>
80009018:	f2 cb ff fc 	sub	r11,r9,-4
8000901c:	51 0b       	stdsp	sp[0x40],r11
8000901e:	fa c6 f9 44 	sub	r6,sp,-1724
80009022:	72 0b       	ld.w	r11,r9[0x0]
80009024:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009028:	f3 4b fd 88 	st.w	r9[-632],r11
8000902c:	2f f8       	sub	r8,-1
8000902e:	14 97       	mov	r7,r10
80009030:	fb 48 06 b4 	st.w	sp[1716],r8
80009034:	c0 58       	rjmp	8000903e <_vfprintf_r+0x72a>
80009036:	72 0b       	ld.w	r11,r9[0x0]
80009038:	14 97       	mov	r7,r10
8000903a:	2f c9       	sub	r9,-4
8000903c:	51 09       	stdsp	sp[0x40],r9
8000903e:	50 1b       	stdsp	sp[0x4],r11
80009040:	bf 5b       	asr	r11,0x1f
80009042:	50 0b       	stdsp	sp[0x0],r11
80009044:	fa ea 00 00 	ld.d	r10,sp[0]
80009048:	58 0a       	cp.w	r10,0
8000904a:	5c 2b       	cpc	r11
8000904c:	c0 e4       	brge	80009068 <_vfprintf_r+0x754>
8000904e:	30 08       	mov	r8,0
80009050:	fa ea 00 00 	ld.d	r10,sp[0]
80009054:	30 09       	mov	r9,0
80009056:	f0 0a 01 0a 	sub	r10,r8,r10
8000905a:	f2 0b 01 4b 	sbc	r11,r9,r11
8000905e:	32 d8       	mov	r8,45
80009060:	fa eb 00 00 	st.d	sp[0],r10
80009064:	fb 68 06 bb 	st.b	sp[1723],r8
80009068:	30 18       	mov	r8,1
8000906a:	e0 8f 06 fe 	bral	80009e66 <_vfprintf_r+0x1552>
8000906e:	50 a7       	stdsp	sp[0x28],r7
80009070:	50 80       	stdsp	sp[0x20],r0
80009072:	0c 97       	mov	r7,r6
80009074:	04 94       	mov	r4,r2
80009076:	06 96       	mov	r6,r3
80009078:	02 92       	mov	r2,r1
8000907a:	40 93       	lddsp	r3,sp[0x24]
8000907c:	10 90       	mov	r0,r8
8000907e:	40 41       	lddsp	r1,sp[0x10]
80009080:	0e 99       	mov	r9,r7
80009082:	ed b5 00 03 	bld	r5,0x3
80009086:	c4 11       	brne	80009108 <_vfprintf_r+0x7f4>
80009088:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000908c:	40 3a       	lddsp	r10,sp[0xc]
8000908e:	58 0a       	cp.w	r10,0
80009090:	c1 90       	breq	800090c2 <_vfprintf_r+0x7ae>
80009092:	10 36       	cp.w	r6,r8
80009094:	c6 45       	brlt	8000915c <_vfprintf_r+0x848>
80009096:	fa c8 f9 50 	sub	r8,sp,-1712
8000909a:	1a d8       	st.w	--sp,r8
8000909c:	fa c8 fa b8 	sub	r8,sp,-1352
800090a0:	1a d8       	st.w	--sp,r8
800090a2:	fa c8 fb b4 	sub	r8,sp,-1100
800090a6:	0c 9b       	mov	r11,r6
800090a8:	1a d8       	st.w	--sp,r8
800090aa:	04 9a       	mov	r10,r2
800090ac:	fa c8 f9 40 	sub	r8,sp,-1728
800090b0:	fa c9 ff b4 	sub	r9,sp,-76
800090b4:	08 9c       	mov	r12,r4
800090b6:	fe b0 fa 91 	rcall	800085d8 <get_arg>
800090ba:	2f dd       	sub	sp,-12
800090bc:	78 16       	ld.w	r6,r12[0x4]
800090be:	50 76       	stdsp	sp[0x1c],r6
800090c0:	c4 88       	rjmp	80009150 <_vfprintf_r+0x83c>
800090c2:	2f f7       	sub	r7,-1
800090c4:	10 39       	cp.w	r9,r8
800090c6:	c0 c4       	brge	800090de <_vfprintf_r+0x7ca>
800090c8:	fa ce f9 44 	sub	lr,sp,-1724
800090cc:	fc 06 00 36 	add	r6,lr,r6<<0x3
800090d0:	ec fc fd 8c 	ld.w	r12,r6[-628]
800090d4:	50 7c       	stdsp	sp[0x1c],r12
800090d6:	ec f6 fd 88 	ld.w	r6,r6[-632]
800090da:	50 56       	stdsp	sp[0x14],r6
800090dc:	c6 68       	rjmp	800091a8 <_vfprintf_r+0x894>
800090de:	41 09       	lddsp	r9,sp[0x40]
800090e0:	59 f8       	cp.w	r8,31
800090e2:	e0 89 00 10 	brgt	80009102 <_vfprintf_r+0x7ee>
800090e6:	f2 ca ff f8 	sub	r10,r9,-8
800090ea:	72 1b       	ld.w	r11,r9[0x4]
800090ec:	51 0a       	stdsp	sp[0x40],r10
800090ee:	72 09       	ld.w	r9,r9[0x0]
800090f0:	fa ca f9 44 	sub	r10,sp,-1724
800090f4:	50 7b       	stdsp	sp[0x1c],r11
800090f6:	50 59       	stdsp	sp[0x14],r9
800090f8:	f4 08 00 39 	add	r9,r10,r8<<0x3
800090fc:	40 5b       	lddsp	r11,sp[0x14]
800090fe:	40 7a       	lddsp	r10,sp[0x1c]
80009100:	c4 78       	rjmp	8000918e <_vfprintf_r+0x87a>
80009102:	72 18       	ld.w	r8,r9[0x4]
80009104:	50 78       	stdsp	sp[0x1c],r8
80009106:	c4 c8       	rjmp	8000919e <_vfprintf_r+0x88a>
80009108:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000910c:	40 3e       	lddsp	lr,sp[0xc]
8000910e:	58 0e       	cp.w	lr,0
80009110:	c2 30       	breq	80009156 <_vfprintf_r+0x842>
80009112:	10 36       	cp.w	r6,r8
80009114:	c0 94       	brge	80009126 <_vfprintf_r+0x812>
80009116:	fa cc f9 44 	sub	r12,sp,-1724
8000911a:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000911e:	ec fb fd 8c 	ld.w	r11,r6[-628]
80009122:	50 7b       	stdsp	sp[0x1c],r11
80009124:	cd 9b       	rjmp	800090d6 <_vfprintf_r+0x7c2>
80009126:	fa c8 f9 50 	sub	r8,sp,-1712
8000912a:	1a d8       	st.w	--sp,r8
8000912c:	fa c8 fa b8 	sub	r8,sp,-1352
80009130:	04 9a       	mov	r10,r2
80009132:	1a d8       	st.w	--sp,r8
80009134:	fa c8 fb b4 	sub	r8,sp,-1100
80009138:	0c 9b       	mov	r11,r6
8000913a:	1a d8       	st.w	--sp,r8
8000913c:	08 9c       	mov	r12,r4
8000913e:	fa c8 f9 40 	sub	r8,sp,-1728
80009142:	fa c9 ff b4 	sub	r9,sp,-76
80009146:	fe b0 fa 49 	rcall	800085d8 <get_arg>
8000914a:	2f dd       	sub	sp,-12
8000914c:	78 1a       	ld.w	r10,r12[0x4]
8000914e:	50 7a       	stdsp	sp[0x1c],r10
80009150:	78 0c       	ld.w	r12,r12[0x0]
80009152:	50 5c       	stdsp	sp[0x14],r12
80009154:	c2 a8       	rjmp	800091a8 <_vfprintf_r+0x894>
80009156:	2f f7       	sub	r7,-1
80009158:	10 39       	cp.w	r9,r8
8000915a:	c0 94       	brge	8000916c <_vfprintf_r+0x858>
8000915c:	fa c9 f9 44 	sub	r9,sp,-1724
80009160:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009164:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80009168:	50 78       	stdsp	sp[0x1c],r8
8000916a:	cb 6b       	rjmp	800090d6 <_vfprintf_r+0x7c2>
8000916c:	41 09       	lddsp	r9,sp[0x40]
8000916e:	59 f8       	cp.w	r8,31
80009170:	e0 89 00 15 	brgt	8000919a <_vfprintf_r+0x886>
80009174:	f2 ca ff f8 	sub	r10,r9,-8
80009178:	72 16       	ld.w	r6,r9[0x4]
8000917a:	72 09       	ld.w	r9,r9[0x0]
8000917c:	51 0a       	stdsp	sp[0x40],r10
8000917e:	50 59       	stdsp	sp[0x14],r9
80009180:	fa ce f9 44 	sub	lr,sp,-1724
80009184:	50 76       	stdsp	sp[0x1c],r6
80009186:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000918a:	40 5b       	lddsp	r11,sp[0x14]
8000918c:	0c 9a       	mov	r10,r6
8000918e:	f2 eb fd 88 	st.d	r9[-632],r10
80009192:	2f f8       	sub	r8,-1
80009194:	fb 48 06 b4 	st.w	sp[1716],r8
80009198:	c0 88       	rjmp	800091a8 <_vfprintf_r+0x894>
8000919a:	72 1c       	ld.w	r12,r9[0x4]
8000919c:	50 7c       	stdsp	sp[0x1c],r12
8000919e:	f2 c8 ff f8 	sub	r8,r9,-8
800091a2:	51 08       	stdsp	sp[0x40],r8
800091a4:	72 09       	ld.w	r9,r9[0x0]
800091a6:	50 59       	stdsp	sp[0x14],r9
800091a8:	40 5b       	lddsp	r11,sp[0x14]
800091aa:	40 7a       	lddsp	r10,sp[0x1c]
800091ac:	e0 a0 19 60 	rcall	8000c46c <__isinfd>
800091b0:	18 96       	mov	r6,r12
800091b2:	c1 50       	breq	800091dc <_vfprintf_r+0x8c8>
800091b4:	30 08       	mov	r8,0
800091b6:	30 09       	mov	r9,0
800091b8:	40 5b       	lddsp	r11,sp[0x14]
800091ba:	40 7a       	lddsp	r10,sp[0x1c]
800091bc:	fe b0 f0 b0 	rcall	8000731c <__avr32_f64_cmp_lt>
800091c0:	c0 40       	breq	800091c8 <_vfprintf_r+0x8b4>
800091c2:	32 d8       	mov	r8,45
800091c4:	fb 68 06 bb 	st.b	sp[1723],r8
800091c8:	4d 18       	lddpc	r8,8000930c <_vfprintf_r+0x9f8>
800091ca:	4d 26       	lddpc	r6,80009310 <_vfprintf_r+0x9fc>
800091cc:	a7 d5       	cbr	r5,0x7
800091ce:	e0 40 00 47 	cp.w	r0,71
800091d2:	f0 06 17 a0 	movle	r6,r8
800091d6:	30 32       	mov	r2,3
800091d8:	e0 8f 06 d4 	bral	80009f80 <_vfprintf_r+0x166c>
800091dc:	40 5b       	lddsp	r11,sp[0x14]
800091de:	40 7a       	lddsp	r10,sp[0x1c]
800091e0:	e0 a0 19 5b 	rcall	8000c496 <__isnand>
800091e4:	c0 c0       	breq	800091fc <_vfprintf_r+0x8e8>
800091e6:	50 26       	stdsp	sp[0x8],r6
800091e8:	4c b8       	lddpc	r8,80009314 <_vfprintf_r+0xa00>
800091ea:	4c c6       	lddpc	r6,80009318 <_vfprintf_r+0xa04>
800091ec:	a7 d5       	cbr	r5,0x7
800091ee:	e0 40 00 47 	cp.w	r0,71
800091f2:	f0 06 17 a0 	movle	r6,r8
800091f6:	30 32       	mov	r2,3
800091f8:	e0 8f 06 ca 	bral	80009f8c <_vfprintf_r+0x1678>
800091fc:	40 2a       	lddsp	r10,sp[0x8]
800091fe:	5b fa       	cp.w	r10,-1
80009200:	c0 41       	brne	80009208 <_vfprintf_r+0x8f4>
80009202:	30 69       	mov	r9,6
80009204:	50 29       	stdsp	sp[0x8],r9
80009206:	c1 18       	rjmp	80009228 <_vfprintf_r+0x914>
80009208:	e0 40 00 47 	cp.w	r0,71
8000920c:	5f 09       	sreq	r9
8000920e:	e0 40 00 67 	cp.w	r0,103
80009212:	5f 08       	sreq	r8
80009214:	f3 e8 10 08 	or	r8,r9,r8
80009218:	f8 08 18 00 	cp.b	r8,r12
8000921c:	c0 60       	breq	80009228 <_vfprintf_r+0x914>
8000921e:	40 28       	lddsp	r8,sp[0x8]
80009220:	58 08       	cp.w	r8,0
80009222:	f9 b8 00 01 	moveq	r8,1
80009226:	50 28       	stdsp	sp[0x8],r8
80009228:	40 78       	lddsp	r8,sp[0x1c]
8000922a:	40 59       	lddsp	r9,sp[0x14]
8000922c:	fa e9 06 94 	st.d	sp[1684],r8
80009230:	a9 a5       	sbr	r5,0x8
80009232:	fa f8 06 94 	ld.w	r8,sp[1684]
80009236:	58 08       	cp.w	r8,0
80009238:	c0 65       	brlt	80009244 <_vfprintf_r+0x930>
8000923a:	40 5e       	lddsp	lr,sp[0x14]
8000923c:	30 0c       	mov	r12,0
8000923e:	50 6e       	stdsp	sp[0x18],lr
80009240:	50 9c       	stdsp	sp[0x24],r12
80009242:	c0 78       	rjmp	80009250 <_vfprintf_r+0x93c>
80009244:	40 5b       	lddsp	r11,sp[0x14]
80009246:	32 da       	mov	r10,45
80009248:	ee 1b 80 00 	eorh	r11,0x8000
8000924c:	50 9a       	stdsp	sp[0x24],r10
8000924e:	50 6b       	stdsp	sp[0x18],r11
80009250:	e0 40 00 46 	cp.w	r0,70
80009254:	5f 09       	sreq	r9
80009256:	e0 40 00 66 	cp.w	r0,102
8000925a:	5f 08       	sreq	r8
8000925c:	f3 e8 10 08 	or	r8,r9,r8
80009260:	50 48       	stdsp	sp[0x10],r8
80009262:	c0 40       	breq	8000926a <_vfprintf_r+0x956>
80009264:	40 22       	lddsp	r2,sp[0x8]
80009266:	30 39       	mov	r9,3
80009268:	c1 08       	rjmp	80009288 <_vfprintf_r+0x974>
8000926a:	e0 40 00 45 	cp.w	r0,69
8000926e:	5f 09       	sreq	r9
80009270:	e0 40 00 65 	cp.w	r0,101
80009274:	5f 08       	sreq	r8
80009276:	40 22       	lddsp	r2,sp[0x8]
80009278:	10 49       	or	r9,r8
8000927a:	2f f2       	sub	r2,-1
8000927c:	40 46       	lddsp	r6,sp[0x10]
8000927e:	ec 09 18 00 	cp.b	r9,r6
80009282:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80009286:	30 29       	mov	r9,2
80009288:	fa c8 f9 5c 	sub	r8,sp,-1700
8000928c:	1a d8       	st.w	--sp,r8
8000928e:	fa c8 f9 54 	sub	r8,sp,-1708
80009292:	1a d8       	st.w	--sp,r8
80009294:	fa c8 f9 4c 	sub	r8,sp,-1716
80009298:	08 9c       	mov	r12,r4
8000929a:	1a d8       	st.w	--sp,r8
8000929c:	04 98       	mov	r8,r2
8000929e:	40 9b       	lddsp	r11,sp[0x24]
800092a0:	40 aa       	lddsp	r10,sp[0x28]
800092a2:	e0 a0 0b cf 	rcall	8000aa40 <_dtoa_r>
800092a6:	e0 40 00 47 	cp.w	r0,71
800092aa:	5f 19       	srne	r9
800092ac:	e0 40 00 67 	cp.w	r0,103
800092b0:	5f 18       	srne	r8
800092b2:	18 96       	mov	r6,r12
800092b4:	2f dd       	sub	sp,-12
800092b6:	f3 e8 00 08 	and	r8,r9,r8
800092ba:	c0 41       	brne	800092c2 <_vfprintf_r+0x9ae>
800092bc:	ed b5 00 00 	bld	r5,0x0
800092c0:	c3 81       	brne	80009330 <_vfprintf_r+0xa1c>
800092c2:	ec 02 00 0e 	add	lr,r6,r2
800092c6:	50 3e       	stdsp	sp[0xc],lr
800092c8:	40 4c       	lddsp	r12,sp[0x10]
800092ca:	58 0c       	cp.w	r12,0
800092cc:	c1 50       	breq	800092f6 <_vfprintf_r+0x9e2>
800092ce:	0d 89       	ld.ub	r9,r6[0x0]
800092d0:	33 08       	mov	r8,48
800092d2:	f0 09 18 00 	cp.b	r9,r8
800092d6:	c0 b1       	brne	800092ec <_vfprintf_r+0x9d8>
800092d8:	30 08       	mov	r8,0
800092da:	30 09       	mov	r9,0
800092dc:	40 6b       	lddsp	r11,sp[0x18]
800092de:	40 7a       	lddsp	r10,sp[0x1c]
800092e0:	e0 a0 1a 33 	rcall	8000c746 <__avr32_f64_cmp_eq>
800092e4:	fb b2 00 01 	rsubeq	r2,1
800092e8:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
800092ec:	40 3b       	lddsp	r11,sp[0xc]
800092ee:	fa f8 06 ac 	ld.w	r8,sp[1708]
800092f2:	10 0b       	add	r11,r8
800092f4:	50 3b       	stdsp	sp[0xc],r11
800092f6:	40 6b       	lddsp	r11,sp[0x18]
800092f8:	30 08       	mov	r8,0
800092fa:	30 09       	mov	r9,0
800092fc:	40 7a       	lddsp	r10,sp[0x1c]
800092fe:	e0 a0 1a 24 	rcall	8000c746 <__avr32_f64_cmp_eq>
80009302:	c1 10       	breq	80009324 <_vfprintf_r+0xa10>
80009304:	40 3a       	lddsp	r10,sp[0xc]
80009306:	fb 4a 06 a4 	st.w	sp[1700],r10
8000930a:	c0 d8       	rjmp	80009324 <_vfprintf_r+0xa10>
8000930c:	80 02       	ld.sh	r2,r0[0x0]
8000930e:	f7 c8       	*unknown*
80009310:	80 02       	ld.sh	r2,r0[0x0]
80009312:	f7 cc       	*unknown*
80009314:	80 02       	ld.sh	r2,r0[0x0]
80009316:	f7 d0 80 02 	ldswp.w	r0,r11[8]
8000931a:	f7 d4 10 c9 	ldins.h	r4:t,r11[402]
8000931e:	fb 48 06 a4 	st.w	sp[1700],r8
80009322:	c0 28       	rjmp	80009326 <_vfprintf_r+0xa12>
80009324:	33 09       	mov	r9,48
80009326:	fa f8 06 a4 	ld.w	r8,sp[1700]
8000932a:	40 3e       	lddsp	lr,sp[0xc]
8000932c:	1c 38       	cp.w	r8,lr
8000932e:	cf 73       	brcs	8000931c <_vfprintf_r+0xa08>
80009330:	e0 40 00 47 	cp.w	r0,71
80009334:	5f 09       	sreq	r9
80009336:	e0 40 00 67 	cp.w	r0,103
8000933a:	5f 08       	sreq	r8
8000933c:	f3 e8 10 08 	or	r8,r9,r8
80009340:	fa f9 06 a4 	ld.w	r9,sp[1700]
80009344:	0c 19       	sub	r9,r6
80009346:	50 69       	stdsp	sp[0x18],r9
80009348:	58 08       	cp.w	r8,0
8000934a:	c0 b0       	breq	80009360 <_vfprintf_r+0xa4c>
8000934c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009350:	5b d8       	cp.w	r8,-3
80009352:	c0 55       	brlt	8000935c <_vfprintf_r+0xa48>
80009354:	40 2c       	lddsp	r12,sp[0x8]
80009356:	18 38       	cp.w	r8,r12
80009358:	e0 8a 00 6a 	brle	8000942c <_vfprintf_r+0xb18>
8000935c:	20 20       	sub	r0,2
8000935e:	c0 58       	rjmp	80009368 <_vfprintf_r+0xa54>
80009360:	e0 40 00 65 	cp.w	r0,101
80009364:	e0 89 00 46 	brgt	800093f0 <_vfprintf_r+0xadc>
80009368:	fa fb 06 ac 	ld.w	r11,sp[1708]
8000936c:	fb 60 06 9c 	st.b	sp[1692],r0
80009370:	20 1b       	sub	r11,1
80009372:	fb 4b 06 ac 	st.w	sp[1708],r11
80009376:	c0 47       	brpl	8000937e <_vfprintf_r+0xa6a>
80009378:	5c 3b       	neg	r11
8000937a:	32 d8       	mov	r8,45
8000937c:	c0 28       	rjmp	80009380 <_vfprintf_r+0xa6c>
8000937e:	32 b8       	mov	r8,43
80009380:	fb 68 06 9d 	st.b	sp[1693],r8
80009384:	58 9b       	cp.w	r11,9
80009386:	e0 8a 00 1d 	brle	800093c0 <_vfprintf_r+0xaac>
8000938a:	fa c9 fa 35 	sub	r9,sp,-1483
8000938e:	30 aa       	mov	r10,10
80009390:	12 98       	mov	r8,r9
80009392:	0e 9c       	mov	r12,r7
80009394:	0c 92       	mov	r2,r6
80009396:	f6 0a 0c 06 	divs	r6,r11,r10
8000939a:	0e 9b       	mov	r11,r7
8000939c:	2d 0b       	sub	r11,-48
8000939e:	10 fb       	st.b	--r8,r11
800093a0:	0c 9b       	mov	r11,r6
800093a2:	58 96       	cp.w	r6,9
800093a4:	fe 99 ff f9 	brgt	80009396 <_vfprintf_r+0xa82>
800093a8:	2d 0b       	sub	r11,-48
800093aa:	18 97       	mov	r7,r12
800093ac:	04 96       	mov	r6,r2
800093ae:	10 fb       	st.b	--r8,r11
800093b0:	fa ca f9 62 	sub	r10,sp,-1694
800093b4:	c0 38       	rjmp	800093ba <_vfprintf_r+0xaa6>
800093b6:	11 3b       	ld.ub	r11,r8++
800093b8:	14 cb       	st.b	r10++,r11
800093ba:	12 38       	cp.w	r8,r9
800093bc:	cf d3       	brcs	800093b6 <_vfprintf_r+0xaa2>
800093be:	c0 98       	rjmp	800093d0 <_vfprintf_r+0xabc>
800093c0:	2d 0b       	sub	r11,-48
800093c2:	33 08       	mov	r8,48
800093c4:	fb 6b 06 9f 	st.b	sp[1695],r11
800093c8:	fb 68 06 9e 	st.b	sp[1694],r8
800093cc:	fa ca f9 60 	sub	r10,sp,-1696
800093d0:	fa c8 f9 64 	sub	r8,sp,-1692
800093d4:	f4 08 01 08 	sub	r8,r10,r8
800093d8:	50 e8       	stdsp	sp[0x38],r8
800093da:	10 92       	mov	r2,r8
800093dc:	40 6b       	lddsp	r11,sp[0x18]
800093de:	16 02       	add	r2,r11
800093e0:	58 1b       	cp.w	r11,1
800093e2:	e0 89 00 05 	brgt	800093ec <_vfprintf_r+0xad8>
800093e6:	ed b5 00 00 	bld	r5,0x0
800093ea:	c3 51       	brne	80009454 <_vfprintf_r+0xb40>
800093ec:	2f f2       	sub	r2,-1
800093ee:	c3 38       	rjmp	80009454 <_vfprintf_r+0xb40>
800093f0:	e0 40 00 66 	cp.w	r0,102
800093f4:	c1 c1       	brne	8000942c <_vfprintf_r+0xb18>
800093f6:	fa f2 06 ac 	ld.w	r2,sp[1708]
800093fa:	58 02       	cp.w	r2,0
800093fc:	e0 8a 00 0c 	brle	80009414 <_vfprintf_r+0xb00>
80009400:	40 2a       	lddsp	r10,sp[0x8]
80009402:	58 0a       	cp.w	r10,0
80009404:	c0 41       	brne	8000940c <_vfprintf_r+0xaf8>
80009406:	ed b5 00 00 	bld	r5,0x0
8000940a:	c2 51       	brne	80009454 <_vfprintf_r+0xb40>
8000940c:	2f f2       	sub	r2,-1
8000940e:	40 29       	lddsp	r9,sp[0x8]
80009410:	12 02       	add	r2,r9
80009412:	c0 b8       	rjmp	80009428 <_vfprintf_r+0xb14>
80009414:	40 28       	lddsp	r8,sp[0x8]
80009416:	58 08       	cp.w	r8,0
80009418:	c0 61       	brne	80009424 <_vfprintf_r+0xb10>
8000941a:	ed b5 00 00 	bld	r5,0x0
8000941e:	c0 30       	breq	80009424 <_vfprintf_r+0xb10>
80009420:	30 12       	mov	r2,1
80009422:	c1 98       	rjmp	80009454 <_vfprintf_r+0xb40>
80009424:	40 22       	lddsp	r2,sp[0x8]
80009426:	2f e2       	sub	r2,-2
80009428:	36 60       	mov	r0,102
8000942a:	c1 58       	rjmp	80009454 <_vfprintf_r+0xb40>
8000942c:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009430:	40 6e       	lddsp	lr,sp[0x18]
80009432:	1c 32       	cp.w	r2,lr
80009434:	c0 65       	brlt	80009440 <_vfprintf_r+0xb2c>
80009436:	ed b5 00 00 	bld	r5,0x0
8000943a:	f7 b2 00 ff 	subeq	r2,-1
8000943e:	c0 a8       	rjmp	80009452 <_vfprintf_r+0xb3e>
80009440:	e4 08 11 02 	rsub	r8,r2,2
80009444:	40 6c       	lddsp	r12,sp[0x18]
80009446:	58 02       	cp.w	r2,0
80009448:	f0 02 17 a0 	movle	r2,r8
8000944c:	f9 b2 09 01 	movgt	r2,1
80009450:	18 02       	add	r2,r12
80009452:	36 70       	mov	r0,103
80009454:	40 9b       	lddsp	r11,sp[0x24]
80009456:	58 0b       	cp.w	r11,0
80009458:	e0 80 05 94 	breq	80009f80 <_vfprintf_r+0x166c>
8000945c:	32 d8       	mov	r8,45
8000945e:	fb 68 06 bb 	st.b	sp[1723],r8
80009462:	e0 8f 05 93 	bral	80009f88 <_vfprintf_r+0x1674>
80009466:	50 a7       	stdsp	sp[0x28],r7
80009468:	04 94       	mov	r4,r2
8000946a:	0c 97       	mov	r7,r6
8000946c:	02 92       	mov	r2,r1
8000946e:	06 96       	mov	r6,r3
80009470:	40 41       	lddsp	r1,sp[0x10]
80009472:	40 93       	lddsp	r3,sp[0x24]
80009474:	0e 99       	mov	r9,r7
80009476:	ed b5 00 05 	bld	r5,0x5
8000947a:	c4 81       	brne	8000950a <_vfprintf_r+0xbf6>
8000947c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009480:	40 3e       	lddsp	lr,sp[0xc]
80009482:	58 0e       	cp.w	lr,0
80009484:	c1 d0       	breq	800094be <_vfprintf_r+0xbaa>
80009486:	10 36       	cp.w	r6,r8
80009488:	c0 64       	brge	80009494 <_vfprintf_r+0xb80>
8000948a:	fa cc f9 44 	sub	r12,sp,-1724
8000948e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009492:	c1 d8       	rjmp	800094cc <_vfprintf_r+0xbb8>
80009494:	fa c8 f9 50 	sub	r8,sp,-1712
80009498:	1a d8       	st.w	--sp,r8
8000949a:	fa c8 fa b8 	sub	r8,sp,-1352
8000949e:	04 9a       	mov	r10,r2
800094a0:	1a d8       	st.w	--sp,r8
800094a2:	fa c8 fb b4 	sub	r8,sp,-1100
800094a6:	0c 9b       	mov	r11,r6
800094a8:	1a d8       	st.w	--sp,r8
800094aa:	08 9c       	mov	r12,r4
800094ac:	fa c8 f9 40 	sub	r8,sp,-1728
800094b0:	fa c9 ff b4 	sub	r9,sp,-76
800094b4:	fe b0 f8 92 	rcall	800085d8 <get_arg>
800094b8:	2f dd       	sub	sp,-12
800094ba:	78 0a       	ld.w	r10,r12[0x0]
800094bc:	c2 08       	rjmp	800094fc <_vfprintf_r+0xbe8>
800094be:	2f f7       	sub	r7,-1
800094c0:	10 39       	cp.w	r9,r8
800094c2:	c0 84       	brge	800094d2 <_vfprintf_r+0xbbe>
800094c4:	fa cb f9 44 	sub	r11,sp,-1724
800094c8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800094cc:	ec fa fd 88 	ld.w	r10,r6[-632]
800094d0:	c1 68       	rjmp	800094fc <_vfprintf_r+0xbe8>
800094d2:	41 09       	lddsp	r9,sp[0x40]
800094d4:	59 f8       	cp.w	r8,31
800094d6:	e0 89 00 10 	brgt	800094f6 <_vfprintf_r+0xbe2>
800094da:	f2 ca ff fc 	sub	r10,r9,-4
800094de:	51 0a       	stdsp	sp[0x40],r10
800094e0:	fa c6 f9 44 	sub	r6,sp,-1724
800094e4:	72 0a       	ld.w	r10,r9[0x0]
800094e6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800094ea:	f3 4a fd 88 	st.w	r9[-632],r10
800094ee:	2f f8       	sub	r8,-1
800094f0:	fb 48 06 b4 	st.w	sp[1716],r8
800094f4:	c0 48       	rjmp	800094fc <_vfprintf_r+0xbe8>
800094f6:	72 0a       	ld.w	r10,r9[0x0]
800094f8:	2f c9       	sub	r9,-4
800094fa:	51 09       	stdsp	sp[0x40],r9
800094fc:	40 be       	lddsp	lr,sp[0x2c]
800094fe:	1c 98       	mov	r8,lr
80009500:	95 1e       	st.w	r10[0x4],lr
80009502:	bf 58       	asr	r8,0x1f
80009504:	95 08       	st.w	r10[0x0],r8
80009506:	fe 9f fa 92 	bral	80008a2a <_vfprintf_r+0x116>
8000950a:	ed b5 00 04 	bld	r5,0x4
8000950e:	c4 80       	breq	8000959e <_vfprintf_r+0xc8a>
80009510:	e2 15 00 40 	andl	r5,0x40,COH
80009514:	c4 50       	breq	8000959e <_vfprintf_r+0xc8a>
80009516:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000951a:	40 3c       	lddsp	r12,sp[0xc]
8000951c:	58 0c       	cp.w	r12,0
8000951e:	c1 d0       	breq	80009558 <_vfprintf_r+0xc44>
80009520:	10 36       	cp.w	r6,r8
80009522:	c0 64       	brge	8000952e <_vfprintf_r+0xc1a>
80009524:	fa cb f9 44 	sub	r11,sp,-1724
80009528:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000952c:	c1 d8       	rjmp	80009566 <_vfprintf_r+0xc52>
8000952e:	fa c8 f9 50 	sub	r8,sp,-1712
80009532:	1a d8       	st.w	--sp,r8
80009534:	fa c8 fa b8 	sub	r8,sp,-1352
80009538:	04 9a       	mov	r10,r2
8000953a:	1a d8       	st.w	--sp,r8
8000953c:	fa c8 fb b4 	sub	r8,sp,-1100
80009540:	0c 9b       	mov	r11,r6
80009542:	1a d8       	st.w	--sp,r8
80009544:	08 9c       	mov	r12,r4
80009546:	fa c8 f9 40 	sub	r8,sp,-1728
8000954a:	fa c9 ff b4 	sub	r9,sp,-76
8000954e:	fe b0 f8 45 	rcall	800085d8 <get_arg>
80009552:	2f dd       	sub	sp,-12
80009554:	78 0a       	ld.w	r10,r12[0x0]
80009556:	c2 08       	rjmp	80009596 <_vfprintf_r+0xc82>
80009558:	2f f7       	sub	r7,-1
8000955a:	10 39       	cp.w	r9,r8
8000955c:	c0 84       	brge	8000956c <_vfprintf_r+0xc58>
8000955e:	fa ca f9 44 	sub	r10,sp,-1724
80009562:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009566:	ec fa fd 88 	ld.w	r10,r6[-632]
8000956a:	c1 68       	rjmp	80009596 <_vfprintf_r+0xc82>
8000956c:	41 09       	lddsp	r9,sp[0x40]
8000956e:	59 f8       	cp.w	r8,31
80009570:	e0 89 00 10 	brgt	80009590 <_vfprintf_r+0xc7c>
80009574:	f2 ca ff fc 	sub	r10,r9,-4
80009578:	51 0a       	stdsp	sp[0x40],r10
8000957a:	fa c6 f9 44 	sub	r6,sp,-1724
8000957e:	72 0a       	ld.w	r10,r9[0x0]
80009580:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009584:	f3 4a fd 88 	st.w	r9[-632],r10
80009588:	2f f8       	sub	r8,-1
8000958a:	fb 48 06 b4 	st.w	sp[1716],r8
8000958e:	c0 48       	rjmp	80009596 <_vfprintf_r+0xc82>
80009590:	72 0a       	ld.w	r10,r9[0x0]
80009592:	2f c9       	sub	r9,-4
80009594:	51 09       	stdsp	sp[0x40],r9
80009596:	40 be       	lddsp	lr,sp[0x2c]
80009598:	b4 0e       	st.h	r10[0x0],lr
8000959a:	fe 9f fa 48 	bral	80008a2a <_vfprintf_r+0x116>
8000959e:	fa f8 06 b4 	ld.w	r8,sp[1716]
800095a2:	40 3c       	lddsp	r12,sp[0xc]
800095a4:	58 0c       	cp.w	r12,0
800095a6:	c1 d0       	breq	800095e0 <_vfprintf_r+0xccc>
800095a8:	10 36       	cp.w	r6,r8
800095aa:	c0 64       	brge	800095b6 <_vfprintf_r+0xca2>
800095ac:	fa cb f9 44 	sub	r11,sp,-1724
800095b0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800095b4:	c1 d8       	rjmp	800095ee <_vfprintf_r+0xcda>
800095b6:	fa c8 f9 50 	sub	r8,sp,-1712
800095ba:	1a d8       	st.w	--sp,r8
800095bc:	fa c8 fa b8 	sub	r8,sp,-1352
800095c0:	04 9a       	mov	r10,r2
800095c2:	1a d8       	st.w	--sp,r8
800095c4:	fa c8 fb b4 	sub	r8,sp,-1100
800095c8:	0c 9b       	mov	r11,r6
800095ca:	1a d8       	st.w	--sp,r8
800095cc:	08 9c       	mov	r12,r4
800095ce:	fa c8 f9 40 	sub	r8,sp,-1728
800095d2:	fa c9 ff b4 	sub	r9,sp,-76
800095d6:	fe b0 f8 01 	rcall	800085d8 <get_arg>
800095da:	2f dd       	sub	sp,-12
800095dc:	78 0a       	ld.w	r10,r12[0x0]
800095de:	c2 08       	rjmp	8000961e <_vfprintf_r+0xd0a>
800095e0:	2f f7       	sub	r7,-1
800095e2:	10 39       	cp.w	r9,r8
800095e4:	c0 84       	brge	800095f4 <_vfprintf_r+0xce0>
800095e6:	fa ca f9 44 	sub	r10,sp,-1724
800095ea:	f4 06 00 36 	add	r6,r10,r6<<0x3
800095ee:	ec fa fd 88 	ld.w	r10,r6[-632]
800095f2:	c1 68       	rjmp	8000961e <_vfprintf_r+0xd0a>
800095f4:	41 09       	lddsp	r9,sp[0x40]
800095f6:	59 f8       	cp.w	r8,31
800095f8:	e0 89 00 10 	brgt	80009618 <_vfprintf_r+0xd04>
800095fc:	f2 ca ff fc 	sub	r10,r9,-4
80009600:	51 0a       	stdsp	sp[0x40],r10
80009602:	fa c6 f9 44 	sub	r6,sp,-1724
80009606:	72 0a       	ld.w	r10,r9[0x0]
80009608:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000960c:	f3 4a fd 88 	st.w	r9[-632],r10
80009610:	2f f8       	sub	r8,-1
80009612:	fb 48 06 b4 	st.w	sp[1716],r8
80009616:	c0 48       	rjmp	8000961e <_vfprintf_r+0xd0a>
80009618:	72 0a       	ld.w	r10,r9[0x0]
8000961a:	2f c9       	sub	r9,-4
8000961c:	51 09       	stdsp	sp[0x40],r9
8000961e:	40 be       	lddsp	lr,sp[0x2c]
80009620:	95 0e       	st.w	r10[0x0],lr
80009622:	fe 9f fa 04 	bral	80008a2a <_vfprintf_r+0x116>
80009626:	50 a7       	stdsp	sp[0x28],r7
80009628:	50 80       	stdsp	sp[0x20],r0
8000962a:	0c 97       	mov	r7,r6
8000962c:	04 94       	mov	r4,r2
8000962e:	06 96       	mov	r6,r3
80009630:	02 92       	mov	r2,r1
80009632:	40 93       	lddsp	r3,sp[0x24]
80009634:	10 90       	mov	r0,r8
80009636:	40 41       	lddsp	r1,sp[0x10]
80009638:	a5 a5       	sbr	r5,0x4
8000963a:	c0 a8       	rjmp	8000964e <_vfprintf_r+0xd3a>
8000963c:	50 a7       	stdsp	sp[0x28],r7
8000963e:	50 80       	stdsp	sp[0x20],r0
80009640:	0c 97       	mov	r7,r6
80009642:	04 94       	mov	r4,r2
80009644:	06 96       	mov	r6,r3
80009646:	02 92       	mov	r2,r1
80009648:	40 93       	lddsp	r3,sp[0x24]
8000964a:	10 90       	mov	r0,r8
8000964c:	40 41       	lddsp	r1,sp[0x10]
8000964e:	ed b5 00 05 	bld	r5,0x5
80009652:	c5 d1       	brne	8000970c <_vfprintf_r+0xdf8>
80009654:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009658:	40 3c       	lddsp	r12,sp[0xc]
8000965a:	58 0c       	cp.w	r12,0
8000965c:	c2 60       	breq	800096a8 <_vfprintf_r+0xd94>
8000965e:	10 36       	cp.w	r6,r8
80009660:	c0 a4       	brge	80009674 <_vfprintf_r+0xd60>
80009662:	fa cb f9 44 	sub	r11,sp,-1724
80009666:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000966a:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000966e:	fa e9 00 00 	st.d	sp[0],r8
80009672:	c1 88       	rjmp	800096a2 <_vfprintf_r+0xd8e>
80009674:	fa c8 f9 50 	sub	r8,sp,-1712
80009678:	1a d8       	st.w	--sp,r8
8000967a:	fa c8 fa b8 	sub	r8,sp,-1352
8000967e:	04 9a       	mov	r10,r2
80009680:	1a d8       	st.w	--sp,r8
80009682:	0c 9b       	mov	r11,r6
80009684:	fa c8 fb b4 	sub	r8,sp,-1100
80009688:	08 9c       	mov	r12,r4
8000968a:	1a d8       	st.w	--sp,r8
8000968c:	fa c8 f9 40 	sub	r8,sp,-1728
80009690:	fa c9 ff b4 	sub	r9,sp,-76
80009694:	fe b0 f7 a2 	rcall	800085d8 <get_arg>
80009698:	2f dd       	sub	sp,-12
8000969a:	f8 ea 00 00 	ld.d	r10,r12[0]
8000969e:	fa eb 00 00 	st.d	sp[0],r10
800096a2:	30 08       	mov	r8,0
800096a4:	e0 8f 03 de 	bral	80009e60 <_vfprintf_r+0x154c>
800096a8:	ee ca ff ff 	sub	r10,r7,-1
800096ac:	10 37       	cp.w	r7,r8
800096ae:	c0 b4       	brge	800096c4 <_vfprintf_r+0xdb0>
800096b0:	fa c9 f9 44 	sub	r9,sp,-1724
800096b4:	14 97       	mov	r7,r10
800096b6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800096ba:	ec ea fd 88 	ld.d	r10,r6[-632]
800096be:	fa eb 00 00 	st.d	sp[0],r10
800096c2:	c1 88       	rjmp	800096f2 <_vfprintf_r+0xdde>
800096c4:	41 09       	lddsp	r9,sp[0x40]
800096c6:	59 f8       	cp.w	r8,31
800096c8:	e0 89 00 18 	brgt	800096f8 <_vfprintf_r+0xde4>
800096cc:	f2 e6 00 00 	ld.d	r6,r9[0]
800096d0:	f2 cb ff f8 	sub	r11,r9,-8
800096d4:	fa e7 00 00 	st.d	sp[0],r6
800096d8:	51 0b       	stdsp	sp[0x40],r11
800096da:	fa c6 f9 44 	sub	r6,sp,-1724
800096de:	ec 08 00 39 	add	r9,r6,r8<<0x3
800096e2:	fa e6 00 00 	ld.d	r6,sp[0]
800096e6:	f2 e7 fd 88 	st.d	r9[-632],r6
800096ea:	2f f8       	sub	r8,-1
800096ec:	14 97       	mov	r7,r10
800096ee:	fb 48 06 b4 	st.w	sp[1716],r8
800096f2:	40 38       	lddsp	r8,sp[0xc]
800096f4:	e0 8f 03 b6 	bral	80009e60 <_vfprintf_r+0x154c>
800096f8:	f2 e6 00 00 	ld.d	r6,r9[0]
800096fc:	40 38       	lddsp	r8,sp[0xc]
800096fe:	fa e7 00 00 	st.d	sp[0],r6
80009702:	2f 89       	sub	r9,-8
80009704:	14 97       	mov	r7,r10
80009706:	51 09       	stdsp	sp[0x40],r9
80009708:	e0 8f 03 ac 	bral	80009e60 <_vfprintf_r+0x154c>
8000970c:	ed b5 00 04 	bld	r5,0x4
80009710:	c1 61       	brne	8000973c <_vfprintf_r+0xe28>
80009712:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009716:	40 3e       	lddsp	lr,sp[0xc]
80009718:	58 0e       	cp.w	lr,0
8000971a:	c0 80       	breq	8000972a <_vfprintf_r+0xe16>
8000971c:	10 36       	cp.w	r6,r8
8000971e:	c6 74       	brge	800097ec <_vfprintf_r+0xed8>
80009720:	fa cc f9 44 	sub	r12,sp,-1724
80009724:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009728:	c8 08       	rjmp	80009828 <_vfprintf_r+0xf14>
8000972a:	ee ca ff ff 	sub	r10,r7,-1
8000972e:	10 37       	cp.w	r7,r8
80009730:	c7 f4       	brge	8000982e <_vfprintf_r+0xf1a>
80009732:	fa cb f9 44 	sub	r11,sp,-1724
80009736:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000973a:	c7 68       	rjmp	80009826 <_vfprintf_r+0xf12>
8000973c:	ed b5 00 06 	bld	r5,0x6
80009740:	c4 a1       	brne	800097d4 <_vfprintf_r+0xec0>
80009742:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009746:	40 3c       	lddsp	r12,sp[0xc]
80009748:	58 0c       	cp.w	r12,0
8000974a:	c1 d0       	breq	80009784 <_vfprintf_r+0xe70>
8000974c:	10 36       	cp.w	r6,r8
8000974e:	c0 64       	brge	8000975a <_vfprintf_r+0xe46>
80009750:	fa cb f9 44 	sub	r11,sp,-1724
80009754:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009758:	c1 f8       	rjmp	80009796 <_vfprintf_r+0xe82>
8000975a:	fa c8 f9 50 	sub	r8,sp,-1712
8000975e:	1a d8       	st.w	--sp,r8
80009760:	fa c8 fa b8 	sub	r8,sp,-1352
80009764:	1a d8       	st.w	--sp,r8
80009766:	fa c8 fb b4 	sub	r8,sp,-1100
8000976a:	1a d8       	st.w	--sp,r8
8000976c:	fa c8 f9 40 	sub	r8,sp,-1728
80009770:	fa c9 ff b4 	sub	r9,sp,-76
80009774:	04 9a       	mov	r10,r2
80009776:	0c 9b       	mov	r11,r6
80009778:	08 9c       	mov	r12,r4
8000977a:	fe b0 f7 2f 	rcall	800085d8 <get_arg>
8000977e:	2f dd       	sub	sp,-12
80009780:	98 18       	ld.sh	r8,r12[0x2]
80009782:	c2 68       	rjmp	800097ce <_vfprintf_r+0xeba>
80009784:	ee ca ff ff 	sub	r10,r7,-1
80009788:	10 37       	cp.w	r7,r8
8000978a:	c0 94       	brge	8000979c <_vfprintf_r+0xe88>
8000978c:	fa c9 f9 44 	sub	r9,sp,-1724
80009790:	14 97       	mov	r7,r10
80009792:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009796:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000979a:	c1 a8       	rjmp	800097ce <_vfprintf_r+0xeba>
8000979c:	41 09       	lddsp	r9,sp[0x40]
8000979e:	59 f8       	cp.w	r8,31
800097a0:	e0 89 00 13 	brgt	800097c6 <_vfprintf_r+0xeb2>
800097a4:	f2 cb ff fc 	sub	r11,r9,-4
800097a8:	51 0b       	stdsp	sp[0x40],r11
800097aa:	72 09       	ld.w	r9,r9[0x0]
800097ac:	fa c6 f9 44 	sub	r6,sp,-1724
800097b0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800097b4:	2f f8       	sub	r8,-1
800097b6:	f7 49 fd 88 	st.w	r11[-632],r9
800097ba:	fb 48 06 b4 	st.w	sp[1716],r8
800097be:	14 97       	mov	r7,r10
800097c0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800097c4:	c0 58       	rjmp	800097ce <_vfprintf_r+0xeba>
800097c6:	92 18       	ld.sh	r8,r9[0x2]
800097c8:	14 97       	mov	r7,r10
800097ca:	2f c9       	sub	r9,-4
800097cc:	51 09       	stdsp	sp[0x40],r9
800097ce:	5c 78       	castu.h	r8
800097d0:	50 18       	stdsp	sp[0x4],r8
800097d2:	c4 68       	rjmp	8000985e <_vfprintf_r+0xf4a>
800097d4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800097d8:	40 3c       	lddsp	r12,sp[0xc]
800097da:	58 0c       	cp.w	r12,0
800097dc:	c1 d0       	breq	80009816 <_vfprintf_r+0xf02>
800097de:	10 36       	cp.w	r6,r8
800097e0:	c0 64       	brge	800097ec <_vfprintf_r+0xed8>
800097e2:	fa cb f9 44 	sub	r11,sp,-1724
800097e6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800097ea:	c1 f8       	rjmp	80009828 <_vfprintf_r+0xf14>
800097ec:	fa c8 f9 50 	sub	r8,sp,-1712
800097f0:	1a d8       	st.w	--sp,r8
800097f2:	fa c8 fa b8 	sub	r8,sp,-1352
800097f6:	0c 9b       	mov	r11,r6
800097f8:	1a d8       	st.w	--sp,r8
800097fa:	fa c8 fb b4 	sub	r8,sp,-1100
800097fe:	04 9a       	mov	r10,r2
80009800:	1a d8       	st.w	--sp,r8
80009802:	08 9c       	mov	r12,r4
80009804:	fa c8 f9 40 	sub	r8,sp,-1728
80009808:	fa c9 ff b4 	sub	r9,sp,-76
8000980c:	fe b0 f6 e6 	rcall	800085d8 <get_arg>
80009810:	2f dd       	sub	sp,-12
80009812:	78 0b       	ld.w	r11,r12[0x0]
80009814:	c2 48       	rjmp	8000985c <_vfprintf_r+0xf48>
80009816:	ee ca ff ff 	sub	r10,r7,-1
8000981a:	10 37       	cp.w	r7,r8
8000981c:	c0 94       	brge	8000982e <_vfprintf_r+0xf1a>
8000981e:	fa c9 f9 44 	sub	r9,sp,-1724
80009822:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009826:	14 97       	mov	r7,r10
80009828:	ec fb fd 88 	ld.w	r11,r6[-632]
8000982c:	c1 88       	rjmp	8000985c <_vfprintf_r+0xf48>
8000982e:	41 09       	lddsp	r9,sp[0x40]
80009830:	59 f8       	cp.w	r8,31
80009832:	e0 89 00 11 	brgt	80009854 <_vfprintf_r+0xf40>
80009836:	f2 cb ff fc 	sub	r11,r9,-4
8000983a:	51 0b       	stdsp	sp[0x40],r11
8000983c:	fa c6 f9 44 	sub	r6,sp,-1724
80009840:	72 0b       	ld.w	r11,r9[0x0]
80009842:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009846:	f3 4b fd 88 	st.w	r9[-632],r11
8000984a:	2f f8       	sub	r8,-1
8000984c:	14 97       	mov	r7,r10
8000984e:	fb 48 06 b4 	st.w	sp[1716],r8
80009852:	c0 58       	rjmp	8000985c <_vfprintf_r+0xf48>
80009854:	72 0b       	ld.w	r11,r9[0x0]
80009856:	14 97       	mov	r7,r10
80009858:	2f c9       	sub	r9,-4
8000985a:	51 09       	stdsp	sp[0x40],r9
8000985c:	50 1b       	stdsp	sp[0x4],r11
8000985e:	30 0e       	mov	lr,0
80009860:	50 0e       	stdsp	sp[0x0],lr
80009862:	1c 98       	mov	r8,lr
80009864:	e0 8f 02 fe 	bral	80009e60 <_vfprintf_r+0x154c>
80009868:	50 a7       	stdsp	sp[0x28],r7
8000986a:	50 80       	stdsp	sp[0x20],r0
8000986c:	0c 97       	mov	r7,r6
8000986e:	04 94       	mov	r4,r2
80009870:	06 96       	mov	r6,r3
80009872:	02 92       	mov	r2,r1
80009874:	40 93       	lddsp	r3,sp[0x24]
80009876:	40 41       	lddsp	r1,sp[0x10]
80009878:	0e 99       	mov	r9,r7
8000987a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000987e:	40 3c       	lddsp	r12,sp[0xc]
80009880:	58 0c       	cp.w	r12,0
80009882:	c1 d0       	breq	800098bc <_vfprintf_r+0xfa8>
80009884:	10 36       	cp.w	r6,r8
80009886:	c0 64       	brge	80009892 <_vfprintf_r+0xf7e>
80009888:	fa cb f9 44 	sub	r11,sp,-1724
8000988c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009890:	c1 d8       	rjmp	800098ca <_vfprintf_r+0xfb6>
80009892:	fa c8 f9 50 	sub	r8,sp,-1712
80009896:	1a d8       	st.w	--sp,r8
80009898:	fa c8 fa b8 	sub	r8,sp,-1352
8000989c:	1a d8       	st.w	--sp,r8
8000989e:	fa c8 fb b4 	sub	r8,sp,-1100
800098a2:	1a d8       	st.w	--sp,r8
800098a4:	fa c9 ff b4 	sub	r9,sp,-76
800098a8:	fa c8 f9 40 	sub	r8,sp,-1728
800098ac:	04 9a       	mov	r10,r2
800098ae:	0c 9b       	mov	r11,r6
800098b0:	08 9c       	mov	r12,r4
800098b2:	fe b0 f6 93 	rcall	800085d8 <get_arg>
800098b6:	2f dd       	sub	sp,-12
800098b8:	78 09       	ld.w	r9,r12[0x0]
800098ba:	c2 18       	rjmp	800098fc <_vfprintf_r+0xfe8>
800098bc:	2f f7       	sub	r7,-1
800098be:	10 39       	cp.w	r9,r8
800098c0:	c0 84       	brge	800098d0 <_vfprintf_r+0xfbc>
800098c2:	fa ca f9 44 	sub	r10,sp,-1724
800098c6:	f4 06 00 36 	add	r6,r10,r6<<0x3
800098ca:	ec f9 fd 88 	ld.w	r9,r6[-632]
800098ce:	c1 78       	rjmp	800098fc <_vfprintf_r+0xfe8>
800098d0:	41 09       	lddsp	r9,sp[0x40]
800098d2:	59 f8       	cp.w	r8,31
800098d4:	e0 89 00 10 	brgt	800098f4 <_vfprintf_r+0xfe0>
800098d8:	f2 ca ff fc 	sub	r10,r9,-4
800098dc:	51 0a       	stdsp	sp[0x40],r10
800098de:	fa c6 f9 44 	sub	r6,sp,-1724
800098e2:	72 09       	ld.w	r9,r9[0x0]
800098e4:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800098e8:	f5 49 fd 88 	st.w	r10[-632],r9
800098ec:	2f f8       	sub	r8,-1
800098ee:	fb 48 06 b4 	st.w	sp[1716],r8
800098f2:	c0 58       	rjmp	800098fc <_vfprintf_r+0xfe8>
800098f4:	f2 c8 ff fc 	sub	r8,r9,-4
800098f8:	51 08       	stdsp	sp[0x40],r8
800098fa:	72 09       	ld.w	r9,r9[0x0]
800098fc:	33 08       	mov	r8,48
800098fe:	fb 68 06 b8 	st.b	sp[1720],r8
80009902:	37 88       	mov	r8,120
80009904:	30 0e       	mov	lr,0
80009906:	fb 68 06 b9 	st.b	sp[1721],r8
8000990a:	4c ac       	lddpc	r12,80009a30 <_vfprintf_r+0x111c>
8000990c:	50 19       	stdsp	sp[0x4],r9
8000990e:	a1 b5       	sbr	r5,0x1
80009910:	50 0e       	stdsp	sp[0x0],lr
80009912:	50 dc       	stdsp	sp[0x34],r12
80009914:	30 28       	mov	r8,2
80009916:	37 80       	mov	r0,120
80009918:	e0 8f 02 a4 	bral	80009e60 <_vfprintf_r+0x154c>
8000991c:	50 a7       	stdsp	sp[0x28],r7
8000991e:	50 80       	stdsp	sp[0x20],r0
80009920:	10 90       	mov	r0,r8
80009922:	30 08       	mov	r8,0
80009924:	fb 68 06 bb 	st.b	sp[1723],r8
80009928:	0c 97       	mov	r7,r6
8000992a:	04 94       	mov	r4,r2
8000992c:	06 96       	mov	r6,r3
8000992e:	02 92       	mov	r2,r1
80009930:	40 93       	lddsp	r3,sp[0x24]
80009932:	40 41       	lddsp	r1,sp[0x10]
80009934:	0e 99       	mov	r9,r7
80009936:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000993a:	40 3b       	lddsp	r11,sp[0xc]
8000993c:	58 0b       	cp.w	r11,0
8000993e:	c1 d0       	breq	80009978 <_vfprintf_r+0x1064>
80009940:	10 36       	cp.w	r6,r8
80009942:	c0 64       	brge	8000994e <_vfprintf_r+0x103a>
80009944:	fa ca f9 44 	sub	r10,sp,-1724
80009948:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000994c:	c1 d8       	rjmp	80009986 <_vfprintf_r+0x1072>
8000994e:	fa c8 f9 50 	sub	r8,sp,-1712
80009952:	1a d8       	st.w	--sp,r8
80009954:	fa c8 fa b8 	sub	r8,sp,-1352
80009958:	1a d8       	st.w	--sp,r8
8000995a:	fa c8 fb b4 	sub	r8,sp,-1100
8000995e:	0c 9b       	mov	r11,r6
80009960:	1a d8       	st.w	--sp,r8
80009962:	04 9a       	mov	r10,r2
80009964:	fa c8 f9 40 	sub	r8,sp,-1728
80009968:	fa c9 ff b4 	sub	r9,sp,-76
8000996c:	08 9c       	mov	r12,r4
8000996e:	fe b0 f6 35 	rcall	800085d8 <get_arg>
80009972:	2f dd       	sub	sp,-12
80009974:	78 06       	ld.w	r6,r12[0x0]
80009976:	c2 08       	rjmp	800099b6 <_vfprintf_r+0x10a2>
80009978:	2f f7       	sub	r7,-1
8000997a:	10 39       	cp.w	r9,r8
8000997c:	c0 84       	brge	8000998c <_vfprintf_r+0x1078>
8000997e:	fa c9 f9 44 	sub	r9,sp,-1724
80009982:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009986:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000998a:	c1 68       	rjmp	800099b6 <_vfprintf_r+0x10a2>
8000998c:	41 09       	lddsp	r9,sp[0x40]
8000998e:	59 f8       	cp.w	r8,31
80009990:	e0 89 00 10 	brgt	800099b0 <_vfprintf_r+0x109c>
80009994:	f2 ca ff fc 	sub	r10,r9,-4
80009998:	51 0a       	stdsp	sp[0x40],r10
8000999a:	72 06       	ld.w	r6,r9[0x0]
8000999c:	fa ce f9 44 	sub	lr,sp,-1724
800099a0:	fc 08 00 39 	add	r9,lr,r8<<0x3
800099a4:	f3 46 fd 88 	st.w	r9[-632],r6
800099a8:	2f f8       	sub	r8,-1
800099aa:	fb 48 06 b4 	st.w	sp[1716],r8
800099ae:	c0 48       	rjmp	800099b6 <_vfprintf_r+0x10a2>
800099b0:	72 06       	ld.w	r6,r9[0x0]
800099b2:	2f c9       	sub	r9,-4
800099b4:	51 09       	stdsp	sp[0x40],r9
800099b6:	40 2c       	lddsp	r12,sp[0x8]
800099b8:	58 0c       	cp.w	r12,0
800099ba:	c1 05       	brlt	800099da <_vfprintf_r+0x10c6>
800099bc:	18 9a       	mov	r10,r12
800099be:	30 0b       	mov	r11,0
800099c0:	0c 9c       	mov	r12,r6
800099c2:	e0 a0 12 3f 	rcall	8000be40 <memchr>
800099c6:	e0 80 02 e0 	breq	80009f86 <_vfprintf_r+0x1672>
800099ca:	f8 06 01 02 	sub	r2,r12,r6
800099ce:	40 2b       	lddsp	r11,sp[0x8]
800099d0:	16 32       	cp.w	r2,r11
800099d2:	e0 89 02 da 	brgt	80009f86 <_vfprintf_r+0x1672>
800099d6:	e0 8f 02 d5 	bral	80009f80 <_vfprintf_r+0x166c>
800099da:	30 0a       	mov	r10,0
800099dc:	0c 9c       	mov	r12,r6
800099de:	50 2a       	stdsp	sp[0x8],r10
800099e0:	e0 a0 15 a2 	rcall	8000c524 <strlen>
800099e4:	18 92       	mov	r2,r12
800099e6:	e0 8f 02 d3 	bral	80009f8c <_vfprintf_r+0x1678>
800099ea:	50 a7       	stdsp	sp[0x28],r7
800099ec:	50 80       	stdsp	sp[0x20],r0
800099ee:	0c 97       	mov	r7,r6
800099f0:	04 94       	mov	r4,r2
800099f2:	06 96       	mov	r6,r3
800099f4:	02 92       	mov	r2,r1
800099f6:	40 93       	lddsp	r3,sp[0x24]
800099f8:	10 90       	mov	r0,r8
800099fa:	40 41       	lddsp	r1,sp[0x10]
800099fc:	a5 a5       	sbr	r5,0x4
800099fe:	c0 a8       	rjmp	80009a12 <_vfprintf_r+0x10fe>
80009a00:	50 a7       	stdsp	sp[0x28],r7
80009a02:	50 80       	stdsp	sp[0x20],r0
80009a04:	0c 97       	mov	r7,r6
80009a06:	04 94       	mov	r4,r2
80009a08:	06 96       	mov	r6,r3
80009a0a:	02 92       	mov	r2,r1
80009a0c:	40 93       	lddsp	r3,sp[0x24]
80009a0e:	10 90       	mov	r0,r8
80009a10:	40 41       	lddsp	r1,sp[0x10]
80009a12:	ed b5 00 05 	bld	r5,0x5
80009a16:	c5 71       	brne	80009ac4 <_vfprintf_r+0x11b0>
80009a18:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009a1c:	40 39       	lddsp	r9,sp[0xc]
80009a1e:	58 09       	cp.w	r9,0
80009a20:	c2 20       	breq	80009a64 <_vfprintf_r+0x1150>
80009a22:	10 36       	cp.w	r6,r8
80009a24:	c0 84       	brge	80009a34 <_vfprintf_r+0x1120>
80009a26:	fa c8 f9 44 	sub	r8,sp,-1724
80009a2a:	f0 06 00 36 	add	r6,r8,r6<<0x3
80009a2e:	c2 48       	rjmp	80009a76 <_vfprintf_r+0x1162>
80009a30:	80 02       	ld.sh	r2,r0[0x0]
80009a32:	f7 d8       	*unknown*
80009a34:	fa c8 f9 50 	sub	r8,sp,-1712
80009a38:	1a d8       	st.w	--sp,r8
80009a3a:	fa c8 fa b8 	sub	r8,sp,-1352
80009a3e:	1a d8       	st.w	--sp,r8
80009a40:	fa c8 fb b4 	sub	r8,sp,-1100
80009a44:	1a d8       	st.w	--sp,r8
80009a46:	fa c8 f9 40 	sub	r8,sp,-1728
80009a4a:	fa c9 ff b4 	sub	r9,sp,-76
80009a4e:	04 9a       	mov	r10,r2
80009a50:	0c 9b       	mov	r11,r6
80009a52:	08 9c       	mov	r12,r4
80009a54:	fe b0 f5 c2 	rcall	800085d8 <get_arg>
80009a58:	2f dd       	sub	sp,-12
80009a5a:	f8 e8 00 00 	ld.d	r8,r12[0]
80009a5e:	fa e9 00 00 	st.d	sp[0],r8
80009a62:	c2 e8       	rjmp	80009abe <_vfprintf_r+0x11aa>
80009a64:	ee ca ff ff 	sub	r10,r7,-1
80009a68:	10 37       	cp.w	r7,r8
80009a6a:	c0 b4       	brge	80009a80 <_vfprintf_r+0x116c>
80009a6c:	fa c8 f9 44 	sub	r8,sp,-1724
80009a70:	14 97       	mov	r7,r10
80009a72:	f0 06 00 36 	add	r6,r8,r6<<0x3
80009a76:	ec ea fd 88 	ld.d	r10,r6[-632]
80009a7a:	fa eb 00 00 	st.d	sp[0],r10
80009a7e:	c2 08       	rjmp	80009abe <_vfprintf_r+0x11aa>
80009a80:	41 09       	lddsp	r9,sp[0x40]
80009a82:	59 f8       	cp.w	r8,31
80009a84:	e0 89 00 16 	brgt	80009ab0 <_vfprintf_r+0x119c>
80009a88:	f2 e6 00 00 	ld.d	r6,r9[0]
80009a8c:	f2 cb ff f8 	sub	r11,r9,-8
80009a90:	fa e7 00 00 	st.d	sp[0],r6
80009a94:	51 0b       	stdsp	sp[0x40],r11
80009a96:	fa c6 f9 44 	sub	r6,sp,-1724
80009a9a:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009a9e:	fa e6 00 00 	ld.d	r6,sp[0]
80009aa2:	f2 e7 fd 88 	st.d	r9[-632],r6
80009aa6:	2f f8       	sub	r8,-1
80009aa8:	14 97       	mov	r7,r10
80009aaa:	fb 48 06 b4 	st.w	sp[1716],r8
80009aae:	c0 88       	rjmp	80009abe <_vfprintf_r+0x11aa>
80009ab0:	f2 e6 00 00 	ld.d	r6,r9[0]
80009ab4:	2f 89       	sub	r9,-8
80009ab6:	fa e7 00 00 	st.d	sp[0],r6
80009aba:	51 09       	stdsp	sp[0x40],r9
80009abc:	14 97       	mov	r7,r10
80009abe:	30 18       	mov	r8,1
80009ac0:	e0 8f 01 d0 	bral	80009e60 <_vfprintf_r+0x154c>
80009ac4:	ed b5 00 04 	bld	r5,0x4
80009ac8:	c1 61       	brne	80009af4 <_vfprintf_r+0x11e0>
80009aca:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009ace:	40 3e       	lddsp	lr,sp[0xc]
80009ad0:	58 0e       	cp.w	lr,0
80009ad2:	c0 80       	breq	80009ae2 <_vfprintf_r+0x11ce>
80009ad4:	10 36       	cp.w	r6,r8
80009ad6:	c6 74       	brge	80009ba4 <_vfprintf_r+0x1290>
80009ad8:	fa cc f9 44 	sub	r12,sp,-1724
80009adc:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009ae0:	c8 08       	rjmp	80009be0 <_vfprintf_r+0x12cc>
80009ae2:	ee ca ff ff 	sub	r10,r7,-1
80009ae6:	10 37       	cp.w	r7,r8
80009ae8:	c7 f4       	brge	80009be6 <_vfprintf_r+0x12d2>
80009aea:	fa cb f9 44 	sub	r11,sp,-1724
80009aee:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009af2:	c7 68       	rjmp	80009bde <_vfprintf_r+0x12ca>
80009af4:	ed b5 00 06 	bld	r5,0x6
80009af8:	c4 a1       	brne	80009b8c <_vfprintf_r+0x1278>
80009afa:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009afe:	40 3c       	lddsp	r12,sp[0xc]
80009b00:	58 0c       	cp.w	r12,0
80009b02:	c1 d0       	breq	80009b3c <_vfprintf_r+0x1228>
80009b04:	10 36       	cp.w	r6,r8
80009b06:	c0 64       	brge	80009b12 <_vfprintf_r+0x11fe>
80009b08:	fa cb f9 44 	sub	r11,sp,-1724
80009b0c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009b10:	c1 f8       	rjmp	80009b4e <_vfprintf_r+0x123a>
80009b12:	fa c8 f9 50 	sub	r8,sp,-1712
80009b16:	1a d8       	st.w	--sp,r8
80009b18:	fa c8 fa b8 	sub	r8,sp,-1352
80009b1c:	1a d8       	st.w	--sp,r8
80009b1e:	fa c8 fb b4 	sub	r8,sp,-1100
80009b22:	1a d8       	st.w	--sp,r8
80009b24:	fa c8 f9 40 	sub	r8,sp,-1728
80009b28:	fa c9 ff b4 	sub	r9,sp,-76
80009b2c:	04 9a       	mov	r10,r2
80009b2e:	0c 9b       	mov	r11,r6
80009b30:	08 9c       	mov	r12,r4
80009b32:	fe b0 f5 53 	rcall	800085d8 <get_arg>
80009b36:	2f dd       	sub	sp,-12
80009b38:	98 18       	ld.sh	r8,r12[0x2]
80009b3a:	c2 68       	rjmp	80009b86 <_vfprintf_r+0x1272>
80009b3c:	ee ca ff ff 	sub	r10,r7,-1
80009b40:	10 37       	cp.w	r7,r8
80009b42:	c0 94       	brge	80009b54 <_vfprintf_r+0x1240>
80009b44:	fa c9 f9 44 	sub	r9,sp,-1724
80009b48:	14 97       	mov	r7,r10
80009b4a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009b4e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009b52:	c1 a8       	rjmp	80009b86 <_vfprintf_r+0x1272>
80009b54:	41 09       	lddsp	r9,sp[0x40]
80009b56:	59 f8       	cp.w	r8,31
80009b58:	e0 89 00 13 	brgt	80009b7e <_vfprintf_r+0x126a>
80009b5c:	f2 cb ff fc 	sub	r11,r9,-4
80009b60:	51 0b       	stdsp	sp[0x40],r11
80009b62:	72 09       	ld.w	r9,r9[0x0]
80009b64:	fa c6 f9 44 	sub	r6,sp,-1724
80009b68:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009b6c:	2f f8       	sub	r8,-1
80009b6e:	f7 49 fd 88 	st.w	r11[-632],r9
80009b72:	fb 48 06 b4 	st.w	sp[1716],r8
80009b76:	14 97       	mov	r7,r10
80009b78:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009b7c:	c0 58       	rjmp	80009b86 <_vfprintf_r+0x1272>
80009b7e:	92 18       	ld.sh	r8,r9[0x2]
80009b80:	14 97       	mov	r7,r10
80009b82:	2f c9       	sub	r9,-4
80009b84:	51 09       	stdsp	sp[0x40],r9
80009b86:	5c 78       	castu.h	r8
80009b88:	50 18       	stdsp	sp[0x4],r8
80009b8a:	c4 68       	rjmp	80009c16 <_vfprintf_r+0x1302>
80009b8c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009b90:	40 3c       	lddsp	r12,sp[0xc]
80009b92:	58 0c       	cp.w	r12,0
80009b94:	c1 d0       	breq	80009bce <_vfprintf_r+0x12ba>
80009b96:	10 36       	cp.w	r6,r8
80009b98:	c0 64       	brge	80009ba4 <_vfprintf_r+0x1290>
80009b9a:	fa cb f9 44 	sub	r11,sp,-1724
80009b9e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009ba2:	c1 f8       	rjmp	80009be0 <_vfprintf_r+0x12cc>
80009ba4:	fa c8 f9 50 	sub	r8,sp,-1712
80009ba8:	1a d8       	st.w	--sp,r8
80009baa:	fa c8 fa b8 	sub	r8,sp,-1352
80009bae:	0c 9b       	mov	r11,r6
80009bb0:	1a d8       	st.w	--sp,r8
80009bb2:	fa c8 fb b4 	sub	r8,sp,-1100
80009bb6:	04 9a       	mov	r10,r2
80009bb8:	1a d8       	st.w	--sp,r8
80009bba:	08 9c       	mov	r12,r4
80009bbc:	fa c8 f9 40 	sub	r8,sp,-1728
80009bc0:	fa c9 ff b4 	sub	r9,sp,-76
80009bc4:	fe b0 f5 0a 	rcall	800085d8 <get_arg>
80009bc8:	2f dd       	sub	sp,-12
80009bca:	78 0b       	ld.w	r11,r12[0x0]
80009bcc:	c2 48       	rjmp	80009c14 <_vfprintf_r+0x1300>
80009bce:	ee ca ff ff 	sub	r10,r7,-1
80009bd2:	10 37       	cp.w	r7,r8
80009bd4:	c0 94       	brge	80009be6 <_vfprintf_r+0x12d2>
80009bd6:	fa c9 f9 44 	sub	r9,sp,-1724
80009bda:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009bde:	14 97       	mov	r7,r10
80009be0:	ec fb fd 88 	ld.w	r11,r6[-632]
80009be4:	c1 88       	rjmp	80009c14 <_vfprintf_r+0x1300>
80009be6:	41 09       	lddsp	r9,sp[0x40]
80009be8:	59 f8       	cp.w	r8,31
80009bea:	e0 89 00 11 	brgt	80009c0c <_vfprintf_r+0x12f8>
80009bee:	f2 cb ff fc 	sub	r11,r9,-4
80009bf2:	51 0b       	stdsp	sp[0x40],r11
80009bf4:	fa c6 f9 44 	sub	r6,sp,-1724
80009bf8:	72 0b       	ld.w	r11,r9[0x0]
80009bfa:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009bfe:	f3 4b fd 88 	st.w	r9[-632],r11
80009c02:	2f f8       	sub	r8,-1
80009c04:	14 97       	mov	r7,r10
80009c06:	fb 48 06 b4 	st.w	sp[1716],r8
80009c0a:	c0 58       	rjmp	80009c14 <_vfprintf_r+0x1300>
80009c0c:	72 0b       	ld.w	r11,r9[0x0]
80009c0e:	14 97       	mov	r7,r10
80009c10:	2f c9       	sub	r9,-4
80009c12:	51 09       	stdsp	sp[0x40],r9
80009c14:	50 1b       	stdsp	sp[0x4],r11
80009c16:	30 0e       	mov	lr,0
80009c18:	30 18       	mov	r8,1
80009c1a:	50 0e       	stdsp	sp[0x0],lr
80009c1c:	c2 29       	rjmp	80009e60 <_vfprintf_r+0x154c>
80009c1e:	50 a7       	stdsp	sp[0x28],r7
80009c20:	50 80       	stdsp	sp[0x20],r0
80009c22:	0c 97       	mov	r7,r6
80009c24:	04 94       	mov	r4,r2
80009c26:	06 96       	mov	r6,r3
80009c28:	02 92       	mov	r2,r1
80009c2a:	4d 3c       	lddpc	r12,80009d74 <_vfprintf_r+0x1460>
80009c2c:	40 93       	lddsp	r3,sp[0x24]
80009c2e:	10 90       	mov	r0,r8
80009c30:	40 41       	lddsp	r1,sp[0x10]
80009c32:	50 dc       	stdsp	sp[0x34],r12
80009c34:	ed b5 00 05 	bld	r5,0x5
80009c38:	c5 51       	brne	80009ce2 <_vfprintf_r+0x13ce>
80009c3a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009c3e:	40 3b       	lddsp	r11,sp[0xc]
80009c40:	58 0b       	cp.w	r11,0
80009c42:	c2 20       	breq	80009c86 <_vfprintf_r+0x1372>
80009c44:	10 36       	cp.w	r6,r8
80009c46:	c0 a4       	brge	80009c5a <_vfprintf_r+0x1346>
80009c48:	fa ca f9 44 	sub	r10,sp,-1724
80009c4c:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009c50:	ec e8 fd 88 	ld.d	r8,r6[-632]
80009c54:	fa e9 00 00 	st.d	sp[0],r8
80009c58:	cf 38       	rjmp	80009e3e <_vfprintf_r+0x152a>
80009c5a:	fa c8 f9 50 	sub	r8,sp,-1712
80009c5e:	1a d8       	st.w	--sp,r8
80009c60:	fa c8 fa b8 	sub	r8,sp,-1352
80009c64:	04 9a       	mov	r10,r2
80009c66:	1a d8       	st.w	--sp,r8
80009c68:	0c 9b       	mov	r11,r6
80009c6a:	fa c8 fb b4 	sub	r8,sp,-1100
80009c6e:	08 9c       	mov	r12,r4
80009c70:	1a d8       	st.w	--sp,r8
80009c72:	fa c8 f9 40 	sub	r8,sp,-1728
80009c76:	fa c9 ff b4 	sub	r9,sp,-76
80009c7a:	fe b0 f4 af 	rcall	800085d8 <get_arg>
80009c7e:	2f dd       	sub	sp,-12
80009c80:	f8 ea 00 00 	ld.d	r10,r12[0]
80009c84:	c0 c8       	rjmp	80009c9c <_vfprintf_r+0x1388>
80009c86:	ee ca ff ff 	sub	r10,r7,-1
80009c8a:	10 37       	cp.w	r7,r8
80009c8c:	c0 b4       	brge	80009ca2 <_vfprintf_r+0x138e>
80009c8e:	fa c9 f9 44 	sub	r9,sp,-1724
80009c92:	14 97       	mov	r7,r10
80009c94:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009c98:	ec ea fd 88 	ld.d	r10,r6[-632]
80009c9c:	fa eb 00 00 	st.d	sp[0],r10
80009ca0:	cc f8       	rjmp	80009e3e <_vfprintf_r+0x152a>
80009ca2:	41 09       	lddsp	r9,sp[0x40]
80009ca4:	59 f8       	cp.w	r8,31
80009ca6:	e0 89 00 16 	brgt	80009cd2 <_vfprintf_r+0x13be>
80009caa:	f2 e6 00 00 	ld.d	r6,r9[0]
80009cae:	f2 cb ff f8 	sub	r11,r9,-8
80009cb2:	fa e7 00 00 	st.d	sp[0],r6
80009cb6:	51 0b       	stdsp	sp[0x40],r11
80009cb8:	fa c6 f9 44 	sub	r6,sp,-1724
80009cbc:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009cc0:	fa e6 00 00 	ld.d	r6,sp[0]
80009cc4:	f2 e7 fd 88 	st.d	r9[-632],r6
80009cc8:	2f f8       	sub	r8,-1
80009cca:	14 97       	mov	r7,r10
80009ccc:	fb 48 06 b4 	st.w	sp[1716],r8
80009cd0:	cb 78       	rjmp	80009e3e <_vfprintf_r+0x152a>
80009cd2:	f2 e6 00 00 	ld.d	r6,r9[0]
80009cd6:	2f 89       	sub	r9,-8
80009cd8:	fa e7 00 00 	st.d	sp[0],r6
80009cdc:	51 09       	stdsp	sp[0x40],r9
80009cde:	14 97       	mov	r7,r10
80009ce0:	ca f8       	rjmp	80009e3e <_vfprintf_r+0x152a>
80009ce2:	ed b5 00 04 	bld	r5,0x4
80009ce6:	c1 71       	brne	80009d14 <_vfprintf_r+0x1400>
80009ce8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009cec:	40 3e       	lddsp	lr,sp[0xc]
80009cee:	58 0e       	cp.w	lr,0
80009cf0:	c0 80       	breq	80009d00 <_vfprintf_r+0x13ec>
80009cf2:	10 36       	cp.w	r6,r8
80009cf4:	c6 a4       	brge	80009dc8 <_vfprintf_r+0x14b4>
80009cf6:	fa cc f9 44 	sub	r12,sp,-1724
80009cfa:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009cfe:	c8 38       	rjmp	80009e04 <_vfprintf_r+0x14f0>
80009d00:	ee ca ff ff 	sub	r10,r7,-1
80009d04:	10 37       	cp.w	r7,r8
80009d06:	e0 84 00 82 	brge	80009e0a <_vfprintf_r+0x14f6>
80009d0a:	fa cb f9 44 	sub	r11,sp,-1724
80009d0e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009d12:	c7 88       	rjmp	80009e02 <_vfprintf_r+0x14ee>
80009d14:	ed b5 00 06 	bld	r5,0x6
80009d18:	c4 c1       	brne	80009db0 <_vfprintf_r+0x149c>
80009d1a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009d1e:	40 3c       	lddsp	r12,sp[0xc]
80009d20:	58 0c       	cp.w	r12,0
80009d22:	c1 d0       	breq	80009d5c <_vfprintf_r+0x1448>
80009d24:	10 36       	cp.w	r6,r8
80009d26:	c0 64       	brge	80009d32 <_vfprintf_r+0x141e>
80009d28:	fa cb f9 44 	sub	r11,sp,-1724
80009d2c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009d30:	c1 f8       	rjmp	80009d6e <_vfprintf_r+0x145a>
80009d32:	fa c8 f9 50 	sub	r8,sp,-1712
80009d36:	1a d8       	st.w	--sp,r8
80009d38:	fa c8 fa b8 	sub	r8,sp,-1352
80009d3c:	1a d8       	st.w	--sp,r8
80009d3e:	fa c8 fb b4 	sub	r8,sp,-1100
80009d42:	1a d8       	st.w	--sp,r8
80009d44:	fa c8 f9 40 	sub	r8,sp,-1728
80009d48:	fa c9 ff b4 	sub	r9,sp,-76
80009d4c:	04 9a       	mov	r10,r2
80009d4e:	0c 9b       	mov	r11,r6
80009d50:	08 9c       	mov	r12,r4
80009d52:	fe b0 f4 43 	rcall	800085d8 <get_arg>
80009d56:	2f dd       	sub	sp,-12
80009d58:	98 18       	ld.sh	r8,r12[0x2]
80009d5a:	c2 88       	rjmp	80009daa <_vfprintf_r+0x1496>
80009d5c:	ee ca ff ff 	sub	r10,r7,-1
80009d60:	10 37       	cp.w	r7,r8
80009d62:	c0 b4       	brge	80009d78 <_vfprintf_r+0x1464>
80009d64:	fa c9 f9 44 	sub	r9,sp,-1724
80009d68:	14 97       	mov	r7,r10
80009d6a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009d6e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009d72:	c1 c8       	rjmp	80009daa <_vfprintf_r+0x1496>
80009d74:	80 02       	ld.sh	r2,r0[0x0]
80009d76:	f7 d8 41 09 	ldins.b	r8:b,r11[265]
80009d7a:	59 f8       	cp.w	r8,31
80009d7c:	e0 89 00 13 	brgt	80009da2 <_vfprintf_r+0x148e>
80009d80:	f2 cb ff fc 	sub	r11,r9,-4
80009d84:	51 0b       	stdsp	sp[0x40],r11
80009d86:	72 09       	ld.w	r9,r9[0x0]
80009d88:	fa c6 f9 44 	sub	r6,sp,-1724
80009d8c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009d90:	2f f8       	sub	r8,-1
80009d92:	f7 49 fd 88 	st.w	r11[-632],r9
80009d96:	fb 48 06 b4 	st.w	sp[1716],r8
80009d9a:	14 97       	mov	r7,r10
80009d9c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009da0:	c0 58       	rjmp	80009daa <_vfprintf_r+0x1496>
80009da2:	92 18       	ld.sh	r8,r9[0x2]
80009da4:	14 97       	mov	r7,r10
80009da6:	2f c9       	sub	r9,-4
80009da8:	51 09       	stdsp	sp[0x40],r9
80009daa:	5c 78       	castu.h	r8
80009dac:	50 18       	stdsp	sp[0x4],r8
80009dae:	c4 68       	rjmp	80009e3a <_vfprintf_r+0x1526>
80009db0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009db4:	40 3c       	lddsp	r12,sp[0xc]
80009db6:	58 0c       	cp.w	r12,0
80009db8:	c1 d0       	breq	80009df2 <_vfprintf_r+0x14de>
80009dba:	10 36       	cp.w	r6,r8
80009dbc:	c0 64       	brge	80009dc8 <_vfprintf_r+0x14b4>
80009dbe:	fa cb f9 44 	sub	r11,sp,-1724
80009dc2:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009dc6:	c1 f8       	rjmp	80009e04 <_vfprintf_r+0x14f0>
80009dc8:	fa c8 f9 50 	sub	r8,sp,-1712
80009dcc:	1a d8       	st.w	--sp,r8
80009dce:	fa c8 fa b8 	sub	r8,sp,-1352
80009dd2:	0c 9b       	mov	r11,r6
80009dd4:	1a d8       	st.w	--sp,r8
80009dd6:	fa c8 fb b4 	sub	r8,sp,-1100
80009dda:	04 9a       	mov	r10,r2
80009ddc:	1a d8       	st.w	--sp,r8
80009dde:	08 9c       	mov	r12,r4
80009de0:	fa c8 f9 40 	sub	r8,sp,-1728
80009de4:	fa c9 ff b4 	sub	r9,sp,-76
80009de8:	fe b0 f3 f8 	rcall	800085d8 <get_arg>
80009dec:	2f dd       	sub	sp,-12
80009dee:	78 0b       	ld.w	r11,r12[0x0]
80009df0:	c2 48       	rjmp	80009e38 <_vfprintf_r+0x1524>
80009df2:	ee ca ff ff 	sub	r10,r7,-1
80009df6:	10 37       	cp.w	r7,r8
80009df8:	c0 94       	brge	80009e0a <_vfprintf_r+0x14f6>
80009dfa:	fa c9 f9 44 	sub	r9,sp,-1724
80009dfe:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009e02:	14 97       	mov	r7,r10
80009e04:	ec fb fd 88 	ld.w	r11,r6[-632]
80009e08:	c1 88       	rjmp	80009e38 <_vfprintf_r+0x1524>
80009e0a:	41 09       	lddsp	r9,sp[0x40]
80009e0c:	59 f8       	cp.w	r8,31
80009e0e:	e0 89 00 11 	brgt	80009e30 <_vfprintf_r+0x151c>
80009e12:	f2 cb ff fc 	sub	r11,r9,-4
80009e16:	51 0b       	stdsp	sp[0x40],r11
80009e18:	fa c6 f9 44 	sub	r6,sp,-1724
80009e1c:	72 0b       	ld.w	r11,r9[0x0]
80009e1e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009e22:	f3 4b fd 88 	st.w	r9[-632],r11
80009e26:	2f f8       	sub	r8,-1
80009e28:	14 97       	mov	r7,r10
80009e2a:	fb 48 06 b4 	st.w	sp[1716],r8
80009e2e:	c0 58       	rjmp	80009e38 <_vfprintf_r+0x1524>
80009e30:	72 0b       	ld.w	r11,r9[0x0]
80009e32:	14 97       	mov	r7,r10
80009e34:	2f c9       	sub	r9,-4
80009e36:	51 09       	stdsp	sp[0x40],r9
80009e38:	50 1b       	stdsp	sp[0x4],r11
80009e3a:	30 0e       	mov	lr,0
80009e3c:	50 0e       	stdsp	sp[0x0],lr
80009e3e:	40 08       	lddsp	r8,sp[0x0]
80009e40:	40 1c       	lddsp	r12,sp[0x4]
80009e42:	18 48       	or	r8,r12
80009e44:	5f 19       	srne	r9
80009e46:	0a 98       	mov	r8,r5
80009e48:	eb e9 00 09 	and	r9,r5,r9
80009e4c:	a1 b8       	sbr	r8,0x1
80009e4e:	58 09       	cp.w	r9,0
80009e50:	c0 70       	breq	80009e5e <_vfprintf_r+0x154a>
80009e52:	10 95       	mov	r5,r8
80009e54:	fb 60 06 b9 	st.b	sp[1721],r0
80009e58:	33 08       	mov	r8,48
80009e5a:	fb 68 06 b8 	st.b	sp[1720],r8
80009e5e:	30 28       	mov	r8,2
80009e60:	30 09       	mov	r9,0
80009e62:	fb 69 06 bb 	st.b	sp[1723],r9
80009e66:	0a 99       	mov	r9,r5
80009e68:	a7 d9       	cbr	r9,0x7
80009e6a:	40 2b       	lddsp	r11,sp[0x8]
80009e6c:	40 16       	lddsp	r6,sp[0x4]
80009e6e:	58 0b       	cp.w	r11,0
80009e70:	5f 1a       	srne	r10
80009e72:	f2 05 17 40 	movge	r5,r9
80009e76:	fa c2 f9 78 	sub	r2,sp,-1672
80009e7a:	40 09       	lddsp	r9,sp[0x0]
80009e7c:	0c 49       	or	r9,r6
80009e7e:	5f 19       	srne	r9
80009e80:	f5 e9 10 09 	or	r9,r10,r9
80009e84:	c5 c0       	breq	80009f3c <_vfprintf_r+0x1628>
80009e86:	30 19       	mov	r9,1
80009e88:	f2 08 18 00 	cp.b	r8,r9
80009e8c:	c0 60       	breq	80009e98 <_vfprintf_r+0x1584>
80009e8e:	30 29       	mov	r9,2
80009e90:	f2 08 18 00 	cp.b	r8,r9
80009e94:	c0 41       	brne	80009e9c <_vfprintf_r+0x1588>
80009e96:	c3 c8       	rjmp	80009f0e <_vfprintf_r+0x15fa>
80009e98:	04 96       	mov	r6,r2
80009e9a:	c3 08       	rjmp	80009efa <_vfprintf_r+0x15e6>
80009e9c:	04 96       	mov	r6,r2
80009e9e:	fa e8 00 00 	ld.d	r8,sp[0]
80009ea2:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80009ea6:	2d 0a       	sub	r10,-48
80009ea8:	0c fa       	st.b	--r6,r10
80009eaa:	f0 0b 16 03 	lsr	r11,r8,0x3
80009eae:	f2 0c 16 03 	lsr	r12,r9,0x3
80009eb2:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80009eb6:	18 99       	mov	r9,r12
80009eb8:	16 98       	mov	r8,r11
80009eba:	58 08       	cp.w	r8,0
80009ebc:	5c 29       	cpc	r9
80009ebe:	cf 21       	brne	80009ea2 <_vfprintf_r+0x158e>
80009ec0:	fa e9 00 00 	st.d	sp[0],r8
80009ec4:	ed b5 00 00 	bld	r5,0x0
80009ec8:	c4 51       	brne	80009f52 <_vfprintf_r+0x163e>
80009eca:	33 09       	mov	r9,48
80009ecc:	f2 0a 18 00 	cp.b	r10,r9
80009ed0:	c4 10       	breq	80009f52 <_vfprintf_r+0x163e>
80009ed2:	0c f9       	st.b	--r6,r9
80009ed4:	c3 f8       	rjmp	80009f52 <_vfprintf_r+0x163e>
80009ed6:	fa ea 00 00 	ld.d	r10,sp[0]
80009eda:	30 a8       	mov	r8,10
80009edc:	30 09       	mov	r9,0
80009ede:	e0 a0 14 7b 	rcall	8000c7d4 <__avr32_umod64>
80009ee2:	30 a8       	mov	r8,10
80009ee4:	2d 0a       	sub	r10,-48
80009ee6:	30 09       	mov	r9,0
80009ee8:	ac 8a       	st.b	r6[0x0],r10
80009eea:	fa ea 00 00 	ld.d	r10,sp[0]
80009eee:	fe b0 ed 68 	rcall	800079be <__avr32_udiv64>
80009ef2:	16 99       	mov	r9,r11
80009ef4:	14 98       	mov	r8,r10
80009ef6:	fa e9 00 00 	st.d	sp[0],r8
80009efa:	20 16       	sub	r6,1
80009efc:	fa ea 00 00 	ld.d	r10,sp[0]
80009f00:	58 9a       	cp.w	r10,9
80009f02:	5c 2b       	cpc	r11
80009f04:	fe 9b ff e9 	brhi	80009ed6 <_vfprintf_r+0x15c2>
80009f08:	1b f8       	ld.ub	r8,sp[0x7]
80009f0a:	2d 08       	sub	r8,-48
80009f0c:	c2 08       	rjmp	80009f4c <_vfprintf_r+0x1638>
80009f0e:	04 96       	mov	r6,r2
80009f10:	fa e8 00 00 	ld.d	r8,sp[0]
80009f14:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80009f18:	40 de       	lddsp	lr,sp[0x34]
80009f1a:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80009f1e:	0c fa       	st.b	--r6,r10
80009f20:	f2 0b 16 04 	lsr	r11,r9,0x4
80009f24:	f0 0a 16 04 	lsr	r10,r8,0x4
80009f28:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80009f2c:	16 99       	mov	r9,r11
80009f2e:	14 98       	mov	r8,r10
80009f30:	58 08       	cp.w	r8,0
80009f32:	5c 29       	cpc	r9
80009f34:	cf 01       	brne	80009f14 <_vfprintf_r+0x1600>
80009f36:	fa e9 00 00 	st.d	sp[0],r8
80009f3a:	c0 c8       	rjmp	80009f52 <_vfprintf_r+0x163e>
80009f3c:	58 08       	cp.w	r8,0
80009f3e:	c0 91       	brne	80009f50 <_vfprintf_r+0x163c>
80009f40:	ed b5 00 00 	bld	r5,0x0
80009f44:	c0 61       	brne	80009f50 <_vfprintf_r+0x163c>
80009f46:	fa c6 f9 79 	sub	r6,sp,-1671
80009f4a:	33 08       	mov	r8,48
80009f4c:	ac 88       	st.b	r6[0x0],r8
80009f4e:	c0 28       	rjmp	80009f52 <_vfprintf_r+0x163e>
80009f50:	04 96       	mov	r6,r2
80009f52:	0c 12       	sub	r2,r6
80009f54:	c1 c8       	rjmp	80009f8c <_vfprintf_r+0x1678>
80009f56:	50 a7       	stdsp	sp[0x28],r7
80009f58:	50 80       	stdsp	sp[0x20],r0
80009f5a:	40 93       	lddsp	r3,sp[0x24]
80009f5c:	0c 97       	mov	r7,r6
80009f5e:	10 90       	mov	r0,r8
80009f60:	04 94       	mov	r4,r2
80009f62:	40 41       	lddsp	r1,sp[0x10]
80009f64:	58 08       	cp.w	r8,0
80009f66:	e0 80 04 51 	breq	8000a808 <_vfprintf_r+0x1ef4>
80009f6a:	fb 68 06 60 	st.b	sp[1632],r8
80009f6e:	30 0c       	mov	r12,0
80009f70:	30 08       	mov	r8,0
80009f72:	30 12       	mov	r2,1
80009f74:	fb 68 06 bb 	st.b	sp[1723],r8
80009f78:	50 2c       	stdsp	sp[0x8],r12
80009f7a:	fa c6 f9 a0 	sub	r6,sp,-1632
80009f7e:	c0 78       	rjmp	80009f8c <_vfprintf_r+0x1678>
80009f80:	30 0b       	mov	r11,0
80009f82:	50 2b       	stdsp	sp[0x8],r11
80009f84:	c0 48       	rjmp	80009f8c <_vfprintf_r+0x1678>
80009f86:	40 22       	lddsp	r2,sp[0x8]
80009f88:	30 0a       	mov	r10,0
80009f8a:	50 2a       	stdsp	sp[0x8],r10
80009f8c:	40 29       	lddsp	r9,sp[0x8]
80009f8e:	e4 09 0c 49 	max	r9,r2,r9
80009f92:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009f96:	50 39       	stdsp	sp[0xc],r9
80009f98:	0a 9e       	mov	lr,r5
80009f9a:	30 09       	mov	r9,0
80009f9c:	e2 1e 00 02 	andl	lr,0x2,COH
80009fa0:	f2 08 18 00 	cp.b	r8,r9
80009fa4:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80009fa8:	f7 b8 01 ff 	subne	r8,-1
80009fac:	fb f8 1a 03 	st.wne	sp[0xc],r8
80009fb0:	0a 9b       	mov	r11,r5
80009fb2:	58 0e       	cp.w	lr,0
80009fb4:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80009fb8:	f7 bc 01 fe 	subne	r12,-2
80009fbc:	fb fc 1a 03 	st.wne	sp[0xc],r12
80009fc0:	e2 1b 00 84 	andl	r11,0x84,COH
80009fc4:	50 fe       	stdsp	sp[0x3c],lr
80009fc6:	50 9b       	stdsp	sp[0x24],r11
80009fc8:	c4 51       	brne	8000a052 <_vfprintf_r+0x173e>
80009fca:	40 8a       	lddsp	r10,sp[0x20]
80009fcc:	40 39       	lddsp	r9,sp[0xc]
80009fce:	12 1a       	sub	r10,r9
80009fd0:	50 4a       	stdsp	sp[0x10],r10
80009fd2:	58 0a       	cp.w	r10,0
80009fd4:	e0 89 00 1f 	brgt	8000a012 <_vfprintf_r+0x16fe>
80009fd8:	c3 d8       	rjmp	8000a052 <_vfprintf_r+0x173e>
80009fda:	2f 09       	sub	r9,-16
80009fdc:	2f f8       	sub	r8,-1
80009fde:	4c ee       	lddpc	lr,8000a114 <_vfprintf_r+0x1800>
80009fe0:	31 0c       	mov	r12,16
80009fe2:	fb 49 06 90 	st.w	sp[1680],r9
80009fe6:	87 0e       	st.w	r3[0x0],lr
80009fe8:	87 1c       	st.w	r3[0x4],r12
80009fea:	fb 48 06 8c 	st.w	sp[1676],r8
80009fee:	58 78       	cp.w	r8,7
80009ff0:	e0 89 00 04 	brgt	80009ff8 <_vfprintf_r+0x16e4>
80009ff4:	2f 83       	sub	r3,-8
80009ff6:	c0 b8       	rjmp	8000a00c <_vfprintf_r+0x16f8>
80009ff8:	fa ca f9 78 	sub	r10,sp,-1672
80009ffc:	02 9b       	mov	r11,r1
80009ffe:	08 9c       	mov	r12,r4
8000a000:	fe b0 f4 7c 	rcall	800088f8 <__sprint_r>
8000a004:	e0 81 04 13 	brne	8000a82a <_vfprintf_r+0x1f16>
8000a008:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a00c:	40 4b       	lddsp	r11,sp[0x10]
8000a00e:	21 0b       	sub	r11,16
8000a010:	50 4b       	stdsp	sp[0x10],r11
8000a012:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a016:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a01a:	4b fa       	lddpc	r10,8000a114 <_vfprintf_r+0x1800>
8000a01c:	40 4e       	lddsp	lr,sp[0x10]
8000a01e:	59 0e       	cp.w	lr,16
8000a020:	fe 99 ff dd 	brgt	80009fda <_vfprintf_r+0x16c6>
8000a024:	1c 09       	add	r9,lr
8000a026:	2f f8       	sub	r8,-1
8000a028:	87 0a       	st.w	r3[0x0],r10
8000a02a:	fb 49 06 90 	st.w	sp[1680],r9
8000a02e:	87 1e       	st.w	r3[0x4],lr
8000a030:	fb 48 06 8c 	st.w	sp[1676],r8
8000a034:	58 78       	cp.w	r8,7
8000a036:	e0 89 00 04 	brgt	8000a03e <_vfprintf_r+0x172a>
8000a03a:	2f 83       	sub	r3,-8
8000a03c:	c0 b8       	rjmp	8000a052 <_vfprintf_r+0x173e>
8000a03e:	fa ca f9 78 	sub	r10,sp,-1672
8000a042:	02 9b       	mov	r11,r1
8000a044:	08 9c       	mov	r12,r4
8000a046:	fe b0 f4 59 	rcall	800088f8 <__sprint_r>
8000a04a:	e0 81 03 f0 	brne	8000a82a <_vfprintf_r+0x1f16>
8000a04e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a052:	30 09       	mov	r9,0
8000a054:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000a058:	f2 08 18 00 	cp.b	r8,r9
8000a05c:	c1 f0       	breq	8000a09a <_vfprintf_r+0x1786>
8000a05e:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a062:	fa c9 f9 45 	sub	r9,sp,-1723
8000a066:	2f f8       	sub	r8,-1
8000a068:	87 09       	st.w	r3[0x0],r9
8000a06a:	fb 48 06 90 	st.w	sp[1680],r8
8000a06e:	30 19       	mov	r9,1
8000a070:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a074:	87 19       	st.w	r3[0x4],r9
8000a076:	2f f8       	sub	r8,-1
8000a078:	fb 48 06 8c 	st.w	sp[1676],r8
8000a07c:	58 78       	cp.w	r8,7
8000a07e:	e0 89 00 04 	brgt	8000a086 <_vfprintf_r+0x1772>
8000a082:	2f 83       	sub	r3,-8
8000a084:	c0 b8       	rjmp	8000a09a <_vfprintf_r+0x1786>
8000a086:	fa ca f9 78 	sub	r10,sp,-1672
8000a08a:	02 9b       	mov	r11,r1
8000a08c:	08 9c       	mov	r12,r4
8000a08e:	fe b0 f4 35 	rcall	800088f8 <__sprint_r>
8000a092:	e0 81 03 cc 	brne	8000a82a <_vfprintf_r+0x1f16>
8000a096:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a09a:	40 fc       	lddsp	r12,sp[0x3c]
8000a09c:	58 0c       	cp.w	r12,0
8000a09e:	c1 f0       	breq	8000a0dc <_vfprintf_r+0x17c8>
8000a0a0:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a0a4:	fa c9 f9 48 	sub	r9,sp,-1720
8000a0a8:	2f e8       	sub	r8,-2
8000a0aa:	87 09       	st.w	r3[0x0],r9
8000a0ac:	fb 48 06 90 	st.w	sp[1680],r8
8000a0b0:	30 29       	mov	r9,2
8000a0b2:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a0b6:	87 19       	st.w	r3[0x4],r9
8000a0b8:	2f f8       	sub	r8,-1
8000a0ba:	fb 48 06 8c 	st.w	sp[1676],r8
8000a0be:	58 78       	cp.w	r8,7
8000a0c0:	e0 89 00 04 	brgt	8000a0c8 <_vfprintf_r+0x17b4>
8000a0c4:	2f 83       	sub	r3,-8
8000a0c6:	c0 b8       	rjmp	8000a0dc <_vfprintf_r+0x17c8>
8000a0c8:	fa ca f9 78 	sub	r10,sp,-1672
8000a0cc:	02 9b       	mov	r11,r1
8000a0ce:	08 9c       	mov	r12,r4
8000a0d0:	fe b0 f4 14 	rcall	800088f8 <__sprint_r>
8000a0d4:	e0 81 03 ab 	brne	8000a82a <_vfprintf_r+0x1f16>
8000a0d8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a0dc:	40 9b       	lddsp	r11,sp[0x24]
8000a0de:	e0 4b 00 80 	cp.w	r11,128
8000a0e2:	c4 a1       	brne	8000a176 <_vfprintf_r+0x1862>
8000a0e4:	40 8a       	lddsp	r10,sp[0x20]
8000a0e6:	40 39       	lddsp	r9,sp[0xc]
8000a0e8:	12 1a       	sub	r10,r9
8000a0ea:	50 4a       	stdsp	sp[0x10],r10
8000a0ec:	58 0a       	cp.w	r10,0
8000a0ee:	e0 89 00 24 	brgt	8000a136 <_vfprintf_r+0x1822>
8000a0f2:	c4 28       	rjmp	8000a176 <_vfprintf_r+0x1862>
8000a0f4:	2f 09       	sub	r9,-16
8000a0f6:	2f f8       	sub	r8,-1
8000a0f8:	48 8e       	lddpc	lr,8000a118 <_vfprintf_r+0x1804>
8000a0fa:	31 0c       	mov	r12,16
8000a0fc:	fb 49 06 90 	st.w	sp[1680],r9
8000a100:	87 0e       	st.w	r3[0x0],lr
8000a102:	87 1c       	st.w	r3[0x4],r12
8000a104:	fb 48 06 8c 	st.w	sp[1676],r8
8000a108:	58 78       	cp.w	r8,7
8000a10a:	e0 89 00 09 	brgt	8000a11c <_vfprintf_r+0x1808>
8000a10e:	2f 83       	sub	r3,-8
8000a110:	c1 08       	rjmp	8000a130 <_vfprintf_r+0x181c>
8000a112:	d7 03       	nop
8000a114:	80 02       	ld.sh	r2,r0[0x0]
8000a116:	f7 f0 80 02 	ld.wls	r0,r11[0x8]
8000a11a:	f8 00       	*unknown*
8000a11c:	fa ca f9 78 	sub	r10,sp,-1672
8000a120:	02 9b       	mov	r11,r1
8000a122:	08 9c       	mov	r12,r4
8000a124:	fe b0 f3 ea 	rcall	800088f8 <__sprint_r>
8000a128:	e0 81 03 81 	brne	8000a82a <_vfprintf_r+0x1f16>
8000a12c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a130:	40 4b       	lddsp	r11,sp[0x10]
8000a132:	21 0b       	sub	r11,16
8000a134:	50 4b       	stdsp	sp[0x10],r11
8000a136:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a13a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a13e:	4c 6a       	lddpc	r10,8000a254 <_vfprintf_r+0x1940>
8000a140:	40 4e       	lddsp	lr,sp[0x10]
8000a142:	59 0e       	cp.w	lr,16
8000a144:	fe 99 ff d8 	brgt	8000a0f4 <_vfprintf_r+0x17e0>
8000a148:	1c 09       	add	r9,lr
8000a14a:	2f f8       	sub	r8,-1
8000a14c:	87 0a       	st.w	r3[0x0],r10
8000a14e:	fb 49 06 90 	st.w	sp[1680],r9
8000a152:	87 1e       	st.w	r3[0x4],lr
8000a154:	fb 48 06 8c 	st.w	sp[1676],r8
8000a158:	58 78       	cp.w	r8,7
8000a15a:	e0 89 00 04 	brgt	8000a162 <_vfprintf_r+0x184e>
8000a15e:	2f 83       	sub	r3,-8
8000a160:	c0 b8       	rjmp	8000a176 <_vfprintf_r+0x1862>
8000a162:	fa ca f9 78 	sub	r10,sp,-1672
8000a166:	02 9b       	mov	r11,r1
8000a168:	08 9c       	mov	r12,r4
8000a16a:	fe b0 f3 c7 	rcall	800088f8 <__sprint_r>
8000a16e:	e0 81 03 5e 	brne	8000a82a <_vfprintf_r+0x1f16>
8000a172:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a176:	40 2c       	lddsp	r12,sp[0x8]
8000a178:	04 1c       	sub	r12,r2
8000a17a:	50 2c       	stdsp	sp[0x8],r12
8000a17c:	58 0c       	cp.w	r12,0
8000a17e:	e0 89 00 1f 	brgt	8000a1bc <_vfprintf_r+0x18a8>
8000a182:	c3 d8       	rjmp	8000a1fc <_vfprintf_r+0x18e8>
8000a184:	2f 09       	sub	r9,-16
8000a186:	2f f8       	sub	r8,-1
8000a188:	4b 3b       	lddpc	r11,8000a254 <_vfprintf_r+0x1940>
8000a18a:	31 0a       	mov	r10,16
8000a18c:	fb 49 06 90 	st.w	sp[1680],r9
8000a190:	87 0b       	st.w	r3[0x0],r11
8000a192:	87 1a       	st.w	r3[0x4],r10
8000a194:	fb 48 06 8c 	st.w	sp[1676],r8
8000a198:	58 78       	cp.w	r8,7
8000a19a:	e0 89 00 04 	brgt	8000a1a2 <_vfprintf_r+0x188e>
8000a19e:	2f 83       	sub	r3,-8
8000a1a0:	c0 b8       	rjmp	8000a1b6 <_vfprintf_r+0x18a2>
8000a1a2:	fa ca f9 78 	sub	r10,sp,-1672
8000a1a6:	02 9b       	mov	r11,r1
8000a1a8:	08 9c       	mov	r12,r4
8000a1aa:	fe b0 f3 a7 	rcall	800088f8 <__sprint_r>
8000a1ae:	e0 81 03 3e 	brne	8000a82a <_vfprintf_r+0x1f16>
8000a1b2:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a1b6:	40 29       	lddsp	r9,sp[0x8]
8000a1b8:	21 09       	sub	r9,16
8000a1ba:	50 29       	stdsp	sp[0x8],r9
8000a1bc:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a1c0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a1c4:	4a 4a       	lddpc	r10,8000a254 <_vfprintf_r+0x1940>
8000a1c6:	40 2e       	lddsp	lr,sp[0x8]
8000a1c8:	59 0e       	cp.w	lr,16
8000a1ca:	fe 99 ff dd 	brgt	8000a184 <_vfprintf_r+0x1870>
8000a1ce:	1c 09       	add	r9,lr
8000a1d0:	2f f8       	sub	r8,-1
8000a1d2:	87 0a       	st.w	r3[0x0],r10
8000a1d4:	fb 49 06 90 	st.w	sp[1680],r9
8000a1d8:	87 1e       	st.w	r3[0x4],lr
8000a1da:	fb 48 06 8c 	st.w	sp[1676],r8
8000a1de:	58 78       	cp.w	r8,7
8000a1e0:	e0 89 00 04 	brgt	8000a1e8 <_vfprintf_r+0x18d4>
8000a1e4:	2f 83       	sub	r3,-8
8000a1e6:	c0 b8       	rjmp	8000a1fc <_vfprintf_r+0x18e8>
8000a1e8:	fa ca f9 78 	sub	r10,sp,-1672
8000a1ec:	02 9b       	mov	r11,r1
8000a1ee:	08 9c       	mov	r12,r4
8000a1f0:	fe b0 f3 84 	rcall	800088f8 <__sprint_r>
8000a1f4:	e0 81 03 1b 	brne	8000a82a <_vfprintf_r+0x1f16>
8000a1f8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a1fc:	ed b5 00 08 	bld	r5,0x8
8000a200:	c0 b0       	breq	8000a216 <_vfprintf_r+0x1902>
8000a202:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a206:	87 12       	st.w	r3[0x4],r2
8000a208:	87 06       	st.w	r3[0x0],r6
8000a20a:	f0 02 00 02 	add	r2,r8,r2
8000a20e:	fb 42 06 90 	st.w	sp[1680],r2
8000a212:	e0 8f 01 d5 	bral	8000a5bc <_vfprintf_r+0x1ca8>
8000a216:	e0 40 00 65 	cp.w	r0,101
8000a21a:	e0 8a 01 d7 	brle	8000a5c8 <_vfprintf_r+0x1cb4>
8000a21e:	30 08       	mov	r8,0
8000a220:	30 09       	mov	r9,0
8000a222:	40 5b       	lddsp	r11,sp[0x14]
8000a224:	40 7a       	lddsp	r10,sp[0x1c]
8000a226:	e0 a0 12 90 	rcall	8000c746 <__avr32_f64_cmp_eq>
8000a22a:	c7 a0       	breq	8000a31e <_vfprintf_r+0x1a0a>
8000a22c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a230:	48 a9       	lddpc	r9,8000a258 <_vfprintf_r+0x1944>
8000a232:	2f f8       	sub	r8,-1
8000a234:	87 09       	st.w	r3[0x0],r9
8000a236:	fb 48 06 90 	st.w	sp[1680],r8
8000a23a:	30 19       	mov	r9,1
8000a23c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a240:	87 19       	st.w	r3[0x4],r9
8000a242:	2f f8       	sub	r8,-1
8000a244:	fb 48 06 8c 	st.w	sp[1676],r8
8000a248:	58 78       	cp.w	r8,7
8000a24a:	e0 89 00 09 	brgt	8000a25c <_vfprintf_r+0x1948>
8000a24e:	2f 83       	sub	r3,-8
8000a250:	c1 08       	rjmp	8000a270 <_vfprintf_r+0x195c>
8000a252:	d7 03       	nop
8000a254:	80 02       	ld.sh	r2,r0[0x0]
8000a256:	f8 00       	*unknown*
8000a258:	80 02       	ld.sh	r2,r0[0x0]
8000a25a:	f7 ec fa ca 	sthh.w	r10[0x2b0],r11:t,r12:t
8000a25e:	f9 78 02 9b 	stcond	r12[667],r8
8000a262:	08 9c       	mov	r12,r4
8000a264:	fe b0 f3 4a 	rcall	800088f8 <__sprint_r>
8000a268:	e0 81 02 e1 	brne	8000a82a <_vfprintf_r+0x1f16>
8000a26c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a270:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000a274:	40 6c       	lddsp	r12,sp[0x18]
8000a276:	18 38       	cp.w	r8,r12
8000a278:	c0 55       	brlt	8000a282 <_vfprintf_r+0x196e>
8000a27a:	ed b5 00 00 	bld	r5,0x0
8000a27e:	e0 81 02 69 	brne	8000a750 <_vfprintf_r+0x1e3c>
8000a282:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a286:	2f f8       	sub	r8,-1
8000a288:	40 cb       	lddsp	r11,sp[0x30]
8000a28a:	fb 48 06 90 	st.w	sp[1680],r8
8000a28e:	30 19       	mov	r9,1
8000a290:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a294:	87 0b       	st.w	r3[0x0],r11
8000a296:	2f f8       	sub	r8,-1
8000a298:	87 19       	st.w	r3[0x4],r9
8000a29a:	fb 48 06 8c 	st.w	sp[1676],r8
8000a29e:	58 78       	cp.w	r8,7
8000a2a0:	e0 89 00 04 	brgt	8000a2a8 <_vfprintf_r+0x1994>
8000a2a4:	2f 83       	sub	r3,-8
8000a2a6:	c0 b8       	rjmp	8000a2bc <_vfprintf_r+0x19a8>
8000a2a8:	fa ca f9 78 	sub	r10,sp,-1672
8000a2ac:	02 9b       	mov	r11,r1
8000a2ae:	08 9c       	mov	r12,r4
8000a2b0:	fe b0 f3 24 	rcall	800088f8 <__sprint_r>
8000a2b4:	e0 81 02 bb 	brne	8000a82a <_vfprintf_r+0x1f16>
8000a2b8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a2bc:	40 66       	lddsp	r6,sp[0x18]
8000a2be:	20 16       	sub	r6,1
8000a2c0:	58 06       	cp.w	r6,0
8000a2c2:	e0 89 00 1d 	brgt	8000a2fc <_vfprintf_r+0x19e8>
8000a2c6:	e0 8f 02 45 	bral	8000a750 <_vfprintf_r+0x1e3c>
8000a2ca:	2f 09       	sub	r9,-16
8000a2cc:	2f f8       	sub	r8,-1
8000a2ce:	fb 49 06 90 	st.w	sp[1680],r9
8000a2d2:	87 02       	st.w	r3[0x0],r2
8000a2d4:	87 10       	st.w	r3[0x4],r0
8000a2d6:	fb 48 06 8c 	st.w	sp[1676],r8
8000a2da:	58 78       	cp.w	r8,7
8000a2dc:	e0 89 00 04 	brgt	8000a2e4 <_vfprintf_r+0x19d0>
8000a2e0:	2f 83       	sub	r3,-8
8000a2e2:	c0 b8       	rjmp	8000a2f8 <_vfprintf_r+0x19e4>
8000a2e4:	fa ca f9 78 	sub	r10,sp,-1672
8000a2e8:	02 9b       	mov	r11,r1
8000a2ea:	08 9c       	mov	r12,r4
8000a2ec:	fe b0 f3 06 	rcall	800088f8 <__sprint_r>
8000a2f0:	e0 81 02 9d 	brne	8000a82a <_vfprintf_r+0x1f16>
8000a2f4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a2f8:	21 06       	sub	r6,16
8000a2fa:	c0 38       	rjmp	8000a300 <_vfprintf_r+0x19ec>
8000a2fc:	4d 22       	lddpc	r2,8000a444 <_vfprintf_r+0x1b30>
8000a2fe:	31 00       	mov	r0,16
8000a300:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a304:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a308:	4c fa       	lddpc	r10,8000a444 <_vfprintf_r+0x1b30>
8000a30a:	59 06       	cp.w	r6,16
8000a30c:	fe 99 ff df 	brgt	8000a2ca <_vfprintf_r+0x19b6>
8000a310:	0c 09       	add	r9,r6
8000a312:	87 0a       	st.w	r3[0x0],r10
8000a314:	fb 49 06 90 	st.w	sp[1680],r9
8000a318:	2f f8       	sub	r8,-1
8000a31a:	87 16       	st.w	r3[0x4],r6
8000a31c:	c5 39       	rjmp	8000a5c2 <_vfprintf_r+0x1cae>
8000a31e:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000a322:	58 0a       	cp.w	r10,0
8000a324:	e0 89 00 94 	brgt	8000a44c <_vfprintf_r+0x1b38>
8000a328:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a32c:	4c 79       	lddpc	r9,8000a448 <_vfprintf_r+0x1b34>
8000a32e:	2f f8       	sub	r8,-1
8000a330:	87 09       	st.w	r3[0x0],r9
8000a332:	fb 48 06 90 	st.w	sp[1680],r8
8000a336:	30 19       	mov	r9,1
8000a338:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a33c:	87 19       	st.w	r3[0x4],r9
8000a33e:	2f f8       	sub	r8,-1
8000a340:	fb 48 06 8c 	st.w	sp[1676],r8
8000a344:	58 78       	cp.w	r8,7
8000a346:	e0 89 00 04 	brgt	8000a34e <_vfprintf_r+0x1a3a>
8000a34a:	2f 83       	sub	r3,-8
8000a34c:	c0 b8       	rjmp	8000a362 <_vfprintf_r+0x1a4e>
8000a34e:	fa ca f9 78 	sub	r10,sp,-1672
8000a352:	02 9b       	mov	r11,r1
8000a354:	08 9c       	mov	r12,r4
8000a356:	fe b0 f2 d1 	rcall	800088f8 <__sprint_r>
8000a35a:	e0 81 02 68 	brne	8000a82a <_vfprintf_r+0x1f16>
8000a35e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a362:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000a366:	58 08       	cp.w	r8,0
8000a368:	c0 81       	brne	8000a378 <_vfprintf_r+0x1a64>
8000a36a:	40 6a       	lddsp	r10,sp[0x18]
8000a36c:	58 0a       	cp.w	r10,0
8000a36e:	c0 51       	brne	8000a378 <_vfprintf_r+0x1a64>
8000a370:	ed b5 00 00 	bld	r5,0x0
8000a374:	e0 81 01 ee 	brne	8000a750 <_vfprintf_r+0x1e3c>
8000a378:	40 c9       	lddsp	r9,sp[0x30]
8000a37a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a37e:	2f f8       	sub	r8,-1
8000a380:	87 09       	st.w	r3[0x0],r9
8000a382:	fb 48 06 90 	st.w	sp[1680],r8
8000a386:	30 19       	mov	r9,1
8000a388:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a38c:	87 19       	st.w	r3[0x4],r9
8000a38e:	2f f8       	sub	r8,-1
8000a390:	fb 48 06 8c 	st.w	sp[1676],r8
8000a394:	58 78       	cp.w	r8,7
8000a396:	e0 89 00 04 	brgt	8000a39e <_vfprintf_r+0x1a8a>
8000a39a:	2f 83       	sub	r3,-8
8000a39c:	c0 b8       	rjmp	8000a3b2 <_vfprintf_r+0x1a9e>
8000a39e:	fa ca f9 78 	sub	r10,sp,-1672
8000a3a2:	02 9b       	mov	r11,r1
8000a3a4:	08 9c       	mov	r12,r4
8000a3a6:	fe b0 f2 a9 	rcall	800088f8 <__sprint_r>
8000a3aa:	e0 81 02 40 	brne	8000a82a <_vfprintf_r+0x1f16>
8000a3ae:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a3b2:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000a3b6:	5c 32       	neg	r2
8000a3b8:	58 02       	cp.w	r2,0
8000a3ba:	e0 89 00 1d 	brgt	8000a3f4 <_vfprintf_r+0x1ae0>
8000a3be:	c3 b8       	rjmp	8000a434 <_vfprintf_r+0x1b20>
8000a3c0:	2f 09       	sub	r9,-16
8000a3c2:	2f f8       	sub	r8,-1
8000a3c4:	31 0e       	mov	lr,16
8000a3c6:	fb 49 06 90 	st.w	sp[1680],r9
8000a3ca:	87 00       	st.w	r3[0x0],r0
8000a3cc:	87 1e       	st.w	r3[0x4],lr
8000a3ce:	fb 48 06 8c 	st.w	sp[1676],r8
8000a3d2:	58 78       	cp.w	r8,7
8000a3d4:	e0 89 00 04 	brgt	8000a3dc <_vfprintf_r+0x1ac8>
8000a3d8:	2f 83       	sub	r3,-8
8000a3da:	c0 b8       	rjmp	8000a3f0 <_vfprintf_r+0x1adc>
8000a3dc:	fa ca f9 78 	sub	r10,sp,-1672
8000a3e0:	02 9b       	mov	r11,r1
8000a3e2:	08 9c       	mov	r12,r4
8000a3e4:	fe b0 f2 8a 	rcall	800088f8 <__sprint_r>
8000a3e8:	e0 81 02 21 	brne	8000a82a <_vfprintf_r+0x1f16>
8000a3ec:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a3f0:	21 02       	sub	r2,16
8000a3f2:	c0 28       	rjmp	8000a3f6 <_vfprintf_r+0x1ae2>
8000a3f4:	49 40       	lddpc	r0,8000a444 <_vfprintf_r+0x1b30>
8000a3f6:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a3fa:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a3fe:	49 2a       	lddpc	r10,8000a444 <_vfprintf_r+0x1b30>
8000a400:	59 02       	cp.w	r2,16
8000a402:	fe 99 ff df 	brgt	8000a3c0 <_vfprintf_r+0x1aac>
8000a406:	04 09       	add	r9,r2
8000a408:	2f f8       	sub	r8,-1
8000a40a:	87 0a       	st.w	r3[0x0],r10
8000a40c:	fb 49 06 90 	st.w	sp[1680],r9
8000a410:	87 12       	st.w	r3[0x4],r2
8000a412:	fb 48 06 8c 	st.w	sp[1676],r8
8000a416:	58 78       	cp.w	r8,7
8000a418:	e0 89 00 04 	brgt	8000a420 <_vfprintf_r+0x1b0c>
8000a41c:	2f 83       	sub	r3,-8
8000a41e:	c0 b8       	rjmp	8000a434 <_vfprintf_r+0x1b20>
8000a420:	fa ca f9 78 	sub	r10,sp,-1672
8000a424:	02 9b       	mov	r11,r1
8000a426:	08 9c       	mov	r12,r4
8000a428:	fe b0 f2 68 	rcall	800088f8 <__sprint_r>
8000a42c:	e0 81 01 ff 	brne	8000a82a <_vfprintf_r+0x1f16>
8000a430:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a434:	40 6c       	lddsp	r12,sp[0x18]
8000a436:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a43a:	87 06       	st.w	r3[0x0],r6
8000a43c:	87 1c       	st.w	r3[0x4],r12
8000a43e:	18 08       	add	r8,r12
8000a440:	cb c8       	rjmp	8000a5b8 <_vfprintf_r+0x1ca4>
8000a442:	d7 03       	nop
8000a444:	80 02       	ld.sh	r2,r0[0x0]
8000a446:	f8 00       	*unknown*
8000a448:	80 02       	ld.sh	r2,r0[0x0]
8000a44a:	f7 ec fa f9 	sthh.w	r9[0x2bc],r11:t,r12:t
8000a44e:	06 90       	mov	r0,r3
8000a450:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a454:	40 6b       	lddsp	r11,sp[0x18]
8000a456:	16 3a       	cp.w	r10,r11
8000a458:	c6 d5       	brlt	8000a532 <_vfprintf_r+0x1c1e>
8000a45a:	16 09       	add	r9,r11
8000a45c:	2f f8       	sub	r8,-1
8000a45e:	87 06       	st.w	r3[0x0],r6
8000a460:	fb 49 06 90 	st.w	sp[1680],r9
8000a464:	87 1b       	st.w	r3[0x4],r11
8000a466:	fb 48 06 8c 	st.w	sp[1676],r8
8000a46a:	58 78       	cp.w	r8,7
8000a46c:	e0 89 00 04 	brgt	8000a474 <_vfprintf_r+0x1b60>
8000a470:	2f 83       	sub	r3,-8
8000a472:	c0 b8       	rjmp	8000a488 <_vfprintf_r+0x1b74>
8000a474:	fa ca f9 78 	sub	r10,sp,-1672
8000a478:	02 9b       	mov	r11,r1
8000a47a:	08 9c       	mov	r12,r4
8000a47c:	fe b0 f2 3e 	rcall	800088f8 <__sprint_r>
8000a480:	e0 81 01 d5 	brne	8000a82a <_vfprintf_r+0x1f16>
8000a484:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a488:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000a48c:	40 6a       	lddsp	r10,sp[0x18]
8000a48e:	14 16       	sub	r6,r10
8000a490:	58 06       	cp.w	r6,0
8000a492:	e0 89 00 1c 	brgt	8000a4ca <_vfprintf_r+0x1bb6>
8000a496:	c3 b8       	rjmp	8000a50c <_vfprintf_r+0x1bf8>
8000a498:	2f 09       	sub	r9,-16
8000a49a:	2f f8       	sub	r8,-1
8000a49c:	fb 49 06 90 	st.w	sp[1680],r9
8000a4a0:	87 02       	st.w	r3[0x0],r2
8000a4a2:	87 10       	st.w	r3[0x4],r0
8000a4a4:	fb 48 06 8c 	st.w	sp[1676],r8
8000a4a8:	58 78       	cp.w	r8,7
8000a4aa:	e0 89 00 04 	brgt	8000a4b2 <_vfprintf_r+0x1b9e>
8000a4ae:	2f 83       	sub	r3,-8
8000a4b0:	c0 b8       	rjmp	8000a4c6 <_vfprintf_r+0x1bb2>
8000a4b2:	fa ca f9 78 	sub	r10,sp,-1672
8000a4b6:	02 9b       	mov	r11,r1
8000a4b8:	08 9c       	mov	r12,r4
8000a4ba:	fe b0 f2 1f 	rcall	800088f8 <__sprint_r>
8000a4be:	e0 81 01 b6 	brne	8000a82a <_vfprintf_r+0x1f16>
8000a4c2:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a4c6:	21 06       	sub	r6,16
8000a4c8:	c0 38       	rjmp	8000a4ce <_vfprintf_r+0x1bba>
8000a4ca:	4d c2       	lddpc	r2,8000a638 <_vfprintf_r+0x1d24>
8000a4cc:	31 00       	mov	r0,16
8000a4ce:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a4d2:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a4d6:	4d 9a       	lddpc	r10,8000a638 <_vfprintf_r+0x1d24>
8000a4d8:	59 06       	cp.w	r6,16
8000a4da:	fe 99 ff df 	brgt	8000a498 <_vfprintf_r+0x1b84>
8000a4de:	0c 09       	add	r9,r6
8000a4e0:	2f f8       	sub	r8,-1
8000a4e2:	87 0a       	st.w	r3[0x0],r10
8000a4e4:	fb 49 06 90 	st.w	sp[1680],r9
8000a4e8:	87 16       	st.w	r3[0x4],r6
8000a4ea:	fb 48 06 8c 	st.w	sp[1676],r8
8000a4ee:	58 78       	cp.w	r8,7
8000a4f0:	e0 89 00 04 	brgt	8000a4f8 <_vfprintf_r+0x1be4>
8000a4f4:	2f 83       	sub	r3,-8
8000a4f6:	c0 b8       	rjmp	8000a50c <_vfprintf_r+0x1bf8>
8000a4f8:	fa ca f9 78 	sub	r10,sp,-1672
8000a4fc:	02 9b       	mov	r11,r1
8000a4fe:	08 9c       	mov	r12,r4
8000a500:	fe b0 f1 fc 	rcall	800088f8 <__sprint_r>
8000a504:	e0 81 01 93 	brne	8000a82a <_vfprintf_r+0x1f16>
8000a508:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a50c:	ed b5 00 00 	bld	r5,0x0
8000a510:	e0 81 01 20 	brne	8000a750 <_vfprintf_r+0x1e3c>
8000a514:	40 c9       	lddsp	r9,sp[0x30]
8000a516:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a51a:	2f f8       	sub	r8,-1
8000a51c:	87 09       	st.w	r3[0x0],r9
8000a51e:	fb 48 06 90 	st.w	sp[1680],r8
8000a522:	30 19       	mov	r9,1
8000a524:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a528:	87 19       	st.w	r3[0x4],r9
8000a52a:	2f f8       	sub	r8,-1
8000a52c:	fb 48 06 8c 	st.w	sp[1676],r8
8000a530:	c0 29       	rjmp	8000a734 <_vfprintf_r+0x1e20>
8000a532:	14 09       	add	r9,r10
8000a534:	2f f8       	sub	r8,-1
8000a536:	fb 49 06 90 	st.w	sp[1680],r9
8000a53a:	87 06       	st.w	r3[0x0],r6
8000a53c:	87 1a       	st.w	r3[0x4],r10
8000a53e:	fb 48 06 8c 	st.w	sp[1676],r8
8000a542:	58 78       	cp.w	r8,7
8000a544:	e0 89 00 04 	brgt	8000a54c <_vfprintf_r+0x1c38>
8000a548:	2f 83       	sub	r3,-8
8000a54a:	c0 b8       	rjmp	8000a560 <_vfprintf_r+0x1c4c>
8000a54c:	fa ca f9 78 	sub	r10,sp,-1672
8000a550:	02 9b       	mov	r11,r1
8000a552:	08 9c       	mov	r12,r4
8000a554:	fe b0 f1 d2 	rcall	800088f8 <__sprint_r>
8000a558:	e0 81 01 69 	brne	8000a82a <_vfprintf_r+0x1f16>
8000a55c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a560:	40 c8       	lddsp	r8,sp[0x30]
8000a562:	87 08       	st.w	r3[0x0],r8
8000a564:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a568:	2f f8       	sub	r8,-1
8000a56a:	30 19       	mov	r9,1
8000a56c:	fb 48 06 90 	st.w	sp[1680],r8
8000a570:	87 19       	st.w	r3[0x4],r9
8000a572:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a576:	2f f8       	sub	r8,-1
8000a578:	fb 48 06 8c 	st.w	sp[1676],r8
8000a57c:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000a580:	58 78       	cp.w	r8,7
8000a582:	e0 89 00 04 	brgt	8000a58a <_vfprintf_r+0x1c76>
8000a586:	2f 83       	sub	r3,-8
8000a588:	c0 b8       	rjmp	8000a59e <_vfprintf_r+0x1c8a>
8000a58a:	fa ca f9 78 	sub	r10,sp,-1672
8000a58e:	02 9b       	mov	r11,r1
8000a590:	08 9c       	mov	r12,r4
8000a592:	fe b0 f1 b3 	rcall	800088f8 <__sprint_r>
8000a596:	e0 81 01 4a 	brne	8000a82a <_vfprintf_r+0x1f16>
8000a59a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a59e:	04 06       	add	r6,r2
8000a5a0:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000a5a4:	87 06       	st.w	r3[0x0],r6
8000a5a6:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a5aa:	40 66       	lddsp	r6,sp[0x18]
8000a5ac:	40 6e       	lddsp	lr,sp[0x18]
8000a5ae:	10 16       	sub	r6,r8
8000a5b0:	f2 08 01 08 	sub	r8,r9,r8
8000a5b4:	87 16       	st.w	r3[0x4],r6
8000a5b6:	1c 08       	add	r8,lr
8000a5b8:	fb 48 06 90 	st.w	sp[1680],r8
8000a5bc:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a5c0:	2f f8       	sub	r8,-1
8000a5c2:	fb 48 06 8c 	st.w	sp[1676],r8
8000a5c6:	cb 78       	rjmp	8000a734 <_vfprintf_r+0x1e20>
8000a5c8:	40 6c       	lddsp	r12,sp[0x18]
8000a5ca:	58 1c       	cp.w	r12,1
8000a5cc:	e0 89 00 06 	brgt	8000a5d8 <_vfprintf_r+0x1cc4>
8000a5d0:	ed b5 00 00 	bld	r5,0x0
8000a5d4:	e0 81 00 85 	brne	8000a6de <_vfprintf_r+0x1dca>
8000a5d8:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a5dc:	2f f8       	sub	r8,-1
8000a5de:	30 19       	mov	r9,1
8000a5e0:	fb 48 06 90 	st.w	sp[1680],r8
8000a5e4:	87 06       	st.w	r3[0x0],r6
8000a5e6:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a5ea:	87 19       	st.w	r3[0x4],r9
8000a5ec:	2f f8       	sub	r8,-1
8000a5ee:	fb 48 06 8c 	st.w	sp[1676],r8
8000a5f2:	58 78       	cp.w	r8,7
8000a5f4:	e0 89 00 04 	brgt	8000a5fc <_vfprintf_r+0x1ce8>
8000a5f8:	2f 83       	sub	r3,-8
8000a5fa:	c0 b8       	rjmp	8000a610 <_vfprintf_r+0x1cfc>
8000a5fc:	fa ca f9 78 	sub	r10,sp,-1672
8000a600:	02 9b       	mov	r11,r1
8000a602:	08 9c       	mov	r12,r4
8000a604:	fe b0 f1 7a 	rcall	800088f8 <__sprint_r>
8000a608:	e0 81 01 11 	brne	8000a82a <_vfprintf_r+0x1f16>
8000a60c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a610:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a614:	2f f8       	sub	r8,-1
8000a616:	40 cb       	lddsp	r11,sp[0x30]
8000a618:	fb 48 06 90 	st.w	sp[1680],r8
8000a61c:	30 19       	mov	r9,1
8000a61e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a622:	87 0b       	st.w	r3[0x0],r11
8000a624:	2f f8       	sub	r8,-1
8000a626:	87 19       	st.w	r3[0x4],r9
8000a628:	fb 48 06 8c 	st.w	sp[1676],r8
8000a62c:	58 78       	cp.w	r8,7
8000a62e:	e0 89 00 07 	brgt	8000a63c <_vfprintf_r+0x1d28>
8000a632:	2f 83       	sub	r3,-8
8000a634:	c0 e8       	rjmp	8000a650 <_vfprintf_r+0x1d3c>
8000a636:	d7 03       	nop
8000a638:	80 02       	ld.sh	r2,r0[0x0]
8000a63a:	f8 00       	*unknown*
8000a63c:	fa ca f9 78 	sub	r10,sp,-1672
8000a640:	02 9b       	mov	r11,r1
8000a642:	08 9c       	mov	r12,r4
8000a644:	fe b0 f1 5a 	rcall	800088f8 <__sprint_r>
8000a648:	e0 81 00 f1 	brne	8000a82a <_vfprintf_r+0x1f16>
8000a64c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a650:	30 08       	mov	r8,0
8000a652:	30 09       	mov	r9,0
8000a654:	40 5b       	lddsp	r11,sp[0x14]
8000a656:	40 7a       	lddsp	r10,sp[0x1c]
8000a658:	e0 a0 10 77 	rcall	8000c746 <__avr32_f64_cmp_eq>
8000a65c:	40 68       	lddsp	r8,sp[0x18]
8000a65e:	20 18       	sub	r8,1
8000a660:	58 0c       	cp.w	r12,0
8000a662:	c0 d1       	brne	8000a67c <_vfprintf_r+0x1d68>
8000a664:	2f f6       	sub	r6,-1
8000a666:	87 18       	st.w	r3[0x4],r8
8000a668:	87 06       	st.w	r3[0x0],r6
8000a66a:	fa f6 06 90 	ld.w	r6,sp[1680]
8000a66e:	10 06       	add	r6,r8
8000a670:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a674:	fb 46 06 90 	st.w	sp[1680],r6
8000a678:	2f f8       	sub	r8,-1
8000a67a:	c2 f8       	rjmp	8000a6d8 <_vfprintf_r+0x1dc4>
8000a67c:	10 96       	mov	r6,r8
8000a67e:	58 08       	cp.w	r8,0
8000a680:	e0 89 00 1c 	brgt	8000a6b8 <_vfprintf_r+0x1da4>
8000a684:	c4 98       	rjmp	8000a716 <_vfprintf_r+0x1e02>
8000a686:	2f 09       	sub	r9,-16
8000a688:	2f f8       	sub	r8,-1
8000a68a:	fb 49 06 90 	st.w	sp[1680],r9
8000a68e:	87 02       	st.w	r3[0x0],r2
8000a690:	87 10       	st.w	r3[0x4],r0
8000a692:	fb 48 06 8c 	st.w	sp[1676],r8
8000a696:	58 78       	cp.w	r8,7
8000a698:	e0 89 00 04 	brgt	8000a6a0 <_vfprintf_r+0x1d8c>
8000a69c:	2f 83       	sub	r3,-8
8000a69e:	c0 b8       	rjmp	8000a6b4 <_vfprintf_r+0x1da0>
8000a6a0:	fa ca f9 78 	sub	r10,sp,-1672
8000a6a4:	02 9b       	mov	r11,r1
8000a6a6:	08 9c       	mov	r12,r4
8000a6a8:	fe b0 f1 28 	rcall	800088f8 <__sprint_r>
8000a6ac:	e0 81 00 bf 	brne	8000a82a <_vfprintf_r+0x1f16>
8000a6b0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a6b4:	21 06       	sub	r6,16
8000a6b6:	c0 38       	rjmp	8000a6bc <_vfprintf_r+0x1da8>
8000a6b8:	4d 22       	lddpc	r2,8000a800 <_vfprintf_r+0x1eec>
8000a6ba:	31 00       	mov	r0,16
8000a6bc:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a6c0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a6c4:	4c fa       	lddpc	r10,8000a800 <_vfprintf_r+0x1eec>
8000a6c6:	59 06       	cp.w	r6,16
8000a6c8:	fe 99 ff df 	brgt	8000a686 <_vfprintf_r+0x1d72>
8000a6cc:	0c 09       	add	r9,r6
8000a6ce:	87 0a       	st.w	r3[0x0],r10
8000a6d0:	fb 49 06 90 	st.w	sp[1680],r9
8000a6d4:	2f f8       	sub	r8,-1
8000a6d6:	87 16       	st.w	r3[0x4],r6
8000a6d8:	fb 48 06 8c 	st.w	sp[1676],r8
8000a6dc:	c0 e8       	rjmp	8000a6f8 <_vfprintf_r+0x1de4>
8000a6de:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a6e2:	2f f8       	sub	r8,-1
8000a6e4:	30 19       	mov	r9,1
8000a6e6:	fb 48 06 90 	st.w	sp[1680],r8
8000a6ea:	87 06       	st.w	r3[0x0],r6
8000a6ec:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a6f0:	87 19       	st.w	r3[0x4],r9
8000a6f2:	2f f8       	sub	r8,-1
8000a6f4:	fb 48 06 8c 	st.w	sp[1676],r8
8000a6f8:	58 78       	cp.w	r8,7
8000a6fa:	e0 89 00 04 	brgt	8000a702 <_vfprintf_r+0x1dee>
8000a6fe:	2f 83       	sub	r3,-8
8000a700:	c0 b8       	rjmp	8000a716 <_vfprintf_r+0x1e02>
8000a702:	fa ca f9 78 	sub	r10,sp,-1672
8000a706:	02 9b       	mov	r11,r1
8000a708:	08 9c       	mov	r12,r4
8000a70a:	fe b0 f0 f7 	rcall	800088f8 <__sprint_r>
8000a70e:	e0 81 00 8e 	brne	8000a82a <_vfprintf_r+0x1f16>
8000a712:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a716:	40 ea       	lddsp	r10,sp[0x38]
8000a718:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a71c:	14 08       	add	r8,r10
8000a71e:	fa c9 f9 64 	sub	r9,sp,-1692
8000a722:	fb 48 06 90 	st.w	sp[1680],r8
8000a726:	87 1a       	st.w	r3[0x4],r10
8000a728:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a72c:	87 09       	st.w	r3[0x0],r9
8000a72e:	2f f8       	sub	r8,-1
8000a730:	fb 48 06 8c 	st.w	sp[1676],r8
8000a734:	58 78       	cp.w	r8,7
8000a736:	e0 89 00 04 	brgt	8000a73e <_vfprintf_r+0x1e2a>
8000a73a:	2f 83       	sub	r3,-8
8000a73c:	c0 a8       	rjmp	8000a750 <_vfprintf_r+0x1e3c>
8000a73e:	fa ca f9 78 	sub	r10,sp,-1672
8000a742:	02 9b       	mov	r11,r1
8000a744:	08 9c       	mov	r12,r4
8000a746:	fe b0 f0 d9 	rcall	800088f8 <__sprint_r>
8000a74a:	c7 01       	brne	8000a82a <_vfprintf_r+0x1f16>
8000a74c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a750:	e2 15 00 04 	andl	r5,0x4,COH
8000a754:	c3 d0       	breq	8000a7ce <_vfprintf_r+0x1eba>
8000a756:	40 86       	lddsp	r6,sp[0x20]
8000a758:	40 39       	lddsp	r9,sp[0xc]
8000a75a:	12 16       	sub	r6,r9
8000a75c:	58 06       	cp.w	r6,0
8000a75e:	e0 89 00 1a 	brgt	8000a792 <_vfprintf_r+0x1e7e>
8000a762:	c3 68       	rjmp	8000a7ce <_vfprintf_r+0x1eba>
8000a764:	2f 09       	sub	r9,-16
8000a766:	2f f8       	sub	r8,-1
8000a768:	fb 49 06 90 	st.w	sp[1680],r9
8000a76c:	87 05       	st.w	r3[0x0],r5
8000a76e:	87 12       	st.w	r3[0x4],r2
8000a770:	fb 48 06 8c 	st.w	sp[1676],r8
8000a774:	58 78       	cp.w	r8,7
8000a776:	e0 89 00 04 	brgt	8000a77e <_vfprintf_r+0x1e6a>
8000a77a:	2f 83       	sub	r3,-8
8000a77c:	c0 98       	rjmp	8000a78e <_vfprintf_r+0x1e7a>
8000a77e:	00 9a       	mov	r10,r0
8000a780:	02 9b       	mov	r11,r1
8000a782:	08 9c       	mov	r12,r4
8000a784:	fe b0 f0 ba 	rcall	800088f8 <__sprint_r>
8000a788:	c5 11       	brne	8000a82a <_vfprintf_r+0x1f16>
8000a78a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a78e:	21 06       	sub	r6,16
8000a790:	c0 58       	rjmp	8000a79a <_vfprintf_r+0x1e86>
8000a792:	49 d5       	lddpc	r5,8000a804 <_vfprintf_r+0x1ef0>
8000a794:	31 02       	mov	r2,16
8000a796:	fa c0 f9 78 	sub	r0,sp,-1672
8000a79a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a79e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a7a2:	49 9a       	lddpc	r10,8000a804 <_vfprintf_r+0x1ef0>
8000a7a4:	59 06       	cp.w	r6,16
8000a7a6:	fe 99 ff df 	brgt	8000a764 <_vfprintf_r+0x1e50>
8000a7aa:	0c 09       	add	r9,r6
8000a7ac:	2f f8       	sub	r8,-1
8000a7ae:	87 0a       	st.w	r3[0x0],r10
8000a7b0:	87 16       	st.w	r3[0x4],r6
8000a7b2:	fb 49 06 90 	st.w	sp[1680],r9
8000a7b6:	fb 48 06 8c 	st.w	sp[1676],r8
8000a7ba:	58 78       	cp.w	r8,7
8000a7bc:	e0 8a 00 09 	brle	8000a7ce <_vfprintf_r+0x1eba>
8000a7c0:	fa ca f9 78 	sub	r10,sp,-1672
8000a7c4:	02 9b       	mov	r11,r1
8000a7c6:	08 9c       	mov	r12,r4
8000a7c8:	fe b0 f0 98 	rcall	800088f8 <__sprint_r>
8000a7cc:	c2 f1       	brne	8000a82a <_vfprintf_r+0x1f16>
8000a7ce:	40 bc       	lddsp	r12,sp[0x2c]
8000a7d0:	40 36       	lddsp	r6,sp[0xc]
8000a7d2:	40 8e       	lddsp	lr,sp[0x20]
8000a7d4:	ec 0e 0c 48 	max	r8,r6,lr
8000a7d8:	10 0c       	add	r12,r8
8000a7da:	50 bc       	stdsp	sp[0x2c],r12
8000a7dc:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a7e0:	58 08       	cp.w	r8,0
8000a7e2:	c0 80       	breq	8000a7f2 <_vfprintf_r+0x1ede>
8000a7e4:	fa ca f9 78 	sub	r10,sp,-1672
8000a7e8:	02 9b       	mov	r11,r1
8000a7ea:	08 9c       	mov	r12,r4
8000a7ec:	fe b0 f0 86 	rcall	800088f8 <__sprint_r>
8000a7f0:	c1 d1       	brne	8000a82a <_vfprintf_r+0x1f16>
8000a7f2:	30 0b       	mov	r11,0
8000a7f4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a7f8:	fb 4b 06 8c 	st.w	sp[1676],r11
8000a7fc:	fe 9f f1 17 	bral	80008a2a <_vfprintf_r+0x116>
8000a800:	80 02       	ld.sh	r2,r0[0x0]
8000a802:	f8 00       	*unknown*
8000a804:	80 02       	ld.sh	r2,r0[0x0]
8000a806:	f7 f0 08 95 	ld.ubeq	r0,r11[0x95]
8000a80a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a80e:	58 08       	cp.w	r8,0
8000a810:	c0 80       	breq	8000a820 <_vfprintf_r+0x1f0c>
8000a812:	08 9c       	mov	r12,r4
8000a814:	fa ca f9 78 	sub	r10,sp,-1672
8000a818:	02 9b       	mov	r11,r1
8000a81a:	fe b0 f0 6f 	rcall	800088f8 <__sprint_r>
8000a81e:	c0 61       	brne	8000a82a <_vfprintf_r+0x1f16>
8000a820:	30 08       	mov	r8,0
8000a822:	fb 48 06 8c 	st.w	sp[1676],r8
8000a826:	c0 28       	rjmp	8000a82a <_vfprintf_r+0x1f16>
8000a828:	40 41       	lddsp	r1,sp[0x10]
8000a82a:	82 68       	ld.sh	r8,r1[0xc]
8000a82c:	ed b8 00 06 	bld	r8,0x6
8000a830:	c0 31       	brne	8000a836 <_vfprintf_r+0x1f22>
8000a832:	3f fa       	mov	r10,-1
8000a834:	50 ba       	stdsp	sp[0x2c],r10
8000a836:	40 bc       	lddsp	r12,sp[0x2c]
8000a838:	fe 3d f9 44 	sub	sp,-1724
8000a83c:	d8 32       	popm	r0-r7,pc
8000a83e:	d7 03       	nop

8000a840 <__swsetup_r>:
8000a840:	d4 21       	pushm	r4-r7,lr
8000a842:	e0 68 05 34 	mov	r8,1332
8000a846:	18 96       	mov	r6,r12
8000a848:	16 97       	mov	r7,r11
8000a84a:	70 0c       	ld.w	r12,r8[0x0]
8000a84c:	58 0c       	cp.w	r12,0
8000a84e:	c0 60       	breq	8000a85a <__swsetup_r+0x1a>
8000a850:	78 68       	ld.w	r8,r12[0x18]
8000a852:	58 08       	cp.w	r8,0
8000a854:	c0 31       	brne	8000a85a <__swsetup_r+0x1a>
8000a856:	e0 a0 07 c7 	rcall	8000b7e4 <__sinit>
8000a85a:	4a f8       	lddpc	r8,8000a914 <__swsetup_r+0xd4>
8000a85c:	10 37       	cp.w	r7,r8
8000a85e:	c0 61       	brne	8000a86a <__swsetup_r+0x2a>
8000a860:	e0 68 05 34 	mov	r8,1332
8000a864:	70 08       	ld.w	r8,r8[0x0]
8000a866:	70 07       	ld.w	r7,r8[0x0]
8000a868:	c1 08       	rjmp	8000a888 <__swsetup_r+0x48>
8000a86a:	4a c8       	lddpc	r8,8000a918 <__swsetup_r+0xd8>
8000a86c:	10 37       	cp.w	r7,r8
8000a86e:	c0 61       	brne	8000a87a <__swsetup_r+0x3a>
8000a870:	e0 68 05 34 	mov	r8,1332
8000a874:	70 08       	ld.w	r8,r8[0x0]
8000a876:	70 17       	ld.w	r7,r8[0x4]
8000a878:	c0 88       	rjmp	8000a888 <__swsetup_r+0x48>
8000a87a:	4a 98       	lddpc	r8,8000a91c <__swsetup_r+0xdc>
8000a87c:	10 37       	cp.w	r7,r8
8000a87e:	c0 51       	brne	8000a888 <__swsetup_r+0x48>
8000a880:	e0 68 05 34 	mov	r8,1332
8000a884:	70 08       	ld.w	r8,r8[0x0]
8000a886:	70 27       	ld.w	r7,r8[0x8]
8000a888:	8e 68       	ld.sh	r8,r7[0xc]
8000a88a:	ed b8 00 03 	bld	r8,0x3
8000a88e:	c1 e0       	breq	8000a8ca <__swsetup_r+0x8a>
8000a890:	ed b8 00 04 	bld	r8,0x4
8000a894:	c3 e1       	brne	8000a910 <__swsetup_r+0xd0>
8000a896:	ed b8 00 02 	bld	r8,0x2
8000a89a:	c1 51       	brne	8000a8c4 <__swsetup_r+0x84>
8000a89c:	6e db       	ld.w	r11,r7[0x34]
8000a89e:	58 0b       	cp.w	r11,0
8000a8a0:	c0 a0       	breq	8000a8b4 <__swsetup_r+0x74>
8000a8a2:	ee c8 ff bc 	sub	r8,r7,-68
8000a8a6:	10 3b       	cp.w	r11,r8
8000a8a8:	c0 40       	breq	8000a8b0 <__swsetup_r+0x70>
8000a8aa:	0c 9c       	mov	r12,r6
8000a8ac:	e0 a0 08 34 	rcall	8000b914 <_free_r>
8000a8b0:	30 08       	mov	r8,0
8000a8b2:	8f d8       	st.w	r7[0x34],r8
8000a8b4:	8e 68       	ld.sh	r8,r7[0xc]
8000a8b6:	e0 18 ff db 	andl	r8,0xffdb
8000a8ba:	ae 68       	st.h	r7[0xc],r8
8000a8bc:	30 08       	mov	r8,0
8000a8be:	8f 18       	st.w	r7[0x4],r8
8000a8c0:	6e 48       	ld.w	r8,r7[0x10]
8000a8c2:	8f 08       	st.w	r7[0x0],r8
8000a8c4:	8e 68       	ld.sh	r8,r7[0xc]
8000a8c6:	a3 b8       	sbr	r8,0x3
8000a8c8:	ae 68       	st.h	r7[0xc],r8
8000a8ca:	6e 48       	ld.w	r8,r7[0x10]
8000a8cc:	58 08       	cp.w	r8,0
8000a8ce:	c0 b1       	brne	8000a8e4 <__swsetup_r+0xa4>
8000a8d0:	8e 68       	ld.sh	r8,r7[0xc]
8000a8d2:	e2 18 02 80 	andl	r8,0x280,COH
8000a8d6:	e0 48 02 00 	cp.w	r8,512
8000a8da:	c0 50       	breq	8000a8e4 <__swsetup_r+0xa4>
8000a8dc:	0c 9c       	mov	r12,r6
8000a8de:	0e 9b       	mov	r11,r7
8000a8e0:	e0 a0 0a 52 	rcall	8000bd84 <__smakebuf_r>
8000a8e4:	8e 69       	ld.sh	r9,r7[0xc]
8000a8e6:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000a8ea:	c0 70       	breq	8000a8f8 <__swsetup_r+0xb8>
8000a8ec:	30 08       	mov	r8,0
8000a8ee:	8f 28       	st.w	r7[0x8],r8
8000a8f0:	6e 58       	ld.w	r8,r7[0x14]
8000a8f2:	5c 38       	neg	r8
8000a8f4:	8f 68       	st.w	r7[0x18],r8
8000a8f6:	c0 68       	rjmp	8000a902 <__swsetup_r+0xc2>
8000a8f8:	ed b9 00 01 	bld	r9,0x1
8000a8fc:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000a900:	8f 28       	st.w	r7[0x8],r8
8000a902:	6e 48       	ld.w	r8,r7[0x10]
8000a904:	58 08       	cp.w	r8,0
8000a906:	c0 61       	brne	8000a912 <__swsetup_r+0xd2>
8000a908:	8e 68       	ld.sh	r8,r7[0xc]
8000a90a:	ed b8 00 07 	bld	r8,0x7
8000a90e:	c0 21       	brne	8000a912 <__swsetup_r+0xd2>
8000a910:	dc 2a       	popm	r4-r7,pc,r12=-1
8000a912:	d8 2a       	popm	r4-r7,pc,r12=0
8000a914:	80 02       	ld.sh	r2,r0[0x0]
8000a916:	f9 20 80 02 	ld.sb	r0,r12[-32766]
8000a91a:	f9 40 80 02 	st.w	r12[-32766],r0
8000a91e:	f9 60 d4 31 	st.b	r12[-11215],r0

8000a920 <quorem>:
8000a920:	d4 31       	pushm	r0-r7,lr
8000a922:	20 2d       	sub	sp,8
8000a924:	18 97       	mov	r7,r12
8000a926:	78 48       	ld.w	r8,r12[0x10]
8000a928:	76 46       	ld.w	r6,r11[0x10]
8000a92a:	0c 38       	cp.w	r8,r6
8000a92c:	c0 34       	brge	8000a932 <quorem+0x12>
8000a92e:	30 0c       	mov	r12,0
8000a930:	c8 58       	rjmp	8000aa3a <quorem+0x11a>
8000a932:	ec c2 ff fc 	sub	r2,r6,-4
8000a936:	f6 c3 ff ec 	sub	r3,r11,-20
8000a93a:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000a93e:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000a942:	2f f9       	sub	r9,-1
8000a944:	20 16       	sub	r6,1
8000a946:	f8 09 0d 08 	divu	r8,r12,r9
8000a94a:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000a94e:	ee c4 ff ec 	sub	r4,r7,-20
8000a952:	10 95       	mov	r5,r8
8000a954:	58 08       	cp.w	r8,0
8000a956:	c4 10       	breq	8000a9d8 <quorem+0xb8>
8000a958:	30 09       	mov	r9,0
8000a95a:	06 9a       	mov	r10,r3
8000a95c:	08 98       	mov	r8,r4
8000a95e:	12 91       	mov	r1,r9
8000a960:	50 0b       	stdsp	sp[0x0],r11
8000a962:	70 0e       	ld.w	lr,r8[0x0]
8000a964:	b1 8e       	lsr	lr,0x10
8000a966:	50 1e       	stdsp	sp[0x4],lr
8000a968:	15 0e       	ld.w	lr,r10++
8000a96a:	fc 00 16 10 	lsr	r0,lr,0x10
8000a96e:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000a972:	ea 0e 03 41 	mac	r1,r5,lr
8000a976:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000a97a:	b1 81       	lsr	r1,0x10
8000a97c:	40 1b       	lddsp	r11,sp[0x4]
8000a97e:	ea 00 02 40 	mul	r0,r5,r0
8000a982:	e2 00 00 00 	add	r0,r1,r0
8000a986:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000a98a:	02 1b       	sub	r11,r1
8000a98c:	50 1b       	stdsp	sp[0x4],r11
8000a98e:	70 0b       	ld.w	r11,r8[0x0]
8000a990:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000a994:	02 09       	add	r9,r1
8000a996:	f2 0e 01 0e 	sub	lr,r9,lr
8000a99a:	b0 1e       	st.h	r8[0x2],lr
8000a99c:	fc 09 14 10 	asr	r9,lr,0x10
8000a9a0:	40 1e       	lddsp	lr,sp[0x4]
8000a9a2:	fc 09 00 09 	add	r9,lr,r9
8000a9a6:	b0 09       	st.h	r8[0x0],r9
8000a9a8:	e0 01 16 10 	lsr	r1,r0,0x10
8000a9ac:	2f c8       	sub	r8,-4
8000a9ae:	b1 49       	asr	r9,0x10
8000a9b0:	04 3a       	cp.w	r10,r2
8000a9b2:	fe 98 ff d8 	brls	8000a962 <quorem+0x42>
8000a9b6:	40 0b       	lddsp	r11,sp[0x0]
8000a9b8:	58 0c       	cp.w	r12,0
8000a9ba:	c0 f1       	brne	8000a9d8 <quorem+0xb8>
8000a9bc:	ec c8 ff fb 	sub	r8,r6,-5
8000a9c0:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a9c4:	c0 28       	rjmp	8000a9c8 <quorem+0xa8>
8000a9c6:	20 16       	sub	r6,1
8000a9c8:	20 48       	sub	r8,4
8000a9ca:	08 38       	cp.w	r8,r4
8000a9cc:	e0 88 00 05 	brls	8000a9d6 <quorem+0xb6>
8000a9d0:	70 09       	ld.w	r9,r8[0x0]
8000a9d2:	58 09       	cp.w	r9,0
8000a9d4:	cf 90       	breq	8000a9c6 <quorem+0xa6>
8000a9d6:	8f 46       	st.w	r7[0x10],r6
8000a9d8:	0e 9c       	mov	r12,r7
8000a9da:	e0 a0 0a d4 	rcall	8000bf82 <__mcmp>
8000a9de:	c2 d5       	brlt	8000aa38 <quorem+0x118>
8000a9e0:	2f f5       	sub	r5,-1
8000a9e2:	08 98       	mov	r8,r4
8000a9e4:	30 09       	mov	r9,0
8000a9e6:	07 0b       	ld.w	r11,r3++
8000a9e8:	f6 0a 16 10 	lsr	r10,r11,0x10
8000a9ec:	70 0c       	ld.w	r12,r8[0x0]
8000a9ee:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a9f2:	f8 0e 16 10 	lsr	lr,r12,0x10
8000a9f6:	14 1e       	sub	lr,r10
8000a9f8:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000a9fc:	16 1a       	sub	r10,r11
8000a9fe:	12 0a       	add	r10,r9
8000aa00:	b0 1a       	st.h	r8[0x2],r10
8000aa02:	b1 4a       	asr	r10,0x10
8000aa04:	fc 0a 00 09 	add	r9,lr,r10
8000aa08:	b0 09       	st.h	r8[0x0],r9
8000aa0a:	2f c8       	sub	r8,-4
8000aa0c:	b1 49       	asr	r9,0x10
8000aa0e:	04 33       	cp.w	r3,r2
8000aa10:	fe 98 ff eb 	brls	8000a9e6 <quorem+0xc6>
8000aa14:	ec c8 ff fb 	sub	r8,r6,-5
8000aa18:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000aa1c:	58 09       	cp.w	r9,0
8000aa1e:	c0 d1       	brne	8000aa38 <quorem+0x118>
8000aa20:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000aa24:	c0 28       	rjmp	8000aa28 <quorem+0x108>
8000aa26:	20 16       	sub	r6,1
8000aa28:	20 48       	sub	r8,4
8000aa2a:	08 38       	cp.w	r8,r4
8000aa2c:	e0 88 00 05 	brls	8000aa36 <quorem+0x116>
8000aa30:	70 09       	ld.w	r9,r8[0x0]
8000aa32:	58 09       	cp.w	r9,0
8000aa34:	cf 90       	breq	8000aa26 <quorem+0x106>
8000aa36:	8f 46       	st.w	r7[0x10],r6
8000aa38:	0a 9c       	mov	r12,r5
8000aa3a:	2f ed       	sub	sp,-8
8000aa3c:	d8 32       	popm	r0-r7,pc
8000aa3e:	d7 03       	nop

8000aa40 <_dtoa_r>:
8000aa40:	d4 31       	pushm	r0-r7,lr
8000aa42:	21 ad       	sub	sp,104
8000aa44:	fa c4 ff 74 	sub	r4,sp,-140
8000aa48:	18 97       	mov	r7,r12
8000aa4a:	16 95       	mov	r5,r11
8000aa4c:	68 2c       	ld.w	r12,r4[0x8]
8000aa4e:	50 c9       	stdsp	sp[0x30],r9
8000aa50:	68 16       	ld.w	r6,r4[0x4]
8000aa52:	68 09       	ld.w	r9,r4[0x0]
8000aa54:	50 e8       	stdsp	sp[0x38],r8
8000aa56:	14 94       	mov	r4,r10
8000aa58:	51 2c       	stdsp	sp[0x48],r12
8000aa5a:	fa e5 00 08 	st.d	sp[8],r4
8000aa5e:	51 59       	stdsp	sp[0x54],r9
8000aa60:	6e 95       	ld.w	r5,r7[0x24]
8000aa62:	58 05       	cp.w	r5,0
8000aa64:	c0 91       	brne	8000aa76 <_dtoa_r+0x36>
8000aa66:	31 0c       	mov	r12,16
8000aa68:	fe b0 e8 e6 	rcall	80007c34 <malloc>
8000aa6c:	99 35       	st.w	r12[0xc],r5
8000aa6e:	8f 9c       	st.w	r7[0x24],r12
8000aa70:	99 15       	st.w	r12[0x4],r5
8000aa72:	99 25       	st.w	r12[0x8],r5
8000aa74:	99 05       	st.w	r12[0x0],r5
8000aa76:	6e 99       	ld.w	r9,r7[0x24]
8000aa78:	72 08       	ld.w	r8,r9[0x0]
8000aa7a:	58 08       	cp.w	r8,0
8000aa7c:	c0 f0       	breq	8000aa9a <_dtoa_r+0x5a>
8000aa7e:	72 1a       	ld.w	r10,r9[0x4]
8000aa80:	91 1a       	st.w	r8[0x4],r10
8000aa82:	30 1a       	mov	r10,1
8000aa84:	72 19       	ld.w	r9,r9[0x4]
8000aa86:	f4 09 09 49 	lsl	r9,r10,r9
8000aa8a:	10 9b       	mov	r11,r8
8000aa8c:	91 29       	st.w	r8[0x8],r9
8000aa8e:	0e 9c       	mov	r12,r7
8000aa90:	e0 a0 0a 92 	rcall	8000bfb4 <_Bfree>
8000aa94:	6e 98       	ld.w	r8,r7[0x24]
8000aa96:	30 09       	mov	r9,0
8000aa98:	91 09       	st.w	r8[0x0],r9
8000aa9a:	40 28       	lddsp	r8,sp[0x8]
8000aa9c:	10 94       	mov	r4,r8
8000aa9e:	58 08       	cp.w	r8,0
8000aaa0:	c0 64       	brge	8000aaac <_dtoa_r+0x6c>
8000aaa2:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000aaa6:	50 28       	stdsp	sp[0x8],r8
8000aaa8:	30 18       	mov	r8,1
8000aaaa:	c0 28       	rjmp	8000aaae <_dtoa_r+0x6e>
8000aaac:	30 08       	mov	r8,0
8000aaae:	8d 08       	st.w	r6[0x0],r8
8000aab0:	fc 1c 7f f0 	movh	r12,0x7ff0
8000aab4:	40 26       	lddsp	r6,sp[0x8]
8000aab6:	0c 98       	mov	r8,r6
8000aab8:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000aabc:	18 38       	cp.w	r8,r12
8000aabe:	c1 e1       	brne	8000aafa <_dtoa_r+0xba>
8000aac0:	e0 68 27 0f 	mov	r8,9999
8000aac4:	41 5b       	lddsp	r11,sp[0x54]
8000aac6:	97 08       	st.w	r11[0x0],r8
8000aac8:	40 3a       	lddsp	r10,sp[0xc]
8000aaca:	58 0a       	cp.w	r10,0
8000aacc:	c0 61       	brne	8000aad8 <_dtoa_r+0x98>
8000aace:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000aad2:	c0 31       	brne	8000aad8 <_dtoa_r+0x98>
8000aad4:	4a cc       	lddpc	r12,8000ab84 <_dtoa_r+0x144>
8000aad6:	c0 28       	rjmp	8000aada <_dtoa_r+0x9a>
8000aad8:	4a cc       	lddpc	r12,8000ab88 <_dtoa_r+0x148>
8000aada:	41 29       	lddsp	r9,sp[0x48]
8000aadc:	58 09       	cp.w	r9,0
8000aade:	e0 80 05 9e 	breq	8000b61a <_dtoa_r+0xbda>
8000aae2:	f8 c8 ff fd 	sub	r8,r12,-3
8000aae6:	f8 c9 ff f8 	sub	r9,r12,-8
8000aaea:	11 8b       	ld.ub	r11,r8[0x0]
8000aaec:	30 0a       	mov	r10,0
8000aaee:	41 25       	lddsp	r5,sp[0x48]
8000aaf0:	f4 0b 18 00 	cp.b	r11,r10
8000aaf4:	f2 08 17 10 	movne	r8,r9
8000aaf8:	c1 58       	rjmp	8000ab22 <_dtoa_r+0xe2>
8000aafa:	fa ea 00 08 	ld.d	r10,sp[8]
8000aafe:	30 08       	mov	r8,0
8000ab00:	fa eb 00 3c 	st.d	sp[60],r10
8000ab04:	30 09       	mov	r9,0
8000ab06:	e0 a0 0e 20 	rcall	8000c746 <__avr32_f64_cmp_eq>
8000ab0a:	c0 f0       	breq	8000ab28 <_dtoa_r+0xe8>
8000ab0c:	30 18       	mov	r8,1
8000ab0e:	41 5a       	lddsp	r10,sp[0x54]
8000ab10:	95 08       	st.w	r10[0x0],r8
8000ab12:	49 fc       	lddpc	r12,8000ab8c <_dtoa_r+0x14c>
8000ab14:	41 29       	lddsp	r9,sp[0x48]
8000ab16:	f8 08 00 08 	add	r8,r12,r8
8000ab1a:	58 09       	cp.w	r9,0
8000ab1c:	e0 80 05 7f 	breq	8000b61a <_dtoa_r+0xbda>
8000ab20:	12 95       	mov	r5,r9
8000ab22:	8b 08       	st.w	r5[0x0],r8
8000ab24:	e0 8f 05 7b 	bral	8000b61a <_dtoa_r+0xbda>
8000ab28:	fa c8 ff 9c 	sub	r8,sp,-100
8000ab2c:	fa c9 ff a0 	sub	r9,sp,-96
8000ab30:	fa ea 00 3c 	ld.d	r10,sp[60]
8000ab34:	0e 9c       	mov	r12,r7
8000ab36:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000ab3a:	e0 a0 0a 8f 	rcall	8000c058 <__d2b>
8000ab3e:	18 93       	mov	r3,r12
8000ab40:	58 05       	cp.w	r5,0
8000ab42:	c0 d0       	breq	8000ab5c <_dtoa_r+0x11c>
8000ab44:	fa ea 00 3c 	ld.d	r10,sp[60]
8000ab48:	30 04       	mov	r4,0
8000ab4a:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000ab4e:	ea c5 03 ff 	sub	r5,r5,1023
8000ab52:	10 9b       	mov	r11,r8
8000ab54:	51 74       	stdsp	sp[0x5c],r4
8000ab56:	ea 1b 3f f0 	orh	r11,0x3ff0
8000ab5a:	c2 a8       	rjmp	8000abae <_dtoa_r+0x16e>
8000ab5c:	41 88       	lddsp	r8,sp[0x60]
8000ab5e:	41 9c       	lddsp	r12,sp[0x64]
8000ab60:	10 0c       	add	r12,r8
8000ab62:	f8 c5 fb ce 	sub	r5,r12,-1074
8000ab66:	e0 45 00 20 	cp.w	r5,32
8000ab6a:	e0 8a 00 13 	brle	8000ab90 <_dtoa_r+0x150>
8000ab6e:	f8 cc fb ee 	sub	r12,r12,-1042
8000ab72:	40 3b       	lddsp	r11,sp[0xc]
8000ab74:	ea 08 11 40 	rsub	r8,r5,64
8000ab78:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000ab7c:	ec 08 09 46 	lsl	r6,r6,r8
8000ab80:	0c 4c       	or	r12,r6
8000ab82:	c0 c8       	rjmp	8000ab9a <_dtoa_r+0x15a>
8000ab84:	80 02       	ld.sh	r2,r0[0x0]
8000ab86:	f9 10 80 02 	ld.uh	r0,r12[-32766]
8000ab8a:	f9 1c 80 02 	ld.uh	r12,r12[-32766]
8000ab8e:	f7 ec ea 0c 	sthh.w	r12[0x280],r11:t,r12:b
8000ab92:	11 20       	ld.uh	r0,r8++
8000ab94:	40 3a       	lddsp	r10,sp[0xc]
8000ab96:	f4 0c 09 4c 	lsl	r12,r10,r12
8000ab9a:	fe b0 e3 4d 	rcall	80007234 <__avr32_u32_to_f64>
8000ab9e:	fc 18 fe 10 	movh	r8,0xfe10
8000aba2:	30 19       	mov	r9,1
8000aba4:	ea c5 04 33 	sub	r5,r5,1075
8000aba8:	f0 0b 00 0b 	add	r11,r8,r11
8000abac:	51 79       	stdsp	sp[0x5c],r9
8000abae:	30 08       	mov	r8,0
8000abb0:	fc 19 3f f8 	movh	r9,0x3ff8
8000abb4:	fe b0 e1 ea 	rcall	80006f88 <__avr32_f64_sub>
8000abb8:	e0 68 43 61 	mov	r8,17249
8000abbc:	ea 18 63 6f 	orh	r8,0x636f
8000abc0:	e0 69 87 a7 	mov	r9,34727
8000abc4:	ea 19 3f d2 	orh	r9,0x3fd2
8000abc8:	fe b0 e0 f4 	rcall	80006db0 <__avr32_f64_mul>
8000abcc:	e0 68 c8 b3 	mov	r8,51379
8000abd0:	ea 18 8b 60 	orh	r8,0x8b60
8000abd4:	e0 69 8a 28 	mov	r9,35368
8000abd8:	ea 19 3f c6 	orh	r9,0x3fc6
8000abdc:	fe b0 e2 a4 	rcall	80007124 <__avr32_f64_add>
8000abe0:	0a 9c       	mov	r12,r5
8000abe2:	14 90       	mov	r0,r10
8000abe4:	16 91       	mov	r1,r11
8000abe6:	fe b0 e3 2b 	rcall	8000723c <__avr32_s32_to_f64>
8000abea:	e0 68 79 fb 	mov	r8,31227
8000abee:	ea 18 50 9f 	orh	r8,0x509f
8000abf2:	e0 69 44 13 	mov	r9,17427
8000abf6:	ea 19 3f d3 	orh	r9,0x3fd3
8000abfa:	fe b0 e0 db 	rcall	80006db0 <__avr32_f64_mul>
8000abfe:	14 98       	mov	r8,r10
8000ac00:	16 99       	mov	r9,r11
8000ac02:	00 9a       	mov	r10,r0
8000ac04:	02 9b       	mov	r11,r1
8000ac06:	fe b0 e2 8f 	rcall	80007124 <__avr32_f64_add>
8000ac0a:	14 90       	mov	r0,r10
8000ac0c:	16 91       	mov	r1,r11
8000ac0e:	e0 a0 0d 89 	rcall	8000c720 <__avr32_f64_to_s32>
8000ac12:	30 08       	mov	r8,0
8000ac14:	18 96       	mov	r6,r12
8000ac16:	30 09       	mov	r9,0
8000ac18:	00 9a       	mov	r10,r0
8000ac1a:	02 9b       	mov	r11,r1
8000ac1c:	fe b0 e3 80 	rcall	8000731c <__avr32_f64_cmp_lt>
8000ac20:	c0 c0       	breq	8000ac38 <_dtoa_r+0x1f8>
8000ac22:	0c 9c       	mov	r12,r6
8000ac24:	fe b0 e3 0c 	rcall	8000723c <__avr32_s32_to_f64>
8000ac28:	14 98       	mov	r8,r10
8000ac2a:	16 99       	mov	r9,r11
8000ac2c:	00 9a       	mov	r10,r0
8000ac2e:	02 9b       	mov	r11,r1
8000ac30:	e0 a0 0d 8b 	rcall	8000c746 <__avr32_f64_cmp_eq>
8000ac34:	f7 b6 00 01 	subeq	r6,1
8000ac38:	59 66       	cp.w	r6,22
8000ac3a:	e0 88 00 05 	brls	8000ac44 <_dtoa_r+0x204>
8000ac3e:	30 18       	mov	r8,1
8000ac40:	51 48       	stdsp	sp[0x50],r8
8000ac42:	c1 28       	rjmp	8000ac66 <_dtoa_r+0x226>
8000ac44:	4c 08       	lddpc	r8,8000ad44 <_dtoa_r+0x304>
8000ac46:	fa ea 00 3c 	ld.d	r10,sp[60]
8000ac4a:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000ac4e:	fe b0 e3 67 	rcall	8000731c <__avr32_f64_cmp_lt>
8000ac52:	f9 b4 00 00 	moveq	r4,0
8000ac56:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000ac5a:	f7 b6 01 01 	subne	r6,1
8000ac5e:	f9 bc 01 00 	movne	r12,0
8000ac62:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000ac66:	41 90       	lddsp	r0,sp[0x64]
8000ac68:	20 10       	sub	r0,1
8000ac6a:	0a 10       	sub	r0,r5
8000ac6c:	c0 46       	brmi	8000ac74 <_dtoa_r+0x234>
8000ac6e:	50 40       	stdsp	sp[0x10],r0
8000ac70:	30 00       	mov	r0,0
8000ac72:	c0 48       	rjmp	8000ac7a <_dtoa_r+0x23a>
8000ac74:	30 0b       	mov	r11,0
8000ac76:	5c 30       	neg	r0
8000ac78:	50 4b       	stdsp	sp[0x10],r11
8000ac7a:	ec 02 11 00 	rsub	r2,r6,0
8000ac7e:	58 06       	cp.w	r6,0
8000ac80:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000ac84:	f5 d6 e4 0a 	addge	r10,r10,r6
8000ac88:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000ac8c:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000ac90:	f9 b2 04 00 	movge	r2,0
8000ac94:	e1 d6 e5 10 	sublt	r0,r0,r6
8000ac98:	f9 b9 05 00 	movlt	r9,0
8000ac9c:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000aca0:	40 c8       	lddsp	r8,sp[0x30]
8000aca2:	58 98       	cp.w	r8,9
8000aca4:	e0 8b 00 20 	brhi	8000ace4 <_dtoa_r+0x2a4>
8000aca8:	58 58       	cp.w	r8,5
8000acaa:	f9 b4 0a 01 	movle	r4,1
8000acae:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000acb2:	f7 b5 09 04 	subgt	r5,4
8000acb6:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000acba:	f9 b4 09 00 	movgt	r4,0
8000acbe:	40 cc       	lddsp	r12,sp[0x30]
8000acc0:	58 3c       	cp.w	r12,3
8000acc2:	c2 d0       	breq	8000ad1c <_dtoa_r+0x2dc>
8000acc4:	e0 89 00 05 	brgt	8000acce <_dtoa_r+0x28e>
8000acc8:	58 2c       	cp.w	r12,2
8000acca:	c1 01       	brne	8000acea <_dtoa_r+0x2aa>
8000accc:	c1 88       	rjmp	8000acfc <_dtoa_r+0x2bc>
8000acce:	40 cb       	lddsp	r11,sp[0x30]
8000acd0:	58 4b       	cp.w	r11,4
8000acd2:	c0 60       	breq	8000acde <_dtoa_r+0x29e>
8000acd4:	58 5b       	cp.w	r11,5
8000acd6:	c0 a1       	brne	8000acea <_dtoa_r+0x2aa>
8000acd8:	30 1a       	mov	r10,1
8000acda:	50 da       	stdsp	sp[0x34],r10
8000acdc:	c2 28       	rjmp	8000ad20 <_dtoa_r+0x2e0>
8000acde:	30 19       	mov	r9,1
8000ace0:	50 d9       	stdsp	sp[0x34],r9
8000ace2:	c0 f8       	rjmp	8000ad00 <_dtoa_r+0x2c0>
8000ace4:	30 08       	mov	r8,0
8000ace6:	30 14       	mov	r4,1
8000ace8:	50 c8       	stdsp	sp[0x30],r8
8000acea:	3f f5       	mov	r5,-1
8000acec:	30 1c       	mov	r12,1
8000acee:	30 0b       	mov	r11,0
8000acf0:	50 95       	stdsp	sp[0x24],r5
8000acf2:	50 dc       	stdsp	sp[0x34],r12
8000acf4:	0a 91       	mov	r1,r5
8000acf6:	31 28       	mov	r8,18
8000acf8:	50 eb       	stdsp	sp[0x38],r11
8000acfa:	c2 08       	rjmp	8000ad3a <_dtoa_r+0x2fa>
8000acfc:	30 0a       	mov	r10,0
8000acfe:	50 da       	stdsp	sp[0x34],r10
8000ad00:	40 e9       	lddsp	r9,sp[0x38]
8000ad02:	58 09       	cp.w	r9,0
8000ad04:	e0 89 00 07 	brgt	8000ad12 <_dtoa_r+0x2d2>
8000ad08:	30 18       	mov	r8,1
8000ad0a:	50 98       	stdsp	sp[0x24],r8
8000ad0c:	10 91       	mov	r1,r8
8000ad0e:	50 e8       	stdsp	sp[0x38],r8
8000ad10:	c1 58       	rjmp	8000ad3a <_dtoa_r+0x2fa>
8000ad12:	40 e5       	lddsp	r5,sp[0x38]
8000ad14:	50 95       	stdsp	sp[0x24],r5
8000ad16:	0a 91       	mov	r1,r5
8000ad18:	0a 98       	mov	r8,r5
8000ad1a:	c1 08       	rjmp	8000ad3a <_dtoa_r+0x2fa>
8000ad1c:	30 0c       	mov	r12,0
8000ad1e:	50 dc       	stdsp	sp[0x34],r12
8000ad20:	40 eb       	lddsp	r11,sp[0x38]
8000ad22:	ec 0b 00 0b 	add	r11,r6,r11
8000ad26:	50 9b       	stdsp	sp[0x24],r11
8000ad28:	16 98       	mov	r8,r11
8000ad2a:	2f f8       	sub	r8,-1
8000ad2c:	58 08       	cp.w	r8,0
8000ad2e:	e0 89 00 05 	brgt	8000ad38 <_dtoa_r+0x2f8>
8000ad32:	10 91       	mov	r1,r8
8000ad34:	30 18       	mov	r8,1
8000ad36:	c0 28       	rjmp	8000ad3a <_dtoa_r+0x2fa>
8000ad38:	10 91       	mov	r1,r8
8000ad3a:	30 09       	mov	r9,0
8000ad3c:	6e 9a       	ld.w	r10,r7[0x24]
8000ad3e:	95 19       	st.w	r10[0x4],r9
8000ad40:	30 49       	mov	r9,4
8000ad42:	c0 78       	rjmp	8000ad50 <_dtoa_r+0x310>
8000ad44:	80 02       	ld.sh	r2,r0[0x0]
8000ad46:	f9 d4 6a 1a 	ldins.b	r4:u,r12[-1510]
8000ad4a:	a1 79       	lsl	r9,0x1
8000ad4c:	2f fa       	sub	r10,-1
8000ad4e:	8b 1a       	st.w	r5[0x4],r10
8000ad50:	6e 95       	ld.w	r5,r7[0x24]
8000ad52:	f2 ca ff ec 	sub	r10,r9,-20
8000ad56:	10 3a       	cp.w	r10,r8
8000ad58:	fe 98 ff f8 	brls	8000ad48 <_dtoa_r+0x308>
8000ad5c:	6a 1b       	ld.w	r11,r5[0x4]
8000ad5e:	0e 9c       	mov	r12,r7
8000ad60:	e0 a0 09 44 	rcall	8000bfe8 <_Balloc>
8000ad64:	58 e1       	cp.w	r1,14
8000ad66:	5f 88       	srls	r8
8000ad68:	8b 0c       	st.w	r5[0x0],r12
8000ad6a:	f1 e4 00 04 	and	r4,r8,r4
8000ad6e:	6e 98       	ld.w	r8,r7[0x24]
8000ad70:	70 08       	ld.w	r8,r8[0x0]
8000ad72:	50 88       	stdsp	sp[0x20],r8
8000ad74:	e0 80 01 82 	breq	8000b078 <_dtoa_r+0x638>
8000ad78:	58 06       	cp.w	r6,0
8000ad7a:	e0 8a 00 40 	brle	8000adfa <_dtoa_r+0x3ba>
8000ad7e:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000ad82:	4c b8       	lddpc	r8,8000aeac <_dtoa_r+0x46c>
8000ad84:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000ad88:	fa e5 00 18 	st.d	sp[24],r4
8000ad8c:	ec 04 14 04 	asr	r4,r6,0x4
8000ad90:	ed b4 00 04 	bld	r4,0x4
8000ad94:	c0 30       	breq	8000ad9a <_dtoa_r+0x35a>
8000ad96:	30 25       	mov	r5,2
8000ad98:	c0 f8       	rjmp	8000adb6 <_dtoa_r+0x376>
8000ad9a:	4c 68       	lddpc	r8,8000aeb0 <_dtoa_r+0x470>
8000ad9c:	f0 e8 00 20 	ld.d	r8,r8[32]
8000ada0:	fa ea 00 3c 	ld.d	r10,sp[60]
8000ada4:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000ada8:	fe b0 e3 08 	rcall	800073b8 <__avr32_f64_div>
8000adac:	30 35       	mov	r5,3
8000adae:	14 98       	mov	r8,r10
8000adb0:	16 99       	mov	r9,r11
8000adb2:	fa e9 00 08 	st.d	sp[8],r8
8000adb6:	4b fc       	lddpc	r12,8000aeb0 <_dtoa_r+0x470>
8000adb8:	50 a3       	stdsp	sp[0x28],r3
8000adba:	0c 93       	mov	r3,r6
8000adbc:	18 96       	mov	r6,r12
8000adbe:	c0 f8       	rjmp	8000addc <_dtoa_r+0x39c>
8000adc0:	fa ea 00 18 	ld.d	r10,sp[24]
8000adc4:	ed b4 00 00 	bld	r4,0x0
8000adc8:	c0 81       	brne	8000add8 <_dtoa_r+0x398>
8000adca:	ec e8 00 00 	ld.d	r8,r6[0]
8000adce:	2f f5       	sub	r5,-1
8000add0:	fe b0 df f0 	rcall	80006db0 <__avr32_f64_mul>
8000add4:	fa eb 00 18 	st.d	sp[24],r10
8000add8:	a1 54       	asr	r4,0x1
8000adda:	2f 86       	sub	r6,-8
8000addc:	58 04       	cp.w	r4,0
8000adde:	cf 11       	brne	8000adc0 <_dtoa_r+0x380>
8000ade0:	fa e8 00 18 	ld.d	r8,sp[24]
8000ade4:	fa ea 00 08 	ld.d	r10,sp[8]
8000ade8:	06 96       	mov	r6,r3
8000adea:	fe b0 e2 e7 	rcall	800073b8 <__avr32_f64_div>
8000adee:	40 a3       	lddsp	r3,sp[0x28]
8000adf0:	14 98       	mov	r8,r10
8000adf2:	16 99       	mov	r9,r11
8000adf4:	fa e9 00 08 	st.d	sp[8],r8
8000adf8:	c2 d8       	rjmp	8000ae52 <_dtoa_r+0x412>
8000adfa:	ec 08 11 00 	rsub	r8,r6,0
8000adfe:	c0 31       	brne	8000ae04 <_dtoa_r+0x3c4>
8000ae00:	30 25       	mov	r5,2
8000ae02:	c2 88       	rjmp	8000ae52 <_dtoa_r+0x412>
8000ae04:	4a bc       	lddpc	r12,8000aeb0 <_dtoa_r+0x470>
8000ae06:	f0 04 14 04 	asr	r4,r8,0x4
8000ae0a:	50 1c       	stdsp	sp[0x4],r12
8000ae0c:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000ae10:	4a 79       	lddpc	r9,8000aeac <_dtoa_r+0x46c>
8000ae12:	fa ea 00 3c 	ld.d	r10,sp[60]
8000ae16:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000ae1a:	fe b0 df cb 	rcall	80006db0 <__avr32_f64_mul>
8000ae1e:	40 1c       	lddsp	r12,sp[0x4]
8000ae20:	50 63       	stdsp	sp[0x18],r3
8000ae22:	30 25       	mov	r5,2
8000ae24:	0c 93       	mov	r3,r6
8000ae26:	fa eb 00 08 	st.d	sp[8],r10
8000ae2a:	18 96       	mov	r6,r12
8000ae2c:	c0 f8       	rjmp	8000ae4a <_dtoa_r+0x40a>
8000ae2e:	fa ea 00 08 	ld.d	r10,sp[8]
8000ae32:	ed b4 00 00 	bld	r4,0x0
8000ae36:	c0 81       	brne	8000ae46 <_dtoa_r+0x406>
8000ae38:	ec e8 00 00 	ld.d	r8,r6[0]
8000ae3c:	2f f5       	sub	r5,-1
8000ae3e:	fe b0 df b9 	rcall	80006db0 <__avr32_f64_mul>
8000ae42:	fa eb 00 08 	st.d	sp[8],r10
8000ae46:	a1 54       	asr	r4,0x1
8000ae48:	2f 86       	sub	r6,-8
8000ae4a:	58 04       	cp.w	r4,0
8000ae4c:	cf 11       	brne	8000ae2e <_dtoa_r+0x3ee>
8000ae4e:	06 96       	mov	r6,r3
8000ae50:	40 63       	lddsp	r3,sp[0x18]
8000ae52:	41 4a       	lddsp	r10,sp[0x50]
8000ae54:	58 0a       	cp.w	r10,0
8000ae56:	c2 f0       	breq	8000aeb4 <_dtoa_r+0x474>
8000ae58:	fa e8 00 08 	ld.d	r8,sp[8]
8000ae5c:	58 01       	cp.w	r1,0
8000ae5e:	5f 94       	srgt	r4
8000ae60:	fa e9 00 18 	st.d	sp[24],r8
8000ae64:	30 08       	mov	r8,0
8000ae66:	fc 19 3f f0 	movh	r9,0x3ff0
8000ae6a:	fa ea 00 18 	ld.d	r10,sp[24]
8000ae6e:	fe b0 e2 57 	rcall	8000731c <__avr32_f64_cmp_lt>
8000ae72:	f9 bc 00 00 	moveq	r12,0
8000ae76:	f9 bc 01 01 	movne	r12,1
8000ae7a:	e9 ec 00 0c 	and	r12,r4,r12
8000ae7e:	c1 b0       	breq	8000aeb4 <_dtoa_r+0x474>
8000ae80:	40 98       	lddsp	r8,sp[0x24]
8000ae82:	58 08       	cp.w	r8,0
8000ae84:	e0 8a 00 f6 	brle	8000b070 <_dtoa_r+0x630>
8000ae88:	30 08       	mov	r8,0
8000ae8a:	fc 19 40 24 	movh	r9,0x4024
8000ae8e:	ec c4 00 01 	sub	r4,r6,1
8000ae92:	fa ea 00 18 	ld.d	r10,sp[24]
8000ae96:	2f f5       	sub	r5,-1
8000ae98:	50 64       	stdsp	sp[0x18],r4
8000ae9a:	fe b0 df 8b 	rcall	80006db0 <__avr32_f64_mul>
8000ae9e:	40 94       	lddsp	r4,sp[0x24]
8000aea0:	14 98       	mov	r8,r10
8000aea2:	16 99       	mov	r9,r11
8000aea4:	fa e9 00 08 	st.d	sp[8],r8
8000aea8:	c0 88       	rjmp	8000aeb8 <_dtoa_r+0x478>
8000aeaa:	d7 03       	nop
8000aeac:	80 02       	ld.sh	r2,r0[0x0]
8000aeae:	f9 d4 80 02 	ldswp.w	r4,r12[8]
8000aeb2:	fa 9c 50 66 	brvs	7ff74f7e <_estack+0x7ff64f7e>
8000aeb6:	02 94       	mov	r4,r1
8000aeb8:	0a 9c       	mov	r12,r5
8000aeba:	fe b0 e1 c1 	rcall	8000723c <__avr32_s32_to_f64>
8000aebe:	fa e8 00 08 	ld.d	r8,sp[8]
8000aec2:	fe b0 df 77 	rcall	80006db0 <__avr32_f64_mul>
8000aec6:	30 08       	mov	r8,0
8000aec8:	fc 19 40 1c 	movh	r9,0x401c
8000aecc:	fe b0 e1 2c 	rcall	80007124 <__avr32_f64_add>
8000aed0:	14 98       	mov	r8,r10
8000aed2:	16 99       	mov	r9,r11
8000aed4:	fa e9 00 28 	st.d	sp[40],r8
8000aed8:	fc 18 fc c0 	movh	r8,0xfcc0
8000aedc:	40 a5       	lddsp	r5,sp[0x28]
8000aede:	10 05       	add	r5,r8
8000aee0:	50 a5       	stdsp	sp[0x28],r5
8000aee2:	58 04       	cp.w	r4,0
8000aee4:	c2 11       	brne	8000af26 <_dtoa_r+0x4e6>
8000aee6:	fa ea 00 08 	ld.d	r10,sp[8]
8000aeea:	30 08       	mov	r8,0
8000aeec:	fc 19 40 14 	movh	r9,0x4014
8000aef0:	fe b0 e0 4c 	rcall	80006f88 <__avr32_f64_sub>
8000aef4:	40 bc       	lddsp	r12,sp[0x2c]
8000aef6:	fa eb 00 08 	st.d	sp[8],r10
8000aefa:	14 98       	mov	r8,r10
8000aefc:	16 99       	mov	r9,r11
8000aefe:	18 9a       	mov	r10,r12
8000af00:	0a 9b       	mov	r11,r5
8000af02:	fe b0 e2 0d 	rcall	8000731c <__avr32_f64_cmp_lt>
8000af06:	e0 81 02 54 	brne	8000b3ae <_dtoa_r+0x96e>
8000af0a:	0a 98       	mov	r8,r5
8000af0c:	40 b9       	lddsp	r9,sp[0x2c]
8000af0e:	ee 18 80 00 	eorh	r8,0x8000
8000af12:	fa ea 00 08 	ld.d	r10,sp[8]
8000af16:	10 95       	mov	r5,r8
8000af18:	12 98       	mov	r8,r9
8000af1a:	0a 99       	mov	r9,r5
8000af1c:	fe b0 e2 00 	rcall	8000731c <__avr32_f64_cmp_lt>
8000af20:	e0 81 02 3e 	brne	8000b39c <_dtoa_r+0x95c>
8000af24:	ca 68       	rjmp	8000b070 <_dtoa_r+0x630>
8000af26:	4c e9       	lddpc	r9,8000b05c <_dtoa_r+0x61c>
8000af28:	e8 c8 00 01 	sub	r8,r4,1
8000af2c:	40 d5       	lddsp	r5,sp[0x34]
8000af2e:	58 05       	cp.w	r5,0
8000af30:	c4 f0       	breq	8000afce <_dtoa_r+0x58e>
8000af32:	30 0c       	mov	r12,0
8000af34:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000af38:	51 3c       	stdsp	sp[0x4c],r12
8000af3a:	30 0a       	mov	r10,0
8000af3c:	fc 1b 3f e0 	movh	r11,0x3fe0
8000af40:	fe b0 e2 3c 	rcall	800073b8 <__avr32_f64_div>
8000af44:	fa e8 00 28 	ld.d	r8,sp[40]
8000af48:	40 85       	lddsp	r5,sp[0x20]
8000af4a:	fe b0 e0 1f 	rcall	80006f88 <__avr32_f64_sub>
8000af4e:	fa eb 00 28 	st.d	sp[40],r10
8000af52:	fa ea 00 08 	ld.d	r10,sp[8]
8000af56:	e0 a0 0b e5 	rcall	8000c720 <__avr32_f64_to_s32>
8000af5a:	51 6c       	stdsp	sp[0x58],r12
8000af5c:	fe b0 e1 70 	rcall	8000723c <__avr32_s32_to_f64>
8000af60:	14 98       	mov	r8,r10
8000af62:	16 99       	mov	r9,r11
8000af64:	fa ea 00 08 	ld.d	r10,sp[8]
8000af68:	fe b0 e0 10 	rcall	80006f88 <__avr32_f64_sub>
8000af6c:	fa eb 00 08 	st.d	sp[8],r10
8000af70:	41 68       	lddsp	r8,sp[0x58]
8000af72:	2d 08       	sub	r8,-48
8000af74:	0a c8       	st.b	r5++,r8
8000af76:	41 39       	lddsp	r9,sp[0x4c]
8000af78:	2f f9       	sub	r9,-1
8000af7a:	51 39       	stdsp	sp[0x4c],r9
8000af7c:	fa e8 00 28 	ld.d	r8,sp[40]
8000af80:	fe b0 e1 ce 	rcall	8000731c <__avr32_f64_cmp_lt>
8000af84:	e0 81 03 3a 	brne	8000b5f8 <_dtoa_r+0xbb8>
8000af88:	fa e8 00 08 	ld.d	r8,sp[8]
8000af8c:	30 0a       	mov	r10,0
8000af8e:	fc 1b 3f f0 	movh	r11,0x3ff0
8000af92:	fe b0 df fb 	rcall	80006f88 <__avr32_f64_sub>
8000af96:	fa e8 00 28 	ld.d	r8,sp[40]
8000af9a:	fe b0 e1 c1 	rcall	8000731c <__avr32_f64_cmp_lt>
8000af9e:	fa ea 00 28 	ld.d	r10,sp[40]
8000afa2:	30 08       	mov	r8,0
8000afa4:	fc 19 40 24 	movh	r9,0x4024
8000afa8:	e0 81 00 da 	brne	8000b15c <_dtoa_r+0x71c>
8000afac:	41 3c       	lddsp	r12,sp[0x4c]
8000afae:	08 3c       	cp.w	r12,r4
8000afb0:	c6 04       	brge	8000b070 <_dtoa_r+0x630>
8000afb2:	fe b0 de ff 	rcall	80006db0 <__avr32_f64_mul>
8000afb6:	30 08       	mov	r8,0
8000afb8:	fa eb 00 28 	st.d	sp[40],r10
8000afbc:	fc 19 40 24 	movh	r9,0x4024
8000afc0:	fa ea 00 08 	ld.d	r10,sp[8]
8000afc4:	fe b0 de f6 	rcall	80006db0 <__avr32_f64_mul>
8000afc8:	fa eb 00 08 	st.d	sp[8],r10
8000afcc:	cc 3b       	rjmp	8000af52 <_dtoa_r+0x512>
8000afce:	40 85       	lddsp	r5,sp[0x20]
8000afd0:	08 05       	add	r5,r4
8000afd2:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000afd6:	51 35       	stdsp	sp[0x4c],r5
8000afd8:	fa e8 00 28 	ld.d	r8,sp[40]
8000afdc:	40 85       	lddsp	r5,sp[0x20]
8000afde:	fe b0 de e9 	rcall	80006db0 <__avr32_f64_mul>
8000afe2:	fa eb 00 28 	st.d	sp[40],r10
8000afe6:	fa ea 00 08 	ld.d	r10,sp[8]
8000afea:	e0 a0 0b 9b 	rcall	8000c720 <__avr32_f64_to_s32>
8000afee:	51 6c       	stdsp	sp[0x58],r12
8000aff0:	fe b0 e1 26 	rcall	8000723c <__avr32_s32_to_f64>
8000aff4:	14 98       	mov	r8,r10
8000aff6:	16 99       	mov	r9,r11
8000aff8:	fa ea 00 08 	ld.d	r10,sp[8]
8000affc:	fe b0 df c6 	rcall	80006f88 <__avr32_f64_sub>
8000b000:	fa eb 00 08 	st.d	sp[8],r10
8000b004:	41 68       	lddsp	r8,sp[0x58]
8000b006:	2d 08       	sub	r8,-48
8000b008:	0a c8       	st.b	r5++,r8
8000b00a:	41 3c       	lddsp	r12,sp[0x4c]
8000b00c:	18 35       	cp.w	r5,r12
8000b00e:	c2 91       	brne	8000b060 <_dtoa_r+0x620>
8000b010:	30 08       	mov	r8,0
8000b012:	fc 19 3f e0 	movh	r9,0x3fe0
8000b016:	fa ea 00 28 	ld.d	r10,sp[40]
8000b01a:	fe b0 e0 85 	rcall	80007124 <__avr32_f64_add>
8000b01e:	40 85       	lddsp	r5,sp[0x20]
8000b020:	fa e8 00 08 	ld.d	r8,sp[8]
8000b024:	08 05       	add	r5,r4
8000b026:	fe b0 e1 7b 	rcall	8000731c <__avr32_f64_cmp_lt>
8000b02a:	e0 81 00 99 	brne	8000b15c <_dtoa_r+0x71c>
8000b02e:	fa e8 00 28 	ld.d	r8,sp[40]
8000b032:	30 0a       	mov	r10,0
8000b034:	fc 1b 3f e0 	movh	r11,0x3fe0
8000b038:	fe b0 df a8 	rcall	80006f88 <__avr32_f64_sub>
8000b03c:	14 98       	mov	r8,r10
8000b03e:	16 99       	mov	r9,r11
8000b040:	fa ea 00 08 	ld.d	r10,sp[8]
8000b044:	fe b0 e1 6c 	rcall	8000731c <__avr32_f64_cmp_lt>
8000b048:	c1 40       	breq	8000b070 <_dtoa_r+0x630>
8000b04a:	33 09       	mov	r9,48
8000b04c:	0a 98       	mov	r8,r5
8000b04e:	11 7a       	ld.ub	r10,--r8
8000b050:	f2 0a 18 00 	cp.b	r10,r9
8000b054:	e0 81 02 d2 	brne	8000b5f8 <_dtoa_r+0xbb8>
8000b058:	10 95       	mov	r5,r8
8000b05a:	cf 9b       	rjmp	8000b04c <_dtoa_r+0x60c>
8000b05c:	80 02       	ld.sh	r2,r0[0x0]
8000b05e:	f9 d4 30 08 	ldswp.uh	r4,r12[16]
8000b062:	fc 19 40 24 	movh	r9,0x4024
8000b066:	fe b0 de a5 	rcall	80006db0 <__avr32_f64_mul>
8000b06a:	fa eb 00 08 	st.d	sp[8],r10
8000b06e:	cb cb       	rjmp	8000afe6 <_dtoa_r+0x5a6>
8000b070:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b074:	fa eb 00 08 	st.d	sp[8],r10
8000b078:	58 e6       	cp.w	r6,14
8000b07a:	5f ab       	srle	r11
8000b07c:	41 8a       	lddsp	r10,sp[0x60]
8000b07e:	30 08       	mov	r8,0
8000b080:	f4 09 11 ff 	rsub	r9,r10,-1
8000b084:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000b088:	f0 09 18 00 	cp.b	r9,r8
8000b08c:	e0 80 00 81 	breq	8000b18e <_dtoa_r+0x74e>
8000b090:	40 ea       	lddsp	r10,sp[0x38]
8000b092:	58 01       	cp.w	r1,0
8000b094:	5f a9       	srle	r9
8000b096:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000b09a:	4c 9a       	lddpc	r10,8000b1bc <_dtoa_r+0x77c>
8000b09c:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000b0a0:	fa e5 00 10 	st.d	sp[16],r4
8000b0a4:	f0 09 18 00 	cp.b	r9,r8
8000b0a8:	c1 40       	breq	8000b0d0 <_dtoa_r+0x690>
8000b0aa:	58 01       	cp.w	r1,0
8000b0ac:	e0 81 01 78 	brne	8000b39c <_dtoa_r+0x95c>
8000b0b0:	30 08       	mov	r8,0
8000b0b2:	fc 19 40 14 	movh	r9,0x4014
8000b0b6:	08 9a       	mov	r10,r4
8000b0b8:	0a 9b       	mov	r11,r5
8000b0ba:	fe b0 de 7b 	rcall	80006db0 <__avr32_f64_mul>
8000b0be:	fa e8 00 08 	ld.d	r8,sp[8]
8000b0c2:	e0 a0 0b 55 	rcall	8000c76c <__avr32_f64_cmp_ge>
8000b0c6:	e0 81 01 6b 	brne	8000b39c <_dtoa_r+0x95c>
8000b0ca:	02 92       	mov	r2,r1
8000b0cc:	e0 8f 01 73 	bral	8000b3b2 <_dtoa_r+0x972>
8000b0d0:	40 85       	lddsp	r5,sp[0x20]
8000b0d2:	30 14       	mov	r4,1
8000b0d4:	fa e8 00 10 	ld.d	r8,sp[16]
8000b0d8:	fa ea 00 08 	ld.d	r10,sp[8]
8000b0dc:	fe b0 e1 6e 	rcall	800073b8 <__avr32_f64_div>
8000b0e0:	e0 a0 0b 20 	rcall	8000c720 <__avr32_f64_to_s32>
8000b0e4:	18 92       	mov	r2,r12
8000b0e6:	fe b0 e0 ab 	rcall	8000723c <__avr32_s32_to_f64>
8000b0ea:	fa e8 00 10 	ld.d	r8,sp[16]
8000b0ee:	fe b0 de 61 	rcall	80006db0 <__avr32_f64_mul>
8000b0f2:	14 98       	mov	r8,r10
8000b0f4:	16 99       	mov	r9,r11
8000b0f6:	fa ea 00 08 	ld.d	r10,sp[8]
8000b0fa:	fe b0 df 47 	rcall	80006f88 <__avr32_f64_sub>
8000b0fe:	fa eb 00 08 	st.d	sp[8],r10
8000b102:	e4 c8 ff d0 	sub	r8,r2,-48
8000b106:	0a c8       	st.b	r5++,r8
8000b108:	fc 19 40 24 	movh	r9,0x4024
8000b10c:	30 08       	mov	r8,0
8000b10e:	02 34       	cp.w	r4,r1
8000b110:	c3 31       	brne	8000b176 <_dtoa_r+0x736>
8000b112:	fa e8 00 08 	ld.d	r8,sp[8]
8000b116:	fe b0 e0 07 	rcall	80007124 <__avr32_f64_add>
8000b11a:	16 91       	mov	r1,r11
8000b11c:	14 90       	mov	r0,r10
8000b11e:	14 98       	mov	r8,r10
8000b120:	02 99       	mov	r9,r1
8000b122:	fa ea 00 10 	ld.d	r10,sp[16]
8000b126:	fe b0 e0 fb 	rcall	8000731c <__avr32_f64_cmp_lt>
8000b12a:	c1 a1       	brne	8000b15e <_dtoa_r+0x71e>
8000b12c:	fa e8 00 10 	ld.d	r8,sp[16]
8000b130:	00 9a       	mov	r10,r0
8000b132:	02 9b       	mov	r11,r1
8000b134:	e0 a0 0b 09 	rcall	8000c746 <__avr32_f64_cmp_eq>
8000b138:	e0 80 02 5f 	breq	8000b5f6 <_dtoa_r+0xbb6>
8000b13c:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000b140:	c0 f1       	brne	8000b15e <_dtoa_r+0x71e>
8000b142:	e0 8f 02 5a 	bral	8000b5f6 <_dtoa_r+0xbb6>
8000b146:	40 8a       	lddsp	r10,sp[0x20]
8000b148:	14 38       	cp.w	r8,r10
8000b14a:	c0 30       	breq	8000b150 <_dtoa_r+0x710>
8000b14c:	10 95       	mov	r5,r8
8000b14e:	c0 98       	rjmp	8000b160 <_dtoa_r+0x720>
8000b150:	33 08       	mov	r8,48
8000b152:	40 89       	lddsp	r9,sp[0x20]
8000b154:	2f f6       	sub	r6,-1
8000b156:	b2 88       	st.b	r9[0x0],r8
8000b158:	40 88       	lddsp	r8,sp[0x20]
8000b15a:	c0 88       	rjmp	8000b16a <_dtoa_r+0x72a>
8000b15c:	40 66       	lddsp	r6,sp[0x18]
8000b15e:	33 99       	mov	r9,57
8000b160:	0a 98       	mov	r8,r5
8000b162:	11 7a       	ld.ub	r10,--r8
8000b164:	f2 0a 18 00 	cp.b	r10,r9
8000b168:	ce f0       	breq	8000b146 <_dtoa_r+0x706>
8000b16a:	50 66       	stdsp	sp[0x18],r6
8000b16c:	11 89       	ld.ub	r9,r8[0x0]
8000b16e:	2f f9       	sub	r9,-1
8000b170:	b0 89       	st.b	r8[0x0],r9
8000b172:	e0 8f 02 43 	bral	8000b5f8 <_dtoa_r+0xbb8>
8000b176:	fe b0 de 1d 	rcall	80006db0 <__avr32_f64_mul>
8000b17a:	2f f4       	sub	r4,-1
8000b17c:	fa eb 00 08 	st.d	sp[8],r10
8000b180:	30 08       	mov	r8,0
8000b182:	30 09       	mov	r9,0
8000b184:	e0 a0 0a e1 	rcall	8000c746 <__avr32_f64_cmp_eq>
8000b188:	ca 60       	breq	8000b0d4 <_dtoa_r+0x694>
8000b18a:	e0 8f 02 36 	bral	8000b5f6 <_dtoa_r+0xbb6>
8000b18e:	40 d8       	lddsp	r8,sp[0x34]
8000b190:	58 08       	cp.w	r8,0
8000b192:	c0 51       	brne	8000b19c <_dtoa_r+0x75c>
8000b194:	04 98       	mov	r8,r2
8000b196:	00 95       	mov	r5,r0
8000b198:	40 d4       	lddsp	r4,sp[0x34]
8000b19a:	c3 88       	rjmp	8000b20a <_dtoa_r+0x7ca>
8000b19c:	40 c5       	lddsp	r5,sp[0x30]
8000b19e:	58 15       	cp.w	r5,1
8000b1a0:	e0 89 00 10 	brgt	8000b1c0 <_dtoa_r+0x780>
8000b1a4:	41 74       	lddsp	r4,sp[0x5c]
8000b1a6:	58 04       	cp.w	r4,0
8000b1a8:	c0 40       	breq	8000b1b0 <_dtoa_r+0x770>
8000b1aa:	f4 c9 fb cd 	sub	r9,r10,-1075
8000b1ae:	c0 48       	rjmp	8000b1b6 <_dtoa_r+0x776>
8000b1b0:	41 99       	lddsp	r9,sp[0x64]
8000b1b2:	f2 09 11 36 	rsub	r9,r9,54
8000b1b6:	04 98       	mov	r8,r2
8000b1b8:	00 95       	mov	r5,r0
8000b1ba:	c1 d8       	rjmp	8000b1f4 <_dtoa_r+0x7b4>
8000b1bc:	80 02       	ld.sh	r2,r0[0x0]
8000b1be:	f9 d4       	*unknown*
8000b1c0:	e2 c8 00 01 	sub	r8,r1,1
8000b1c4:	58 01       	cp.w	r1,0
8000b1c6:	e0 05 17 40 	movge	r5,r0
8000b1ca:	e2 09 17 40 	movge	r9,r1
8000b1ce:	e1 d1 e5 15 	sublt	r5,r0,r1
8000b1d2:	f9 b9 05 00 	movlt	r9,0
8000b1d6:	10 32       	cp.w	r2,r8
8000b1d8:	e5 d8 e4 18 	subge	r8,r2,r8
8000b1dc:	f1 d2 e5 18 	sublt	r8,r8,r2
8000b1e0:	e5 d8 e5 02 	addlt	r2,r2,r8
8000b1e4:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000b1e8:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000b1ec:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000b1f0:	f9 b8 05 00 	movlt	r8,0
8000b1f4:	40 4b       	lddsp	r11,sp[0x10]
8000b1f6:	12 0b       	add	r11,r9
8000b1f8:	50 08       	stdsp	sp[0x0],r8
8000b1fa:	50 4b       	stdsp	sp[0x10],r11
8000b1fc:	12 00       	add	r0,r9
8000b1fe:	30 1b       	mov	r11,1
8000b200:	0e 9c       	mov	r12,r7
8000b202:	e0 a0 08 a7 	rcall	8000c350 <__i2b>
8000b206:	40 08       	lddsp	r8,sp[0x0]
8000b208:	18 94       	mov	r4,r12
8000b20a:	40 4a       	lddsp	r10,sp[0x10]
8000b20c:	58 05       	cp.w	r5,0
8000b20e:	5f 99       	srgt	r9
8000b210:	58 0a       	cp.w	r10,0
8000b212:	5f 9a       	srgt	r10
8000b214:	f5 e9 00 09 	and	r9,r10,r9
8000b218:	c0 80       	breq	8000b228 <_dtoa_r+0x7e8>
8000b21a:	40 4c       	lddsp	r12,sp[0x10]
8000b21c:	f8 05 0d 49 	min	r9,r12,r5
8000b220:	12 1c       	sub	r12,r9
8000b222:	12 10       	sub	r0,r9
8000b224:	50 4c       	stdsp	sp[0x10],r12
8000b226:	12 15       	sub	r5,r9
8000b228:	58 02       	cp.w	r2,0
8000b22a:	e0 8a 00 27 	brle	8000b278 <_dtoa_r+0x838>
8000b22e:	40 db       	lddsp	r11,sp[0x34]
8000b230:	58 0b       	cp.w	r11,0
8000b232:	c1 d0       	breq	8000b26c <_dtoa_r+0x82c>
8000b234:	58 08       	cp.w	r8,0
8000b236:	e0 8a 00 17 	brle	8000b264 <_dtoa_r+0x824>
8000b23a:	10 9a       	mov	r10,r8
8000b23c:	50 08       	stdsp	sp[0x0],r8
8000b23e:	08 9b       	mov	r11,r4
8000b240:	0e 9c       	mov	r12,r7
8000b242:	e0 a0 08 cd 	rcall	8000c3dc <__pow5mult>
8000b246:	06 9a       	mov	r10,r3
8000b248:	18 9b       	mov	r11,r12
8000b24a:	18 94       	mov	r4,r12
8000b24c:	0e 9c       	mov	r12,r7
8000b24e:	e0 a0 08 01 	rcall	8000c250 <__multiply>
8000b252:	18 99       	mov	r9,r12
8000b254:	06 9b       	mov	r11,r3
8000b256:	50 19       	stdsp	sp[0x4],r9
8000b258:	0e 9c       	mov	r12,r7
8000b25a:	e0 a0 06 ad 	rcall	8000bfb4 <_Bfree>
8000b25e:	40 19       	lddsp	r9,sp[0x4]
8000b260:	40 08       	lddsp	r8,sp[0x0]
8000b262:	12 93       	mov	r3,r9
8000b264:	e4 08 01 0a 	sub	r10,r2,r8
8000b268:	c0 80       	breq	8000b278 <_dtoa_r+0x838>
8000b26a:	c0 28       	rjmp	8000b26e <_dtoa_r+0x82e>
8000b26c:	04 9a       	mov	r10,r2
8000b26e:	06 9b       	mov	r11,r3
8000b270:	0e 9c       	mov	r12,r7
8000b272:	e0 a0 08 b5 	rcall	8000c3dc <__pow5mult>
8000b276:	18 93       	mov	r3,r12
8000b278:	30 1b       	mov	r11,1
8000b27a:	0e 9c       	mov	r12,r7
8000b27c:	e0 a0 08 6a 	rcall	8000c350 <__i2b>
8000b280:	41 1a       	lddsp	r10,sp[0x44]
8000b282:	18 92       	mov	r2,r12
8000b284:	58 0a       	cp.w	r10,0
8000b286:	e0 8a 00 07 	brle	8000b294 <_dtoa_r+0x854>
8000b28a:	18 9b       	mov	r11,r12
8000b28c:	0e 9c       	mov	r12,r7
8000b28e:	e0 a0 08 a7 	rcall	8000c3dc <__pow5mult>
8000b292:	18 92       	mov	r2,r12
8000b294:	40 c9       	lddsp	r9,sp[0x30]
8000b296:	58 19       	cp.w	r9,1
8000b298:	e0 89 00 14 	brgt	8000b2c0 <_dtoa_r+0x880>
8000b29c:	40 38       	lddsp	r8,sp[0xc]
8000b29e:	58 08       	cp.w	r8,0
8000b2a0:	c1 01       	brne	8000b2c0 <_dtoa_r+0x880>
8000b2a2:	40 29       	lddsp	r9,sp[0x8]
8000b2a4:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000b2a8:	c0 c1       	brne	8000b2c0 <_dtoa_r+0x880>
8000b2aa:	12 98       	mov	r8,r9
8000b2ac:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000b2b0:	c0 80       	breq	8000b2c0 <_dtoa_r+0x880>
8000b2b2:	40 4c       	lddsp	r12,sp[0x10]
8000b2b4:	30 1b       	mov	r11,1
8000b2b6:	2f fc       	sub	r12,-1
8000b2b8:	2f f0       	sub	r0,-1
8000b2ba:	50 4c       	stdsp	sp[0x10],r12
8000b2bc:	50 6b       	stdsp	sp[0x18],r11
8000b2be:	c0 38       	rjmp	8000b2c4 <_dtoa_r+0x884>
8000b2c0:	30 0a       	mov	r10,0
8000b2c2:	50 6a       	stdsp	sp[0x18],r10
8000b2c4:	41 19       	lddsp	r9,sp[0x44]
8000b2c6:	58 09       	cp.w	r9,0
8000b2c8:	c0 31       	brne	8000b2ce <_dtoa_r+0x88e>
8000b2ca:	30 1c       	mov	r12,1
8000b2cc:	c0 98       	rjmp	8000b2de <_dtoa_r+0x89e>
8000b2ce:	64 48       	ld.w	r8,r2[0x10]
8000b2d0:	2f c8       	sub	r8,-4
8000b2d2:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000b2d6:	e0 a0 05 df 	rcall	8000be94 <__hi0bits>
8000b2da:	f8 0c 11 20 	rsub	r12,r12,32
8000b2de:	40 4b       	lddsp	r11,sp[0x10]
8000b2e0:	f8 0b 00 08 	add	r8,r12,r11
8000b2e4:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000b2e8:	c0 c0       	breq	8000b300 <_dtoa_r+0x8c0>
8000b2ea:	f0 08 11 20 	rsub	r8,r8,32
8000b2ee:	58 48       	cp.w	r8,4
8000b2f0:	e0 8a 00 06 	brle	8000b2fc <_dtoa_r+0x8bc>
8000b2f4:	20 48       	sub	r8,4
8000b2f6:	10 0b       	add	r11,r8
8000b2f8:	50 4b       	stdsp	sp[0x10],r11
8000b2fa:	c0 78       	rjmp	8000b308 <_dtoa_r+0x8c8>
8000b2fc:	58 48       	cp.w	r8,4
8000b2fe:	c0 70       	breq	8000b30c <_dtoa_r+0x8cc>
8000b300:	40 4a       	lddsp	r10,sp[0x10]
8000b302:	2e 48       	sub	r8,-28
8000b304:	10 0a       	add	r10,r8
8000b306:	50 4a       	stdsp	sp[0x10],r10
8000b308:	10 00       	add	r0,r8
8000b30a:	10 05       	add	r5,r8
8000b30c:	58 00       	cp.w	r0,0
8000b30e:	e0 8a 00 08 	brle	8000b31e <_dtoa_r+0x8de>
8000b312:	06 9b       	mov	r11,r3
8000b314:	00 9a       	mov	r10,r0
8000b316:	0e 9c       	mov	r12,r7
8000b318:	e0 a0 07 58 	rcall	8000c1c8 <__lshift>
8000b31c:	18 93       	mov	r3,r12
8000b31e:	40 49       	lddsp	r9,sp[0x10]
8000b320:	58 09       	cp.w	r9,0
8000b322:	e0 8a 00 08 	brle	8000b332 <_dtoa_r+0x8f2>
8000b326:	04 9b       	mov	r11,r2
8000b328:	12 9a       	mov	r10,r9
8000b32a:	0e 9c       	mov	r12,r7
8000b32c:	e0 a0 07 4e 	rcall	8000c1c8 <__lshift>
8000b330:	18 92       	mov	r2,r12
8000b332:	41 48       	lddsp	r8,sp[0x50]
8000b334:	58 08       	cp.w	r8,0
8000b336:	c1 b0       	breq	8000b36c <_dtoa_r+0x92c>
8000b338:	04 9b       	mov	r11,r2
8000b33a:	06 9c       	mov	r12,r3
8000b33c:	e0 a0 06 23 	rcall	8000bf82 <__mcmp>
8000b340:	c1 64       	brge	8000b36c <_dtoa_r+0x92c>
8000b342:	06 9b       	mov	r11,r3
8000b344:	30 09       	mov	r9,0
8000b346:	30 aa       	mov	r10,10
8000b348:	0e 9c       	mov	r12,r7
8000b34a:	e0 a0 08 0b 	rcall	8000c360 <__multadd>
8000b34e:	20 16       	sub	r6,1
8000b350:	18 93       	mov	r3,r12
8000b352:	40 dc       	lddsp	r12,sp[0x34]
8000b354:	58 0c       	cp.w	r12,0
8000b356:	c0 31       	brne	8000b35c <_dtoa_r+0x91c>
8000b358:	40 91       	lddsp	r1,sp[0x24]
8000b35a:	c0 98       	rjmp	8000b36c <_dtoa_r+0x92c>
8000b35c:	08 9b       	mov	r11,r4
8000b35e:	40 91       	lddsp	r1,sp[0x24]
8000b360:	30 09       	mov	r9,0
8000b362:	30 aa       	mov	r10,10
8000b364:	0e 9c       	mov	r12,r7
8000b366:	e0 a0 07 fd 	rcall	8000c360 <__multadd>
8000b36a:	18 94       	mov	r4,r12
8000b36c:	58 01       	cp.w	r1,0
8000b36e:	5f a9       	srle	r9
8000b370:	40 cb       	lddsp	r11,sp[0x30]
8000b372:	58 2b       	cp.w	r11,2
8000b374:	5f 98       	srgt	r8
8000b376:	f3 e8 00 08 	and	r8,r9,r8
8000b37a:	c2 50       	breq	8000b3c4 <_dtoa_r+0x984>
8000b37c:	58 01       	cp.w	r1,0
8000b37e:	c1 11       	brne	8000b3a0 <_dtoa_r+0x960>
8000b380:	04 9b       	mov	r11,r2
8000b382:	02 99       	mov	r9,r1
8000b384:	30 5a       	mov	r10,5
8000b386:	0e 9c       	mov	r12,r7
8000b388:	e0 a0 07 ec 	rcall	8000c360 <__multadd>
8000b38c:	18 92       	mov	r2,r12
8000b38e:	18 9b       	mov	r11,r12
8000b390:	06 9c       	mov	r12,r3
8000b392:	e0 a0 05 f8 	rcall	8000bf82 <__mcmp>
8000b396:	e0 89 00 0f 	brgt	8000b3b4 <_dtoa_r+0x974>
8000b39a:	c0 38       	rjmp	8000b3a0 <_dtoa_r+0x960>
8000b39c:	30 02       	mov	r2,0
8000b39e:	04 94       	mov	r4,r2
8000b3a0:	40 ea       	lddsp	r10,sp[0x38]
8000b3a2:	30 09       	mov	r9,0
8000b3a4:	5c da       	com	r10
8000b3a6:	40 85       	lddsp	r5,sp[0x20]
8000b3a8:	50 6a       	stdsp	sp[0x18],r10
8000b3aa:	50 49       	stdsp	sp[0x10],r9
8000b3ac:	c0 f9       	rjmp	8000b5ca <_dtoa_r+0xb8a>
8000b3ae:	08 92       	mov	r2,r4
8000b3b0:	40 66       	lddsp	r6,sp[0x18]
8000b3b2:	04 94       	mov	r4,r2
8000b3b4:	2f f6       	sub	r6,-1
8000b3b6:	50 66       	stdsp	sp[0x18],r6
8000b3b8:	33 18       	mov	r8,49
8000b3ba:	40 85       	lddsp	r5,sp[0x20]
8000b3bc:	0a c8       	st.b	r5++,r8
8000b3be:	30 08       	mov	r8,0
8000b3c0:	50 48       	stdsp	sp[0x10],r8
8000b3c2:	c0 49       	rjmp	8000b5ca <_dtoa_r+0xb8a>
8000b3c4:	40 dc       	lddsp	r12,sp[0x34]
8000b3c6:	58 0c       	cp.w	r12,0
8000b3c8:	e0 80 00 b5 	breq	8000b532 <_dtoa_r+0xaf2>
8000b3cc:	58 05       	cp.w	r5,0
8000b3ce:	e0 8a 00 08 	brle	8000b3de <_dtoa_r+0x99e>
8000b3d2:	08 9b       	mov	r11,r4
8000b3d4:	0a 9a       	mov	r10,r5
8000b3d6:	0e 9c       	mov	r12,r7
8000b3d8:	e0 a0 06 f8 	rcall	8000c1c8 <__lshift>
8000b3dc:	18 94       	mov	r4,r12
8000b3de:	40 6b       	lddsp	r11,sp[0x18]
8000b3e0:	58 0b       	cp.w	r11,0
8000b3e2:	c0 31       	brne	8000b3e8 <_dtoa_r+0x9a8>
8000b3e4:	08 9c       	mov	r12,r4
8000b3e6:	c1 38       	rjmp	8000b40c <_dtoa_r+0x9cc>
8000b3e8:	68 1b       	ld.w	r11,r4[0x4]
8000b3ea:	0e 9c       	mov	r12,r7
8000b3ec:	e0 a0 05 fe 	rcall	8000bfe8 <_Balloc>
8000b3f0:	68 4a       	ld.w	r10,r4[0x10]
8000b3f2:	18 95       	mov	r5,r12
8000b3f4:	e8 cb ff f4 	sub	r11,r4,-12
8000b3f8:	2f ea       	sub	r10,-2
8000b3fa:	2f 4c       	sub	r12,-12
8000b3fc:	a3 6a       	lsl	r10,0x2
8000b3fe:	fe b0 e6 39 	rcall	80008070 <memcpy>
8000b402:	0a 9b       	mov	r11,r5
8000b404:	30 1a       	mov	r10,1
8000b406:	0e 9c       	mov	r12,r7
8000b408:	e0 a0 06 e0 	rcall	8000c1c8 <__lshift>
8000b40c:	50 44       	stdsp	sp[0x10],r4
8000b40e:	40 3a       	lddsp	r10,sp[0xc]
8000b410:	30 19       	mov	r9,1
8000b412:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000b416:	18 94       	mov	r4,r12
8000b418:	50 da       	stdsp	sp[0x34],r10
8000b41a:	40 85       	lddsp	r5,sp[0x20]
8000b41c:	50 99       	stdsp	sp[0x24],r9
8000b41e:	50 26       	stdsp	sp[0x8],r6
8000b420:	50 e1       	stdsp	sp[0x38],r1
8000b422:	04 9b       	mov	r11,r2
8000b424:	06 9c       	mov	r12,r3
8000b426:	fe b0 fa 7d 	rcall	8000a920 <quorem>
8000b42a:	40 4b       	lddsp	r11,sp[0x10]
8000b42c:	f8 c0 ff d0 	sub	r0,r12,-48
8000b430:	06 9c       	mov	r12,r3
8000b432:	e0 a0 05 a8 	rcall	8000bf82 <__mcmp>
8000b436:	08 9a       	mov	r10,r4
8000b438:	50 6c       	stdsp	sp[0x18],r12
8000b43a:	04 9b       	mov	r11,r2
8000b43c:	0e 9c       	mov	r12,r7
8000b43e:	e0 a0 06 5d 	rcall	8000c0f8 <__mdiff>
8000b442:	18 91       	mov	r1,r12
8000b444:	78 38       	ld.w	r8,r12[0xc]
8000b446:	58 08       	cp.w	r8,0
8000b448:	c0 30       	breq	8000b44e <_dtoa_r+0xa0e>
8000b44a:	30 16       	mov	r6,1
8000b44c:	c0 68       	rjmp	8000b458 <_dtoa_r+0xa18>
8000b44e:	18 9b       	mov	r11,r12
8000b450:	06 9c       	mov	r12,r3
8000b452:	e0 a0 05 98 	rcall	8000bf82 <__mcmp>
8000b456:	18 96       	mov	r6,r12
8000b458:	0e 9c       	mov	r12,r7
8000b45a:	02 9b       	mov	r11,r1
8000b45c:	e0 a0 05 ac 	rcall	8000bfb4 <_Bfree>
8000b460:	40 cc       	lddsp	r12,sp[0x30]
8000b462:	ed ec 10 08 	or	r8,r6,r12
8000b466:	c0 d1       	brne	8000b480 <_dtoa_r+0xa40>
8000b468:	40 db       	lddsp	r11,sp[0x34]
8000b46a:	58 0b       	cp.w	r11,0
8000b46c:	c0 a1       	brne	8000b480 <_dtoa_r+0xa40>
8000b46e:	40 26       	lddsp	r6,sp[0x8]
8000b470:	e0 40 00 39 	cp.w	r0,57
8000b474:	c3 00       	breq	8000b4d4 <_dtoa_r+0xa94>
8000b476:	40 6a       	lddsp	r10,sp[0x18]
8000b478:	58 0a       	cp.w	r10,0
8000b47a:	e0 89 00 24 	brgt	8000b4c2 <_dtoa_r+0xa82>
8000b47e:	c2 f8       	rjmp	8000b4dc <_dtoa_r+0xa9c>
8000b480:	40 69       	lddsp	r9,sp[0x18]
8000b482:	58 09       	cp.w	r9,0
8000b484:	c0 85       	brlt	8000b494 <_dtoa_r+0xa54>
8000b486:	12 98       	mov	r8,r9
8000b488:	40 cc       	lddsp	r12,sp[0x30]
8000b48a:	18 48       	or	r8,r12
8000b48c:	c1 d1       	brne	8000b4c6 <_dtoa_r+0xa86>
8000b48e:	40 db       	lddsp	r11,sp[0x34]
8000b490:	58 0b       	cp.w	r11,0
8000b492:	c1 a1       	brne	8000b4c6 <_dtoa_r+0xa86>
8000b494:	0c 99       	mov	r9,r6
8000b496:	40 26       	lddsp	r6,sp[0x8]
8000b498:	58 09       	cp.w	r9,0
8000b49a:	e0 8a 00 21 	brle	8000b4dc <_dtoa_r+0xa9c>
8000b49e:	06 9b       	mov	r11,r3
8000b4a0:	30 1a       	mov	r10,1
8000b4a2:	0e 9c       	mov	r12,r7
8000b4a4:	e0 a0 06 92 	rcall	8000c1c8 <__lshift>
8000b4a8:	04 9b       	mov	r11,r2
8000b4aa:	18 93       	mov	r3,r12
8000b4ac:	e0 a0 05 6b 	rcall	8000bf82 <__mcmp>
8000b4b0:	e0 89 00 06 	brgt	8000b4bc <_dtoa_r+0xa7c>
8000b4b4:	c1 41       	brne	8000b4dc <_dtoa_r+0xa9c>
8000b4b6:	ed b0 00 00 	bld	r0,0x0
8000b4ba:	c1 11       	brne	8000b4dc <_dtoa_r+0xa9c>
8000b4bc:	e0 40 00 39 	cp.w	r0,57
8000b4c0:	c0 a0       	breq	8000b4d4 <_dtoa_r+0xa94>
8000b4c2:	2f f0       	sub	r0,-1
8000b4c4:	c0 c8       	rjmp	8000b4dc <_dtoa_r+0xa9c>
8000b4c6:	58 06       	cp.w	r6,0
8000b4c8:	e0 8a 00 0c 	brle	8000b4e0 <_dtoa_r+0xaa0>
8000b4cc:	40 26       	lddsp	r6,sp[0x8]
8000b4ce:	e0 40 00 39 	cp.w	r0,57
8000b4d2:	c0 41       	brne	8000b4da <_dtoa_r+0xa9a>
8000b4d4:	33 98       	mov	r8,57
8000b4d6:	0a c8       	st.b	r5++,r8
8000b4d8:	c6 78       	rjmp	8000b5a6 <_dtoa_r+0xb66>
8000b4da:	2f f0       	sub	r0,-1
8000b4dc:	0a c0       	st.b	r5++,r0
8000b4de:	c7 58       	rjmp	8000b5c8 <_dtoa_r+0xb88>
8000b4e0:	0a c0       	st.b	r5++,r0
8000b4e2:	40 9a       	lddsp	r10,sp[0x24]
8000b4e4:	40 e9       	lddsp	r9,sp[0x38]
8000b4e6:	12 3a       	cp.w	r10,r9
8000b4e8:	c4 30       	breq	8000b56e <_dtoa_r+0xb2e>
8000b4ea:	06 9b       	mov	r11,r3
8000b4ec:	30 09       	mov	r9,0
8000b4ee:	30 aa       	mov	r10,10
8000b4f0:	0e 9c       	mov	r12,r7
8000b4f2:	e0 a0 07 37 	rcall	8000c360 <__multadd>
8000b4f6:	40 48       	lddsp	r8,sp[0x10]
8000b4f8:	18 93       	mov	r3,r12
8000b4fa:	08 38       	cp.w	r8,r4
8000b4fc:	c0 91       	brne	8000b50e <_dtoa_r+0xace>
8000b4fe:	10 9b       	mov	r11,r8
8000b500:	30 09       	mov	r9,0
8000b502:	30 aa       	mov	r10,10
8000b504:	0e 9c       	mov	r12,r7
8000b506:	e0 a0 07 2d 	rcall	8000c360 <__multadd>
8000b50a:	50 4c       	stdsp	sp[0x10],r12
8000b50c:	c0 e8       	rjmp	8000b528 <_dtoa_r+0xae8>
8000b50e:	40 4b       	lddsp	r11,sp[0x10]
8000b510:	30 09       	mov	r9,0
8000b512:	30 aa       	mov	r10,10
8000b514:	0e 9c       	mov	r12,r7
8000b516:	e0 a0 07 25 	rcall	8000c360 <__multadd>
8000b51a:	08 9b       	mov	r11,r4
8000b51c:	50 4c       	stdsp	sp[0x10],r12
8000b51e:	30 09       	mov	r9,0
8000b520:	30 aa       	mov	r10,10
8000b522:	0e 9c       	mov	r12,r7
8000b524:	e0 a0 07 1e 	rcall	8000c360 <__multadd>
8000b528:	18 94       	mov	r4,r12
8000b52a:	40 9c       	lddsp	r12,sp[0x24]
8000b52c:	2f fc       	sub	r12,-1
8000b52e:	50 9c       	stdsp	sp[0x24],r12
8000b530:	c7 9b       	rjmp	8000b422 <_dtoa_r+0x9e2>
8000b532:	30 18       	mov	r8,1
8000b534:	06 90       	mov	r0,r3
8000b536:	40 85       	lddsp	r5,sp[0x20]
8000b538:	08 93       	mov	r3,r4
8000b53a:	0c 94       	mov	r4,r6
8000b53c:	10 96       	mov	r6,r8
8000b53e:	04 9b       	mov	r11,r2
8000b540:	00 9c       	mov	r12,r0
8000b542:	fe b0 f9 ef 	rcall	8000a920 <quorem>
8000b546:	2d 0c       	sub	r12,-48
8000b548:	0a cc       	st.b	r5++,r12
8000b54a:	02 36       	cp.w	r6,r1
8000b54c:	c0 a4       	brge	8000b560 <_dtoa_r+0xb20>
8000b54e:	00 9b       	mov	r11,r0
8000b550:	30 09       	mov	r9,0
8000b552:	30 aa       	mov	r10,10
8000b554:	0e 9c       	mov	r12,r7
8000b556:	2f f6       	sub	r6,-1
8000b558:	e0 a0 07 04 	rcall	8000c360 <__multadd>
8000b55c:	18 90       	mov	r0,r12
8000b55e:	cf 0b       	rjmp	8000b53e <_dtoa_r+0xafe>
8000b560:	08 96       	mov	r6,r4
8000b562:	30 0b       	mov	r11,0
8000b564:	06 94       	mov	r4,r3
8000b566:	50 4b       	stdsp	sp[0x10],r11
8000b568:	00 93       	mov	r3,r0
8000b56a:	18 90       	mov	r0,r12
8000b56c:	c0 28       	rjmp	8000b570 <_dtoa_r+0xb30>
8000b56e:	40 26       	lddsp	r6,sp[0x8]
8000b570:	06 9b       	mov	r11,r3
8000b572:	30 1a       	mov	r10,1
8000b574:	0e 9c       	mov	r12,r7
8000b576:	e0 a0 06 29 	rcall	8000c1c8 <__lshift>
8000b57a:	04 9b       	mov	r11,r2
8000b57c:	18 93       	mov	r3,r12
8000b57e:	e0 a0 05 02 	rcall	8000bf82 <__mcmp>
8000b582:	e0 89 00 12 	brgt	8000b5a6 <_dtoa_r+0xb66>
8000b586:	c1 b1       	brne	8000b5bc <_dtoa_r+0xb7c>
8000b588:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000b58c:	c0 d1       	brne	8000b5a6 <_dtoa_r+0xb66>
8000b58e:	c1 78       	rjmp	8000b5bc <_dtoa_r+0xb7c>
8000b590:	40 89       	lddsp	r9,sp[0x20]
8000b592:	12 38       	cp.w	r8,r9
8000b594:	c0 30       	breq	8000b59a <_dtoa_r+0xb5a>
8000b596:	10 95       	mov	r5,r8
8000b598:	c0 88       	rjmp	8000b5a8 <_dtoa_r+0xb68>
8000b59a:	2f f6       	sub	r6,-1
8000b59c:	50 66       	stdsp	sp[0x18],r6
8000b59e:	33 18       	mov	r8,49
8000b5a0:	40 8c       	lddsp	r12,sp[0x20]
8000b5a2:	b8 88       	st.b	r12[0x0],r8
8000b5a4:	c1 38       	rjmp	8000b5ca <_dtoa_r+0xb8a>
8000b5a6:	33 9a       	mov	r10,57
8000b5a8:	0a 98       	mov	r8,r5
8000b5aa:	11 79       	ld.ub	r9,--r8
8000b5ac:	f4 09 18 00 	cp.b	r9,r10
8000b5b0:	cf 00       	breq	8000b590 <_dtoa_r+0xb50>
8000b5b2:	2f f9       	sub	r9,-1
8000b5b4:	b0 89       	st.b	r8[0x0],r9
8000b5b6:	c0 98       	rjmp	8000b5c8 <_dtoa_r+0xb88>
8000b5b8:	10 95       	mov	r5,r8
8000b5ba:	c0 28       	rjmp	8000b5be <_dtoa_r+0xb7e>
8000b5bc:	33 09       	mov	r9,48
8000b5be:	0a 98       	mov	r8,r5
8000b5c0:	11 7a       	ld.ub	r10,--r8
8000b5c2:	f2 0a 18 00 	cp.b	r10,r9
8000b5c6:	cf 90       	breq	8000b5b8 <_dtoa_r+0xb78>
8000b5c8:	50 66       	stdsp	sp[0x18],r6
8000b5ca:	04 9b       	mov	r11,r2
8000b5cc:	0e 9c       	mov	r12,r7
8000b5ce:	e0 a0 04 f3 	rcall	8000bfb4 <_Bfree>
8000b5d2:	58 04       	cp.w	r4,0
8000b5d4:	c1 20       	breq	8000b5f8 <_dtoa_r+0xbb8>
8000b5d6:	40 4b       	lddsp	r11,sp[0x10]
8000b5d8:	08 3b       	cp.w	r11,r4
8000b5da:	5f 19       	srne	r9
8000b5dc:	58 0b       	cp.w	r11,0
8000b5de:	5f 18       	srne	r8
8000b5e0:	f3 e8 00 08 	and	r8,r9,r8
8000b5e4:	c0 40       	breq	8000b5ec <_dtoa_r+0xbac>
8000b5e6:	0e 9c       	mov	r12,r7
8000b5e8:	e0 a0 04 e6 	rcall	8000bfb4 <_Bfree>
8000b5ec:	08 9b       	mov	r11,r4
8000b5ee:	0e 9c       	mov	r12,r7
8000b5f0:	e0 a0 04 e2 	rcall	8000bfb4 <_Bfree>
8000b5f4:	c0 28       	rjmp	8000b5f8 <_dtoa_r+0xbb8>
8000b5f6:	50 66       	stdsp	sp[0x18],r6
8000b5f8:	0e 9c       	mov	r12,r7
8000b5fa:	06 9b       	mov	r11,r3
8000b5fc:	e0 a0 04 dc 	rcall	8000bfb4 <_Bfree>
8000b600:	30 08       	mov	r8,0
8000b602:	aa 88       	st.b	r5[0x0],r8
8000b604:	40 68       	lddsp	r8,sp[0x18]
8000b606:	41 5a       	lddsp	r10,sp[0x54]
8000b608:	2f f8       	sub	r8,-1
8000b60a:	41 29       	lddsp	r9,sp[0x48]
8000b60c:	95 08       	st.w	r10[0x0],r8
8000b60e:	40 8c       	lddsp	r12,sp[0x20]
8000b610:	58 09       	cp.w	r9,0
8000b612:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000b616:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000b61a:	2e 6d       	sub	sp,-104
8000b61c:	d8 32       	popm	r0-r7,pc
8000b61e:	d7 03       	nop

8000b620 <__errno>:
8000b620:	e0 68 05 34 	mov	r8,1332
8000b624:	70 0c       	ld.w	r12,r8[0x0]
8000b626:	2f 4c       	sub	r12,-12
8000b628:	5e fc       	retal	r12
8000b62a:	d7 03       	nop

8000b62c <_fflush_r>:
8000b62c:	d4 21       	pushm	r4-r7,lr
8000b62e:	16 97       	mov	r7,r11
8000b630:	18 96       	mov	r6,r12
8000b632:	76 48       	ld.w	r8,r11[0x10]
8000b634:	58 08       	cp.w	r8,0
8000b636:	c7 c0       	breq	8000b72e <_fflush_r+0x102>
8000b638:	58 0c       	cp.w	r12,0
8000b63a:	c0 50       	breq	8000b644 <_fflush_r+0x18>
8000b63c:	78 68       	ld.w	r8,r12[0x18]
8000b63e:	58 08       	cp.w	r8,0
8000b640:	c0 21       	brne	8000b644 <_fflush_r+0x18>
8000b642:	cd 1c       	rcall	8000b7e4 <__sinit>
8000b644:	4b b8       	lddpc	r8,8000b730 <_fflush_r+0x104>
8000b646:	10 37       	cp.w	r7,r8
8000b648:	c0 31       	brne	8000b64e <_fflush_r+0x22>
8000b64a:	6c 07       	ld.w	r7,r6[0x0]
8000b64c:	c0 a8       	rjmp	8000b660 <_fflush_r+0x34>
8000b64e:	4b a8       	lddpc	r8,8000b734 <_fflush_r+0x108>
8000b650:	10 37       	cp.w	r7,r8
8000b652:	c0 31       	brne	8000b658 <_fflush_r+0x2c>
8000b654:	6c 17       	ld.w	r7,r6[0x4]
8000b656:	c0 58       	rjmp	8000b660 <_fflush_r+0x34>
8000b658:	4b 88       	lddpc	r8,8000b738 <_fflush_r+0x10c>
8000b65a:	10 37       	cp.w	r7,r8
8000b65c:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000b660:	8e 6a       	ld.sh	r10,r7[0xc]
8000b662:	14 98       	mov	r8,r10
8000b664:	ed ba 00 03 	bld	r10,0x3
8000b668:	c4 20       	breq	8000b6ec <_fflush_r+0xc0>
8000b66a:	ab ba       	sbr	r10,0xb
8000b66c:	ae 6a       	st.h	r7[0xc],r10
8000b66e:	6e 18       	ld.w	r8,r7[0x4]
8000b670:	58 08       	cp.w	r8,0
8000b672:	e0 89 00 06 	brgt	8000b67e <_fflush_r+0x52>
8000b676:	6f 08       	ld.w	r8,r7[0x40]
8000b678:	58 08       	cp.w	r8,0
8000b67a:	e0 8a 00 5a 	brle	8000b72e <_fflush_r+0x102>
8000b67e:	6e b8       	ld.w	r8,r7[0x2c]
8000b680:	58 08       	cp.w	r8,0
8000b682:	c5 60       	breq	8000b72e <_fflush_r+0x102>
8000b684:	e2 1a 10 00 	andl	r10,0x1000,COH
8000b688:	c0 30       	breq	8000b68e <_fflush_r+0x62>
8000b68a:	6f 55       	ld.w	r5,r7[0x54]
8000b68c:	c0 f8       	rjmp	8000b6aa <_fflush_r+0x7e>
8000b68e:	30 19       	mov	r9,1
8000b690:	6e 8b       	ld.w	r11,r7[0x20]
8000b692:	0c 9c       	mov	r12,r6
8000b694:	5d 18       	icall	r8
8000b696:	18 95       	mov	r5,r12
8000b698:	5b fc       	cp.w	r12,-1
8000b69a:	c0 81       	brne	8000b6aa <_fflush_r+0x7e>
8000b69c:	6c 38       	ld.w	r8,r6[0xc]
8000b69e:	59 d8       	cp.w	r8,29
8000b6a0:	c4 70       	breq	8000b72e <_fflush_r+0x102>
8000b6a2:	8e 68       	ld.sh	r8,r7[0xc]
8000b6a4:	a7 a8       	sbr	r8,0x6
8000b6a6:	ae 68       	st.h	r7[0xc],r8
8000b6a8:	d8 22       	popm	r4-r7,pc
8000b6aa:	8e 68       	ld.sh	r8,r7[0xc]
8000b6ac:	ed b8 00 02 	bld	r8,0x2
8000b6b0:	c0 91       	brne	8000b6c2 <_fflush_r+0x96>
8000b6b2:	6e 18       	ld.w	r8,r7[0x4]
8000b6b4:	10 15       	sub	r5,r8
8000b6b6:	6e d8       	ld.w	r8,r7[0x34]
8000b6b8:	58 08       	cp.w	r8,0
8000b6ba:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000b6be:	eb d8 e1 15 	subne	r5,r5,r8
8000b6c2:	6e b8       	ld.w	r8,r7[0x2c]
8000b6c4:	0c 9c       	mov	r12,r6
8000b6c6:	30 09       	mov	r9,0
8000b6c8:	0a 9a       	mov	r10,r5
8000b6ca:	6e 8b       	ld.w	r11,r7[0x20]
8000b6cc:	5d 18       	icall	r8
8000b6ce:	8e 68       	ld.sh	r8,r7[0xc]
8000b6d0:	0a 3c       	cp.w	r12,r5
8000b6d2:	c2 61       	brne	8000b71e <_fflush_r+0xf2>
8000b6d4:	ab d8       	cbr	r8,0xb
8000b6d6:	30 0c       	mov	r12,0
8000b6d8:	6e 49       	ld.w	r9,r7[0x10]
8000b6da:	ae 68       	st.h	r7[0xc],r8
8000b6dc:	8f 1c       	st.w	r7[0x4],r12
8000b6de:	8f 09       	st.w	r7[0x0],r9
8000b6e0:	ed b8 00 0c 	bld	r8,0xc
8000b6e4:	c2 51       	brne	8000b72e <_fflush_r+0x102>
8000b6e6:	ef 45 00 54 	st.w	r7[84],r5
8000b6ea:	d8 22       	popm	r4-r7,pc
8000b6ec:	6e 45       	ld.w	r5,r7[0x10]
8000b6ee:	58 05       	cp.w	r5,0
8000b6f0:	c1 f0       	breq	8000b72e <_fflush_r+0x102>
8000b6f2:	6e 04       	ld.w	r4,r7[0x0]
8000b6f4:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000b6f8:	8f 05       	st.w	r7[0x0],r5
8000b6fa:	f9 b8 01 00 	movne	r8,0
8000b6fe:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000b702:	0a 14       	sub	r4,r5
8000b704:	8f 28       	st.w	r7[0x8],r8
8000b706:	c1 18       	rjmp	8000b728 <_fflush_r+0xfc>
8000b708:	08 99       	mov	r9,r4
8000b70a:	0a 9a       	mov	r10,r5
8000b70c:	6e a8       	ld.w	r8,r7[0x28]
8000b70e:	6e 8b       	ld.w	r11,r7[0x20]
8000b710:	0c 9c       	mov	r12,r6
8000b712:	5d 18       	icall	r8
8000b714:	18 14       	sub	r4,r12
8000b716:	58 0c       	cp.w	r12,0
8000b718:	e0 89 00 07 	brgt	8000b726 <_fflush_r+0xfa>
8000b71c:	8e 68       	ld.sh	r8,r7[0xc]
8000b71e:	a7 a8       	sbr	r8,0x6
8000b720:	3f fc       	mov	r12,-1
8000b722:	ae 68       	st.h	r7[0xc],r8
8000b724:	d8 22       	popm	r4-r7,pc
8000b726:	18 05       	add	r5,r12
8000b728:	58 04       	cp.w	r4,0
8000b72a:	fe 99 ff ef 	brgt	8000b708 <_fflush_r+0xdc>
8000b72e:	d8 2a       	popm	r4-r7,pc,r12=0
8000b730:	80 02       	ld.sh	r2,r0[0x0]
8000b732:	f9 20 80 02 	ld.sb	r0,r12[-32766]
8000b736:	f9 40 80 02 	st.w	r12[-32766],r0
8000b73a:	f9 60 5e fc 	st.b	r12[24316],r0

8000b73c <__sfp_lock_acquire>:
8000b73c:	5e fc       	retal	r12

8000b73e <__sfp_lock_release>:
8000b73e:	5e fc       	retal	r12

8000b740 <_cleanup_r>:
8000b740:	d4 01       	pushm	lr
8000b742:	fe cb f0 aa 	sub	r11,pc,-3926
8000b746:	e0 a0 02 f5 	rcall	8000bd30 <_fwalk>
8000b74a:	d8 02       	popm	pc

8000b74c <__sfmoreglue>:
8000b74c:	d4 21       	pushm	r4-r7,lr
8000b74e:	16 95       	mov	r5,r11
8000b750:	f6 06 10 5c 	mul	r6,r11,92
8000b754:	ec cb ff f4 	sub	r11,r6,-12
8000b758:	fe b0 e2 76 	rcall	80007c44 <_malloc_r>
8000b75c:	18 97       	mov	r7,r12
8000b75e:	c0 90       	breq	8000b770 <__sfmoreglue+0x24>
8000b760:	99 15       	st.w	r12[0x4],r5
8000b762:	30 0b       	mov	r11,0
8000b764:	2f 4c       	sub	r12,-12
8000b766:	0c 9a       	mov	r10,r6
8000b768:	8f 2c       	st.w	r7[0x8],r12
8000b76a:	8f 0b       	st.w	r7[0x0],r11
8000b76c:	fe b0 e5 26 	rcall	800081b8 <memset>
8000b770:	0e 9c       	mov	r12,r7
8000b772:	d8 22       	popm	r4-r7,pc

8000b774 <__sfp>:
8000b774:	d4 21       	pushm	r4-r7,lr
8000b776:	49 b8       	lddpc	r8,8000b7e0 <__sfp+0x6c>
8000b778:	18 96       	mov	r6,r12
8000b77a:	70 07       	ld.w	r7,r8[0x0]
8000b77c:	6e 68       	ld.w	r8,r7[0x18]
8000b77e:	58 08       	cp.w	r8,0
8000b780:	c0 31       	brne	8000b786 <__sfp+0x12>
8000b782:	0e 9c       	mov	r12,r7
8000b784:	c3 0c       	rcall	8000b7e4 <__sinit>
8000b786:	ee c7 ff 28 	sub	r7,r7,-216
8000b78a:	30 05       	mov	r5,0
8000b78c:	6e 2c       	ld.w	r12,r7[0x8]
8000b78e:	6e 18       	ld.w	r8,r7[0x4]
8000b790:	c0 68       	rjmp	8000b79c <__sfp+0x28>
8000b792:	98 69       	ld.sh	r9,r12[0xc]
8000b794:	ea 09 19 00 	cp.h	r9,r5
8000b798:	c1 10       	breq	8000b7ba <__sfp+0x46>
8000b79a:	2a 4c       	sub	r12,-92
8000b79c:	20 18       	sub	r8,1
8000b79e:	cf a7       	brpl	8000b792 <__sfp+0x1e>
8000b7a0:	6e 08       	ld.w	r8,r7[0x0]
8000b7a2:	58 08       	cp.w	r8,0
8000b7a4:	c0 61       	brne	8000b7b0 <__sfp+0x3c>
8000b7a6:	30 4b       	mov	r11,4
8000b7a8:	0c 9c       	mov	r12,r6
8000b7aa:	cd 1f       	rcall	8000b74c <__sfmoreglue>
8000b7ac:	8f 0c       	st.w	r7[0x0],r12
8000b7ae:	c0 30       	breq	8000b7b4 <__sfp+0x40>
8000b7b0:	6e 07       	ld.w	r7,r7[0x0]
8000b7b2:	ce db       	rjmp	8000b78c <__sfp+0x18>
8000b7b4:	30 c8       	mov	r8,12
8000b7b6:	8d 38       	st.w	r6[0xc],r8
8000b7b8:	d8 22       	popm	r4-r7,pc
8000b7ba:	30 08       	mov	r8,0
8000b7bc:	f9 48 00 4c 	st.w	r12[76],r8
8000b7c0:	99 08       	st.w	r12[0x0],r8
8000b7c2:	99 28       	st.w	r12[0x8],r8
8000b7c4:	99 18       	st.w	r12[0x4],r8
8000b7c6:	99 48       	st.w	r12[0x10],r8
8000b7c8:	99 58       	st.w	r12[0x14],r8
8000b7ca:	99 68       	st.w	r12[0x18],r8
8000b7cc:	99 d8       	st.w	r12[0x34],r8
8000b7ce:	99 e8       	st.w	r12[0x38],r8
8000b7d0:	f9 48 00 48 	st.w	r12[72],r8
8000b7d4:	3f f8       	mov	r8,-1
8000b7d6:	b8 78       	st.h	r12[0xe],r8
8000b7d8:	30 18       	mov	r8,1
8000b7da:	b8 68       	st.h	r12[0xc],r8
8000b7dc:	d8 22       	popm	r4-r7,pc
8000b7de:	d7 03       	nop
8000b7e0:	80 02       	ld.sh	r2,r0[0x0]
8000b7e2:	f9 84       	*unknown*

8000b7e4 <__sinit>:
8000b7e4:	d4 21       	pushm	r4-r7,lr
8000b7e6:	18 96       	mov	r6,r12
8000b7e8:	78 67       	ld.w	r7,r12[0x18]
8000b7ea:	58 07       	cp.w	r7,0
8000b7ec:	c4 91       	brne	8000b87e <__sinit+0x9a>
8000b7ee:	fe c8 00 ae 	sub	r8,pc,174
8000b7f2:	30 15       	mov	r5,1
8000b7f4:	99 a8       	st.w	r12[0x28],r8
8000b7f6:	f9 47 00 d8 	st.w	r12[216],r7
8000b7fa:	f9 47 00 dc 	st.w	r12[220],r7
8000b7fe:	f9 47 00 e0 	st.w	r12[224],r7
8000b802:	99 65       	st.w	r12[0x18],r5
8000b804:	cb 8f       	rcall	8000b774 <__sfp>
8000b806:	8d 0c       	st.w	r6[0x0],r12
8000b808:	0c 9c       	mov	r12,r6
8000b80a:	cb 5f       	rcall	8000b774 <__sfp>
8000b80c:	8d 1c       	st.w	r6[0x4],r12
8000b80e:	0c 9c       	mov	r12,r6
8000b810:	cb 2f       	rcall	8000b774 <__sfp>
8000b812:	6c 09       	ld.w	r9,r6[0x0]
8000b814:	30 48       	mov	r8,4
8000b816:	93 07       	st.w	r9[0x0],r7
8000b818:	b2 68       	st.h	r9[0xc],r8
8000b81a:	93 17       	st.w	r9[0x4],r7
8000b81c:	93 27       	st.w	r9[0x8],r7
8000b81e:	6c 18       	ld.w	r8,r6[0x4]
8000b820:	b2 77       	st.h	r9[0xe],r7
8000b822:	93 47       	st.w	r9[0x10],r7
8000b824:	93 57       	st.w	r9[0x14],r7
8000b826:	93 67       	st.w	r9[0x18],r7
8000b828:	93 89       	st.w	r9[0x20],r9
8000b82a:	91 07       	st.w	r8[0x0],r7
8000b82c:	91 17       	st.w	r8[0x4],r7
8000b82e:	91 27       	st.w	r8[0x8],r7
8000b830:	fe ce f3 28 	sub	lr,pc,-3288
8000b834:	fe cb f3 58 	sub	r11,pc,-3240
8000b838:	93 9e       	st.w	r9[0x24],lr
8000b83a:	93 ab       	st.w	r9[0x28],r11
8000b83c:	fe ca f3 80 	sub	r10,pc,-3200
8000b840:	fe c4 f3 8c 	sub	r4,pc,-3188
8000b844:	93 ba       	st.w	r9[0x2c],r10
8000b846:	93 c4       	st.w	r9[0x30],r4
8000b848:	30 99       	mov	r9,9
8000b84a:	b0 69       	st.h	r8[0xc],r9
8000b84c:	b0 75       	st.h	r8[0xe],r5
8000b84e:	91 c4       	st.w	r8[0x30],r4
8000b850:	91 47       	st.w	r8[0x10],r7
8000b852:	91 57       	st.w	r8[0x14],r7
8000b854:	91 67       	st.w	r8[0x18],r7
8000b856:	91 88       	st.w	r8[0x20],r8
8000b858:	91 9e       	st.w	r8[0x24],lr
8000b85a:	91 ab       	st.w	r8[0x28],r11
8000b85c:	91 ba       	st.w	r8[0x2c],r10
8000b85e:	8d 2c       	st.w	r6[0x8],r12
8000b860:	31 28       	mov	r8,18
8000b862:	99 07       	st.w	r12[0x0],r7
8000b864:	b8 68       	st.h	r12[0xc],r8
8000b866:	99 17       	st.w	r12[0x4],r7
8000b868:	99 27       	st.w	r12[0x8],r7
8000b86a:	30 28       	mov	r8,2
8000b86c:	b8 78       	st.h	r12[0xe],r8
8000b86e:	99 c4       	st.w	r12[0x30],r4
8000b870:	99 67       	st.w	r12[0x18],r7
8000b872:	99 9e       	st.w	r12[0x24],lr
8000b874:	99 ab       	st.w	r12[0x28],r11
8000b876:	99 ba       	st.w	r12[0x2c],r10
8000b878:	99 47       	st.w	r12[0x10],r7
8000b87a:	99 57       	st.w	r12[0x14],r7
8000b87c:	99 8c       	st.w	r12[0x20],r12
8000b87e:	d8 22       	popm	r4-r7,pc

8000b880 <_malloc_trim_r>:
8000b880:	d4 21       	pushm	r4-r7,lr
8000b882:	16 95       	mov	r5,r11
8000b884:	18 97       	mov	r7,r12
8000b886:	fe b0 d3 43 	rcall	80005f0c <__malloc_lock>
8000b88a:	33 44       	mov	r4,52
8000b88c:	68 28       	ld.w	r8,r4[0x8]
8000b88e:	70 16       	ld.w	r6,r8[0x4]
8000b890:	e0 16 ff fc 	andl	r6,0xfffc
8000b894:	ec c8 ff 91 	sub	r8,r6,-111
8000b898:	f0 05 01 05 	sub	r5,r8,r5
8000b89c:	e0 15 ff 80 	andl	r5,0xff80
8000b8a0:	ea c5 00 80 	sub	r5,r5,128
8000b8a4:	e0 45 00 7f 	cp.w	r5,127
8000b8a8:	e0 8a 00 25 	brle	8000b8f2 <_malloc_trim_r+0x72>
8000b8ac:	30 0b       	mov	r11,0
8000b8ae:	0e 9c       	mov	r12,r7
8000b8b0:	fe b0 e5 ec 	rcall	80008488 <_sbrk_r>
8000b8b4:	68 28       	ld.w	r8,r4[0x8]
8000b8b6:	0c 08       	add	r8,r6
8000b8b8:	10 3c       	cp.w	r12,r8
8000b8ba:	c1 c1       	brne	8000b8f2 <_malloc_trim_r+0x72>
8000b8bc:	ea 0b 11 00 	rsub	r11,r5,0
8000b8c0:	0e 9c       	mov	r12,r7
8000b8c2:	fe b0 e5 e3 	rcall	80008488 <_sbrk_r>
8000b8c6:	5b fc       	cp.w	r12,-1
8000b8c8:	c1 91       	brne	8000b8fa <_malloc_trim_r+0x7a>
8000b8ca:	30 0b       	mov	r11,0
8000b8cc:	0e 9c       	mov	r12,r7
8000b8ce:	fe b0 e5 dd 	rcall	80008488 <_sbrk_r>
8000b8d2:	68 28       	ld.w	r8,r4[0x8]
8000b8d4:	f8 08 01 09 	sub	r9,r12,r8
8000b8d8:	58 f9       	cp.w	r9,15
8000b8da:	e0 8a 00 0c 	brle	8000b8f2 <_malloc_trim_r+0x72>
8000b8de:	a1 a9       	sbr	r9,0x0
8000b8e0:	91 19       	st.w	r8[0x4],r9
8000b8e2:	e0 68 04 40 	mov	r8,1088
8000b8e6:	70 09       	ld.w	r9,r8[0x0]
8000b8e8:	e0 68 07 e0 	mov	r8,2016
8000b8ec:	f8 09 01 09 	sub	r9,r12,r9
8000b8f0:	91 09       	st.w	r8[0x0],r9
8000b8f2:	0e 9c       	mov	r12,r7
8000b8f4:	fe b0 d3 12 	rcall	80005f18 <__malloc_unlock>
8000b8f8:	d8 2a       	popm	r4-r7,pc,r12=0
8000b8fa:	68 28       	ld.w	r8,r4[0x8]
8000b8fc:	0a 16       	sub	r6,r5
8000b8fe:	a1 a6       	sbr	r6,0x0
8000b900:	91 16       	st.w	r8[0x4],r6
8000b902:	e0 68 07 e0 	mov	r8,2016
8000b906:	70 09       	ld.w	r9,r8[0x0]
8000b908:	0a 19       	sub	r9,r5
8000b90a:	0e 9c       	mov	r12,r7
8000b90c:	91 09       	st.w	r8[0x0],r9
8000b90e:	fe b0 d3 05 	rcall	80005f18 <__malloc_unlock>
8000b912:	da 2a       	popm	r4-r7,pc,r12=1

8000b914 <_free_r>:
8000b914:	d4 21       	pushm	r4-r7,lr
8000b916:	16 96       	mov	r6,r11
8000b918:	18 97       	mov	r7,r12
8000b91a:	58 0b       	cp.w	r11,0
8000b91c:	e0 80 00 be 	breq	8000ba98 <_free_r+0x184>
8000b920:	fe b0 d2 f6 	rcall	80005f0c <__malloc_lock>
8000b924:	20 86       	sub	r6,8
8000b926:	33 4a       	mov	r10,52
8000b928:	6c 18       	ld.w	r8,r6[0x4]
8000b92a:	74 2e       	ld.w	lr,r10[0x8]
8000b92c:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000b930:	a1 c8       	cbr	r8,0x0
8000b932:	ec 08 00 09 	add	r9,r6,r8
8000b936:	72 1b       	ld.w	r11,r9[0x4]
8000b938:	e0 1b ff fc 	andl	r11,0xfffc
8000b93c:	1c 39       	cp.w	r9,lr
8000b93e:	c1 e1       	brne	8000b97a <_free_r+0x66>
8000b940:	f6 08 00 08 	add	r8,r11,r8
8000b944:	58 0c       	cp.w	r12,0
8000b946:	c0 81       	brne	8000b956 <_free_r+0x42>
8000b948:	6c 09       	ld.w	r9,r6[0x0]
8000b94a:	12 16       	sub	r6,r9
8000b94c:	12 08       	add	r8,r9
8000b94e:	6c 3b       	ld.w	r11,r6[0xc]
8000b950:	6c 29       	ld.w	r9,r6[0x8]
8000b952:	97 29       	st.w	r11[0x8],r9
8000b954:	93 3b       	st.w	r9[0xc],r11
8000b956:	10 99       	mov	r9,r8
8000b958:	95 26       	st.w	r10[0x8],r6
8000b95a:	a1 a9       	sbr	r9,0x0
8000b95c:	8d 19       	st.w	r6[0x4],r9
8000b95e:	e0 69 04 3c 	mov	r9,1084
8000b962:	72 09       	ld.w	r9,r9[0x0]
8000b964:	12 38       	cp.w	r8,r9
8000b966:	c0 63       	brcs	8000b972 <_free_r+0x5e>
8000b968:	e0 68 07 dc 	mov	r8,2012
8000b96c:	0e 9c       	mov	r12,r7
8000b96e:	70 0b       	ld.w	r11,r8[0x0]
8000b970:	c8 8f       	rcall	8000b880 <_malloc_trim_r>
8000b972:	0e 9c       	mov	r12,r7
8000b974:	fe b0 d2 d2 	rcall	80005f18 <__malloc_unlock>
8000b978:	d8 22       	popm	r4-r7,pc
8000b97a:	93 1b       	st.w	r9[0x4],r11
8000b97c:	58 0c       	cp.w	r12,0
8000b97e:	c0 30       	breq	8000b984 <_free_r+0x70>
8000b980:	30 0c       	mov	r12,0
8000b982:	c1 08       	rjmp	8000b9a2 <_free_r+0x8e>
8000b984:	6c 0e       	ld.w	lr,r6[0x0]
8000b986:	f4 c5 ff f8 	sub	r5,r10,-8
8000b98a:	1c 16       	sub	r6,lr
8000b98c:	1c 08       	add	r8,lr
8000b98e:	6c 2e       	ld.w	lr,r6[0x8]
8000b990:	0a 3e       	cp.w	lr,r5
8000b992:	f9 bc 00 01 	moveq	r12,1
8000b996:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000b99a:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000b99e:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000b9a2:	f2 0b 00 0e 	add	lr,r9,r11
8000b9a6:	7c 1e       	ld.w	lr,lr[0x4]
8000b9a8:	ed be 00 00 	bld	lr,0x0
8000b9ac:	c1 30       	breq	8000b9d2 <_free_r+0xbe>
8000b9ae:	16 08       	add	r8,r11
8000b9b0:	58 0c       	cp.w	r12,0
8000b9b2:	c0 c1       	brne	8000b9ca <_free_r+0xb6>
8000b9b4:	33 4e       	mov	lr,52
8000b9b6:	72 2b       	ld.w	r11,r9[0x8]
8000b9b8:	2f 8e       	sub	lr,-8
8000b9ba:	1c 3b       	cp.w	r11,lr
8000b9bc:	c0 71       	brne	8000b9ca <_free_r+0xb6>
8000b9be:	97 36       	st.w	r11[0xc],r6
8000b9c0:	97 26       	st.w	r11[0x8],r6
8000b9c2:	8d 2b       	st.w	r6[0x8],r11
8000b9c4:	8d 3b       	st.w	r6[0xc],r11
8000b9c6:	30 1c       	mov	r12,1
8000b9c8:	c0 58       	rjmp	8000b9d2 <_free_r+0xbe>
8000b9ca:	72 2b       	ld.w	r11,r9[0x8]
8000b9cc:	72 39       	ld.w	r9,r9[0xc]
8000b9ce:	93 2b       	st.w	r9[0x8],r11
8000b9d0:	97 39       	st.w	r11[0xc],r9
8000b9d2:	10 99       	mov	r9,r8
8000b9d4:	ec 08 09 08 	st.w	r6[r8],r8
8000b9d8:	a1 a9       	sbr	r9,0x0
8000b9da:	8d 19       	st.w	r6[0x4],r9
8000b9dc:	58 0c       	cp.w	r12,0
8000b9de:	c5 a1       	brne	8000ba92 <_free_r+0x17e>
8000b9e0:	e0 48 01 ff 	cp.w	r8,511
8000b9e4:	e0 8b 00 13 	brhi	8000ba0a <_free_r+0xf6>
8000b9e8:	a3 98       	lsr	r8,0x3
8000b9ea:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000b9ee:	72 2b       	ld.w	r11,r9[0x8]
8000b9f0:	8d 39       	st.w	r6[0xc],r9
8000b9f2:	8d 2b       	st.w	r6[0x8],r11
8000b9f4:	97 36       	st.w	r11[0xc],r6
8000b9f6:	93 26       	st.w	r9[0x8],r6
8000b9f8:	a3 48       	asr	r8,0x2
8000b9fa:	74 19       	ld.w	r9,r10[0x4]
8000b9fc:	30 1b       	mov	r11,1
8000b9fe:	f6 08 09 48 	lsl	r8,r11,r8
8000ba02:	f3 e8 10 08 	or	r8,r9,r8
8000ba06:	95 18       	st.w	r10[0x4],r8
8000ba08:	c4 58       	rjmp	8000ba92 <_free_r+0x17e>
8000ba0a:	f0 0b 16 09 	lsr	r11,r8,0x9
8000ba0e:	58 4b       	cp.w	r11,4
8000ba10:	e0 8b 00 06 	brhi	8000ba1c <_free_r+0x108>
8000ba14:	f0 0b 16 06 	lsr	r11,r8,0x6
8000ba18:	2c 8b       	sub	r11,-56
8000ba1a:	c2 08       	rjmp	8000ba5a <_free_r+0x146>
8000ba1c:	59 4b       	cp.w	r11,20
8000ba1e:	e0 8b 00 04 	brhi	8000ba26 <_free_r+0x112>
8000ba22:	2a 5b       	sub	r11,-91
8000ba24:	c1 b8       	rjmp	8000ba5a <_free_r+0x146>
8000ba26:	e0 4b 00 54 	cp.w	r11,84
8000ba2a:	e0 8b 00 06 	brhi	8000ba36 <_free_r+0x122>
8000ba2e:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000ba32:	29 2b       	sub	r11,-110
8000ba34:	c1 38       	rjmp	8000ba5a <_free_r+0x146>
8000ba36:	e0 4b 01 54 	cp.w	r11,340
8000ba3a:	e0 8b 00 06 	brhi	8000ba46 <_free_r+0x132>
8000ba3e:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000ba42:	28 9b       	sub	r11,-119
8000ba44:	c0 b8       	rjmp	8000ba5a <_free_r+0x146>
8000ba46:	e0 4b 05 54 	cp.w	r11,1364
8000ba4a:	e0 88 00 05 	brls	8000ba54 <_free_r+0x140>
8000ba4e:	37 eb       	mov	r11,126
8000ba50:	c0 58       	rjmp	8000ba5a <_free_r+0x146>
8000ba52:	d7 03       	nop
8000ba54:	f0 0b 16 12 	lsr	r11,r8,0x12
8000ba58:	28 4b       	sub	r11,-124
8000ba5a:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000ba5e:	78 29       	ld.w	r9,r12[0x8]
8000ba60:	18 39       	cp.w	r9,r12
8000ba62:	c0 e1       	brne	8000ba7e <_free_r+0x16a>
8000ba64:	74 18       	ld.w	r8,r10[0x4]
8000ba66:	a3 4b       	asr	r11,0x2
8000ba68:	30 1c       	mov	r12,1
8000ba6a:	f8 0b 09 4b 	lsl	r11,r12,r11
8000ba6e:	f1 eb 10 0b 	or	r11,r8,r11
8000ba72:	12 98       	mov	r8,r9
8000ba74:	95 1b       	st.w	r10[0x4],r11
8000ba76:	c0 a8       	rjmp	8000ba8a <_free_r+0x176>
8000ba78:	72 29       	ld.w	r9,r9[0x8]
8000ba7a:	18 39       	cp.w	r9,r12
8000ba7c:	c0 60       	breq	8000ba88 <_free_r+0x174>
8000ba7e:	72 1a       	ld.w	r10,r9[0x4]
8000ba80:	e0 1a ff fc 	andl	r10,0xfffc
8000ba84:	14 38       	cp.w	r8,r10
8000ba86:	cf 93       	brcs	8000ba78 <_free_r+0x164>
8000ba88:	72 38       	ld.w	r8,r9[0xc]
8000ba8a:	8d 38       	st.w	r6[0xc],r8
8000ba8c:	8d 29       	st.w	r6[0x8],r9
8000ba8e:	93 36       	st.w	r9[0xc],r6
8000ba90:	91 26       	st.w	r8[0x8],r6
8000ba92:	0e 9c       	mov	r12,r7
8000ba94:	fe b0 d2 42 	rcall	80005f18 <__malloc_unlock>
8000ba98:	d8 22       	popm	r4-r7,pc
8000ba9a:	d7 03       	nop

8000ba9c <__sfvwrite_r>:
8000ba9c:	d4 31       	pushm	r0-r7,lr
8000ba9e:	20 3d       	sub	sp,12
8000baa0:	14 94       	mov	r4,r10
8000baa2:	18 95       	mov	r5,r12
8000baa4:	16 97       	mov	r7,r11
8000baa6:	74 28       	ld.w	r8,r10[0x8]
8000baa8:	58 08       	cp.w	r8,0
8000baaa:	e0 80 01 40 	breq	8000bd2a <__sfvwrite_r+0x28e>
8000baae:	96 68       	ld.sh	r8,r11[0xc]
8000bab0:	ed b8 00 03 	bld	r8,0x3
8000bab4:	c0 41       	brne	8000babc <__sfvwrite_r+0x20>
8000bab6:	76 48       	ld.w	r8,r11[0x10]
8000bab8:	58 08       	cp.w	r8,0
8000baba:	c0 c1       	brne	8000bad2 <__sfvwrite_r+0x36>
8000babc:	0e 9b       	mov	r11,r7
8000babe:	0a 9c       	mov	r12,r5
8000bac0:	fe b0 f6 c0 	rcall	8000a840 <__swsetup_r>
8000bac4:	c0 70       	breq	8000bad2 <__sfvwrite_r+0x36>
8000bac6:	8e 68       	ld.sh	r8,r7[0xc]
8000bac8:	a7 a8       	sbr	r8,0x6
8000baca:	ae 68       	st.h	r7[0xc],r8
8000bacc:	30 98       	mov	r8,9
8000bace:	8b 38       	st.w	r5[0xc],r8
8000bad0:	c2 b9       	rjmp	8000bd26 <__sfvwrite_r+0x28a>
8000bad2:	8e 63       	ld.sh	r3,r7[0xc]
8000bad4:	68 00       	ld.w	r0,r4[0x0]
8000bad6:	06 96       	mov	r6,r3
8000bad8:	e2 16 00 02 	andl	r6,0x2,COH
8000badc:	c2 10       	breq	8000bb1e <__sfvwrite_r+0x82>
8000bade:	30 03       	mov	r3,0
8000bae0:	e0 62 04 00 	mov	r2,1024
8000bae4:	06 96       	mov	r6,r3
8000bae6:	c0 48       	rjmp	8000baee <__sfvwrite_r+0x52>
8000bae8:	60 03       	ld.w	r3,r0[0x0]
8000baea:	60 16       	ld.w	r6,r0[0x4]
8000baec:	2f 80       	sub	r0,-8
8000baee:	58 06       	cp.w	r6,0
8000baf0:	cf c0       	breq	8000bae8 <__sfvwrite_r+0x4c>
8000baf2:	e0 46 04 00 	cp.w	r6,1024
8000baf6:	ec 09 17 80 	movls	r9,r6
8000bafa:	e4 09 17 b0 	movhi	r9,r2
8000bafe:	06 9a       	mov	r10,r3
8000bb00:	6e a8       	ld.w	r8,r7[0x28]
8000bb02:	6e 8b       	ld.w	r11,r7[0x20]
8000bb04:	0a 9c       	mov	r12,r5
8000bb06:	5d 18       	icall	r8
8000bb08:	18 16       	sub	r6,r12
8000bb0a:	58 0c       	cp.w	r12,0
8000bb0c:	e0 8a 01 0a 	brle	8000bd20 <__sfvwrite_r+0x284>
8000bb10:	68 28       	ld.w	r8,r4[0x8]
8000bb12:	18 18       	sub	r8,r12
8000bb14:	89 28       	st.w	r4[0x8],r8
8000bb16:	e0 80 01 0a 	breq	8000bd2a <__sfvwrite_r+0x28e>
8000bb1a:	18 03       	add	r3,r12
8000bb1c:	ce 9b       	rjmp	8000baee <__sfvwrite_r+0x52>
8000bb1e:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000bb22:	c0 70       	breq	8000bb30 <__sfvwrite_r+0x94>
8000bb24:	50 06       	stdsp	sp[0x0],r6
8000bb26:	0c 93       	mov	r3,r6
8000bb28:	0c 91       	mov	r1,r6
8000bb2a:	50 15       	stdsp	sp[0x4],r5
8000bb2c:	08 92       	mov	r2,r4
8000bb2e:	c9 c8       	rjmp	8000bc66 <__sfvwrite_r+0x1ca>
8000bb30:	06 96       	mov	r6,r3
8000bb32:	08 91       	mov	r1,r4
8000bb34:	c0 48       	rjmp	8000bb3c <__sfvwrite_r+0xa0>
8000bb36:	60 03       	ld.w	r3,r0[0x0]
8000bb38:	60 16       	ld.w	r6,r0[0x4]
8000bb3a:	2f 80       	sub	r0,-8
8000bb3c:	58 06       	cp.w	r6,0
8000bb3e:	cf c0       	breq	8000bb36 <__sfvwrite_r+0x9a>
8000bb40:	8e 68       	ld.sh	r8,r7[0xc]
8000bb42:	6e 24       	ld.w	r4,r7[0x8]
8000bb44:	10 99       	mov	r9,r8
8000bb46:	e2 19 02 00 	andl	r9,0x200,COH
8000bb4a:	c5 50       	breq	8000bbf4 <__sfvwrite_r+0x158>
8000bb4c:	08 36       	cp.w	r6,r4
8000bb4e:	c4 43       	brcs	8000bbd6 <__sfvwrite_r+0x13a>
8000bb50:	10 99       	mov	r9,r8
8000bb52:	e2 19 04 80 	andl	r9,0x480,COH
8000bb56:	c4 00       	breq	8000bbd6 <__sfvwrite_r+0x13a>
8000bb58:	6e 4b       	ld.w	r11,r7[0x10]
8000bb5a:	6e 09       	ld.w	r9,r7[0x0]
8000bb5c:	16 19       	sub	r9,r11
8000bb5e:	50 09       	stdsp	sp[0x0],r9
8000bb60:	6e 59       	ld.w	r9,r7[0x14]
8000bb62:	10 9c       	mov	r12,r8
8000bb64:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000bb68:	30 28       	mov	r8,2
8000bb6a:	f4 08 0c 08 	divs	r8,r10,r8
8000bb6e:	fa e9 00 04 	st.d	sp[4],r8
8000bb72:	10 94       	mov	r4,r8
8000bb74:	40 09       	lddsp	r9,sp[0x0]
8000bb76:	e2 1c 04 00 	andl	r12,0x400,COH
8000bb7a:	2f f9       	sub	r9,-1
8000bb7c:	0c 09       	add	r9,r6
8000bb7e:	12 38       	cp.w	r8,r9
8000bb80:	f2 04 17 30 	movlo	r4,r9
8000bb84:	58 0c       	cp.w	r12,0
8000bb86:	c1 10       	breq	8000bba8 <__sfvwrite_r+0x10c>
8000bb88:	08 9b       	mov	r11,r4
8000bb8a:	0a 9c       	mov	r12,r5
8000bb8c:	fe b0 e0 5c 	rcall	80007c44 <_malloc_r>
8000bb90:	18 92       	mov	r2,r12
8000bb92:	c1 40       	breq	8000bbba <__sfvwrite_r+0x11e>
8000bb94:	40 0a       	lddsp	r10,sp[0x0]
8000bb96:	6e 4b       	ld.w	r11,r7[0x10]
8000bb98:	fe b0 e2 6c 	rcall	80008070 <memcpy>
8000bb9c:	8e 68       	ld.sh	r8,r7[0xc]
8000bb9e:	e0 18 fb 7f 	andl	r8,0xfb7f
8000bba2:	a7 b8       	sbr	r8,0x7
8000bba4:	ae 68       	st.h	r7[0xc],r8
8000bba6:	c0 d8       	rjmp	8000bbc0 <__sfvwrite_r+0x124>
8000bba8:	08 9a       	mov	r10,r4
8000bbaa:	0a 9c       	mov	r12,r5
8000bbac:	fe b0 e3 0e 	rcall	800081c8 <_realloc_r>
8000bbb0:	18 92       	mov	r2,r12
8000bbb2:	c0 71       	brne	8000bbc0 <__sfvwrite_r+0x124>
8000bbb4:	6e 4b       	ld.w	r11,r7[0x10]
8000bbb6:	0a 9c       	mov	r12,r5
8000bbb8:	ca ee       	rcall	8000b914 <_free_r>
8000bbba:	30 c8       	mov	r8,12
8000bbbc:	8b 38       	st.w	r5[0xc],r8
8000bbbe:	cb 18       	rjmp	8000bd20 <__sfvwrite_r+0x284>
8000bbc0:	40 0a       	lddsp	r10,sp[0x0]
8000bbc2:	40 09       	lddsp	r9,sp[0x0]
8000bbc4:	e8 0a 01 0a 	sub	r10,r4,r10
8000bbc8:	e4 09 00 08 	add	r8,r2,r9
8000bbcc:	8f 54       	st.w	r7[0x14],r4
8000bbce:	8f 2a       	st.w	r7[0x8],r10
8000bbd0:	8f 08       	st.w	r7[0x0],r8
8000bbd2:	8f 42       	st.w	r7[0x10],r2
8000bbd4:	0c 94       	mov	r4,r6
8000bbd6:	08 36       	cp.w	r6,r4
8000bbd8:	ec 04 17 30 	movlo	r4,r6
8000bbdc:	06 9b       	mov	r11,r3
8000bbde:	08 9a       	mov	r10,r4
8000bbe0:	6e 0c       	ld.w	r12,r7[0x0]
8000bbe2:	c3 ad       	rcall	8000be56 <memmove>
8000bbe4:	6e 08       	ld.w	r8,r7[0x0]
8000bbe6:	08 08       	add	r8,r4
8000bbe8:	8f 08       	st.w	r7[0x0],r8
8000bbea:	6e 28       	ld.w	r8,r7[0x8]
8000bbec:	08 18       	sub	r8,r4
8000bbee:	0c 94       	mov	r4,r6
8000bbf0:	8f 28       	st.w	r7[0x8],r8
8000bbf2:	c2 e8       	rjmp	8000bc4e <__sfvwrite_r+0x1b2>
8000bbf4:	08 36       	cp.w	r6,r4
8000bbf6:	5f ba       	srhi	r10
8000bbf8:	6e 0c       	ld.w	r12,r7[0x0]
8000bbfa:	6e 48       	ld.w	r8,r7[0x10]
8000bbfc:	10 3c       	cp.w	r12,r8
8000bbfe:	5f b8       	srhi	r8
8000bc00:	f5 e8 00 08 	and	r8,r10,r8
8000bc04:	f2 08 18 00 	cp.b	r8,r9
8000bc08:	c0 d0       	breq	8000bc22 <__sfvwrite_r+0x186>
8000bc0a:	06 9b       	mov	r11,r3
8000bc0c:	08 9a       	mov	r10,r4
8000bc0e:	c2 4d       	rcall	8000be56 <memmove>
8000bc10:	6e 08       	ld.w	r8,r7[0x0]
8000bc12:	08 08       	add	r8,r4
8000bc14:	0e 9b       	mov	r11,r7
8000bc16:	8f 08       	st.w	r7[0x0],r8
8000bc18:	0a 9c       	mov	r12,r5
8000bc1a:	fe b0 fd 09 	rcall	8000b62c <_fflush_r>
8000bc1e:	c1 80       	breq	8000bc4e <__sfvwrite_r+0x1b2>
8000bc20:	c8 08       	rjmp	8000bd20 <__sfvwrite_r+0x284>
8000bc22:	6e 59       	ld.w	r9,r7[0x14]
8000bc24:	12 36       	cp.w	r6,r9
8000bc26:	c0 a3       	brcs	8000bc3a <__sfvwrite_r+0x19e>
8000bc28:	6e a8       	ld.w	r8,r7[0x28]
8000bc2a:	06 9a       	mov	r10,r3
8000bc2c:	6e 8b       	ld.w	r11,r7[0x20]
8000bc2e:	0a 9c       	mov	r12,r5
8000bc30:	5d 18       	icall	r8
8000bc32:	18 94       	mov	r4,r12
8000bc34:	e0 89 00 0d 	brgt	8000bc4e <__sfvwrite_r+0x1b2>
8000bc38:	c7 48       	rjmp	8000bd20 <__sfvwrite_r+0x284>
8000bc3a:	0c 9a       	mov	r10,r6
8000bc3c:	06 9b       	mov	r11,r3
8000bc3e:	c0 cd       	rcall	8000be56 <memmove>
8000bc40:	6e 08       	ld.w	r8,r7[0x0]
8000bc42:	0c 08       	add	r8,r6
8000bc44:	0c 94       	mov	r4,r6
8000bc46:	8f 08       	st.w	r7[0x0],r8
8000bc48:	6e 28       	ld.w	r8,r7[0x8]
8000bc4a:	0c 18       	sub	r8,r6
8000bc4c:	8f 28       	st.w	r7[0x8],r8
8000bc4e:	62 28       	ld.w	r8,r1[0x8]
8000bc50:	08 18       	sub	r8,r4
8000bc52:	83 28       	st.w	r1[0x8],r8
8000bc54:	c6 b0       	breq	8000bd2a <__sfvwrite_r+0x28e>
8000bc56:	08 16       	sub	r6,r4
8000bc58:	08 03       	add	r3,r4
8000bc5a:	c7 1b       	rjmp	8000bb3c <__sfvwrite_r+0xa0>
8000bc5c:	60 03       	ld.w	r3,r0[0x0]
8000bc5e:	60 11       	ld.w	r1,r0[0x4]
8000bc60:	30 08       	mov	r8,0
8000bc62:	2f 80       	sub	r0,-8
8000bc64:	50 08       	stdsp	sp[0x0],r8
8000bc66:	58 01       	cp.w	r1,0
8000bc68:	cf a0       	breq	8000bc5c <__sfvwrite_r+0x1c0>
8000bc6a:	40 0a       	lddsp	r10,sp[0x0]
8000bc6c:	58 0a       	cp.w	r10,0
8000bc6e:	c1 41       	brne	8000bc96 <__sfvwrite_r+0x1fa>
8000bc70:	e2 c6 ff ff 	sub	r6,r1,-1
8000bc74:	02 9a       	mov	r10,r1
8000bc76:	30 ab       	mov	r11,10
8000bc78:	06 9c       	mov	r12,r3
8000bc7a:	ce 3c       	rcall	8000be40 <memchr>
8000bc7c:	f8 c8 ff ff 	sub	r8,r12,-1
8000bc80:	58 0c       	cp.w	r12,0
8000bc82:	f1 d3 e1 16 	subne	r6,r8,r3
8000bc86:	f9 b9 01 01 	movne	r9,1
8000bc8a:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000bc8e:	f9 b8 00 01 	moveq	r8,1
8000bc92:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000bc96:	02 36       	cp.w	r6,r1
8000bc98:	ec 04 17 80 	movls	r4,r6
8000bc9c:	e2 04 17 b0 	movhi	r4,r1
8000bca0:	6e 59       	ld.w	r9,r7[0x14]
8000bca2:	6e 25       	ld.w	r5,r7[0x8]
8000bca4:	f2 05 00 05 	add	r5,r9,r5
8000bca8:	0a 34       	cp.w	r4,r5
8000bcaa:	5f 9a       	srgt	r10
8000bcac:	6e 0c       	ld.w	r12,r7[0x0]
8000bcae:	6e 48       	ld.w	r8,r7[0x10]
8000bcb0:	10 3c       	cp.w	r12,r8
8000bcb2:	5f b8       	srhi	r8
8000bcb4:	f5 e8 00 08 	and	r8,r10,r8
8000bcb8:	30 0a       	mov	r10,0
8000bcba:	f4 08 18 00 	cp.b	r8,r10
8000bcbe:	c0 d0       	breq	8000bcd8 <__sfvwrite_r+0x23c>
8000bcc0:	06 9b       	mov	r11,r3
8000bcc2:	0a 9a       	mov	r10,r5
8000bcc4:	cc 9c       	rcall	8000be56 <memmove>
8000bcc6:	6e 08       	ld.w	r8,r7[0x0]
8000bcc8:	0a 08       	add	r8,r5
8000bcca:	0e 9b       	mov	r11,r7
8000bccc:	8f 08       	st.w	r7[0x0],r8
8000bcce:	40 1c       	lddsp	r12,sp[0x4]
8000bcd0:	fe b0 fc ae 	rcall	8000b62c <_fflush_r>
8000bcd4:	c1 70       	breq	8000bd02 <__sfvwrite_r+0x266>
8000bcd6:	c2 58       	rjmp	8000bd20 <__sfvwrite_r+0x284>
8000bcd8:	12 34       	cp.w	r4,r9
8000bcda:	c0 a5       	brlt	8000bcee <__sfvwrite_r+0x252>
8000bcdc:	6e a8       	ld.w	r8,r7[0x28]
8000bcde:	06 9a       	mov	r10,r3
8000bce0:	6e 8b       	ld.w	r11,r7[0x20]
8000bce2:	40 1c       	lddsp	r12,sp[0x4]
8000bce4:	5d 18       	icall	r8
8000bce6:	18 95       	mov	r5,r12
8000bce8:	e0 89 00 0d 	brgt	8000bd02 <__sfvwrite_r+0x266>
8000bcec:	c1 a8       	rjmp	8000bd20 <__sfvwrite_r+0x284>
8000bcee:	08 9a       	mov	r10,r4
8000bcf0:	06 9b       	mov	r11,r3
8000bcf2:	cb 2c       	rcall	8000be56 <memmove>
8000bcf4:	6e 08       	ld.w	r8,r7[0x0]
8000bcf6:	08 08       	add	r8,r4
8000bcf8:	08 95       	mov	r5,r4
8000bcfa:	8f 08       	st.w	r7[0x0],r8
8000bcfc:	6e 28       	ld.w	r8,r7[0x8]
8000bcfe:	08 18       	sub	r8,r4
8000bd00:	8f 28       	st.w	r7[0x8],r8
8000bd02:	0a 16       	sub	r6,r5
8000bd04:	c0 71       	brne	8000bd12 <__sfvwrite_r+0x276>
8000bd06:	0e 9b       	mov	r11,r7
8000bd08:	40 1c       	lddsp	r12,sp[0x4]
8000bd0a:	fe b0 fc 91 	rcall	8000b62c <_fflush_r>
8000bd0e:	c0 91       	brne	8000bd20 <__sfvwrite_r+0x284>
8000bd10:	50 06       	stdsp	sp[0x0],r6
8000bd12:	64 28       	ld.w	r8,r2[0x8]
8000bd14:	0a 18       	sub	r8,r5
8000bd16:	85 28       	st.w	r2[0x8],r8
8000bd18:	c0 90       	breq	8000bd2a <__sfvwrite_r+0x28e>
8000bd1a:	0a 11       	sub	r1,r5
8000bd1c:	0a 03       	add	r3,r5
8000bd1e:	ca 4b       	rjmp	8000bc66 <__sfvwrite_r+0x1ca>
8000bd20:	8e 68       	ld.sh	r8,r7[0xc]
8000bd22:	a7 a8       	sbr	r8,0x6
8000bd24:	ae 68       	st.h	r7[0xc],r8
8000bd26:	3f fc       	mov	r12,-1
8000bd28:	c0 28       	rjmp	8000bd2c <__sfvwrite_r+0x290>
8000bd2a:	30 0c       	mov	r12,0
8000bd2c:	2f dd       	sub	sp,-12
8000bd2e:	d8 32       	popm	r0-r7,pc

8000bd30 <_fwalk>:
8000bd30:	d4 31       	pushm	r0-r7,lr
8000bd32:	30 05       	mov	r5,0
8000bd34:	16 91       	mov	r1,r11
8000bd36:	f8 c7 ff 28 	sub	r7,r12,-216
8000bd3a:	0a 92       	mov	r2,r5
8000bd3c:	fe b0 fd 00 	rcall	8000b73c <__sfp_lock_acquire>
8000bd40:	3f f3       	mov	r3,-1
8000bd42:	c1 68       	rjmp	8000bd6e <_fwalk+0x3e>
8000bd44:	6e 26       	ld.w	r6,r7[0x8]
8000bd46:	6e 14       	ld.w	r4,r7[0x4]
8000bd48:	2f 46       	sub	r6,-12
8000bd4a:	c0 c8       	rjmp	8000bd62 <_fwalk+0x32>
8000bd4c:	8c 08       	ld.sh	r8,r6[0x0]
8000bd4e:	e4 08 19 00 	cp.h	r8,r2
8000bd52:	c0 70       	breq	8000bd60 <_fwalk+0x30>
8000bd54:	8c 18       	ld.sh	r8,r6[0x2]
8000bd56:	e6 08 19 00 	cp.h	r8,r3
8000bd5a:	c0 30       	breq	8000bd60 <_fwalk+0x30>
8000bd5c:	5d 11       	icall	r1
8000bd5e:	18 45       	or	r5,r12
8000bd60:	2a 46       	sub	r6,-92
8000bd62:	20 14       	sub	r4,1
8000bd64:	ec cc 00 0c 	sub	r12,r6,12
8000bd68:	58 04       	cp.w	r4,0
8000bd6a:	cf 14       	brge	8000bd4c <_fwalk+0x1c>
8000bd6c:	6e 07       	ld.w	r7,r7[0x0]
8000bd6e:	58 07       	cp.w	r7,0
8000bd70:	ce a1       	brne	8000bd44 <_fwalk+0x14>
8000bd72:	fe b0 fc e6 	rcall	8000b73e <__sfp_lock_release>
8000bd76:	0a 9c       	mov	r12,r5
8000bd78:	d8 32       	popm	r0-r7,pc
8000bd7a:	d7 03       	nop

8000bd7c <_localeconv_r>:
8000bd7c:	48 1c       	lddpc	r12,8000bd80 <_localeconv_r+0x4>
8000bd7e:	5e fc       	retal	r12
8000bd80:	80 02       	ld.sh	r2,r0[0x0]
8000bd82:	f9 88       	*unknown*

8000bd84 <__smakebuf_r>:
8000bd84:	d4 21       	pushm	r4-r7,lr
8000bd86:	20 fd       	sub	sp,60
8000bd88:	96 68       	ld.sh	r8,r11[0xc]
8000bd8a:	16 97       	mov	r7,r11
8000bd8c:	18 96       	mov	r6,r12
8000bd8e:	e2 18 00 02 	andl	r8,0x2,COH
8000bd92:	c3 d1       	brne	8000be0c <__smakebuf_r+0x88>
8000bd94:	96 7b       	ld.sh	r11,r11[0xe]
8000bd96:	f0 0b 19 00 	cp.h	r11,r8
8000bd9a:	c0 55       	brlt	8000bda4 <__smakebuf_r+0x20>
8000bd9c:	1a 9a       	mov	r10,sp
8000bd9e:	e0 a0 04 85 	rcall	8000c6a8 <_fstat_r>
8000bda2:	c0 f4       	brge	8000bdc0 <__smakebuf_r+0x3c>
8000bda4:	8e 65       	ld.sh	r5,r7[0xc]
8000bda6:	0a 98       	mov	r8,r5
8000bda8:	ab b8       	sbr	r8,0xb
8000bdaa:	e2 15 00 80 	andl	r5,0x80,COH
8000bdae:	ae 68       	st.h	r7[0xc],r8
8000bdb0:	30 04       	mov	r4,0
8000bdb2:	e0 68 04 00 	mov	r8,1024
8000bdb6:	f9 b5 01 40 	movne	r5,64
8000bdba:	f0 05 17 00 	moveq	r5,r8
8000bdbe:	c1 c8       	rjmp	8000bdf6 <__smakebuf_r+0x72>
8000bdc0:	40 18       	lddsp	r8,sp[0x4]
8000bdc2:	e2 18 f0 00 	andl	r8,0xf000,COH
8000bdc6:	e0 48 20 00 	cp.w	r8,8192
8000bdca:	5f 04       	sreq	r4
8000bdcc:	e0 48 80 00 	cp.w	r8,32768
8000bdd0:	c0 e1       	brne	8000bdec <__smakebuf_r+0x68>
8000bdd2:	6e b9       	ld.w	r9,r7[0x2c]
8000bdd4:	fe c8 f9 18 	sub	r8,pc,-1768
8000bdd8:	10 39       	cp.w	r9,r8
8000bdda:	c0 91       	brne	8000bdec <__smakebuf_r+0x68>
8000bddc:	8e 68       	ld.sh	r8,r7[0xc]
8000bdde:	e0 65 04 00 	mov	r5,1024
8000bde2:	ab a8       	sbr	r8,0xa
8000bde4:	ef 45 00 50 	st.w	r7[80],r5
8000bde8:	ae 68       	st.h	r7[0xc],r8
8000bdea:	c0 68       	rjmp	8000bdf6 <__smakebuf_r+0x72>
8000bdec:	8e 68       	ld.sh	r8,r7[0xc]
8000bdee:	e0 65 04 00 	mov	r5,1024
8000bdf2:	ab b8       	sbr	r8,0xb
8000bdf4:	ae 68       	st.h	r7[0xc],r8
8000bdf6:	0a 9b       	mov	r11,r5
8000bdf8:	0c 9c       	mov	r12,r6
8000bdfa:	fe b0 df 25 	rcall	80007c44 <_malloc_r>
8000bdfe:	8e 68       	ld.sh	r8,r7[0xc]
8000be00:	c0 d1       	brne	8000be1a <__smakebuf_r+0x96>
8000be02:	ed b8 00 09 	bld	r8,0x9
8000be06:	c1 b0       	breq	8000be3c <__smakebuf_r+0xb8>
8000be08:	a1 b8       	sbr	r8,0x1
8000be0a:	ae 68       	st.h	r7[0xc],r8
8000be0c:	ee c8 ff b9 	sub	r8,r7,-71
8000be10:	8f 48       	st.w	r7[0x10],r8
8000be12:	8f 08       	st.w	r7[0x0],r8
8000be14:	30 18       	mov	r8,1
8000be16:	8f 58       	st.w	r7[0x14],r8
8000be18:	c1 28       	rjmp	8000be3c <__smakebuf_r+0xb8>
8000be1a:	a7 b8       	sbr	r8,0x7
8000be1c:	8f 4c       	st.w	r7[0x10],r12
8000be1e:	ae 68       	st.h	r7[0xc],r8
8000be20:	8f 55       	st.w	r7[0x14],r5
8000be22:	fe c8 06 e2 	sub	r8,pc,1762
8000be26:	8f 0c       	st.w	r7[0x0],r12
8000be28:	8d a8       	st.w	r6[0x28],r8
8000be2a:	58 04       	cp.w	r4,0
8000be2c:	c0 80       	breq	8000be3c <__smakebuf_r+0xb8>
8000be2e:	8e 7c       	ld.sh	r12,r7[0xe]
8000be30:	fe b0 e3 7e 	rcall	8000852c <isatty>
8000be34:	c0 40       	breq	8000be3c <__smakebuf_r+0xb8>
8000be36:	8e 68       	ld.sh	r8,r7[0xc]
8000be38:	a1 a8       	sbr	r8,0x0
8000be3a:	ae 68       	st.h	r7[0xc],r8
8000be3c:	2f 1d       	sub	sp,-60
8000be3e:	d8 22       	popm	r4-r7,pc

8000be40 <memchr>:
8000be40:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000be44:	c0 68       	rjmp	8000be50 <memchr+0x10>
8000be46:	20 1a       	sub	r10,1
8000be48:	19 88       	ld.ub	r8,r12[0x0]
8000be4a:	16 38       	cp.w	r8,r11
8000be4c:	5e 0c       	reteq	r12
8000be4e:	2f fc       	sub	r12,-1
8000be50:	58 0a       	cp.w	r10,0
8000be52:	cf a1       	brne	8000be46 <memchr+0x6>
8000be54:	5e fa       	retal	r10

8000be56 <memmove>:
8000be56:	d4 01       	pushm	lr
8000be58:	18 3b       	cp.w	r11,r12
8000be5a:	c1 92       	brcc	8000be8c <memmove+0x36>
8000be5c:	f6 0a 00 09 	add	r9,r11,r10
8000be60:	12 3c       	cp.w	r12,r9
8000be62:	c1 52       	brcc	8000be8c <memmove+0x36>
8000be64:	f8 0a 00 0b 	add	r11,r12,r10
8000be68:	30 08       	mov	r8,0
8000be6a:	c0 68       	rjmp	8000be76 <memmove+0x20>
8000be6c:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000be70:	20 1a       	sub	r10,1
8000be72:	f6 08 0b 0e 	st.b	r11[r8],lr
8000be76:	20 18       	sub	r8,1
8000be78:	58 0a       	cp.w	r10,0
8000be7a:	cf 91       	brne	8000be6c <memmove+0x16>
8000be7c:	d8 02       	popm	pc
8000be7e:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000be82:	20 1a       	sub	r10,1
8000be84:	f8 08 0b 09 	st.b	r12[r8],r9
8000be88:	2f f8       	sub	r8,-1
8000be8a:	c0 28       	rjmp	8000be8e <memmove+0x38>
8000be8c:	30 08       	mov	r8,0
8000be8e:	58 0a       	cp.w	r10,0
8000be90:	cf 71       	brne	8000be7e <memmove+0x28>
8000be92:	d8 02       	popm	pc

8000be94 <__hi0bits>:
8000be94:	18 98       	mov	r8,r12
8000be96:	e0 1c 00 00 	andl	r12,0x0
8000be9a:	f0 09 15 10 	lsl	r9,r8,0x10
8000be9e:	58 0c       	cp.w	r12,0
8000bea0:	f2 08 17 00 	moveq	r8,r9
8000bea4:	f9 bc 00 10 	moveq	r12,16
8000bea8:	f9 bc 01 00 	movne	r12,0
8000beac:	10 9a       	mov	r10,r8
8000beae:	f0 09 15 08 	lsl	r9,r8,0x8
8000beb2:	e6 1a ff 00 	andh	r10,0xff00,COH
8000beb6:	f7 bc 00 f8 	subeq	r12,-8
8000beba:	f2 08 17 00 	moveq	r8,r9
8000bebe:	10 9a       	mov	r10,r8
8000bec0:	f0 09 15 04 	lsl	r9,r8,0x4
8000bec4:	e6 1a f0 00 	andh	r10,0xf000,COH
8000bec8:	f7 bc 00 fc 	subeq	r12,-4
8000becc:	f2 08 17 00 	moveq	r8,r9
8000bed0:	10 9a       	mov	r10,r8
8000bed2:	f0 09 15 02 	lsl	r9,r8,0x2
8000bed6:	e6 1a c0 00 	andh	r10,0xc000,COH
8000beda:	f7 bc 00 fe 	subeq	r12,-2
8000bede:	f2 08 17 00 	moveq	r8,r9
8000bee2:	58 08       	cp.w	r8,0
8000bee4:	5e 5c       	retlt	r12
8000bee6:	ed b8 00 1e 	bld	r8,0x1e
8000beea:	f9 bc 01 20 	movne	r12,32
8000beee:	f7 bc 00 ff 	subeq	r12,-1
8000bef2:	5e fc       	retal	r12

8000bef4 <__lo0bits>:
8000bef4:	18 99       	mov	r9,r12
8000bef6:	78 08       	ld.w	r8,r12[0x0]
8000bef8:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000befc:	c1 50       	breq	8000bf26 <__lo0bits+0x32>
8000befe:	ed b8 00 00 	bld	r8,0x0
8000bf02:	c0 21       	brne	8000bf06 <__lo0bits+0x12>
8000bf04:	5e fd       	retal	0
8000bf06:	10 9b       	mov	r11,r8
8000bf08:	f0 0a 16 01 	lsr	r10,r8,0x1
8000bf0c:	e2 1b 00 02 	andl	r11,0x2,COH
8000bf10:	a3 88       	lsr	r8,0x2
8000bf12:	58 0b       	cp.w	r11,0
8000bf14:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000bf18:	f9 bc 01 01 	movne	r12,1
8000bf1c:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000bf20:	f9 bc 00 02 	moveq	r12,2
8000bf24:	5e fc       	retal	r12
8000bf26:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000bf2a:	f0 0b 16 10 	lsr	r11,r8,0x10
8000bf2e:	58 0a       	cp.w	r10,0
8000bf30:	f6 08 17 00 	moveq	r8,r11
8000bf34:	f9 bc 00 10 	moveq	r12,16
8000bf38:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000bf3c:	f0 0a 16 08 	lsr	r10,r8,0x8
8000bf40:	58 0b       	cp.w	r11,0
8000bf42:	f7 bc 00 f8 	subeq	r12,-8
8000bf46:	f4 08 17 00 	moveq	r8,r10
8000bf4a:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000bf4e:	f0 0a 16 04 	lsr	r10,r8,0x4
8000bf52:	58 0b       	cp.w	r11,0
8000bf54:	f7 bc 00 fc 	subeq	r12,-4
8000bf58:	f4 08 17 00 	moveq	r8,r10
8000bf5c:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000bf60:	f0 0a 16 02 	lsr	r10,r8,0x2
8000bf64:	58 0b       	cp.w	r11,0
8000bf66:	f7 bc 00 fe 	subeq	r12,-2
8000bf6a:	f4 08 17 00 	moveq	r8,r10
8000bf6e:	ed b8 00 00 	bld	r8,0x0
8000bf72:	c0 60       	breq	8000bf7e <__lo0bits+0x8a>
8000bf74:	a1 98       	lsr	r8,0x1
8000bf76:	c0 31       	brne	8000bf7c <__lo0bits+0x88>
8000bf78:	32 0c       	mov	r12,32
8000bf7a:	5e fc       	retal	r12
8000bf7c:	2f fc       	sub	r12,-1
8000bf7e:	93 08       	st.w	r9[0x0],r8
8000bf80:	5e fc       	retal	r12

8000bf82 <__mcmp>:
8000bf82:	d4 01       	pushm	lr
8000bf84:	18 98       	mov	r8,r12
8000bf86:	76 49       	ld.w	r9,r11[0x10]
8000bf88:	78 4c       	ld.w	r12,r12[0x10]
8000bf8a:	12 1c       	sub	r12,r9
8000bf8c:	c1 31       	brne	8000bfb2 <__mcmp+0x30>
8000bf8e:	2f b9       	sub	r9,-5
8000bf90:	a3 69       	lsl	r9,0x2
8000bf92:	12 0b       	add	r11,r9
8000bf94:	f0 09 00 09 	add	r9,r8,r9
8000bf98:	2e c8       	sub	r8,-20
8000bf9a:	13 4e       	ld.w	lr,--r9
8000bf9c:	17 4a       	ld.w	r10,--r11
8000bf9e:	14 3e       	cp.w	lr,r10
8000bfa0:	c0 60       	breq	8000bfac <__mcmp+0x2a>
8000bfa2:	f9 bc 03 ff 	movlo	r12,-1
8000bfa6:	f9 bc 02 01 	movhs	r12,1
8000bfaa:	d8 02       	popm	pc
8000bfac:	10 39       	cp.w	r9,r8
8000bfae:	fe 9b ff f6 	brhi	8000bf9a <__mcmp+0x18>
8000bfb2:	d8 02       	popm	pc

8000bfb4 <_Bfree>:
8000bfb4:	d4 21       	pushm	r4-r7,lr
8000bfb6:	18 97       	mov	r7,r12
8000bfb8:	16 95       	mov	r5,r11
8000bfba:	78 96       	ld.w	r6,r12[0x24]
8000bfbc:	58 06       	cp.w	r6,0
8000bfbe:	c0 91       	brne	8000bfd0 <_Bfree+0x1c>
8000bfc0:	31 0c       	mov	r12,16
8000bfc2:	fe b0 de 39 	rcall	80007c34 <malloc>
8000bfc6:	99 36       	st.w	r12[0xc],r6
8000bfc8:	8f 9c       	st.w	r7[0x24],r12
8000bfca:	99 16       	st.w	r12[0x4],r6
8000bfcc:	99 26       	st.w	r12[0x8],r6
8000bfce:	99 06       	st.w	r12[0x0],r6
8000bfd0:	58 05       	cp.w	r5,0
8000bfd2:	c0 90       	breq	8000bfe4 <_Bfree+0x30>
8000bfd4:	6a 19       	ld.w	r9,r5[0x4]
8000bfd6:	6e 98       	ld.w	r8,r7[0x24]
8000bfd8:	70 38       	ld.w	r8,r8[0xc]
8000bfda:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000bfde:	8b 0a       	st.w	r5[0x0],r10
8000bfe0:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000bfe4:	d8 22       	popm	r4-r7,pc
8000bfe6:	d7 03       	nop

8000bfe8 <_Balloc>:
8000bfe8:	d4 21       	pushm	r4-r7,lr
8000bfea:	18 97       	mov	r7,r12
8000bfec:	16 96       	mov	r6,r11
8000bfee:	78 95       	ld.w	r5,r12[0x24]
8000bff0:	58 05       	cp.w	r5,0
8000bff2:	c0 91       	brne	8000c004 <_Balloc+0x1c>
8000bff4:	31 0c       	mov	r12,16
8000bff6:	fe b0 de 1f 	rcall	80007c34 <malloc>
8000bffa:	99 35       	st.w	r12[0xc],r5
8000bffc:	8f 9c       	st.w	r7[0x24],r12
8000bffe:	99 15       	st.w	r12[0x4],r5
8000c000:	99 25       	st.w	r12[0x8],r5
8000c002:	99 05       	st.w	r12[0x0],r5
8000c004:	6e 95       	ld.w	r5,r7[0x24]
8000c006:	6a 38       	ld.w	r8,r5[0xc]
8000c008:	58 08       	cp.w	r8,0
8000c00a:	c0 b1       	brne	8000c020 <_Balloc+0x38>
8000c00c:	31 0a       	mov	r10,16
8000c00e:	30 4b       	mov	r11,4
8000c010:	0e 9c       	mov	r12,r7
8000c012:	e0 a0 02 a9 	rcall	8000c564 <_calloc_r>
8000c016:	8b 3c       	st.w	r5[0xc],r12
8000c018:	6e 98       	ld.w	r8,r7[0x24]
8000c01a:	70 3c       	ld.w	r12,r8[0xc]
8000c01c:	58 0c       	cp.w	r12,0
8000c01e:	c1 b0       	breq	8000c054 <_Balloc+0x6c>
8000c020:	6e 98       	ld.w	r8,r7[0x24]
8000c022:	70 38       	ld.w	r8,r8[0xc]
8000c024:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000c028:	70 0c       	ld.w	r12,r8[0x0]
8000c02a:	58 0c       	cp.w	r12,0
8000c02c:	c0 40       	breq	8000c034 <_Balloc+0x4c>
8000c02e:	78 09       	ld.w	r9,r12[0x0]
8000c030:	91 09       	st.w	r8[0x0],r9
8000c032:	c0 e8       	rjmp	8000c04e <_Balloc+0x66>
8000c034:	0e 9c       	mov	r12,r7
8000c036:	30 17       	mov	r7,1
8000c038:	0e 9b       	mov	r11,r7
8000c03a:	ee 06 09 47 	lsl	r7,r7,r6
8000c03e:	ee ca ff fb 	sub	r10,r7,-5
8000c042:	a3 6a       	lsl	r10,0x2
8000c044:	e0 a0 02 90 	rcall	8000c564 <_calloc_r>
8000c048:	c0 60       	breq	8000c054 <_Balloc+0x6c>
8000c04a:	99 16       	st.w	r12[0x4],r6
8000c04c:	99 27       	st.w	r12[0x8],r7
8000c04e:	30 08       	mov	r8,0
8000c050:	99 38       	st.w	r12[0xc],r8
8000c052:	99 48       	st.w	r12[0x10],r8
8000c054:	d8 22       	popm	r4-r7,pc
8000c056:	d7 03       	nop

8000c058 <__d2b>:
8000c058:	d4 31       	pushm	r0-r7,lr
8000c05a:	20 2d       	sub	sp,8
8000c05c:	16 93       	mov	r3,r11
8000c05e:	12 96       	mov	r6,r9
8000c060:	10 95       	mov	r5,r8
8000c062:	14 92       	mov	r2,r10
8000c064:	30 1b       	mov	r11,1
8000c066:	cc 1f       	rcall	8000bfe8 <_Balloc>
8000c068:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000c06c:	50 09       	stdsp	sp[0x0],r9
8000c06e:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000c072:	b5 a9       	sbr	r9,0x14
8000c074:	f0 01 16 14 	lsr	r1,r8,0x14
8000c078:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000c07c:	18 94       	mov	r4,r12
8000c07e:	58 02       	cp.w	r2,0
8000c080:	c1 d0       	breq	8000c0ba <__d2b+0x62>
8000c082:	fa cc ff f8 	sub	r12,sp,-8
8000c086:	18 d2       	st.w	--r12,r2
8000c088:	c3 6f       	rcall	8000bef4 <__lo0bits>
8000c08a:	40 18       	lddsp	r8,sp[0x4]
8000c08c:	c0 d0       	breq	8000c0a6 <__d2b+0x4e>
8000c08e:	40 09       	lddsp	r9,sp[0x0]
8000c090:	f8 0a 11 20 	rsub	r10,r12,32
8000c094:	f2 0a 09 4a 	lsl	r10,r9,r10
8000c098:	f5 e8 10 08 	or	r8,r10,r8
8000c09c:	89 58       	st.w	r4[0x14],r8
8000c09e:	f2 0c 0a 49 	lsr	r9,r9,r12
8000c0a2:	50 09       	stdsp	sp[0x0],r9
8000c0a4:	c0 28       	rjmp	8000c0a8 <__d2b+0x50>
8000c0a6:	89 58       	st.w	r4[0x14],r8
8000c0a8:	40 08       	lddsp	r8,sp[0x0]
8000c0aa:	58 08       	cp.w	r8,0
8000c0ac:	f9 b3 01 02 	movne	r3,2
8000c0b0:	f9 b3 00 01 	moveq	r3,1
8000c0b4:	89 68       	st.w	r4[0x18],r8
8000c0b6:	89 43       	st.w	r4[0x10],r3
8000c0b8:	c0 88       	rjmp	8000c0c8 <__d2b+0x70>
8000c0ba:	1a 9c       	mov	r12,sp
8000c0bc:	c1 cf       	rcall	8000bef4 <__lo0bits>
8000c0be:	30 13       	mov	r3,1
8000c0c0:	40 08       	lddsp	r8,sp[0x0]
8000c0c2:	2e 0c       	sub	r12,-32
8000c0c4:	89 43       	st.w	r4[0x10],r3
8000c0c6:	89 58       	st.w	r4[0x14],r8
8000c0c8:	58 01       	cp.w	r1,0
8000c0ca:	c0 90       	breq	8000c0dc <__d2b+0x84>
8000c0cc:	e2 c1 04 33 	sub	r1,r1,1075
8000c0d0:	18 01       	add	r1,r12
8000c0d2:	8d 01       	st.w	r6[0x0],r1
8000c0d4:	f8 0c 11 35 	rsub	r12,r12,53
8000c0d8:	8b 0c       	st.w	r5[0x0],r12
8000c0da:	c0 c8       	rjmp	8000c0f2 <__d2b+0x9a>
8000c0dc:	e6 c8 ff fc 	sub	r8,r3,-4
8000c0e0:	f8 cc 04 32 	sub	r12,r12,1074
8000c0e4:	a5 73       	lsl	r3,0x5
8000c0e6:	8d 0c       	st.w	r6[0x0],r12
8000c0e8:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000c0ec:	cd 4e       	rcall	8000be94 <__hi0bits>
8000c0ee:	18 13       	sub	r3,r12
8000c0f0:	8b 03       	st.w	r5[0x0],r3
8000c0f2:	08 9c       	mov	r12,r4
8000c0f4:	2f ed       	sub	sp,-8
8000c0f6:	d8 32       	popm	r0-r7,pc

8000c0f8 <__mdiff>:
8000c0f8:	d4 31       	pushm	r0-r7,lr
8000c0fa:	74 48       	ld.w	r8,r10[0x10]
8000c0fc:	76 45       	ld.w	r5,r11[0x10]
8000c0fe:	16 97       	mov	r7,r11
8000c100:	14 96       	mov	r6,r10
8000c102:	10 15       	sub	r5,r8
8000c104:	c1 31       	brne	8000c12a <__mdiff+0x32>
8000c106:	2f b8       	sub	r8,-5
8000c108:	ee ce ff ec 	sub	lr,r7,-20
8000c10c:	a3 68       	lsl	r8,0x2
8000c10e:	f4 08 00 0b 	add	r11,r10,r8
8000c112:	ee 08 00 08 	add	r8,r7,r8
8000c116:	11 4a       	ld.w	r10,--r8
8000c118:	17 49       	ld.w	r9,--r11
8000c11a:	12 3a       	cp.w	r10,r9
8000c11c:	c0 30       	breq	8000c122 <__mdiff+0x2a>
8000c11e:	c0 e2       	brcc	8000c13a <__mdiff+0x42>
8000c120:	c0 78       	rjmp	8000c12e <__mdiff+0x36>
8000c122:	1c 38       	cp.w	r8,lr
8000c124:	fe 9b ff f9 	brhi	8000c116 <__mdiff+0x1e>
8000c128:	c4 98       	rjmp	8000c1ba <__mdiff+0xc2>
8000c12a:	58 05       	cp.w	r5,0
8000c12c:	c0 64       	brge	8000c138 <__mdiff+0x40>
8000c12e:	0e 98       	mov	r8,r7
8000c130:	30 15       	mov	r5,1
8000c132:	0c 97       	mov	r7,r6
8000c134:	10 96       	mov	r6,r8
8000c136:	c0 28       	rjmp	8000c13a <__mdiff+0x42>
8000c138:	30 05       	mov	r5,0
8000c13a:	6e 1b       	ld.w	r11,r7[0x4]
8000c13c:	c5 6f       	rcall	8000bfe8 <_Balloc>
8000c13e:	6e 49       	ld.w	r9,r7[0x10]
8000c140:	6c 44       	ld.w	r4,r6[0x10]
8000c142:	99 35       	st.w	r12[0xc],r5
8000c144:	2f b4       	sub	r4,-5
8000c146:	f2 c5 ff fb 	sub	r5,r9,-5
8000c14a:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000c14e:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000c152:	2e c6       	sub	r6,-20
8000c154:	2e c7       	sub	r7,-20
8000c156:	f8 c8 ff ec 	sub	r8,r12,-20
8000c15a:	30 0a       	mov	r10,0
8000c15c:	0f 0e       	ld.w	lr,r7++
8000c15e:	0d 0b       	ld.w	r11,r6++
8000c160:	fc 02 16 10 	lsr	r2,lr,0x10
8000c164:	f6 03 16 10 	lsr	r3,r11,0x10
8000c168:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c16c:	e4 03 01 03 	sub	r3,r2,r3
8000c170:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000c174:	fc 0b 01 0b 	sub	r11,lr,r11
8000c178:	f6 0a 00 0a 	add	r10,r11,r10
8000c17c:	b0 1a       	st.h	r8[0x2],r10
8000c17e:	b1 4a       	asr	r10,0x10
8000c180:	e6 0a 00 0a 	add	r10,r3,r10
8000c184:	b0 0a       	st.h	r8[0x0],r10
8000c186:	2f c8       	sub	r8,-4
8000c188:	b1 4a       	asr	r10,0x10
8000c18a:	08 36       	cp.w	r6,r4
8000c18c:	ce 83       	brcs	8000c15c <__mdiff+0x64>
8000c18e:	c0 d8       	rjmp	8000c1a8 <__mdiff+0xb0>
8000c190:	0f 0b       	ld.w	r11,r7++
8000c192:	f6 0e 16 10 	lsr	lr,r11,0x10
8000c196:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000c19a:	16 0a       	add	r10,r11
8000c19c:	b0 1a       	st.h	r8[0x2],r10
8000c19e:	b1 4a       	asr	r10,0x10
8000c1a0:	1c 0a       	add	r10,lr
8000c1a2:	b0 0a       	st.h	r8[0x0],r10
8000c1a4:	2f c8       	sub	r8,-4
8000c1a6:	b1 4a       	asr	r10,0x10
8000c1a8:	0a 37       	cp.w	r7,r5
8000c1aa:	cf 33       	brcs	8000c190 <__mdiff+0x98>
8000c1ac:	c0 28       	rjmp	8000c1b0 <__mdiff+0xb8>
8000c1ae:	20 19       	sub	r9,1
8000c1b0:	11 4a       	ld.w	r10,--r8
8000c1b2:	58 0a       	cp.w	r10,0
8000c1b4:	cf d0       	breq	8000c1ae <__mdiff+0xb6>
8000c1b6:	99 49       	st.w	r12[0x10],r9
8000c1b8:	d8 32       	popm	r0-r7,pc
8000c1ba:	30 0b       	mov	r11,0
8000c1bc:	c1 6f       	rcall	8000bfe8 <_Balloc>
8000c1be:	30 18       	mov	r8,1
8000c1c0:	99 48       	st.w	r12[0x10],r8
8000c1c2:	30 08       	mov	r8,0
8000c1c4:	99 58       	st.w	r12[0x14],r8
8000c1c6:	d8 32       	popm	r0-r7,pc

8000c1c8 <__lshift>:
8000c1c8:	d4 31       	pushm	r0-r7,lr
8000c1ca:	16 97       	mov	r7,r11
8000c1cc:	76 46       	ld.w	r6,r11[0x10]
8000c1ce:	f4 02 14 05 	asr	r2,r10,0x5
8000c1d2:	2f f6       	sub	r6,-1
8000c1d4:	14 93       	mov	r3,r10
8000c1d6:	18 94       	mov	r4,r12
8000c1d8:	04 06       	add	r6,r2
8000c1da:	76 1b       	ld.w	r11,r11[0x4]
8000c1dc:	6e 28       	ld.w	r8,r7[0x8]
8000c1de:	c0 38       	rjmp	8000c1e4 <__lshift+0x1c>
8000c1e0:	2f fb       	sub	r11,-1
8000c1e2:	a1 78       	lsl	r8,0x1
8000c1e4:	10 36       	cp.w	r6,r8
8000c1e6:	fe 99 ff fd 	brgt	8000c1e0 <__lshift+0x18>
8000c1ea:	08 9c       	mov	r12,r4
8000c1ec:	cf ee       	rcall	8000bfe8 <_Balloc>
8000c1ee:	30 09       	mov	r9,0
8000c1f0:	18 95       	mov	r5,r12
8000c1f2:	f8 c8 ff ec 	sub	r8,r12,-20
8000c1f6:	12 9a       	mov	r10,r9
8000c1f8:	c0 38       	rjmp	8000c1fe <__lshift+0x36>
8000c1fa:	10 aa       	st.w	r8++,r10
8000c1fc:	2f f9       	sub	r9,-1
8000c1fe:	04 39       	cp.w	r9,r2
8000c200:	cf d5       	brlt	8000c1fa <__lshift+0x32>
8000c202:	6e 4b       	ld.w	r11,r7[0x10]
8000c204:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000c208:	2f bb       	sub	r11,-5
8000c20a:	ee c9 ff ec 	sub	r9,r7,-20
8000c20e:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000c212:	58 03       	cp.w	r3,0
8000c214:	c1 30       	breq	8000c23a <__lshift+0x72>
8000c216:	e6 0c 11 20 	rsub	r12,r3,32
8000c21a:	30 0a       	mov	r10,0
8000c21c:	72 02       	ld.w	r2,r9[0x0]
8000c21e:	e4 03 09 42 	lsl	r2,r2,r3
8000c222:	04 4a       	or	r10,r2
8000c224:	10 aa       	st.w	r8++,r10
8000c226:	13 0a       	ld.w	r10,r9++
8000c228:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c22c:	16 39       	cp.w	r9,r11
8000c22e:	cf 73       	brcs	8000c21c <__lshift+0x54>
8000c230:	91 0a       	st.w	r8[0x0],r10
8000c232:	58 0a       	cp.w	r10,0
8000c234:	c0 70       	breq	8000c242 <__lshift+0x7a>
8000c236:	2f f6       	sub	r6,-1
8000c238:	c0 58       	rjmp	8000c242 <__lshift+0x7a>
8000c23a:	13 0a       	ld.w	r10,r9++
8000c23c:	10 aa       	st.w	r8++,r10
8000c23e:	16 39       	cp.w	r9,r11
8000c240:	cf d3       	brcs	8000c23a <__lshift+0x72>
8000c242:	08 9c       	mov	r12,r4
8000c244:	20 16       	sub	r6,1
8000c246:	0e 9b       	mov	r11,r7
8000c248:	8b 46       	st.w	r5[0x10],r6
8000c24a:	cb 5e       	rcall	8000bfb4 <_Bfree>
8000c24c:	0a 9c       	mov	r12,r5
8000c24e:	d8 32       	popm	r0-r7,pc

8000c250 <__multiply>:
8000c250:	d4 31       	pushm	r0-r7,lr
8000c252:	20 2d       	sub	sp,8
8000c254:	76 49       	ld.w	r9,r11[0x10]
8000c256:	74 48       	ld.w	r8,r10[0x10]
8000c258:	16 96       	mov	r6,r11
8000c25a:	14 95       	mov	r5,r10
8000c25c:	10 39       	cp.w	r9,r8
8000c25e:	ec 08 17 50 	movlt	r8,r6
8000c262:	ea 06 17 50 	movlt	r6,r5
8000c266:	f0 05 17 50 	movlt	r5,r8
8000c26a:	6c 28       	ld.w	r8,r6[0x8]
8000c26c:	76 43       	ld.w	r3,r11[0x10]
8000c26e:	74 42       	ld.w	r2,r10[0x10]
8000c270:	76 1b       	ld.w	r11,r11[0x4]
8000c272:	e4 03 00 07 	add	r7,r2,r3
8000c276:	10 37       	cp.w	r7,r8
8000c278:	f7 bb 09 ff 	subgt	r11,-1
8000c27c:	cb 6e       	rcall	8000bfe8 <_Balloc>
8000c27e:	ee c4 ff fb 	sub	r4,r7,-5
8000c282:	f8 c9 ff ec 	sub	r9,r12,-20
8000c286:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000c28a:	30 0a       	mov	r10,0
8000c28c:	12 98       	mov	r8,r9
8000c28e:	c0 28       	rjmp	8000c292 <__multiply+0x42>
8000c290:	10 aa       	st.w	r8++,r10
8000c292:	08 38       	cp.w	r8,r4
8000c294:	cf e3       	brcs	8000c290 <__multiply+0x40>
8000c296:	2f b3       	sub	r3,-5
8000c298:	2f b2       	sub	r2,-5
8000c29a:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000c29e:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000c2a2:	ec cb ff ec 	sub	r11,r6,-20
8000c2a6:	50 12       	stdsp	sp[0x4],r2
8000c2a8:	ea ca ff ec 	sub	r10,r5,-20
8000c2ac:	c4 48       	rjmp	8000c334 <__multiply+0xe4>
8000c2ae:	94 95       	ld.uh	r5,r10[0x2]
8000c2b0:	58 05       	cp.w	r5,0
8000c2b2:	c2 00       	breq	8000c2f2 <__multiply+0xa2>
8000c2b4:	12 98       	mov	r8,r9
8000c2b6:	16 96       	mov	r6,r11
8000c2b8:	30 0e       	mov	lr,0
8000c2ba:	50 09       	stdsp	sp[0x0],r9
8000c2bc:	0d 02       	ld.w	r2,r6++
8000c2be:	e4 00 16 10 	lsr	r0,r2,0x10
8000c2c2:	70 01       	ld.w	r1,r8[0x0]
8000c2c4:	70 09       	ld.w	r9,r8[0x0]
8000c2c6:	b1 81       	lsr	r1,0x10
8000c2c8:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000c2cc:	e0 05 03 41 	mac	r1,r0,r5
8000c2d0:	ab 32       	mul	r2,r5
8000c2d2:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000c2d6:	00 02       	add	r2,r0
8000c2d8:	e4 0e 00 0e 	add	lr,r2,lr
8000c2dc:	b0 1e       	st.h	r8[0x2],lr
8000c2de:	b1 8e       	lsr	lr,0x10
8000c2e0:	1c 01       	add	r1,lr
8000c2e2:	b0 01       	st.h	r8[0x0],r1
8000c2e4:	e2 0e 16 10 	lsr	lr,r1,0x10
8000c2e8:	2f c8       	sub	r8,-4
8000c2ea:	06 36       	cp.w	r6,r3
8000c2ec:	ce 83       	brcs	8000c2bc <__multiply+0x6c>
8000c2ee:	40 09       	lddsp	r9,sp[0x0]
8000c2f0:	91 0e       	st.w	r8[0x0],lr
8000c2f2:	94 86       	ld.uh	r6,r10[0x0]
8000c2f4:	58 06       	cp.w	r6,0
8000c2f6:	c1 d0       	breq	8000c330 <__multiply+0xe0>
8000c2f8:	72 02       	ld.w	r2,r9[0x0]
8000c2fa:	12 98       	mov	r8,r9
8000c2fc:	16 9e       	mov	lr,r11
8000c2fe:	30 05       	mov	r5,0
8000c300:	b0 12       	st.h	r8[0x2],r2
8000c302:	1d 01       	ld.w	r1,lr++
8000c304:	90 82       	ld.uh	r2,r8[0x0]
8000c306:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000c30a:	ad 30       	mul	r0,r6
8000c30c:	e0 02 00 02 	add	r2,r0,r2
8000c310:	e4 05 00 05 	add	r5,r2,r5
8000c314:	b0 05       	st.h	r8[0x0],r5
8000c316:	b1 85       	lsr	r5,0x10
8000c318:	b1 81       	lsr	r1,0x10
8000c31a:	2f c8       	sub	r8,-4
8000c31c:	ad 31       	mul	r1,r6
8000c31e:	90 92       	ld.uh	r2,r8[0x2]
8000c320:	e2 02 00 02 	add	r2,r1,r2
8000c324:	0a 02       	add	r2,r5
8000c326:	e4 05 16 10 	lsr	r5,r2,0x10
8000c32a:	06 3e       	cp.w	lr,r3
8000c32c:	ce a3       	brcs	8000c300 <__multiply+0xb0>
8000c32e:	91 02       	st.w	r8[0x0],r2
8000c330:	2f ca       	sub	r10,-4
8000c332:	2f c9       	sub	r9,-4
8000c334:	40 18       	lddsp	r8,sp[0x4]
8000c336:	10 3a       	cp.w	r10,r8
8000c338:	cb b3       	brcs	8000c2ae <__multiply+0x5e>
8000c33a:	c0 28       	rjmp	8000c33e <__multiply+0xee>
8000c33c:	20 17       	sub	r7,1
8000c33e:	58 07       	cp.w	r7,0
8000c340:	e0 8a 00 05 	brle	8000c34a <__multiply+0xfa>
8000c344:	09 48       	ld.w	r8,--r4
8000c346:	58 08       	cp.w	r8,0
8000c348:	cf a0       	breq	8000c33c <__multiply+0xec>
8000c34a:	99 47       	st.w	r12[0x10],r7
8000c34c:	2f ed       	sub	sp,-8
8000c34e:	d8 32       	popm	r0-r7,pc

8000c350 <__i2b>:
8000c350:	d4 21       	pushm	r4-r7,lr
8000c352:	16 97       	mov	r7,r11
8000c354:	30 1b       	mov	r11,1
8000c356:	c4 9e       	rcall	8000bfe8 <_Balloc>
8000c358:	30 19       	mov	r9,1
8000c35a:	99 57       	st.w	r12[0x14],r7
8000c35c:	99 49       	st.w	r12[0x10],r9
8000c35e:	d8 22       	popm	r4-r7,pc

8000c360 <__multadd>:
8000c360:	d4 31       	pushm	r0-r7,lr
8000c362:	30 08       	mov	r8,0
8000c364:	12 95       	mov	r5,r9
8000c366:	16 97       	mov	r7,r11
8000c368:	18 96       	mov	r6,r12
8000c36a:	76 44       	ld.w	r4,r11[0x10]
8000c36c:	f6 c9 ff ec 	sub	r9,r11,-20
8000c370:	72 0b       	ld.w	r11,r9[0x0]
8000c372:	f6 0c 16 10 	lsr	r12,r11,0x10
8000c376:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000c37a:	f4 0c 02 4c 	mul	r12,r10,r12
8000c37e:	f4 0b 03 45 	mac	r5,r10,r11
8000c382:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000c386:	b1 85       	lsr	r5,0x10
8000c388:	18 05       	add	r5,r12
8000c38a:	ea 0c 15 10 	lsl	r12,r5,0x10
8000c38e:	f8 0b 00 0b 	add	r11,r12,r11
8000c392:	12 ab       	st.w	r9++,r11
8000c394:	2f f8       	sub	r8,-1
8000c396:	b1 85       	lsr	r5,0x10
8000c398:	08 38       	cp.w	r8,r4
8000c39a:	ce b5       	brlt	8000c370 <__multadd+0x10>
8000c39c:	58 05       	cp.w	r5,0
8000c39e:	c1 c0       	breq	8000c3d6 <__multadd+0x76>
8000c3a0:	6e 28       	ld.w	r8,r7[0x8]
8000c3a2:	10 34       	cp.w	r4,r8
8000c3a4:	c1 35       	brlt	8000c3ca <__multadd+0x6a>
8000c3a6:	6e 1b       	ld.w	r11,r7[0x4]
8000c3a8:	0c 9c       	mov	r12,r6
8000c3aa:	2f fb       	sub	r11,-1
8000c3ac:	c1 ee       	rcall	8000bfe8 <_Balloc>
8000c3ae:	6e 4a       	ld.w	r10,r7[0x10]
8000c3b0:	ee cb ff f4 	sub	r11,r7,-12
8000c3b4:	18 93       	mov	r3,r12
8000c3b6:	2f ea       	sub	r10,-2
8000c3b8:	2f 4c       	sub	r12,-12
8000c3ba:	a3 6a       	lsl	r10,0x2
8000c3bc:	fe b0 de 5a 	rcall	80008070 <memcpy>
8000c3c0:	0e 9b       	mov	r11,r7
8000c3c2:	0c 9c       	mov	r12,r6
8000c3c4:	fe b0 fd f8 	rcall	8000bfb4 <_Bfree>
8000c3c8:	06 97       	mov	r7,r3
8000c3ca:	e8 c8 ff ff 	sub	r8,r4,-1
8000c3ce:	2f b4       	sub	r4,-5
8000c3d0:	8f 48       	st.w	r7[0x10],r8
8000c3d2:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000c3d6:	0e 9c       	mov	r12,r7
8000c3d8:	d8 32       	popm	r0-r7,pc
8000c3da:	d7 03       	nop

8000c3dc <__pow5mult>:
8000c3dc:	d4 31       	pushm	r0-r7,lr
8000c3de:	14 96       	mov	r6,r10
8000c3e0:	18 97       	mov	r7,r12
8000c3e2:	16 94       	mov	r4,r11
8000c3e4:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000c3e8:	c0 80       	breq	8000c3f8 <__pow5mult+0x1c>
8000c3ea:	20 18       	sub	r8,1
8000c3ec:	49 f9       	lddpc	r9,8000c468 <__pow5mult+0x8c>
8000c3ee:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000c3f2:	30 09       	mov	r9,0
8000c3f4:	cb 6f       	rcall	8000c360 <__multadd>
8000c3f6:	18 94       	mov	r4,r12
8000c3f8:	a3 46       	asr	r6,0x2
8000c3fa:	c3 40       	breq	8000c462 <__pow5mult+0x86>
8000c3fc:	6e 95       	ld.w	r5,r7[0x24]
8000c3fe:	58 05       	cp.w	r5,0
8000c400:	c0 91       	brne	8000c412 <__pow5mult+0x36>
8000c402:	31 0c       	mov	r12,16
8000c404:	fe b0 dc 18 	rcall	80007c34 <malloc>
8000c408:	99 35       	st.w	r12[0xc],r5
8000c40a:	8f 9c       	st.w	r7[0x24],r12
8000c40c:	99 15       	st.w	r12[0x4],r5
8000c40e:	99 25       	st.w	r12[0x8],r5
8000c410:	99 05       	st.w	r12[0x0],r5
8000c412:	6e 93       	ld.w	r3,r7[0x24]
8000c414:	66 25       	ld.w	r5,r3[0x8]
8000c416:	58 05       	cp.w	r5,0
8000c418:	c0 c1       	brne	8000c430 <__pow5mult+0x54>
8000c41a:	e0 6b 02 71 	mov	r11,625
8000c41e:	0e 9c       	mov	r12,r7
8000c420:	c9 8f       	rcall	8000c350 <__i2b>
8000c422:	87 2c       	st.w	r3[0x8],r12
8000c424:	30 08       	mov	r8,0
8000c426:	18 95       	mov	r5,r12
8000c428:	99 08       	st.w	r12[0x0],r8
8000c42a:	c0 38       	rjmp	8000c430 <__pow5mult+0x54>
8000c42c:	06 9c       	mov	r12,r3
8000c42e:	18 95       	mov	r5,r12
8000c430:	ed b6 00 00 	bld	r6,0x0
8000c434:	c0 b1       	brne	8000c44a <__pow5mult+0x6e>
8000c436:	08 9b       	mov	r11,r4
8000c438:	0a 9a       	mov	r10,r5
8000c43a:	0e 9c       	mov	r12,r7
8000c43c:	c0 af       	rcall	8000c250 <__multiply>
8000c43e:	08 9b       	mov	r11,r4
8000c440:	18 93       	mov	r3,r12
8000c442:	0e 9c       	mov	r12,r7
8000c444:	06 94       	mov	r4,r3
8000c446:	fe b0 fd b7 	rcall	8000bfb4 <_Bfree>
8000c44a:	a1 56       	asr	r6,0x1
8000c44c:	c0 b0       	breq	8000c462 <__pow5mult+0x86>
8000c44e:	6a 03       	ld.w	r3,r5[0x0]
8000c450:	58 03       	cp.w	r3,0
8000c452:	ce d1       	brne	8000c42c <__pow5mult+0x50>
8000c454:	0a 9a       	mov	r10,r5
8000c456:	0a 9b       	mov	r11,r5
8000c458:	0e 9c       	mov	r12,r7
8000c45a:	cf be       	rcall	8000c250 <__multiply>
8000c45c:	8b 0c       	st.w	r5[0x0],r12
8000c45e:	99 03       	st.w	r12[0x0],r3
8000c460:	ce 7b       	rjmp	8000c42e <__pow5mult+0x52>
8000c462:	08 9c       	mov	r12,r4
8000c464:	d8 32       	popm	r0-r7,pc
8000c466:	d7 03       	nop
8000c468:	80 02       	ld.sh	r2,r0[0x0]
8000c46a:	f9 c8       	*unknown*

8000c46c <__isinfd>:
8000c46c:	14 98       	mov	r8,r10
8000c46e:	fc 19 7f f0 	movh	r9,0x7ff0
8000c472:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000c476:	f0 0b 11 00 	rsub	r11,r8,0
8000c47a:	f7 e8 10 08 	or	r8,r11,r8
8000c47e:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000c482:	f2 08 01 08 	sub	r8,r9,r8
8000c486:	f0 0c 11 00 	rsub	r12,r8,0
8000c48a:	f9 e8 10 08 	or	r8,r12,r8
8000c48e:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000c492:	2f fc       	sub	r12,-1
8000c494:	5e fc       	retal	r12

8000c496 <__isnand>:
8000c496:	14 98       	mov	r8,r10
8000c498:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000c49c:	f0 0c 11 00 	rsub	r12,r8,0
8000c4a0:	10 4c       	or	r12,r8
8000c4a2:	fc 18 7f f0 	movh	r8,0x7ff0
8000c4a6:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000c4aa:	f0 0c 01 0c 	sub	r12,r8,r12
8000c4ae:	bf 9c       	lsr	r12,0x1f
8000c4b0:	5e fc       	retal	r12
8000c4b2:	d7 03       	nop

8000c4b4 <__sclose>:
8000c4b4:	d4 01       	pushm	lr
8000c4b6:	96 7b       	ld.sh	r11,r11[0xe]
8000c4b8:	c8 2c       	rcall	8000c5bc <_close_r>
8000c4ba:	d8 02       	popm	pc

8000c4bc <__sseek>:
8000c4bc:	d4 21       	pushm	r4-r7,lr
8000c4be:	16 97       	mov	r7,r11
8000c4c0:	96 7b       	ld.sh	r11,r11[0xe]
8000c4c2:	c0 5d       	rcall	8000c6cc <_lseek_r>
8000c4c4:	8e 68       	ld.sh	r8,r7[0xc]
8000c4c6:	10 99       	mov	r9,r8
8000c4c8:	ad c8       	cbr	r8,0xc
8000c4ca:	ad a9       	sbr	r9,0xc
8000c4cc:	5b fc       	cp.w	r12,-1
8000c4ce:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000c4d2:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000c4d6:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000c4da:	d8 22       	popm	r4-r7,pc

8000c4dc <__swrite>:
8000c4dc:	d4 21       	pushm	r4-r7,lr
8000c4de:	96 68       	ld.sh	r8,r11[0xc]
8000c4e0:	16 97       	mov	r7,r11
8000c4e2:	14 95       	mov	r5,r10
8000c4e4:	12 94       	mov	r4,r9
8000c4e6:	e2 18 01 00 	andl	r8,0x100,COH
8000c4ea:	18 96       	mov	r6,r12
8000c4ec:	c0 50       	breq	8000c4f6 <__swrite+0x1a>
8000c4ee:	30 29       	mov	r9,2
8000c4f0:	30 0a       	mov	r10,0
8000c4f2:	96 7b       	ld.sh	r11,r11[0xe]
8000c4f4:	ce cc       	rcall	8000c6cc <_lseek_r>
8000c4f6:	8e 68       	ld.sh	r8,r7[0xc]
8000c4f8:	ad c8       	cbr	r8,0xc
8000c4fa:	08 99       	mov	r9,r4
8000c4fc:	0a 9a       	mov	r10,r5
8000c4fe:	8e 7b       	ld.sh	r11,r7[0xe]
8000c500:	0c 9c       	mov	r12,r6
8000c502:	ae 68       	st.h	r7[0xc],r8
8000c504:	c1 cc       	rcall	8000c53c <_write_r>
8000c506:	d8 22       	popm	r4-r7,pc

8000c508 <__sread>:
8000c508:	d4 21       	pushm	r4-r7,lr
8000c50a:	16 97       	mov	r7,r11
8000c50c:	96 7b       	ld.sh	r11,r11[0xe]
8000c50e:	cf 3c       	rcall	8000c6f4 <_read_r>
8000c510:	c0 65       	brlt	8000c51c <__sread+0x14>
8000c512:	6f 58       	ld.w	r8,r7[0x54]
8000c514:	18 08       	add	r8,r12
8000c516:	ef 48 00 54 	st.w	r7[84],r8
8000c51a:	d8 22       	popm	r4-r7,pc
8000c51c:	8e 68       	ld.sh	r8,r7[0xc]
8000c51e:	ad c8       	cbr	r8,0xc
8000c520:	ae 68       	st.h	r7[0xc],r8
8000c522:	d8 22       	popm	r4-r7,pc

8000c524 <strlen>:
8000c524:	30 09       	mov	r9,0
8000c526:	18 98       	mov	r8,r12
8000c528:	c0 28       	rjmp	8000c52c <strlen+0x8>
8000c52a:	2f f8       	sub	r8,-1
8000c52c:	11 8a       	ld.ub	r10,r8[0x0]
8000c52e:	f2 0a 18 00 	cp.b	r10,r9
8000c532:	cf c1       	brne	8000c52a <strlen+0x6>
8000c534:	f0 0c 01 0c 	sub	r12,r8,r12
8000c538:	5e fc       	retal	r12
8000c53a:	d7 03       	nop

8000c53c <_write_r>:
8000c53c:	d4 21       	pushm	r4-r7,lr
8000c53e:	16 98       	mov	r8,r11
8000c540:	18 97       	mov	r7,r12
8000c542:	10 9c       	mov	r12,r8
8000c544:	30 08       	mov	r8,0
8000c546:	14 9b       	mov	r11,r10
8000c548:	e0 66 10 6c 	mov	r6,4204
8000c54c:	12 9a       	mov	r10,r9
8000c54e:	8d 08       	st.w	r6[0x0],r8
8000c550:	fe b0 cd 0a 	rcall	80005f64 <_write>
8000c554:	5b fc       	cp.w	r12,-1
8000c556:	c0 51       	brne	8000c560 <_write_r+0x24>
8000c558:	6c 08       	ld.w	r8,r6[0x0]
8000c55a:	58 08       	cp.w	r8,0
8000c55c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c560:	d8 22       	popm	r4-r7,pc
8000c562:	d7 03       	nop

8000c564 <_calloc_r>:
8000c564:	d4 21       	pushm	r4-r7,lr
8000c566:	f4 0b 02 4b 	mul	r11,r10,r11
8000c56a:	fe b0 db 6d 	rcall	80007c44 <_malloc_r>
8000c56e:	18 97       	mov	r7,r12
8000c570:	c2 30       	breq	8000c5b6 <_calloc_r+0x52>
8000c572:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000c576:	e0 1a ff fc 	andl	r10,0xfffc
8000c57a:	20 4a       	sub	r10,4
8000c57c:	e0 4a 00 24 	cp.w	r10,36
8000c580:	e0 8b 00 18 	brhi	8000c5b0 <_calloc_r+0x4c>
8000c584:	18 98       	mov	r8,r12
8000c586:	59 3a       	cp.w	r10,19
8000c588:	e0 88 00 0f 	brls	8000c5a6 <_calloc_r+0x42>
8000c58c:	30 09       	mov	r9,0
8000c58e:	10 a9       	st.w	r8++,r9
8000c590:	10 a9       	st.w	r8++,r9
8000c592:	59 ba       	cp.w	r10,27
8000c594:	e0 88 00 09 	brls	8000c5a6 <_calloc_r+0x42>
8000c598:	10 a9       	st.w	r8++,r9
8000c59a:	10 a9       	st.w	r8++,r9
8000c59c:	e0 4a 00 24 	cp.w	r10,36
8000c5a0:	c0 31       	brne	8000c5a6 <_calloc_r+0x42>
8000c5a2:	10 a9       	st.w	r8++,r9
8000c5a4:	10 a9       	st.w	r8++,r9
8000c5a6:	30 09       	mov	r9,0
8000c5a8:	10 a9       	st.w	r8++,r9
8000c5aa:	91 19       	st.w	r8[0x4],r9
8000c5ac:	91 09       	st.w	r8[0x0],r9
8000c5ae:	c0 48       	rjmp	8000c5b6 <_calloc_r+0x52>
8000c5b0:	30 0b       	mov	r11,0
8000c5b2:	fe b0 de 03 	rcall	800081b8 <memset>
8000c5b6:	0e 9c       	mov	r12,r7
8000c5b8:	d8 22       	popm	r4-r7,pc
8000c5ba:	d7 03       	nop

8000c5bc <_close_r>:
8000c5bc:	d4 21       	pushm	r4-r7,lr
8000c5be:	30 08       	mov	r8,0
8000c5c0:	18 97       	mov	r7,r12
8000c5c2:	e0 66 10 6c 	mov	r6,4204
8000c5c6:	16 9c       	mov	r12,r11
8000c5c8:	8d 08       	st.w	r6[0x0],r8
8000c5ca:	fe b0 df 9d 	rcall	80008504 <_close>
8000c5ce:	5b fc       	cp.w	r12,-1
8000c5d0:	c0 51       	brne	8000c5da <_close_r+0x1e>
8000c5d2:	6c 08       	ld.w	r8,r6[0x0]
8000c5d4:	58 08       	cp.w	r8,0
8000c5d6:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c5da:	d8 22       	popm	r4-r7,pc

8000c5dc <_fclose_r>:
8000c5dc:	d4 21       	pushm	r4-r7,lr
8000c5de:	18 96       	mov	r6,r12
8000c5e0:	16 97       	mov	r7,r11
8000c5e2:	58 0b       	cp.w	r11,0
8000c5e4:	c0 31       	brne	8000c5ea <_fclose_r+0xe>
8000c5e6:	16 95       	mov	r5,r11
8000c5e8:	c5 08       	rjmp	8000c688 <_fclose_r+0xac>
8000c5ea:	fe b0 f8 a9 	rcall	8000b73c <__sfp_lock_acquire>
8000c5ee:	58 06       	cp.w	r6,0
8000c5f0:	c0 70       	breq	8000c5fe <_fclose_r+0x22>
8000c5f2:	6c 68       	ld.w	r8,r6[0x18]
8000c5f4:	58 08       	cp.w	r8,0
8000c5f6:	c0 41       	brne	8000c5fe <_fclose_r+0x22>
8000c5f8:	0c 9c       	mov	r12,r6
8000c5fa:	fe b0 f8 f5 	rcall	8000b7e4 <__sinit>
8000c5fe:	4a 48       	lddpc	r8,8000c68c <_fclose_r+0xb0>
8000c600:	10 37       	cp.w	r7,r8
8000c602:	c0 31       	brne	8000c608 <_fclose_r+0x2c>
8000c604:	6c 07       	ld.w	r7,r6[0x0]
8000c606:	c0 a8       	rjmp	8000c61a <_fclose_r+0x3e>
8000c608:	4a 28       	lddpc	r8,8000c690 <_fclose_r+0xb4>
8000c60a:	10 37       	cp.w	r7,r8
8000c60c:	c0 31       	brne	8000c612 <_fclose_r+0x36>
8000c60e:	6c 17       	ld.w	r7,r6[0x4]
8000c610:	c0 58       	rjmp	8000c61a <_fclose_r+0x3e>
8000c612:	4a 18       	lddpc	r8,8000c694 <_fclose_r+0xb8>
8000c614:	10 37       	cp.w	r7,r8
8000c616:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000c61a:	8e 69       	ld.sh	r9,r7[0xc]
8000c61c:	30 08       	mov	r8,0
8000c61e:	f0 09 19 00 	cp.h	r9,r8
8000c622:	c0 51       	brne	8000c62c <_fclose_r+0x50>
8000c624:	fe b0 f8 8d 	rcall	8000b73e <__sfp_lock_release>
8000c628:	30 05       	mov	r5,0
8000c62a:	c2 f8       	rjmp	8000c688 <_fclose_r+0xac>
8000c62c:	0e 9b       	mov	r11,r7
8000c62e:	0c 9c       	mov	r12,r6
8000c630:	fe b0 f7 fe 	rcall	8000b62c <_fflush_r>
8000c634:	6e c8       	ld.w	r8,r7[0x30]
8000c636:	18 95       	mov	r5,r12
8000c638:	58 08       	cp.w	r8,0
8000c63a:	c0 60       	breq	8000c646 <_fclose_r+0x6a>
8000c63c:	6e 8b       	ld.w	r11,r7[0x20]
8000c63e:	0c 9c       	mov	r12,r6
8000c640:	5d 18       	icall	r8
8000c642:	f9 b5 05 ff 	movlt	r5,-1
8000c646:	8e 68       	ld.sh	r8,r7[0xc]
8000c648:	ed b8 00 07 	bld	r8,0x7
8000c64c:	c0 51       	brne	8000c656 <_fclose_r+0x7a>
8000c64e:	6e 4b       	ld.w	r11,r7[0x10]
8000c650:	0c 9c       	mov	r12,r6
8000c652:	fe b0 f9 61 	rcall	8000b914 <_free_r>
8000c656:	6e db       	ld.w	r11,r7[0x34]
8000c658:	58 0b       	cp.w	r11,0
8000c65a:	c0 a0       	breq	8000c66e <_fclose_r+0x92>
8000c65c:	ee c8 ff bc 	sub	r8,r7,-68
8000c660:	10 3b       	cp.w	r11,r8
8000c662:	c0 40       	breq	8000c66a <_fclose_r+0x8e>
8000c664:	0c 9c       	mov	r12,r6
8000c666:	fe b0 f9 57 	rcall	8000b914 <_free_r>
8000c66a:	30 08       	mov	r8,0
8000c66c:	8f d8       	st.w	r7[0x34],r8
8000c66e:	6f 2b       	ld.w	r11,r7[0x48]
8000c670:	58 0b       	cp.w	r11,0
8000c672:	c0 70       	breq	8000c680 <_fclose_r+0xa4>
8000c674:	0c 9c       	mov	r12,r6
8000c676:	fe b0 f9 4f 	rcall	8000b914 <_free_r>
8000c67a:	30 08       	mov	r8,0
8000c67c:	ef 48 00 48 	st.w	r7[72],r8
8000c680:	30 08       	mov	r8,0
8000c682:	ae 68       	st.h	r7[0xc],r8
8000c684:	fe b0 f8 5d 	rcall	8000b73e <__sfp_lock_release>
8000c688:	0a 9c       	mov	r12,r5
8000c68a:	d8 22       	popm	r4-r7,pc
8000c68c:	80 02       	ld.sh	r2,r0[0x0]
8000c68e:	f9 20 80 02 	ld.sb	r0,r12[-32766]
8000c692:	f9 40 80 02 	st.w	r12[-32766],r0
8000c696:	f9 60 d4 01 	st.b	r12[-11263],r0

8000c698 <fclose>:
8000c698:	d4 01       	pushm	lr
8000c69a:	e0 68 05 34 	mov	r8,1332
8000c69e:	18 9b       	mov	r11,r12
8000c6a0:	70 0c       	ld.w	r12,r8[0x0]
8000c6a2:	c9 df       	rcall	8000c5dc <_fclose_r>
8000c6a4:	d8 02       	popm	pc
8000c6a6:	d7 03       	nop

8000c6a8 <_fstat_r>:
8000c6a8:	d4 21       	pushm	r4-r7,lr
8000c6aa:	16 98       	mov	r8,r11
8000c6ac:	18 97       	mov	r7,r12
8000c6ae:	10 9c       	mov	r12,r8
8000c6b0:	30 08       	mov	r8,0
8000c6b2:	e0 66 10 6c 	mov	r6,4204
8000c6b6:	14 9b       	mov	r11,r10
8000c6b8:	8d 08       	st.w	r6[0x0],r8
8000c6ba:	fe b0 df 4d 	rcall	80008554 <_fstat>
8000c6be:	5b fc       	cp.w	r12,-1
8000c6c0:	c0 51       	brne	8000c6ca <_fstat_r+0x22>
8000c6c2:	6c 08       	ld.w	r8,r6[0x0]
8000c6c4:	58 08       	cp.w	r8,0
8000c6c6:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c6ca:	d8 22       	popm	r4-r7,pc

8000c6cc <_lseek_r>:
8000c6cc:	d4 21       	pushm	r4-r7,lr
8000c6ce:	16 98       	mov	r8,r11
8000c6d0:	18 97       	mov	r7,r12
8000c6d2:	10 9c       	mov	r12,r8
8000c6d4:	30 08       	mov	r8,0
8000c6d6:	14 9b       	mov	r11,r10
8000c6d8:	e0 66 10 6c 	mov	r6,4204
8000c6dc:	12 9a       	mov	r10,r9
8000c6de:	8d 08       	st.w	r6[0x0],r8
8000c6e0:	fe b0 df 1c 	rcall	80008518 <_lseek>
8000c6e4:	5b fc       	cp.w	r12,-1
8000c6e6:	c0 51       	brne	8000c6f0 <_lseek_r+0x24>
8000c6e8:	6c 08       	ld.w	r8,r6[0x0]
8000c6ea:	58 08       	cp.w	r8,0
8000c6ec:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c6f0:	d8 22       	popm	r4-r7,pc
8000c6f2:	d7 03       	nop

8000c6f4 <_read_r>:
8000c6f4:	d4 21       	pushm	r4-r7,lr
8000c6f6:	16 98       	mov	r8,r11
8000c6f8:	18 97       	mov	r7,r12
8000c6fa:	10 9c       	mov	r12,r8
8000c6fc:	30 08       	mov	r8,0
8000c6fe:	14 9b       	mov	r11,r10
8000c700:	e0 66 10 6c 	mov	r6,4204
8000c704:	12 9a       	mov	r10,r9
8000c706:	8d 08       	st.w	r6[0x0],r8
8000c708:	fe b0 cc 0e 	rcall	80005f24 <_read>
8000c70c:	5b fc       	cp.w	r12,-1
8000c70e:	c0 51       	brne	8000c718 <_read_r+0x24>
8000c710:	6c 08       	ld.w	r8,r6[0x0]
8000c712:	58 08       	cp.w	r8,0
8000c714:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c718:	d8 22       	popm	r4-r7,pc
8000c71a:	d7 03       	nop

8000c71c <__avr32_f64_to_u32>:
8000c71c:	58 0b       	cp.w	r11,0
8000c71e:	5e 6d       	retmi	0

8000c720 <__avr32_f64_to_s32>:
8000c720:	f6 0c 15 01 	lsl	r12,r11,0x1
8000c724:	b5 9c       	lsr	r12,0x15
8000c726:	e0 2c 03 ff 	sub	r12,1023
8000c72a:	5e 3d       	retlo	0
8000c72c:	f8 0c 11 1f 	rsub	r12,r12,31
8000c730:	16 99       	mov	r9,r11
8000c732:	ab 7b       	lsl	r11,0xb
8000c734:	bf bb       	sbr	r11,0x1f
8000c736:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c73a:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c73e:	a1 79       	lsl	r9,0x1
8000c740:	5e 2b       	reths	r11
8000c742:	5c 3b       	neg	r11
8000c744:	5e fb       	retal	r11

8000c746 <__avr32_f64_cmp_eq>:
8000c746:	10 3a       	cp.w	r10,r8
8000c748:	f2 0b 13 00 	cpc	r11,r9
8000c74c:	c0 80       	breq	8000c75c <__avr32_f64_cmp_eq+0x16>
8000c74e:	a1 7b       	lsl	r11,0x1
8000c750:	a1 79       	lsl	r9,0x1
8000c752:	14 4b       	or	r11,r10
8000c754:	12 4b       	or	r11,r9
8000c756:	10 4b       	or	r11,r8
8000c758:	5e 0f       	reteq	1
8000c75a:	5e fd       	retal	0
8000c75c:	a1 7b       	lsl	r11,0x1
8000c75e:	fc 1c ff e0 	movh	r12,0xffe0
8000c762:	58 0a       	cp.w	r10,0
8000c764:	f8 0b 13 00 	cpc	r11,r12
8000c768:	5e 8f       	retls	1
8000c76a:	5e fd       	retal	0

8000c76c <__avr32_f64_cmp_ge>:
8000c76c:	1a de       	st.w	--sp,lr
8000c76e:	1a d7       	st.w	--sp,r7
8000c770:	a1 7b       	lsl	r11,0x1
8000c772:	5f 3c       	srlo	r12
8000c774:	a1 79       	lsl	r9,0x1
8000c776:	5f 37       	srlo	r7
8000c778:	5c fc       	rol	r12
8000c77a:	fc 1e ff e0 	movh	lr,0xffe0
8000c77e:	58 0a       	cp.w	r10,0
8000c780:	fc 0b 13 00 	cpc	r11,lr
8000c784:	e0 8b 00 1d 	brhi	8000c7be <__avr32_f64_cmp_ge+0x52>
8000c788:	58 08       	cp.w	r8,0
8000c78a:	fc 09 13 00 	cpc	r9,lr
8000c78e:	e0 8b 00 18 	brhi	8000c7be <__avr32_f64_cmp_ge+0x52>
8000c792:	58 0b       	cp.w	r11,0
8000c794:	f5 ba 00 00 	subfeq	r10,0
8000c798:	c1 50       	breq	8000c7c2 <__avr32_f64_cmp_ge+0x56>
8000c79a:	1b 07       	ld.w	r7,sp++
8000c79c:	1b 0e       	ld.w	lr,sp++
8000c79e:	58 3c       	cp.w	r12,3
8000c7a0:	c0 a0       	breq	8000c7b4 <__avr32_f64_cmp_ge+0x48>
8000c7a2:	58 1c       	cp.w	r12,1
8000c7a4:	c0 33       	brcs	8000c7aa <__avr32_f64_cmp_ge+0x3e>
8000c7a6:	5e 0f       	reteq	1
8000c7a8:	5e 1d       	retne	0
8000c7aa:	10 3a       	cp.w	r10,r8
8000c7ac:	f2 0b 13 00 	cpc	r11,r9
8000c7b0:	5e 2f       	reths	1
8000c7b2:	5e 3d       	retlo	0
8000c7b4:	14 38       	cp.w	r8,r10
8000c7b6:	f6 09 13 00 	cpc	r9,r11
8000c7ba:	5e 2f       	reths	1
8000c7bc:	5e 3d       	retlo	0
8000c7be:	1b 07       	ld.w	r7,sp++
8000c7c0:	d8 0a       	popm	pc,r12=0
8000c7c2:	58 17       	cp.w	r7,1
8000c7c4:	5f 0c       	sreq	r12
8000c7c6:	58 09       	cp.w	r9,0
8000c7c8:	f5 b8 00 00 	subfeq	r8,0
8000c7cc:	1b 07       	ld.w	r7,sp++
8000c7ce:	1b 0e       	ld.w	lr,sp++
8000c7d0:	5e 0f       	reteq	1
8000c7d2:	5e fc       	retal	r12

8000c7d4 <__avr32_umod64>:
8000c7d4:	d4 31       	pushm	r0-r7,lr
8000c7d6:	1a 97       	mov	r7,sp
8000c7d8:	20 3d       	sub	sp,12
8000c7da:	10 9c       	mov	r12,r8
8000c7dc:	12 95       	mov	r5,r9
8000c7de:	14 9e       	mov	lr,r10
8000c7e0:	16 91       	mov	r1,r11
8000c7e2:	16 96       	mov	r6,r11
8000c7e4:	58 09       	cp.w	r9,0
8000c7e6:	e0 81 00 81 	brne	8000c8e8 <__avr32_umod64+0x114>
8000c7ea:	16 38       	cp.w	r8,r11
8000c7ec:	e0 88 00 12 	brls	8000c810 <__avr32_umod64+0x3c>
8000c7f0:	f0 08 12 00 	clz	r8,r8
8000c7f4:	c4 e0       	breq	8000c890 <__avr32_umod64+0xbc>
8000c7f6:	f6 08 09 46 	lsl	r6,r11,r8
8000c7fa:	f8 08 09 4c 	lsl	r12,r12,r8
8000c7fe:	f0 0b 11 20 	rsub	r11,r8,32
8000c802:	f4 08 09 4e 	lsl	lr,r10,r8
8000c806:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000c80a:	f7 e6 10 06 	or	r6,r11,r6
8000c80e:	c4 18       	rjmp	8000c890 <__avr32_umod64+0xbc>
8000c810:	58 08       	cp.w	r8,0
8000c812:	c0 51       	brne	8000c81c <__avr32_umod64+0x48>
8000c814:	30 19       	mov	r9,1
8000c816:	f2 08 0d 08 	divu	r8,r9,r8
8000c81a:	10 9c       	mov	r12,r8
8000c81c:	f8 08 12 00 	clz	r8,r12
8000c820:	c0 31       	brne	8000c826 <__avr32_umod64+0x52>
8000c822:	18 16       	sub	r6,r12
8000c824:	c3 68       	rjmp	8000c890 <__avr32_umod64+0xbc>
8000c826:	f0 03 11 20 	rsub	r3,r8,32
8000c82a:	f4 03 0a 4b 	lsr	r11,r10,r3
8000c82e:	f8 08 09 4c 	lsl	r12,r12,r8
8000c832:	ec 08 09 49 	lsl	r9,r6,r8
8000c836:	ec 03 0a 43 	lsr	r3,r6,r3
8000c83a:	f7 e9 10 09 	or	r9,r11,r9
8000c83e:	f8 05 16 10 	lsr	r5,r12,0x10
8000c842:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c846:	e6 05 0d 02 	divu	r2,r3,r5
8000c84a:	f2 0e 16 10 	lsr	lr,r9,0x10
8000c84e:	ec 02 02 4b 	mul	r11,r6,r2
8000c852:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000c856:	16 3e       	cp.w	lr,r11
8000c858:	c0 72       	brcc	8000c866 <__avr32_umod64+0x92>
8000c85a:	18 0e       	add	lr,r12
8000c85c:	18 3e       	cp.w	lr,r12
8000c85e:	c0 43       	brcs	8000c866 <__avr32_umod64+0x92>
8000c860:	16 3e       	cp.w	lr,r11
8000c862:	fd dc e3 0e 	addcs	lr,lr,r12
8000c866:	fc 0b 01 03 	sub	r3,lr,r11
8000c86a:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000c86e:	e6 05 0d 02 	divu	r2,r3,r5
8000c872:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c876:	a5 36       	mul	r6,r2
8000c878:	0c 39       	cp.w	r9,r6
8000c87a:	c0 72       	brcc	8000c888 <__avr32_umod64+0xb4>
8000c87c:	18 09       	add	r9,r12
8000c87e:	18 39       	cp.w	r9,r12
8000c880:	c0 43       	brcs	8000c888 <__avr32_umod64+0xb4>
8000c882:	0c 39       	cp.w	r9,r6
8000c884:	f3 dc e3 09 	addcs	r9,r9,r12
8000c888:	f2 06 01 06 	sub	r6,r9,r6
8000c88c:	f4 08 09 4e 	lsl	lr,r10,r8
8000c890:	f8 0a 16 10 	lsr	r10,r12,0x10
8000c894:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c898:	ec 0a 0d 02 	divu	r2,r6,r10
8000c89c:	fc 09 16 10 	lsr	r9,lr,0x10
8000c8a0:	ea 02 02 4b 	mul	r11,r5,r2
8000c8a4:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c8a8:	16 39       	cp.w	r9,r11
8000c8aa:	c0 72       	brcc	8000c8b8 <__avr32_umod64+0xe4>
8000c8ac:	18 09       	add	r9,r12
8000c8ae:	18 39       	cp.w	r9,r12
8000c8b0:	c0 43       	brcs	8000c8b8 <__avr32_umod64+0xe4>
8000c8b2:	16 39       	cp.w	r9,r11
8000c8b4:	f3 dc e3 09 	addcs	r9,r9,r12
8000c8b8:	f2 0b 01 0b 	sub	r11,r9,r11
8000c8bc:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c8c0:	f6 0a 0d 0a 	divu	r10,r11,r10
8000c8c4:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000c8c8:	ea 0a 02 4a 	mul	r10,r5,r10
8000c8cc:	14 3e       	cp.w	lr,r10
8000c8ce:	c0 72       	brcc	8000c8dc <__avr32_umod64+0x108>
8000c8d0:	18 0e       	add	lr,r12
8000c8d2:	18 3e       	cp.w	lr,r12
8000c8d4:	c0 43       	brcs	8000c8dc <__avr32_umod64+0x108>
8000c8d6:	14 3e       	cp.w	lr,r10
8000c8d8:	fd dc e3 0e 	addcs	lr,lr,r12
8000c8dc:	fc 0a 01 0a 	sub	r10,lr,r10
8000c8e0:	30 0b       	mov	r11,0
8000c8e2:	f4 08 0a 4a 	lsr	r10,r10,r8
8000c8e6:	c7 b8       	rjmp	8000c9dc <__avr32_umod64+0x208>
8000c8e8:	16 39       	cp.w	r9,r11
8000c8ea:	e0 8b 00 79 	brhi	8000c9dc <__avr32_umod64+0x208>
8000c8ee:	f2 09 12 00 	clz	r9,r9
8000c8f2:	c1 21       	brne	8000c916 <__avr32_umod64+0x142>
8000c8f4:	10 3a       	cp.w	r10,r8
8000c8f6:	5f 2b       	srhs	r11
8000c8f8:	0a 31       	cp.w	r1,r5
8000c8fa:	5f ba       	srhi	r10
8000c8fc:	f7 ea 10 0a 	or	r10,r11,r10
8000c900:	f2 0a 18 00 	cp.b	r10,r9
8000c904:	c0 60       	breq	8000c910 <__avr32_umod64+0x13c>
8000c906:	fc 08 01 0c 	sub	r12,lr,r8
8000c90a:	e2 05 01 46 	sbc	r6,r1,r5
8000c90e:	18 9e       	mov	lr,r12
8000c910:	0c 9b       	mov	r11,r6
8000c912:	1c 9a       	mov	r10,lr
8000c914:	c6 48       	rjmp	8000c9dc <__avr32_umod64+0x208>
8000c916:	ea 09 09 4c 	lsl	r12,r5,r9
8000c91a:	f2 06 11 20 	rsub	r6,r9,32
8000c91e:	f6 09 09 4b 	lsl	r11,r11,r9
8000c922:	f0 09 09 42 	lsl	r2,r8,r9
8000c926:	ef 46 ff f4 	st.w	r7[-12],r6
8000c92a:	f0 06 0a 48 	lsr	r8,r8,r6
8000c92e:	18 48       	or	r8,r12
8000c930:	e2 06 0a 4c 	lsr	r12,r1,r6
8000c934:	f4 09 09 43 	lsl	r3,r10,r9
8000c938:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000c93c:	f4 06 0a 4a 	lsr	r10,r10,r6
8000c940:	16 4a       	or	r10,r11
8000c942:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c946:	f8 0b 0d 04 	divu	r4,r12,r11
8000c94a:	f4 0c 16 10 	lsr	r12,r10,0x10
8000c94e:	08 91       	mov	r1,r4
8000c950:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000c954:	e8 0e 02 46 	mul	r6,r4,lr
8000c958:	0c 3c       	cp.w	r12,r6
8000c95a:	c0 a2       	brcc	8000c96e <__avr32_umod64+0x19a>
8000c95c:	20 11       	sub	r1,1
8000c95e:	10 0c       	add	r12,r8
8000c960:	10 3c       	cp.w	r12,r8
8000c962:	c0 63       	brcs	8000c96e <__avr32_umod64+0x19a>
8000c964:	0c 3c       	cp.w	r12,r6
8000c966:	f7 b1 03 01 	sublo	r1,1
8000c96a:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000c96e:	0c 1c       	sub	r12,r6
8000c970:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000c974:	f8 0b 0d 04 	divu	r4,r12,r11
8000c978:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000c97c:	08 96       	mov	r6,r4
8000c97e:	e8 0e 02 4e 	mul	lr,r4,lr
8000c982:	1c 3b       	cp.w	r11,lr
8000c984:	c0 a2       	brcc	8000c998 <__avr32_umod64+0x1c4>
8000c986:	20 16       	sub	r6,1
8000c988:	10 0b       	add	r11,r8
8000c98a:	10 3b       	cp.w	r11,r8
8000c98c:	c0 63       	brcs	8000c998 <__avr32_umod64+0x1c4>
8000c98e:	1c 3b       	cp.w	r11,lr
8000c990:	f7 b6 03 01 	sublo	r6,1
8000c994:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000c998:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000c99c:	1c 1b       	sub	r11,lr
8000c99e:	e2 02 06 40 	mulu.d	r0,r1,r2
8000c9a2:	00 9e       	mov	lr,r0
8000c9a4:	02 9c       	mov	r12,r1
8000c9a6:	16 3c       	cp.w	r12,r11
8000c9a8:	e0 8b 00 08 	brhi	8000c9b8 <__avr32_umod64+0x1e4>
8000c9ac:	5f 06       	sreq	r6
8000c9ae:	06 30       	cp.w	r0,r3
8000c9b0:	5f ba       	srhi	r10
8000c9b2:	ed ea 00 0a 	and	r10,r6,r10
8000c9b6:	c0 60       	breq	8000c9c2 <__avr32_umod64+0x1ee>
8000c9b8:	fc 02 01 04 	sub	r4,lr,r2
8000c9bc:	f8 08 01 4c 	sbc	r12,r12,r8
8000c9c0:	08 9e       	mov	lr,r4
8000c9c2:	e6 0e 01 0a 	sub	r10,r3,lr
8000c9c6:	f6 0c 01 4c 	sbc	r12,r11,r12
8000c9ca:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000c9ce:	f8 09 0a 4b 	lsr	r11,r12,r9
8000c9d2:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c9d6:	f8 01 09 4c 	lsl	r12,r12,r1
8000c9da:	18 4a       	or	r10,r12
8000c9dc:	2f dd       	sub	sp,-12
8000c9de:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000ca00 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
8000ca00:	c0 08       	rjmp	8000ca00 <_evba>
	...

8000ca04 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
8000ca04:	c0 08       	rjmp	8000ca04 <_handle_TLB_Multiple_Hit>
	...

8000ca08 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
8000ca08:	c0 08       	rjmp	8000ca08 <_handle_Bus_Error_Data_Fetch>
	...

8000ca0c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
8000ca0c:	c0 08       	rjmp	8000ca0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000ca10 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
8000ca10:	c0 08       	rjmp	8000ca10 <_handle_NMI>
	...

8000ca14 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
8000ca14:	c0 08       	rjmp	8000ca14 <_handle_Instruction_Address>
	...

8000ca18 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
8000ca18:	c0 08       	rjmp	8000ca18 <_handle_ITLB_Protection>
	...

8000ca1c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
8000ca1c:	c0 08       	rjmp	8000ca1c <_handle_Breakpoint>
	...

8000ca20 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
8000ca20:	c0 08       	rjmp	8000ca20 <_handle_Illegal_Opcode>
	...

8000ca24 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
8000ca24:	c0 08       	rjmp	8000ca24 <_handle_Unimplemented_Instruction>
	...

8000ca28 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
8000ca28:	c0 08       	rjmp	8000ca28 <_handle_Privilege_Violation>
	...

8000ca2c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR UC3.
_handle_Floating_Point:
	rjmp $
8000ca2c:	c0 08       	rjmp	8000ca2c <_handle_Floating_Point>
	...

8000ca30 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR UC3.
_handle_Coprocessor_Absent:
	rjmp $
8000ca30:	c0 08       	rjmp	8000ca30 <_handle_Coprocessor_Absent>
	...

8000ca34 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
8000ca34:	c0 08       	rjmp	8000ca34 <_handle_Data_Address_Read>
	...

8000ca38 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
8000ca38:	c0 08       	rjmp	8000ca38 <_handle_Data_Address_Write>
	...

8000ca3c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
8000ca3c:	c0 08       	rjmp	8000ca3c <_handle_DTLB_Protection_Read>
	...

8000ca40 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
8000ca40:	c0 08       	rjmp	8000ca40 <_handle_DTLB_Protection_Write>
	...

8000ca44 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
8000ca44:	c0 08       	rjmp	8000ca44 <_handle_DTLB_Modified>
	...

8000ca50 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
8000ca50:	c0 08       	rjmp	8000ca50 <_handle_ITLB_Miss>
	...

8000ca60 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
8000ca60:	c0 08       	rjmp	8000ca60 <_handle_DTLB_Miss_Read>
	...

8000ca70 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
8000ca70:	c0 08       	rjmp	8000ca70 <_handle_DTLB_Miss_Write>
	...

8000cb00 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000cb00:	fe cf 6d 3c 	sub	pc,pc,27964

8000cb04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000cb04:	30 0c       	mov	r12,0
8000cb06:	fe b0 bb 73 	rcall	800041ec <_get_interrupt_handler>
8000cb0a:	58 0c       	cp.w	r12,0
8000cb0c:	f8 0f 17 10 	movne	pc,r12
8000cb10:	d6 03       	rete

8000cb12 <_int1>:
8000cb12:	30 1c       	mov	r12,1
8000cb14:	fe b0 bb 6c 	rcall	800041ec <_get_interrupt_handler>
8000cb18:	58 0c       	cp.w	r12,0
8000cb1a:	f8 0f 17 10 	movne	pc,r12
8000cb1e:	d6 03       	rete

8000cb20 <_int2>:
8000cb20:	30 2c       	mov	r12,2
8000cb22:	fe b0 bb 65 	rcall	800041ec <_get_interrupt_handler>
8000cb26:	58 0c       	cp.w	r12,0
8000cb28:	f8 0f 17 10 	movne	pc,r12
8000cb2c:	d6 03       	rete

8000cb2e <_int3>:
8000cb2e:	30 3c       	mov	r12,3
8000cb30:	fe b0 bb 5e 	rcall	800041ec <_get_interrupt_handler>
8000cb34:	58 0c       	cp.w	r12,0
8000cb36:	f8 0f 17 10 	movne	pc,r12
8000cb3a:	d6 03       	rete
8000cb3c:	d7 03       	nop
8000cb3e:	d7 03       	nop
8000cb40:	d7 03       	nop
8000cb42:	d7 03       	nop
8000cb44:	d7 03       	nop
8000cb46:	d7 03       	nop
8000cb48:	d7 03       	nop
8000cb4a:	d7 03       	nop
8000cb4c:	d7 03       	nop
8000cb4e:	d7 03       	nop
8000cb50:	d7 03       	nop
8000cb52:	d7 03       	nop
8000cb54:	d7 03       	nop
8000cb56:	d7 03       	nop
8000cb58:	d7 03       	nop
8000cb5a:	d7 03       	nop
8000cb5c:	d7 03       	nop
8000cb5e:	d7 03       	nop
8000cb60:	d7 03       	nop
8000cb62:	d7 03       	nop
8000cb64:	d7 03       	nop
8000cb66:	d7 03       	nop
8000cb68:	d7 03       	nop
8000cb6a:	d7 03       	nop
8000cb6c:	d7 03       	nop
8000cb6e:	d7 03       	nop
8000cb70:	d7 03       	nop
8000cb72:	d7 03       	nop
8000cb74:	d7 03       	nop
8000cb76:	d7 03       	nop
8000cb78:	d7 03       	nop
8000cb7a:	d7 03       	nop
8000cb7c:	d7 03       	nop
8000cb7e:	d7 03       	nop
8000cb80:	d7 03       	nop
8000cb82:	d7 03       	nop
8000cb84:	d7 03       	nop
8000cb86:	d7 03       	nop
8000cb88:	d7 03       	nop
8000cb8a:	d7 03       	nop
8000cb8c:	d7 03       	nop
8000cb8e:	d7 03       	nop
8000cb90:	d7 03       	nop
8000cb92:	d7 03       	nop
8000cb94:	d7 03       	nop
8000cb96:	d7 03       	nop
8000cb98:	d7 03       	nop
8000cb9a:	d7 03       	nop
8000cb9c:	d7 03       	nop
8000cb9e:	d7 03       	nop
8000cba0:	d7 03       	nop
8000cba2:	d7 03       	nop
8000cba4:	d7 03       	nop
8000cba6:	d7 03       	nop
8000cba8:	d7 03       	nop
8000cbaa:	d7 03       	nop
8000cbac:	d7 03       	nop
8000cbae:	d7 03       	nop
8000cbb0:	d7 03       	nop
8000cbb2:	d7 03       	nop
8000cbb4:	d7 03       	nop
8000cbb6:	d7 03       	nop
8000cbb8:	d7 03       	nop
8000cbba:	d7 03       	nop
8000cbbc:	d7 03       	nop
8000cbbe:	d7 03       	nop
8000cbc0:	d7 03       	nop
8000cbc2:	d7 03       	nop
8000cbc4:	d7 03       	nop
8000cbc6:	d7 03       	nop
8000cbc8:	d7 03       	nop
8000cbca:	d7 03       	nop
8000cbcc:	d7 03       	nop
8000cbce:	d7 03       	nop
8000cbd0:	d7 03       	nop
8000cbd2:	d7 03       	nop
8000cbd4:	d7 03       	nop
8000cbd6:	d7 03       	nop
8000cbd8:	d7 03       	nop
8000cbda:	d7 03       	nop
8000cbdc:	d7 03       	nop
8000cbde:	d7 03       	nop
8000cbe0:	d7 03       	nop
8000cbe2:	d7 03       	nop
8000cbe4:	d7 03       	nop
8000cbe6:	d7 03       	nop
8000cbe8:	d7 03       	nop
8000cbea:	d7 03       	nop
8000cbec:	d7 03       	nop
8000cbee:	d7 03       	nop
8000cbf0:	d7 03       	nop
8000cbf2:	d7 03       	nop
8000cbf4:	d7 03       	nop
8000cbf6:	d7 03       	nop
8000cbf8:	d7 03       	nop
8000cbfa:	d7 03       	nop
8000cbfc:	d7 03       	nop
8000cbfe:	d7 03       	nop
