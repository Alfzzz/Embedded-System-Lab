
ET024006DHU_EXAMPLE1.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000a9a0  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000ca00  8000ca00  0000ce00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00022ec4  8000cc00  8000cc00  0000d000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .lalign       00000004  8002fac4  8002fac4  0002fec4  2**0
                  ALLOC
  6 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  7 .data         00000530  00000008  8002fac8  00030008  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .bss          00000b28  00000538  00000538  00000000  2**2
                  ALLOC
  9 .heap         0000dfa0  00001060  00001060  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  00030538  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 00001648  00000000  00000000  00030568  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 00003442  00000000  00000000  00031bb0  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   00030a13  00000000  00000000  00034ff2  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 00006f0d  00000000  00000000  00065a05  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   00014b96  00000000  00000000  0006c912  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00003a94  00000000  00000000  000814a8  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    00007541  00000000  00000000  00084f3c  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    0000f248  00000000  00000000  0008c47d  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_macinfo 0167be21  00000000  00000000  0009b6c5  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 21 .debug_ranges 00001948  00000000  00000000  017174e8  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	fe cf b4 b4 	sub	pc,pc,-19276

80000004 <_trampoline>:
80000004:	e0 8f 10 00 	bral	80002004 <program_start>
	...

80002004 <program_start>:
  rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002004:	fe cf d4 b8 	sub	pc,pc,-11080

Disassembly of section .text:

80002008 <sd_mmc_spi_get_capacity>:
80002008:	d4 01       	pushm	lr
8000200a:	4c 18       	lddpc	r8,8000210c <sd_mmc_spi_get_capacity+0x104>
  uint8_t  read_bl_len;
  uint8_t  erase_grp_size;
  uint8_t  erase_grp_mult;

  // extract variables from CSD array
  read_bl_len = csd[5] & 0x0F;
8000200c:	11 db       	ld.ub	r11,r8[0x5]
  if (card_type == SD_CARD_2_SDHC) {
8000200e:	4c 18       	lddpc	r8,80002110 <sd_mmc_spi_get_capacity+0x108>
80002010:	11 8a       	ld.ub	r10,r8[0x0]
80002012:	30 38       	mov	r8,3
80002014:	f0 0a 18 00 	cp.b	r10,r8
80002018:	c2 71       	brne	80002066 <sd_mmc_spi_get_capacity+0x5e>
    c_size = ((csd[7] & 0x3F) << 16) | (csd[8] << 8) | csd[9];
8000201a:	4b d8       	lddpc	r8,8000210c <sd_mmc_spi_get_capacity+0x104>
8000201c:	f1 3a 00 08 	ld.ub	r10,r8[8]
80002020:	f1 39 00 09 	ld.ub	r9,r8[9]
80002024:	f3 ea 10 89 	or	r9,r9,r10<<0x8
80002028:	11 fa       	ld.ub	r10,r8[0x7]
8000202a:	f5 da c0 06 	bfextu	r10,r10,0x0,0x6
8000202e:	f3 ea 11 0a 	or	r10,r9,r10<<0x10
    ++c_size;
80002032:	2f fa       	sub	r10,-1
    capacity = (uint64_t)c_size << 19;
80002034:	f4 0b 16 0d 	lsr	r11,r10,0xd
80002038:	16 99       	mov	r9,r11
8000203a:	f4 08 15 13 	lsl	r8,r10,0x13
8000203e:	4b 6a       	lddpc	r10,80002114 <sd_mmc_spi_get_capacity+0x10c>
80002040:	f4 e9 00 00 	st.d	r10[0],r8
    capacity_mult = (c_size >> 13) & 0x01FF;
80002044:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80002048:	4b 48       	lddpc	r8,80002118 <sd_mmc_spi_get_capacity+0x110>
8000204a:	b0 0b       	st.h	r8[0x0],r11
    sd_mmc_spi_last_block_address = (capacity >> 9) + (capacity_mult << 23) - 1;
8000204c:	f4 ea 00 00 	ld.d	r10,r10[0]
80002050:	90 09       	ld.sh	r9,r8[0x0]
80002052:	f4 08 16 09 	lsr	r8,r10,0x9
80002056:	f1 eb 11 78 	or	r8,r8,r11<<0x17
8000205a:	20 18       	sub	r8,1
8000205c:	b7 79       	lsl	r9,0x17
8000205e:	12 08       	add	r8,r9
80002060:	4a f9       	lddpc	r9,8000211c <sd_mmc_spi_get_capacity+0x114>
80002062:	93 08       	st.w	r9[0x0],r8
80002064:	c4 28       	rjmp	800020e8 <sd_mmc_spi_get_capacity+0xe0>
  } else {
    c_size      = ((csd[6] & 0x03) << 10) + (csd[7] << 2) + ((csd[8] & 0xC0) >> 6);
    c_size_mult = ((csd[9] & 0x03) << 1) + ((csd[10] & 0x80) >> 7);
80002066:	4a a8       	lddpc	r8,8000210c <sd_mmc_spi_get_capacity+0x104>
80002068:	f1 3c 00 0a 	ld.ub	r12,r8[10]
    sd_mmc_spi_last_block_address = ((uint32_t)(c_size + 1) * (uint32_t)((1 << (c_size_mult + 2)))) - 1;
8000206c:	f1 39 00 08 	ld.ub	r9,r8[8]
80002070:	a7 89       	lsr	r9,0x6
80002072:	11 fe       	ld.ub	lr,r8[0x7]
80002074:	f2 0e 00 29 	add	r9,r9,lr<<0x2
80002078:	11 ee       	ld.ub	lr,r8[0x6]
8000207a:	fd de c0 02 	bfextu	lr,lr,0x0,0x2
8000207e:	ab 6e       	lsl	lr,0xa
80002080:	1c 09       	add	r9,lr
80002082:	2f f9       	sub	r9,-1
80002084:	f1 38 00 09 	ld.ub	r8,r8[9]
80002088:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000208c:	f8 0e 16 07 	lsr	lr,r12,0x7
80002090:	fc 08 00 18 	add	r8,lr,r8<<0x1
80002094:	2f e8       	sub	r8,-2
80002096:	f2 08 09 49 	lsl	r9,r9,r8
8000209a:	20 19       	sub	r9,1
8000209c:	4a 08       	lddpc	r8,8000211c <sd_mmc_spi_get_capacity+0x114>
8000209e:	91 09       	st.w	r8[0x0],r9
    capacity = (1 << read_bl_len) * (sd_mmc_spi_last_block_address + 1);
800020a0:	70 0e       	ld.w	lr,r8[0x0]
800020a2:	f7 db c0 04 	bfextu	r11,r11,0x0,0x4
800020a6:	2f fe       	sub	lr,-1
800020a8:	fc 0b 09 48 	lsl	r8,lr,r11
800020ac:	30 09       	mov	r9,0
800020ae:	49 ae       	lddpc	lr,80002114 <sd_mmc_spi_get_capacity+0x10c>
800020b0:	fc e9 00 00 	st.d	lr[0],r8
    capacity_mult = 0;
800020b4:	49 98       	lddpc	r8,80002118 <sd_mmc_spi_get_capacity+0x110>
800020b6:	b0 09       	st.h	r8[0x0],r9
    if (read_bl_len > 9) {  // 9 means 2^9 = 512b
800020b8:	30 98       	mov	r8,9
800020ba:	f0 0b 18 00 	cp.b	r11,r8
800020be:	e0 88 00 08 	brls	800020ce <sd_mmc_spi_get_capacity+0xc6>
      sd_mmc_spi_last_block_address <<= (read_bl_len - 9);
800020c2:	49 78       	lddpc	r8,8000211c <sd_mmc_spi_get_capacity+0x114>
800020c4:	70 09       	ld.w	r9,r8[0x0]
800020c6:	20 9b       	sub	r11,9
800020c8:	f2 0b 09 4b 	lsl	r11,r9,r11
800020cc:	91 0b       	st.w	r8[0x0],r11
    }
  }
  if (card_type == MMC_CARD)
800020ce:	58 0a       	cp.w	r10,0
800020d0:	c0 c1       	brne	800020e8 <sd_mmc_spi_get_capacity+0xe0>
  {
    erase_grp_size = ((csd[10] & 0x7C) >> 2);
800020d2:	f1 dc c0 45 	bfextu	r8,r12,0x2,0x5
    erase_grp_mult = ((csd[10] & 0x03) << 3) | ((csd[11] & 0xE0) >> 5);
800020d6:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
800020da:	48 d9       	lddpc	r9,8000210c <sd_mmc_spi_get_capacity+0x104>
800020dc:	f3 39 00 0b 	ld.ub	r9,r9[11]
800020e0:	a3 7c       	lsl	r12,0x3
800020e2:	f9 e9 12 59 	or	r9,r12,r9>>0x5
800020e6:	c0 c8       	rjmp	800020fe <sd_mmc_spi_get_capacity+0xf6>
  }
  else
  {
    erase_grp_size = ((csd[10] & 0x3F) << 1) + ((csd[11] & 0x80) >> 7);
800020e8:	48 9a       	lddpc	r10,8000210c <sd_mmc_spi_get_capacity+0x104>
800020ea:	f5 39 00 0a 	ld.ub	r9,r10[10]
800020ee:	f3 d9 c0 06 	bfextu	r9,r9,0x0,0x6
800020f2:	f5 38 00 0b 	ld.ub	r8,r10[11]
800020f6:	a7 98       	lsr	r8,0x7
800020f8:	f0 09 00 18 	add	r8,r8,r9<<0x1
800020fc:	30 09       	mov	r9,0
    erase_grp_mult = 0;
  }
  erase_group_size = (erase_grp_size + 1) * (erase_grp_mult + 1);
800020fe:	2f f9       	sub	r9,-1
80002100:	2f f8       	sub	r8,-1
80002102:	b1 39       	mul	r9,r8
80002104:	48 78       	lddpc	r8,80002120 <sd_mmc_spi_get_capacity+0x118>
80002106:	b0 09       	st.h	r8[0x0],r9
}
80002108:	d8 02       	popm	pc
8000210a:	00 00       	add	r0,r0
8000210c:	00 00       	add	r0,r0
8000210e:	0a 24       	rsub	r4,r5
80002110:	00 00       	add	r0,r0
80002112:	0a 22       	rsub	r2,r5
80002114:	00 00       	add	r0,r0
80002116:	0a 10       	sub	r0,r5
80002118:	00 00       	add	r0,r0
8000211a:	0a 18       	sub	r8,r5
8000211c:	00 00       	add	r0,r0
8000211e:	0a 1c       	sub	r12,r5
80002120:	00 00       	add	r0,r0
80002122:	0a 1a       	sub	r10,r5

80002124 <sd_mmc_spi_write_close>:
//! page programming.
//!
void sd_mmc_spi_write_close (void)
{

}
80002124:	5e fc       	retal	r12
80002126:	d7 03       	nop

80002128 <sd_mmc_spi_send_and_read>:
//! @param  data_to_send   byte to send over SPI
//!
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
80002128:	d4 01       	pushm	lr
8000212a:	20 1d       	sub	sp,4
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
8000212c:	18 9b       	mov	r11,r12
8000212e:	fe 7c 24 00 	mov	r12,-56320
80002132:	f0 1f 00 09 	mcall	80002154 <sd_mmc_spi_send_and_read+0x2c>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80002136:	fa cb ff fe 	sub	r11,sp,-2
8000213a:	fe 7c 24 00 	mov	r12,-56320
8000213e:	f0 1f 00 07 	mcall	80002158 <sd_mmc_spi_send_and_read+0x30>
80002142:	58 1c       	cp.w	r12,1
80002144:	c0 41       	brne	8000214c <sd_mmc_spi_send_and_read+0x24>
80002146:	e0 6c 00 ff 	mov	r12,255
8000214a:	c0 28       	rjmp	8000214e <sd_mmc_spi_send_and_read+0x26>
     return 0xFF;
   return data_read;
8000214c:	1b bc       	ld.ub	r12,sp[0x3]
}
8000214e:	2f fd       	sub	sp,-4
80002150:	d8 02       	popm	pc
80002152:	00 00       	add	r0,r0
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	2d 2e       	sub	lr,-46
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	2d 4a       	sub	r10,-44

8000215c <sd_mmc_spi_wait_not_busy>:
//! @brief This function waits until the SD/MMC is not busy.
//!
//! @return bit
//!          true when card is not busy
bool sd_mmc_spi_wait_not_busy(void)
{
8000215c:	d4 21       	pushm	r4-r7,lr
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
8000215e:	30 1b       	mov	r11,1
80002160:	fe 7c 24 00 	mov	r12,-56320
80002164:	f0 1f 00 10 	mcall	800021a4 <sd_mmc_spi_wait_not_busy+0x48>
80002168:	30 07       	mov	r7,0
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
8000216a:	e0 65 00 ff 	mov	r5,255
8000216e:	48 f4       	lddpc	r4,800021a8 <sd_mmc_spi_wait_not_busy+0x4c>
80002170:	3f f6       	mov	r6,-1
80002172:	c0 b8       	rjmp	80002188 <sd_mmc_spi_wait_not_busy+0x2c>
  {
    retry++;
80002174:	2f f7       	sub	r7,-1
    if (retry == 200000)
80002176:	e2 57 0d 40 	cp.w	r7,200000
8000217a:	c0 71       	brne	80002188 <sd_mmc_spi_wait_not_busy+0x2c>
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
8000217c:	30 1b       	mov	r11,1
8000217e:	fe 7c 24 00 	mov	r12,-56320
80002182:	f0 1f 00 0b 	mcall	800021ac <sd_mmc_spi_wait_not_busy+0x50>
80002186:	d8 2a       	popm	r4-r7,pc,r12=0
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
80002188:	0a 9c       	mov	r12,r5
8000218a:	f0 1f 00 0a 	mcall	800021b0 <sd_mmc_spi_wait_not_busy+0x54>
8000218e:	a8 8c       	st.b	r4[0x0],r12
80002190:	ec 0c 18 00 	cp.b	r12,r6
80002194:	cf 01       	brne	80002174 <sd_mmc_spi_wait_not_busy+0x18>
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
      return false;
    }
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80002196:	30 1b       	mov	r11,1
80002198:	fe 7c 24 00 	mov	r12,-56320
8000219c:	f0 1f 00 04 	mcall	800021ac <sd_mmc_spi_wait_not_busy+0x50>
800021a0:	da 2a       	popm	r4-r7,pc,r12=1
800021a2:	00 00       	add	r0,r0
800021a4:	80 00       	ld.sh	r0,r0[0x0]
800021a6:	2b fc       	sub	r12,-65
800021a8:	00 00       	add	r0,r0
800021aa:	0a 34       	cp.w	r4,r5
800021ac:	80 00       	ld.sh	r0,r0[0x0]
800021ae:	2c 48       	sub	r8,-60
800021b0:	80 00       	ld.sh	r0,r0[0x0]
800021b2:	21 28       	sub	r8,18

800021b4 <sd_mmc_spi_write_open>:
//! @param  pos   Sector address
//!
//! @return bit
//!   The open succeeded      -> true
bool sd_mmc_spi_write_open (uint32_t pos)
{
800021b4:	d4 01       	pushm	lr
  // Set the global memory ptr at a Byte address.
  gl_ptr_mem = (uint64_t)pos << 9; // gl_ptr_mem = pos * 512
800021b6:	48 58       	lddpc	r8,800021c8 <sd_mmc_spi_write_open+0x14>
800021b8:	f8 09 16 17 	lsr	r9,r12,0x17
800021bc:	91 09       	st.w	r8[0x0],r9
800021be:	a9 7c       	lsl	r12,0x9
800021c0:	91 1c       	st.w	r8[0x4],r12

  // wait for MMC not busy
  return sd_mmc_spi_wait_not_busy();
800021c2:	f0 1f 00 03 	mcall	800021cc <sd_mmc_spi_write_open+0x18>
}
800021c6:	d8 02       	popm	pc
800021c8:	00 00       	add	r0,r0
800021ca:	05 38       	ld.ub	r8,r2++
800021cc:	80 00       	ld.sh	r0,r0[0x0]
800021ce:	21 5c       	sub	r12,21

800021d0 <sd_mmc_spi_read_close>:

//!
//! @brief This function unselects the current SD_MMC memory.
//!
bool sd_mmc_spi_read_close (void)
{
800021d0:	d4 01       	pushm	lr
  if (false == sd_mmc_spi_wait_not_busy())
800021d2:	f0 1f 00 02 	mcall	800021d8 <sd_mmc_spi_read_close+0x8>
    return false;
  return true;
}
800021d6:	d8 02       	popm	pc
800021d8:	80 00       	ld.sh	r0,r0[0x0]
800021da:	21 5c       	sub	r12,21

800021dc <sd_mmc_spi_read_open>:
//! @param  pos   Sector address
//!
//! @return bit
//!   The open succeeded      -> true
bool sd_mmc_spi_read_open (uint32_t pos)
{
800021dc:	d4 01       	pushm	lr
  // Set the global memory ptr at a Byte address.
  gl_ptr_mem = (uint64_t)pos << 9;        // gl_ptr_mem = pos * 512
800021de:	48 58       	lddpc	r8,800021f0 <sd_mmc_spi_read_open+0x14>
800021e0:	f8 09 16 17 	lsr	r9,r12,0x17
800021e4:	91 09       	st.w	r8[0x0],r9
800021e6:	a9 7c       	lsl	r12,0x9
800021e8:	91 1c       	st.w	r8[0x4],r12

  // wait for MMC not busy
  return sd_mmc_spi_wait_not_busy();
800021ea:	f0 1f 00 03 	mcall	800021f4 <sd_mmc_spi_read_open+0x18>
}
800021ee:	d8 02       	popm	pc
800021f0:	00 00       	add	r0,r0
800021f2:	05 38       	ld.ub	r8,r2++
800021f4:	80 00       	ld.sh	r0,r0[0x0]
800021f6:	21 5c       	sub	r12,21

800021f8 <sd_mmc_spi_command>:
//! @param  arg       argument of the command
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF time out error)
uint8_t sd_mmc_spi_command(uint8_t command, uint32_t arg)
{
800021f8:	eb cd 40 f8 	pushm	r3-r7,lr
800021fc:	18 96       	mov	r6,r12
800021fe:	16 97       	mov	r7,r11
  uint8_t retry;

  spi_write(SD_MMC_SPI, 0xFF);            // write dummy byte
80002200:	e0 6b 00 ff 	mov	r11,255
80002204:	fe 7c 24 00 	mov	r12,-56320
80002208:	f0 1f 00 2b 	mcall	800022b4 <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, command | 0x40);  // send command
8000220c:	0c 9b       	mov	r11,r6
8000220e:	a7 ab       	sbr	r11,0x6
80002210:	5c 5b       	castu.b	r11
80002212:	fe 7c 24 00 	mov	r12,-56320
80002216:	f0 1f 00 28 	mcall	800022b4 <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, arg>>24);         // send parameter
8000221a:	ee 0b 16 18 	lsr	r11,r7,0x18
8000221e:	fe 7c 24 00 	mov	r12,-56320
80002222:	f0 1f 00 25 	mcall	800022b4 <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, arg>>16);
80002226:	ee 0b 16 10 	lsr	r11,r7,0x10
8000222a:	fe 7c 24 00 	mov	r12,-56320
8000222e:	f0 1f 00 22 	mcall	800022b4 <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, arg>>8 );
80002232:	f7 d7 c1 10 	bfextu	r11,r7,0x8,0x10
80002236:	fe 7c 24 00 	mov	r12,-56320
8000223a:	f0 1f 00 1f 	mcall	800022b4 <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, arg    );
8000223e:	0e 9b       	mov	r11,r7
80002240:	5c 7b       	castu.h	r11
80002242:	fe 7c 24 00 	mov	r12,-56320
80002246:	f0 1f 00 1c 	mcall	800022b4 <sd_mmc_spi_command+0xbc>
  switch(command)
8000224a:	30 08       	mov	r8,0
8000224c:	f0 06 18 00 	cp.b	r6,r8
80002250:	c0 60       	breq	8000225c <sd_mmc_spi_command+0x64>
80002252:	30 88       	mov	r8,8
80002254:	f0 06 18 00 	cp.b	r6,r8
80002258:	c1 01       	brne	80002278 <sd_mmc_spi_command+0x80>
8000225a:	c0 88       	rjmp	8000226a <sd_mmc_spi_command+0x72>
  {
      case MMC_GO_IDLE_STATE:
         spi_write(SD_MMC_SPI, 0x95);
8000225c:	e0 6b 00 95 	mov	r11,149
80002260:	fe 7c 24 00 	mov	r12,-56320
80002264:	f0 1f 00 14 	mcall	800022b4 <sd_mmc_spi_command+0xbc>
         break;
80002268:	c0 e8       	rjmp	80002284 <sd_mmc_spi_command+0x8c>
      case MMC_SEND_IF_COND:
         spi_write(SD_MMC_SPI, 0x87);
8000226a:	e0 6b 00 87 	mov	r11,135
8000226e:	fe 7c 24 00 	mov	r12,-56320
80002272:	f0 1f 00 11 	mcall	800022b4 <sd_mmc_spi_command+0xbc>
         break;
80002276:	c0 78       	rjmp	80002284 <sd_mmc_spi_command+0x8c>
      default:
         spi_write(SD_MMC_SPI, 0xff);
80002278:	e0 6b 00 ff 	mov	r11,255
8000227c:	fe 7c 24 00 	mov	r12,-56320
80002280:	f0 1f 00 0d 	mcall	800022b4 <sd_mmc_spi_command+0xbc>

  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
80002284:	3f f9       	mov	r9,-1
80002286:	48 d8       	lddpc	r8,800022b8 <sd_mmc_spi_command+0xc0>
80002288:	b0 89       	st.b	r8[0x0],r9
8000228a:	30 07       	mov	r7,0
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
8000228c:	e0 64 00 ff 	mov	r4,255
80002290:	10 93       	mov	r3,r8
80002292:	12 96       	mov	r6,r9
  {
    retry++;
    if(retry > 10) break;
80002294:	30 b5       	mov	r5,11
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80002296:	c0 68       	rjmp	800022a2 <sd_mmc_spi_command+0xaa>
  {
    retry++;
80002298:	2f f7       	sub	r7,-1
8000229a:	5c 57       	castu.b	r7
    if(retry > 10) break;
8000229c:	ea 07 18 00 	cp.b	r7,r5
800022a0:	c0 80       	breq	800022b0 <sd_mmc_spi_command+0xb8>
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
800022a2:	08 9c       	mov	r12,r4
800022a4:	f0 1f 00 06 	mcall	800022bc <sd_mmc_spi_command+0xc4>
800022a8:	a6 8c       	st.b	r3[0x0],r12
800022aa:	ec 0c 18 00 	cp.b	r12,r6
800022ae:	cf 50       	breq	80002298 <sd_mmc_spi_command+0xa0>
  {
    retry++;
    if(retry > 10) break;
  }
  return r1;
}
800022b0:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800022b4:	80 00       	ld.sh	r0,r0[0x0]
800022b6:	2d 2e       	sub	lr,-46
800022b8:	00 00       	add	r0,r0
800022ba:	0a 34       	cp.w	r4,r5
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	21 28       	sub	r8,18

800022c0 <sd_mmc_spi_send_command>:
//! @param  arg       argument of the command
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
800022c0:	eb cd 40 c0 	pushm	r6-r7,lr
800022c4:	18 97       	mov	r7,r12
800022c6:	16 96       	mov	r6,r11
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
800022c8:	30 1b       	mov	r11,1
800022ca:	fe 7c 24 00 	mov	r12,-56320
800022ce:	f0 1f 00 09 	mcall	800022f0 <sd_mmc_spi_send_command+0x30>
  r1 = sd_mmc_spi_command(command, arg);
800022d2:	0c 9b       	mov	r11,r6
800022d4:	0e 9c       	mov	r12,r7
800022d6:	f0 1f 00 08 	mcall	800022f4 <sd_mmc_spi_send_command+0x34>
800022da:	48 87       	lddpc	r7,800022f8 <sd_mmc_spi_send_command+0x38>
800022dc:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800022de:	30 1b       	mov	r11,1
800022e0:	fe 7c 24 00 	mov	r12,-56320
800022e4:	f0 1f 00 06 	mcall	800022fc <sd_mmc_spi_send_command+0x3c>
  return r1;
}
800022e8:	0f 8c       	ld.ub	r12,r7[0x0]
800022ea:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800022ee:	00 00       	add	r0,r0
800022f0:	80 00       	ld.sh	r0,r0[0x0]
800022f2:	2b fc       	sub	r12,-65
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	21 f8       	sub	r8,31
800022f8:	00 00       	add	r0,r0
800022fa:	0a 34       	cp.w	r4,r5
800022fc:	80 00       	ld.sh	r0,r0[0x0]
800022fe:	2c 48       	sub	r8,-60

80002300 <sd_mmc_spi_check_presence>:
//!
//! @return bit
//!   The memory is present (true)
//!   The memory does not respond (disconnected) (false)
bool sd_mmc_spi_check_presence(void)
{
80002300:	eb cd 40 fe 	pushm	r1-r7,lr
  uint16_t retry;

  retry = 0;
  if (sd_mmc_spi_init_done == false)
80002304:	49 a8       	lddpc	r8,8000236c <sd_mmc_spi_check_presence+0x6c>
80002306:	11 89       	ld.ub	r9,r8[0x0]
80002308:	30 08       	mov	r8,0
8000230a:	f0 09 18 00 	cp.b	r9,r8
8000230e:	c1 f1       	brne	8000234c <sd_mmc_spi_check_presence+0x4c>
80002310:	30 07       	mov	r7,0
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
80002312:	0e 94       	mov	r4,r7
80002314:	49 73       	lddpc	r3,80002370 <sd_mmc_spi_check_presence+0x70>
80002316:	30 16       	mov	r6,1
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80002318:	e0 62 00 ff 	mov	r2,255
8000231c:	fe 71 24 00 	mov	r1,-56320
      retry++;
      if (retry > 10)
80002320:	30 b5       	mov	r5,11
80002322:	c0 c8       	rjmp	8000233a <sd_mmc_spi_check_presence+0x3a>
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80002324:	04 9b       	mov	r11,r2
80002326:	02 9c       	mov	r12,r1
80002328:	f0 1f 00 13 	mcall	80002374 <sd_mmc_spi_check_presence+0x74>
      retry++;
8000232c:	2f f7       	sub	r7,-1
8000232e:	5c 87       	casts.h	r7
      if (retry > 10)
80002330:	ea 07 19 00 	cp.h	r7,r5
80002334:	c0 31       	brne	8000233a <sd_mmc_spi_check_presence+0x3a>
80002336:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
8000233a:	08 9b       	mov	r11,r4
8000233c:	08 9c       	mov	r12,r4
8000233e:	f0 1f 00 0f 	mcall	80002378 <sd_mmc_spi_check_presence+0x78>
80002342:	a6 8c       	st.b	r3[0x0],r12
80002344:	ec 0c 18 00 	cp.b	r12,r6
80002348:	ce e1       	brne	80002324 <sd_mmc_spi_check_presence+0x24>
8000234a:	c0 e8       	rjmp	80002366 <sd_mmc_spi_check_presence+0x66>
    return true;
  }
  else
  {
    // If memory already initialized, send a CRC command (CMD59) (supported only if card is initialized)
    if ((r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0)) == 0x00)
8000234c:	30 0b       	mov	r11,0
8000234e:	33 bc       	mov	r12,59
80002350:	f0 1f 00 0a 	mcall	80002378 <sd_mmc_spi_check_presence+0x78>
80002354:	48 78       	lddpc	r8,80002370 <sd_mmc_spi_check_presence+0x70>
80002356:	b0 8c       	st.b	r8[0x0],r12
80002358:	58 0c       	cp.w	r12,0
8000235a:	c0 60       	breq	80002366 <sd_mmc_spi_check_presence+0x66>
      return true;
    sd_mmc_spi_init_done = false;
8000235c:	30 09       	mov	r9,0
8000235e:	48 48       	lddpc	r8,8000236c <sd_mmc_spi_check_presence+0x6c>
80002360:	b0 89       	st.b	r8[0x0],r9
80002362:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
    return false;
80002366:	e3 cf 90 fe 	ldm	sp++,r1-r7,pc,r12=1
8000236a:	00 00       	add	r0,r0
8000236c:	00 00       	add	r0,r0
8000236e:	05 54       	ld.sh	r4,--r2
80002370:	00 00       	add	r0,r0
80002372:	0a 34       	cp.w	r4,r5
80002374:	80 00       	ld.sh	r0,r0[0x0]
80002376:	2d 2e       	sub	lr,-46
80002378:	80 00       	ld.sh	r0,r0[0x0]
8000237a:	22 c0       	sub	r0,44

8000237c <sd_mmc_spi_write_sector_from_ram>:
//! @return bit
//!   The write succeeded   -> true
//!   The write failed      -> false
//!
bool sd_mmc_spi_write_sector_from_ram(const void *ram)
{
8000237c:	eb cd 40 e0 	pushm	r5-r7,lr
80002380:	18 97       	mov	r7,r12
  const uint8_t *_ram = ram;
  uint16_t i;

  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
80002382:	f0 1f 00 4e 	mcall	800024b8 <sd_mmc_spi_write_sector_from_ram+0x13c>
80002386:	e0 80 00 96 	breq	800024b2 <sd_mmc_spi_write_sector_from_ram+0x136>
    return false;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000238a:	30 1b       	mov	r11,1
8000238c:	fe 7c 24 00 	mov	r12,-56320
80002390:	f0 1f 00 4b 	mcall	800024bc <sd_mmc_spi_write_sector_from_ram+0x140>

  // issue command
  if(card_type == SD_CARD_2_SDHC) {
80002394:	4c b8       	lddpc	r8,800024c0 <sd_mmc_spi_write_sector_from_ram+0x144>
80002396:	11 89       	ld.ub	r9,r8[0x0]
80002398:	30 38       	mov	r8,3
8000239a:	f0 09 18 00 	cp.b	r9,r8
8000239e:	c0 d1       	brne	800023b8 <sd_mmc_spi_write_sector_from_ram+0x3c>
    r1 = sd_mmc_spi_command(MMC_WRITE_BLOCK, gl_ptr_mem>>9);
800023a0:	4c 98       	lddpc	r8,800024c4 <sd_mmc_spi_write_sector_from_ram+0x148>
800023a2:	70 0b       	ld.w	r11,r8[0x0]
800023a4:	70 18       	ld.w	r8,r8[0x4]
800023a6:	a9 98       	lsr	r8,0x9
800023a8:	f1 eb 11 7b 	or	r11,r8,r11<<0x17
800023ac:	31 8c       	mov	r12,24
800023ae:	f0 1f 00 47 	mcall	800024c8 <sd_mmc_spi_write_sector_from_ram+0x14c>
800023b2:	4c 78       	lddpc	r8,800024cc <sd_mmc_spi_write_sector_from_ram+0x150>
800023b4:	b0 8c       	st.b	r8[0x0],r12
800023b6:	c0 88       	rjmp	800023c6 <sd_mmc_spi_write_sector_from_ram+0x4a>
  } else {
    r1 = sd_mmc_spi_command(MMC_WRITE_BLOCK, gl_ptr_mem);
800023b8:	4c 38       	lddpc	r8,800024c4 <sd_mmc_spi_write_sector_from_ram+0x148>
800023ba:	70 1b       	ld.w	r11,r8[0x4]
800023bc:	31 8c       	mov	r12,24
800023be:	f0 1f 00 43 	mcall	800024c8 <sd_mmc_spi_write_sector_from_ram+0x14c>
800023c2:	4c 38       	lddpc	r8,800024cc <sd_mmc_spi_write_sector_from_ram+0x150>
800023c4:	b0 8c       	st.b	r8[0x0],r12
  }

  // check for valid response
  if(r1 != 0x00)
800023c6:	4c 28       	lddpc	r8,800024cc <sd_mmc_spi_write_sector_from_ram+0x150>
800023c8:	11 89       	ld.ub	r9,r8[0x0]
800023ca:	30 08       	mov	r8,0
800023cc:	f0 09 18 00 	cp.b	r9,r8
800023d0:	c0 80       	breq	800023e0 <sd_mmc_spi_write_sector_from_ram+0x64>
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
800023d2:	30 1b       	mov	r11,1
800023d4:	fe 7c 24 00 	mov	r12,-56320
800023d8:	f0 1f 00 3e 	mcall	800024d0 <sd_mmc_spi_write_sector_from_ram+0x154>
800023dc:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
    return false;
  }
  // send dummy
  spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction
800023e0:	e0 6b 00 ff 	mov	r11,255
800023e4:	fe 7c 24 00 	mov	r12,-56320
800023e8:	f0 1f 00 3b 	mcall	800024d4 <sd_mmc_spi_write_sector_from_ram+0x158>

  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
800023ec:	e0 6b 00 fe 	mov	r11,254
800023f0:	fe 7c 24 00 	mov	r12,-56320
800023f4:	f0 1f 00 38 	mcall	800024d4 <sd_mmc_spi_write_sector_from_ram+0x158>
//!
//! @return bit
//!   The write succeeded   -> true
//!   The write failed      -> false
//!
bool sd_mmc_spi_write_sector_from_ram(const void *ram)
800023f8:	ee c6 fe 00 	sub	r6,r7,-512
  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
  // write data
  for(i=0;i<MMC_SECTOR_SIZE;i++)
  {
    spi_write(SD_MMC_SPI,*_ram++);
800023fc:	fe 75 24 00 	mov	r5,-56320
80002400:	0f 3b       	ld.ub	r11,r7++
80002402:	0a 9c       	mov	r12,r5
80002404:	f0 1f 00 34 	mcall	800024d4 <sd_mmc_spi_write_sector_from_ram+0x158>
  spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction

  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
  // write data
  for(i=0;i<MMC_SECTOR_SIZE;i++)
80002408:	0c 37       	cp.w	r7,r6
8000240a:	cf b1       	brne	80002400 <sd_mmc_spi_write_sector_from_ram+0x84>
  {
    spi_write(SD_MMC_SPI,*_ram++);
  }

  spi_write(SD_MMC_SPI,0xFF);    // send CRC (field required but value ignored)
8000240c:	e0 6b 00 ff 	mov	r11,255
80002410:	fe 7c 24 00 	mov	r12,-56320
80002414:	f0 1f 00 30 	mcall	800024d4 <sd_mmc_spi_write_sector_from_ram+0x158>
  spi_write(SD_MMC_SPI,0xFF);
80002418:	e0 6b 00 ff 	mov	r11,255
8000241c:	fe 7c 24 00 	mov	r12,-56320
80002420:	f0 1f 00 2d 	mcall	800024d4 <sd_mmc_spi_write_sector_from_ram+0x158>

  // read data response token
  r1 = sd_mmc_spi_send_and_read(0xFF);
80002424:	e0 6c 00 ff 	mov	r12,255
80002428:	f0 1f 00 2c 	mcall	800024d8 <sd_mmc_spi_write_sector_from_ram+0x15c>
8000242c:	4a 88       	lddpc	r8,800024cc <sd_mmc_spi_write_sector_from_ram+0x150>
8000242e:	b0 8c       	st.b	r8[0x0],r12
  if( (r1&MMC_DR_MASK) != MMC_DR_ACCEPT)
80002430:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80002434:	58 5c       	cp.w	r12,5
80002436:	c1 40       	breq	8000245e <sd_mmc_spi_write_sector_from_ram+0xe2>
  {
    spi_write(SD_MMC_SPI,0xFF);    // send dummy bytes
80002438:	e0 6b 00 ff 	mov	r11,255
8000243c:	fe 7c 24 00 	mov	r12,-56320
80002440:	f0 1f 00 25 	mcall	800024d4 <sd_mmc_spi_write_sector_from_ram+0x158>
    spi_write(SD_MMC_SPI,0xFF);
80002444:	e0 6b 00 ff 	mov	r11,255
80002448:	fe 7c 24 00 	mov	r12,-56320
8000244c:	f0 1f 00 22 	mcall	800024d4 <sd_mmc_spi_write_sector_from_ram+0x158>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80002450:	30 1b       	mov	r11,1
80002452:	fe 7c 24 00 	mov	r12,-56320
80002456:	f0 1f 00 1f 	mcall	800024d0 <sd_mmc_spi_write_sector_from_ram+0x154>
8000245a:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
    return false;         // return ERROR byte
  }

  spi_write(SD_MMC_SPI,0xFF);    // send dummy bytes
8000245e:	e0 6b 00 ff 	mov	r11,255
80002462:	fe 7c 24 00 	mov	r12,-56320
80002466:	f0 1f 00 1c 	mcall	800024d4 <sd_mmc_spi_write_sector_from_ram+0x158>
  spi_write(SD_MMC_SPI,0xFF);
8000246a:	e0 6b 00 ff 	mov	r11,255
8000246e:	fe 7c 24 00 	mov	r12,-56320
80002472:	f0 1f 00 19 	mcall	800024d4 <sd_mmc_spi_write_sector_from_ram+0x158>

  // release chip select
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002476:	30 1b       	mov	r11,1
80002478:	fe 7c 24 00 	mov	r12,-56320
8000247c:	f0 1f 00 15 	mcall	800024d0 <sd_mmc_spi_write_sector_from_ram+0x154>
  gl_ptr_mem += 512;        // Update the memory pointer.
80002480:	49 18       	lddpc	r8,800024c4 <sd_mmc_spi_write_sector_from_ram+0x148>
80002482:	f0 e6 00 00 	ld.d	r6,r8[0]
80002486:	e0 6a 02 00 	mov	r10,512
8000248a:	30 0b       	mov	r11,0
8000248c:	ec 0a 00 0a 	add	r10,r6,r10
80002490:	ee 0b 00 4b 	adc	r11,r7,r11
80002494:	f0 eb 00 00 	st.d	r8[0],r10
80002498:	30 07       	mov	r7,0
  // wait card not busy after last programming operation
  i=0;
  while (false == sd_mmc_spi_wait_not_busy())
  {
    i++;
    if (i == 10)
8000249a:	30 a6       	mov	r6,10
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
  gl_ptr_mem += 512;        // Update the memory pointer.

  // wait card not busy after last programming operation
  i=0;
  while (false == sd_mmc_spi_wait_not_busy())
8000249c:	c0 68       	rjmp	800024a8 <sd_mmc_spi_write_sector_from_ram+0x12c>
  {
    i++;
8000249e:	2f f7       	sub	r7,-1
800024a0:	5c 87       	casts.h	r7
    if (i == 10)
800024a2:	ec 07 19 00 	cp.h	r7,r6
800024a6:	c0 60       	breq	800024b2 <sd_mmc_spi_write_sector_from_ram+0x136>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
  gl_ptr_mem += 512;        // Update the memory pointer.

  // wait card not busy after last programming operation
  i=0;
  while (false == sd_mmc_spi_wait_not_busy())
800024a8:	f0 1f 00 04 	mcall	800024b8 <sd_mmc_spi_write_sector_from_ram+0x13c>
800024ac:	cf 90       	breq	8000249e <sd_mmc_spi_write_sector_from_ram+0x122>
800024ae:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
800024b2:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
800024b6:	00 00       	add	r0,r0
800024b8:	80 00       	ld.sh	r0,r0[0x0]
800024ba:	21 5c       	sub	r12,21
800024bc:	80 00       	ld.sh	r0,r0[0x0]
800024be:	2b fc       	sub	r12,-65
800024c0:	00 00       	add	r0,r0
800024c2:	0a 22       	rsub	r2,r5
800024c4:	00 00       	add	r0,r0
800024c6:	05 38       	ld.ub	r8,r2++
800024c8:	80 00       	ld.sh	r0,r0[0x0]
800024ca:	21 f8       	sub	r8,31
800024cc:	00 00       	add	r0,r0
800024ce:	0a 34       	cp.w	r4,r5
800024d0:	80 00       	ld.sh	r0,r0[0x0]
800024d2:	2c 48       	sub	r8,-60
800024d4:	80 00       	ld.sh	r0,r0[0x0]
800024d6:	2d 2e       	sub	lr,-46
800024d8:	80 00       	ld.sh	r0,r0[0x0]
800024da:	21 28       	sub	r8,18

800024dc <sd_mmc_spi_check_hc>:
//!           SD_CARD      Detected card is SD
//!           ERROR


int sd_mmc_spi_check_hc(void)
{
800024dc:	eb cd 40 c0 	pushm	r6-r7,lr
  unsigned char hc_bit;
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
800024e0:	f0 1f 00 1c 	mcall	80002550 <sd_mmc_spi_check_hc+0x74>
800024e4:	c0 31       	brne	800024ea <sd_mmc_spi_check_hc+0xe>
800024e6:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
    return SD_FAILURE;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
800024ea:	30 1b       	mov	r11,1
800024ec:	fe 7c 24 00 	mov	r12,-56320
800024f0:	f0 1f 00 19 	mcall	80002554 <sd_mmc_spi_check_hc+0x78>
  r1 = sd_mmc_spi_command(SD_READ_OCR, 0);
800024f4:	30 0b       	mov	r11,0
800024f6:	33 ac       	mov	r12,58
800024f8:	f0 1f 00 18 	mcall	80002558 <sd_mmc_spi_check_hc+0x7c>
800024fc:	49 88       	lddpc	r8,8000255c <sd_mmc_spi_check_hc+0x80>
800024fe:	b0 8c       	st.b	r8[0x0],r12
  // check for valid response
  if(r1 != 0) {
80002500:	58 0c       	cp.w	r12,0
80002502:	c0 80       	breq	80002512 <sd_mmc_spi_check_hc+0x36>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002504:	30 1b       	mov	r11,1
80002506:	fe 7c 24 00 	mov	r12,-56320
8000250a:	f0 1f 00 16 	mcall	80002560 <sd_mmc_spi_check_hc+0x84>
8000250e:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
    return SD_FAILURE;
  }
  hc_bit = sd_mmc_spi_send_and_read(0xFF);
80002512:	e0 6c 00 ff 	mov	r12,255
80002516:	f0 1f 00 14 	mcall	80002564 <sd_mmc_spi_check_hc+0x88>
8000251a:	18 96       	mov	r6,r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
8000251c:	e0 6c 00 ff 	mov	r12,255
80002520:	f0 1f 00 11 	mcall	80002564 <sd_mmc_spi_check_hc+0x88>
80002524:	48 e7       	lddpc	r7,8000255c <sd_mmc_spi_check_hc+0x80>
80002526:	ae 8c       	st.b	r7[0x0],r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
80002528:	e0 6c 00 ff 	mov	r12,255
8000252c:	f0 1f 00 0e 	mcall	80002564 <sd_mmc_spi_check_hc+0x88>
80002530:	ae 8c       	st.b	r7[0x0],r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
80002532:	e0 6c 00 ff 	mov	r12,255
80002536:	f0 1f 00 0c 	mcall	80002564 <sd_mmc_spi_check_hc+0x88>
8000253a:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000253c:	30 1b       	mov	r11,1
8000253e:	fe 7c 24 00 	mov	r12,-56320
80002542:	f0 1f 00 08 	mcall	80002560 <sd_mmc_spi_check_hc+0x84>
80002546:	f9 d6 c0 c1 	bfextu	r12,r6,0x6,0x1
  if(hc_bit & 0x40) {
      return SDHC_CARD;
  }
  return 0;
}
8000254a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000254e:	00 00       	add	r0,r0
80002550:	80 00       	ld.sh	r0,r0[0x0]
80002552:	21 5c       	sub	r12,21
80002554:	80 00       	ld.sh	r0,r0[0x0]
80002556:	2b fc       	sub	r12,-65
80002558:	80 00       	ld.sh	r0,r0[0x0]
8000255a:	21 f8       	sub	r8,31
8000255c:	00 00       	add	r0,r0
8000255e:	0a 34       	cp.w	r4,r5
80002560:	80 00       	ld.sh	r0,r0[0x0]
80002562:	2c 48       	sub	r8,-60
80002564:	80 00       	ld.sh	r0,r0[0x0]
80002566:	21 28       	sub	r8,18

80002568 <sd_mmc_spi_get_if>:
//!                true
//!                SD_MMC


int sd_mmc_spi_get_if(void)
{
80002568:	eb cd 40 80 	pushm	r7,lr
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
8000256c:	f0 1f 00 27 	mcall	80002608 <sd_mmc_spi_get_if+0xa0>
80002570:	c0 31       	brne	80002576 <sd_mmc_spi_get_if+0xe>
80002572:	e3 cf c0 80 	ldm	sp++,r7,pc,r12=-1
    return SD_FAILURE;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80002576:	30 1b       	mov	r11,1
80002578:	fe 7c 24 00 	mov	r12,-56320
8000257c:	f0 1f 00 24 	mcall	8000260c <sd_mmc_spi_get_if+0xa4>
  r1 = sd_mmc_spi_command(MMC_SEND_IF_COND, 0x000001AA);
80002580:	e0 6b 01 aa 	mov	r11,426
80002584:	30 8c       	mov	r12,8
80002586:	f0 1f 00 23 	mcall	80002610 <sd_mmc_spi_get_if+0xa8>
8000258a:	4a 38       	lddpc	r8,80002614 <sd_mmc_spi_get_if+0xac>
8000258c:	b0 8c       	st.b	r8[0x0],r12
  // check for valid response
  if((r1 & MMC_R1_ILLEGAL_COM) != 0) {
8000258e:	e2 1c 00 04 	andl	r12,0x4,COH
80002592:	c0 80       	breq	800025a2 <sd_mmc_spi_get_if+0x3a>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002594:	30 1b       	mov	r11,1
80002596:	fe 7c 24 00 	mov	r12,-56320
8000259a:	f0 1f 00 20 	mcall	80002618 <sd_mmc_spi_get_if+0xb0>
8000259e:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
    return SD_MMC;
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
800025a2:	e0 6c 00 ff 	mov	r12,255
800025a6:	f0 1f 00 1e 	mcall	8000261c <sd_mmc_spi_get_if+0xb4>
800025aa:	49 b7       	lddpc	r7,80002614 <sd_mmc_spi_get_if+0xac>
800025ac:	ae 8c       	st.b	r7[0x0],r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
800025ae:	e0 6c 00 ff 	mov	r12,255
800025b2:	f0 1f 00 1b 	mcall	8000261c <sd_mmc_spi_get_if+0xb4>
800025b6:	ae 8c       	st.b	r7[0x0],r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
800025b8:	e0 6c 00 ff 	mov	r12,255
800025bc:	f0 1f 00 18 	mcall	8000261c <sd_mmc_spi_get_if+0xb4>
800025c0:	ae 8c       	st.b	r7[0x0],r12
  if((r1 & 0x01) == 0) {
800025c2:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
800025c6:	c0 81       	brne	800025d6 <sd_mmc_spi_get_if+0x6e>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800025c8:	30 1b       	mov	r11,1
800025ca:	fe 7c 24 00 	mov	r12,-56320
800025ce:	f0 1f 00 13 	mcall	80002618 <sd_mmc_spi_get_if+0xb0>
800025d2:	e3 cf c0 80 	ldm	sp++,r7,pc,r12=-1
    return SD_FAILURE;
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
800025d6:	e0 6c 00 ff 	mov	r12,255
800025da:	f0 1f 00 11 	mcall	8000261c <sd_mmc_spi_get_if+0xb4>
800025de:	48 e8       	lddpc	r8,80002614 <sd_mmc_spi_get_if+0xac>
800025e0:	b0 8c       	st.b	r8[0x0],r12
  if(r1 != 0xaa) {
800025e2:	3a a8       	mov	r8,-86
800025e4:	f0 0c 18 00 	cp.b	r12,r8
800025e8:	c0 80       	breq	800025f8 <sd_mmc_spi_get_if+0x90>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800025ea:	30 1b       	mov	r11,1
800025ec:	fe 7c 24 00 	mov	r12,-56320
800025f0:	f0 1f 00 0a 	mcall	80002618 <sd_mmc_spi_get_if+0xb0>
800025f4:	e3 cf c0 80 	ldm	sp++,r7,pc,r12=-1
    return SD_FAILURE; /* wrong test pattern */
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800025f8:	30 1b       	mov	r11,1
800025fa:	fe 7c 24 00 	mov	r12,-56320
800025fe:	f0 1f 00 07 	mcall	80002618 <sd_mmc_spi_get_if+0xb0>
80002602:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
80002606:	00 00       	add	r0,r0
80002608:	80 00       	ld.sh	r0,r0[0x0]
8000260a:	21 5c       	sub	r12,21
8000260c:	80 00       	ld.sh	r0,r0[0x0]
8000260e:	2b fc       	sub	r12,-65
80002610:	80 00       	ld.sh	r0,r0[0x0]
80002612:	21 f8       	sub	r8,31
80002614:	00 00       	add	r0,r0
80002616:	0a 34       	cp.w	r4,r5
80002618:	80 00       	ld.sh	r0,r0[0x0]
8000261a:	2c 48       	sub	r8,-60
8000261c:	80 00       	ld.sh	r0,r0[0x0]
8000261e:	21 28       	sub	r8,18

80002620 <sd_mmc_spi_read_sector_to_ram>:
//! @return bit
//!   The read succeeded   -> true
//!   The read failed (bad address, etc.)  -> false
//!/
bool sd_mmc_spi_read_sector_to_ram(void *ram)
{
80002620:	eb cd 40 f8 	pushm	r3-r7,lr
80002624:	20 1d       	sub	sp,4
80002626:	18 93       	mov	r3,r12
  uint8_t *_ram = ram;
  uint16_t  i;
  uint16_t  read_time_out;
  unsigned short data_read;
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
80002628:	f0 1f 00 4d 	mcall	8000275c <sd_mmc_spi_read_sector_to_ram+0x13c>
8000262c:	e0 80 00 94 	breq	80002754 <sd_mmc_spi_read_sector_to_ram+0x134>
    return false;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80002630:	30 1b       	mov	r11,1
80002632:	fe 7c 24 00 	mov	r12,-56320
80002636:	f0 1f 00 4b 	mcall	80002760 <sd_mmc_spi_read_sector_to_ram+0x140>

  // issue command
  if(card_type == SD_CARD_2_SDHC) {
8000263a:	4c b8       	lddpc	r8,80002764 <sd_mmc_spi_read_sector_to_ram+0x144>
8000263c:	11 89       	ld.ub	r9,r8[0x0]
8000263e:	30 38       	mov	r8,3
80002640:	f0 09 18 00 	cp.b	r9,r8
80002644:	c0 d1       	brne	8000265e <sd_mmc_spi_read_sector_to_ram+0x3e>
    r1 = sd_mmc_spi_command(MMC_READ_SINGLE_BLOCK, gl_ptr_mem>>9);
80002646:	4c 98       	lddpc	r8,80002768 <sd_mmc_spi_read_sector_to_ram+0x148>
80002648:	70 0b       	ld.w	r11,r8[0x0]
8000264a:	70 18       	ld.w	r8,r8[0x4]
8000264c:	a9 98       	lsr	r8,0x9
8000264e:	f1 eb 11 7b 	or	r11,r8,r11<<0x17
80002652:	31 1c       	mov	r12,17
80002654:	f0 1f 00 46 	mcall	8000276c <sd_mmc_spi_read_sector_to_ram+0x14c>
80002658:	4c 68       	lddpc	r8,80002770 <sd_mmc_spi_read_sector_to_ram+0x150>
8000265a:	b0 8c       	st.b	r8[0x0],r12
8000265c:	c0 88       	rjmp	8000266c <sd_mmc_spi_read_sector_to_ram+0x4c>
  } else {
    r1 = sd_mmc_spi_command(MMC_READ_SINGLE_BLOCK, gl_ptr_mem);
8000265e:	4c 38       	lddpc	r8,80002768 <sd_mmc_spi_read_sector_to_ram+0x148>
80002660:	70 1b       	ld.w	r11,r8[0x4]
80002662:	31 1c       	mov	r12,17
80002664:	f0 1f 00 42 	mcall	8000276c <sd_mmc_spi_read_sector_to_ram+0x14c>
80002668:	4c 28       	lddpc	r8,80002770 <sd_mmc_spi_read_sector_to_ram+0x150>
8000266a:	b0 8c       	st.b	r8[0x0],r12
  }

  // check for valid response
  if (r1 != 0x00)
8000266c:	4c 18       	lddpc	r8,80002770 <sd_mmc_spi_read_sector_to_ram+0x150>
8000266e:	11 89       	ld.ub	r9,r8[0x0]
80002670:	30 08       	mov	r8,0
80002672:	f0 09 18 00 	cp.b	r9,r8
80002676:	c1 20       	breq	8000269a <sd_mmc_spi_read_sector_to_ram+0x7a>
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002678:	30 1b       	mov	r11,1
8000267a:	fe 7c 24 00 	mov	r12,-56320
8000267e:	f0 1f 00 3e 	mcall	80002774 <sd_mmc_spi_read_sector_to_ram+0x154>
80002682:	30 0c       	mov	r12,0
    return false;
80002684:	c6 88       	rjmp	80002754 <sd_mmc_spi_read_sector_to_ram+0x134>

  // wait for token (may be a datablock start token OR a data error token !)
  read_time_out = 30000;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
  {
     read_time_out--;
80002686:	20 17       	sub	r7,1
80002688:	5c 87       	casts.h	r7
     if (read_time_out == 0)   // TIME-OUT
8000268a:	c0 e1       	brne	800026a6 <sd_mmc_spi_read_sector_to_ram+0x86>
     {
       spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS); // unselect SD_MMC_SPI
8000268c:	30 1b       	mov	r11,1
8000268e:	fe 7c 24 00 	mov	r12,-56320
80002692:	f0 1f 00 39 	mcall	80002774 <sd_mmc_spi_read_sector_to_ram+0x154>
80002696:	30 0c       	mov	r12,0
       return false;
80002698:	c5 e8       	rjmp	80002754 <sd_mmc_spi_read_sector_to_ram+0x134>
8000269a:	e0 67 75 30 	mov	r7,30000
    return false;
  }

  // wait for token (may be a datablock start token OR a data error token !)
  read_time_out = 30000;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
8000269e:	e0 65 00 ff 	mov	r5,255
800026a2:	4b 44       	lddpc	r4,80002770 <sd_mmc_spi_read_sector_to_ram+0x150>
800026a4:	3f f6       	mov	r6,-1
800026a6:	0a 9c       	mov	r12,r5
800026a8:	f0 1f 00 34 	mcall	80002778 <sd_mmc_spi_read_sector_to_ram+0x158>
800026ac:	a8 8c       	st.b	r4[0x0],r12
800026ae:	ec 0c 18 00 	cp.b	r12,r6
800026b2:	ce a0       	breq	80002686 <sd_mmc_spi_read_sector_to_ram+0x66>
       return false;
     }
  }

  // check token
  if (r1 != MMC_STARTBLOCK_READ)
800026b4:	3f e8       	mov	r8,-2
800026b6:	f0 0c 18 00 	cp.b	r12,r8
800026ba:	c0 e0       	breq	800026d6 <sd_mmc_spi_read_sector_to_ram+0xb6>
  {
    spi_write(SD_MMC_SPI,0xFF);
800026bc:	e0 6b 00 ff 	mov	r11,255
800026c0:	fe 7c 24 00 	mov	r12,-56320
800026c4:	f0 1f 00 2e 	mcall	8000277c <sd_mmc_spi_read_sector_to_ram+0x15c>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800026c8:	30 1b       	mov	r11,1
800026ca:	fe 7c 24 00 	mov	r12,-56320
800026ce:	f0 1f 00 2a 	mcall	80002774 <sd_mmc_spi_read_sector_to_ram+0x154>
800026d2:	30 0c       	mov	r12,0
    return false;
800026d4:	c4 08       	rjmp	80002754 <sd_mmc_spi_read_sector_to_ram+0x134>
//!   The read succeeded   -> true
//!   The read failed (bad address, etc.)  -> false
//!/
bool sd_mmc_spi_read_sector_to_ram(void *ram)
{
  uint8_t *_ram = ram;
800026d6:	06 97       	mov	r7,r3
//!
//! @return bit
//!   The read succeeded   -> true
//!   The read failed (bad address, etc.)  -> false
//!/
bool sd_mmc_spi_read_sector_to_ram(void *ram)
800026d8:	e6 c5 fe 00 	sub	r5,r3,-512
  }

  // store datablock
  for(i=0;i<MMC_SECTOR_SIZE;i++)
  {
    spi_write(SD_MMC_SPI,0xFF);
800026dc:	e0 64 00 ff 	mov	r4,255
800026e0:	fe 76 24 00 	mov	r6,-56320
    spi_read(SD_MMC_SPI,&data_read);
800026e4:	fa c3 ff fe 	sub	r3,sp,-2
  }

  // store datablock
  for(i=0;i<MMC_SECTOR_SIZE;i++)
  {
    spi_write(SD_MMC_SPI,0xFF);
800026e8:	08 9b       	mov	r11,r4
800026ea:	0c 9c       	mov	r12,r6
800026ec:	f0 1f 00 24 	mcall	8000277c <sd_mmc_spi_read_sector_to_ram+0x15c>
    spi_read(SD_MMC_SPI,&data_read);
800026f0:	06 9b       	mov	r11,r3
800026f2:	0c 9c       	mov	r12,r6
800026f4:	f0 1f 00 23 	mcall	80002780 <sd_mmc_spi_read_sector_to_ram+0x160>
    *_ram++=data_read;
800026f8:	9a 18       	ld.sh	r8,sp[0x2]
800026fa:	0e c8       	st.b	r7++,r8
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return false;
  }

  // store datablock
  for(i=0;i<MMC_SECTOR_SIZE;i++)
800026fc:	0a 37       	cp.w	r7,r5
800026fe:	cf 51       	brne	800026e8 <sd_mmc_spi_read_sector_to_ram+0xc8>
  {
    spi_write(SD_MMC_SPI,0xFF);
    spi_read(SD_MMC_SPI,&data_read);
    *_ram++=data_read;
  }
  gl_ptr_mem += 512;     // Update the memory pointer.
80002700:	49 a8       	lddpc	r8,80002768 <sd_mmc_spi_read_sector_to_ram+0x148>
80002702:	f0 e6 00 00 	ld.d	r6,r8[0]
80002706:	e0 6a 02 00 	mov	r10,512
8000270a:	30 0b       	mov	r11,0
8000270c:	ec 0a 00 0a 	add	r10,r6,r10
80002710:	ee 0b 00 4b 	adc	r11,r7,r11
80002714:	f0 eb 00 00 	st.d	r8[0],r10

  // load 16-bit CRC (ignored)
  spi_write(SD_MMC_SPI,0xFF);
80002718:	e0 6b 00 ff 	mov	r11,255
8000271c:	fe 7c 24 00 	mov	r12,-56320
80002720:	f0 1f 00 17 	mcall	8000277c <sd_mmc_spi_read_sector_to_ram+0x15c>
  spi_write(SD_MMC_SPI,0xFF);
80002724:	e0 6b 00 ff 	mov	r11,255
80002728:	fe 7c 24 00 	mov	r12,-56320
8000272c:	f0 1f 00 14 	mcall	8000277c <sd_mmc_spi_read_sector_to_ram+0x15c>

  // continue delivering some clock cycles
  spi_write(SD_MMC_SPI,0xFF);
80002730:	e0 6b 00 ff 	mov	r11,255
80002734:	fe 7c 24 00 	mov	r12,-56320
80002738:	f0 1f 00 11 	mcall	8000277c <sd_mmc_spi_read_sector_to_ram+0x15c>
  spi_write(SD_MMC_SPI,0xFF);
8000273c:	e0 6b 00 ff 	mov	r11,255
80002740:	fe 7c 24 00 	mov	r12,-56320
80002744:	f0 1f 00 0e 	mcall	8000277c <sd_mmc_spi_read_sector_to_ram+0x15c>

  // release chip select
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002748:	30 1b       	mov	r11,1
8000274a:	fe 7c 24 00 	mov	r12,-56320
8000274e:	f0 1f 00 0a 	mcall	80002774 <sd_mmc_spi_read_sector_to_ram+0x154>
80002752:	30 1c       	mov	r12,1

  return true;   // Read done.
}
80002754:	2f fd       	sub	sp,-4
80002756:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000275a:	00 00       	add	r0,r0
8000275c:	80 00       	ld.sh	r0,r0[0x0]
8000275e:	21 5c       	sub	r12,21
80002760:	80 00       	ld.sh	r0,r0[0x0]
80002762:	2b fc       	sub	r12,-65
80002764:	00 00       	add	r0,r0
80002766:	0a 22       	rsub	r2,r5
80002768:	00 00       	add	r0,r0
8000276a:	05 38       	ld.ub	r8,r2++
8000276c:	80 00       	ld.sh	r0,r0[0x0]
8000276e:	21 f8       	sub	r8,31
80002770:	00 00       	add	r0,r0
80002772:	0a 34       	cp.w	r4,r5
80002774:	80 00       	ld.sh	r0,r0[0x0]
80002776:	2c 48       	sub	r8,-60
80002778:	80 00       	ld.sh	r0,r0[0x0]
8000277a:	21 28       	sub	r8,18
8000277c:	80 00       	ld.sh	r0,r0[0x0]
8000277e:	2d 2e       	sub	lr,-46
80002780:	80 00       	ld.sh	r0,r0[0x0]
80002782:	2d 4a       	sub	r10,-44

80002784 <sd_mmc_spi_get_csd>:
//! @param  buffer to fill
//!
//! @return bit
//!         true / false
bool sd_mmc_spi_get_csd(uint8_t *buffer)
{
80002784:	eb cd 40 fc 	pushm	r2-r7,lr
80002788:	20 1d       	sub	sp,4
8000278a:	18 92       	mov	r2,r12
uint8_t retry;
unsigned short data_read;
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
8000278c:	f0 1f 00 32 	mcall	80002854 <sd_mmc_spi_get_csd+0xd0>
80002790:	c5 f0       	breq	8000284e <sd_mmc_spi_get_csd+0xca>
    return false;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80002792:	30 1b       	mov	r11,1
80002794:	fe 7c 24 00 	mov	r12,-56320
80002798:	f0 1f 00 30 	mcall	80002858 <sd_mmc_spi_get_csd+0xd4>
  // issue command
  r1 = sd_mmc_spi_command(MMC_SEND_CSD, 0);
8000279c:	30 0b       	mov	r11,0
8000279e:	30 9c       	mov	r12,9
800027a0:	f0 1f 00 2f 	mcall	8000285c <sd_mmc_spi_get_csd+0xd8>
800027a4:	4a f8       	lddpc	r8,80002860 <sd_mmc_spi_get_csd+0xdc>
800027a6:	b0 8c       	st.b	r8[0x0],r12
  // check for valid response
  if(r1 != 0x00)
800027a8:	58 0c       	cp.w	r12,0
800027aa:	c0 81       	brne	800027ba <sd_mmc_spi_get_csd+0x36>
800027ac:	30 07       	mov	r7,0
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
800027ae:	e0 64 00 ff 	mov	r4,255
800027b2:	10 93       	mov	r3,r8
800027b4:	3f e6       	mov	r6,-2
  {
    if (retry > 8)
800027b6:	30 95       	mov	r5,9
800027b8:	c1 78       	rjmp	800027e6 <sd_mmc_spi_get_csd+0x62>
  // issue command
  r1 = sd_mmc_spi_command(MMC_SEND_CSD, 0);
  // check for valid response
  if(r1 != 0x00)
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800027ba:	30 1b       	mov	r11,1
800027bc:	fe 7c 24 00 	mov	r12,-56320
800027c0:	f0 1f 00 29 	mcall	80002864 <sd_mmc_spi_get_csd+0xe0>
    sd_mmc_spi_init_done = false;
800027c4:	30 09       	mov	r9,0
800027c6:	4a 98       	lddpc	r8,80002868 <sd_mmc_spi_get_csd+0xe4>
800027c8:	b0 89       	st.b	r8[0x0],r9
800027ca:	30 0c       	mov	r12,0
    return false;
800027cc:	c4 18       	rjmp	8000284e <sd_mmc_spi_get_csd+0xca>
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
  {
    if (retry > 8)
800027ce:	ea 07 18 00 	cp.b	r7,r5
800027d2:	c0 81       	brne	800027e2 <sd_mmc_spi_get_csd+0x5e>
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800027d4:	30 1b       	mov	r11,1
800027d6:	fe 7c 24 00 	mov	r12,-56320
800027da:	f0 1f 00 23 	mcall	80002864 <sd_mmc_spi_get_csd+0xe0>
800027de:	30 0c       	mov	r12,0
      return false;
800027e0:	c3 78       	rjmp	8000284e <sd_mmc_spi_get_csd+0xca>
    }
    retry++;
800027e2:	2f f7       	sub	r7,-1
800027e4:	5c 57       	castu.b	r7
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
800027e6:	08 9c       	mov	r12,r4
800027e8:	f0 1f 00 21 	mcall	8000286c <sd_mmc_spi_get_csd+0xe8>
800027ec:	a6 8c       	st.b	r3[0x0],r12
800027ee:	ec 0c 18 00 	cp.b	r12,r6
800027f2:	ce e1       	brne	800027ce <sd_mmc_spi_get_csd+0x4a>
800027f4:	30 07       	mov	r7,0
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
800027f6:	e0 65 00 ff 	mov	r5,255
800027fa:	fe 76 24 00 	mov	r6,-56320
   spi_read(SD_MMC_SPI,&data_read);
800027fe:	fa c4 ff fe 	sub	r4,sp,-2
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
80002802:	0a 9b       	mov	r11,r5
80002804:	0c 9c       	mov	r12,r6
80002806:	f0 1f 00 1b 	mcall	80002870 <sd_mmc_spi_get_csd+0xec>
   spi_read(SD_MMC_SPI,&data_read);
8000280a:	08 9b       	mov	r11,r4
8000280c:	0c 9c       	mov	r12,r6
8000280e:	f0 1f 00 1a 	mcall	80002874 <sd_mmc_spi_get_csd+0xf0>
    buffer[retry] = data_read;
80002812:	9a 18       	ld.sh	r8,sp[0x2]
80002814:	e4 07 0b 08 	st.b	r2[r7],r8
80002818:	2f f7       	sub	r7,-1
      return false;
    }
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
8000281a:	59 07       	cp.w	r7,16
8000281c:	cf 31       	brne	80002802 <sd_mmc_spi_get_csd+0x7e>
  {
   spi_write(SD_MMC_SPI,0xFF);
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
  }
   spi_write(SD_MMC_SPI,0xFF);   // load CRC (not used)
8000281e:	e0 6b 00 ff 	mov	r11,255
80002822:	fe 7c 24 00 	mov	r12,-56320
80002826:	f0 1f 00 13 	mcall	80002870 <sd_mmc_spi_get_csd+0xec>
   spi_write(SD_MMC_SPI,0xFF);
8000282a:	e0 6b 00 ff 	mov	r11,255
8000282e:	fe 7c 24 00 	mov	r12,-56320
80002832:	f0 1f 00 10 	mcall	80002870 <sd_mmc_spi_get_csd+0xec>
   spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction
80002836:	e0 6b 00 ff 	mov	r11,255
8000283a:	fe 7c 24 00 	mov	r12,-56320
8000283e:	f0 1f 00 0d 	mcall	80002870 <sd_mmc_spi_get_csd+0xec>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002842:	30 1b       	mov	r11,1
80002844:	fe 7c 24 00 	mov	r12,-56320
80002848:	f0 1f 00 07 	mcall	80002864 <sd_mmc_spi_get_csd+0xe0>
8000284c:	30 1c       	mov	r12,1
  return true;
}
8000284e:	2f fd       	sub	sp,-4
80002850:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002854:	80 00       	ld.sh	r0,r0[0x0]
80002856:	21 5c       	sub	r12,21
80002858:	80 00       	ld.sh	r0,r0[0x0]
8000285a:	2b fc       	sub	r12,-65
8000285c:	80 00       	ld.sh	r0,r0[0x0]
8000285e:	21 f8       	sub	r8,31
80002860:	00 00       	add	r0,r0
80002862:	0a 34       	cp.w	r4,r5
80002864:	80 00       	ld.sh	r0,r0[0x0]
80002866:	2c 48       	sub	r8,-60
80002868:	00 00       	add	r0,r0
8000286a:	05 54       	ld.sh	r4,--r2
8000286c:	80 00       	ld.sh	r0,r0[0x0]
8000286e:	21 28       	sub	r8,18
80002870:	80 00       	ld.sh	r0,r0[0x0]
80002872:	2d 2e       	sub	lr,-46
80002874:	80 00       	ld.sh	r0,r0[0x0]
80002876:	2d 4a       	sub	r10,-44

80002878 <sd_mmc_spi_internal_init>:
//!
//!
//! @return bit
//!   The memory is ready     -> true (always)
bool sd_mmc_spi_internal_init(void)
{
80002878:	d4 31       	pushm	r0-r7,lr
  uint16_t retry;
  int i;
  int if_cond;

  // Start at low frequency
  sd_mmc_opt.baudrate = 400000;
8000287a:	fe fb 02 66 	ld.w	r11,pc[614]
8000287e:	e6 68 1a 80 	mov	r8,400000
80002882:	97 18       	st.w	r11[0x4],r8
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);
80002884:	fe f8 02 60 	ld.w	r8,pc[608]
80002888:	70 0a       	ld.w	r10,r8[0x0]
8000288a:	fe 7c 24 00 	mov	r12,-56320
8000288e:	f0 1f 00 97 	mcall	80002ae8 <sd_mmc_spi_internal_init+0x270>

  /* card needs 74 cycles minimum to start up */
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80002892:	30 1b       	mov	r11,1
80002894:	fe 7c 24 00 	mov	r12,-56320
80002898:	f0 1f 00 95 	mcall	80002aec <sd_mmc_spi_internal_init+0x274>
8000289c:	30 07       	mov	r7,0
  for(i = 0; i < 10; ++i) {
    spi_write(SD_MMC_SPI,0xFF);
8000289e:	e0 66 00 ff 	mov	r6,255
800028a2:	fe 75 24 00 	mov	r5,-56320
800028a6:	0c 9b       	mov	r11,r6
800028a8:	0a 9c       	mov	r12,r5
800028aa:	f0 1f 00 92 	mcall	80002af0 <sd_mmc_spi_internal_init+0x278>
  sd_mmc_opt.baudrate = 400000;
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);

  /* card needs 74 cycles minimum to start up */
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  for(i = 0; i < 10; ++i) {
800028ae:	2f f7       	sub	r7,-1
800028b0:	58 a7       	cp.w	r7,10
800028b2:	cf a1       	brne	800028a6 <sd_mmc_spi_internal_init+0x2e>
    spi_write(SD_MMC_SPI,0xFF);
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800028b4:	30 1b       	mov	r11,1
800028b6:	fe 7c 24 00 	mov	r12,-56320
800028ba:	f0 1f 00 8f 	mcall	80002af4 <sd_mmc_spi_internal_init+0x27c>

  // RESET THE MEMORY CARD
  sd_mmc_spi_init_done = false;
800028be:	30 08       	mov	r8,0
800028c0:	fe f9 02 38 	ld.w	r9,pc[568]
800028c4:	b2 88       	st.b	r9[0x0],r8
  card_type = MMC_CARD;
800028c6:	fe f9 02 36 	ld.w	r9,pc[566]
800028ca:	b2 88       	st.b	r9[0x0],r8
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
800028cc:	30 0b       	mov	r11,0
800028ce:	16 9c       	mov	r12,r11
800028d0:	f0 1f 00 8c 	mcall	80002b00 <sd_mmc_spi_internal_init+0x288>
800028d4:	fe f8 02 30 	ld.w	r8,pc[560]
800028d8:	b0 8c       	st.b	r8[0x0],r12
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800028da:	e0 6b 00 ff 	mov	r11,255
800028de:	fe 7c 24 00 	mov	r12,-56320
800028e2:	f0 1f 00 84 	mcall	80002af0 <sd_mmc_spi_internal_init+0x278>
800028e6:	30 17       	mov	r7,1
    // do retry counter
    retry++;
    if(retry > 100)
      return false;
  }
  while(r1 != 0x01);   // check memory enters idle_state
800028e8:	fe f6 02 1c 	ld.w	r6,pc[540]
800028ec:	30 15       	mov	r5,1
  card_type = MMC_CARD;
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
800028ee:	30 03       	mov	r3,0
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800028f0:	e0 62 00 ff 	mov	r2,255
800028f4:	fe 71 24 00 	mov	r1,-56320
    // do retry counter
    retry++;
    if(retry > 100)
800028f8:	36 54       	mov	r4,101
800028fa:	c1 08       	rjmp	8000291a <sd_mmc_spi_internal_init+0xa2>
  card_type = MMC_CARD;
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
800028fc:	06 9b       	mov	r11,r3
800028fe:	06 9c       	mov	r12,r3
80002900:	f0 1f 00 80 	mcall	80002b00 <sd_mmc_spi_internal_init+0x288>
80002904:	ac 8c       	st.b	r6[0x0],r12
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80002906:	04 9b       	mov	r11,r2
80002908:	02 9c       	mov	r12,r1
8000290a:	f0 1f 00 7a 	mcall	80002af0 <sd_mmc_spi_internal_init+0x278>
    // do retry counter
    retry++;
8000290e:	2f f7       	sub	r7,-1
80002910:	5c 87       	casts.h	r7
    if(retry > 100)
80002912:	e8 07 19 00 	cp.h	r7,r4
80002916:	e0 80 00 e4 	breq	80002ade <sd_mmc_spi_internal_init+0x266>
      return false;
  }
  while(r1 != 0x01);   // check memory enters idle_state
8000291a:	0d 88       	ld.ub	r8,r6[0x0]
8000291c:	ea 08 18 00 	cp.b	r8,r5
80002920:	ce e1       	brne	800028fc <sd_mmc_spi_internal_init+0x84>

  if_cond = sd_mmc_spi_get_if();
80002922:	f0 1f 00 7a 	mcall	80002b08 <sd_mmc_spi_internal_init+0x290>
  if(if_cond == -1) {
80002926:	5b fc       	cp.w	r12,-1
80002928:	e0 80 00 db 	breq	80002ade <sd_mmc_spi_internal_init+0x266>
      return false; // card is bad
  } else if (if_cond == 1) {
8000292c:	58 1c       	cp.w	r12,1
8000292e:	c0 51       	brne	80002938 <sd_mmc_spi_internal_init+0xc0>
      card_type = SD_CARD_2;
80002930:	30 29       	mov	r9,2
80002932:	4f 38       	lddpc	r8,80002afc <sd_mmc_spi_internal_init+0x284>
80002934:	b0 89       	st.b	r8[0x0],r9
80002936:	c4 c8       	rjmp	800029ce <sd_mmc_spi_internal_init+0x156>
  } else {
    // IDENTIFICATION OF THE CARD TYPE (SD or MMC)
    // Both cards will accept CMD55 command but only the SD card will respond to ACMD41
    r1 = sd_mmc_spi_send_command(SD_APP_CMD55,0);
80002938:	30 0b       	mov	r11,0
8000293a:	33 7c       	mov	r12,55
8000293c:	f0 1f 00 71 	mcall	80002b00 <sd_mmc_spi_internal_init+0x288>
80002940:	4f 17       	lddpc	r7,80002b04 <sd_mmc_spi_internal_init+0x28c>
80002942:	ae 8c       	st.b	r7[0x0],r12
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte
80002944:	e0 6b 00 ff 	mov	r11,255
80002948:	fe 7c 24 00 	mov	r12,-56320
8000294c:	f0 1f 00 69 	mcall	80002af0 <sd_mmc_spi_internal_init+0x278>

    r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0);
80002950:	30 0b       	mov	r11,0
80002952:	32 9c       	mov	r12,41
80002954:	f0 1f 00 6b 	mcall	80002b00 <sd_mmc_spi_internal_init+0x288>
80002958:	ae 8c       	st.b	r7[0x0],r12
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte
8000295a:	e0 6b 00 ff 	mov	r11,255
8000295e:	fe 7c 24 00 	mov	r12,-56320
80002962:	f0 1f 00 64 	mcall	80002af0 <sd_mmc_spi_internal_init+0x278>

    if ((r1&0xFE) == 0) {   // ignore "in_idle_state" flag bit
80002966:	0f 88       	ld.ub	r8,r7[0x0]
80002968:	e2 18 00 fe 	andl	r8,0xfe,COH
8000296c:	c0 51       	brne	80002976 <sd_mmc_spi_internal_init+0xfe>
      card_type = SD_CARD;    // card has accepted the command, this is a SD card
8000296e:	30 19       	mov	r9,1
80002970:	4e 38       	lddpc	r8,80002afc <sd_mmc_spi_internal_init+0x284>
80002972:	b0 89       	st.b	r8[0x0],r9
80002974:	c2 d8       	rjmp	800029ce <sd_mmc_spi_internal_init+0x156>
    } else {
      card_type = MMC_CARD;   // card has not responded, this is a MMC card
80002976:	30 09       	mov	r9,0
80002978:	4e 18       	lddpc	r8,80002afc <sd_mmc_spi_internal_init+0x284>
8000297a:	b0 89       	st.b	r8[0x0],r9
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
8000297c:	30 0b       	mov	r11,0
8000297e:	16 9c       	mov	r12,r11
80002980:	f0 1f 00 60 	mcall	80002b00 <sd_mmc_spi_internal_init+0x288>
80002984:	4e 08       	lddpc	r8,80002b04 <sd_mmc_spi_internal_init+0x28c>
80002986:	b0 8c       	st.b	r8[0x0],r12
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80002988:	e0 6b 00 ff 	mov	r11,255
8000298c:	fe 7c 24 00 	mov	r12,-56320
80002990:	f0 1f 00 58 	mcall	80002af0 <sd_mmc_spi_internal_init+0x278>
80002994:	30 17       	mov	r7,1
        // do retry counter
        retry++;
        if(retry > 100)
          return false;
      }
      while(r1 != 0x01);   // check memory enters idle_state
80002996:	4d c6       	lddpc	r6,80002b04 <sd_mmc_spi_internal_init+0x28c>
80002998:	30 15       	mov	r5,1
      card_type = MMC_CARD;   // card has not responded, this is a MMC card
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
8000299a:	30 03       	mov	r3,0
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000299c:	e0 62 00 ff 	mov	r2,255
800029a0:	fe 71 24 00 	mov	r1,-56320
        // do retry counter
        retry++;
        if(retry > 100)
800029a4:	36 54       	mov	r4,101
800029a6:	c1 08       	rjmp	800029c6 <sd_mmc_spi_internal_init+0x14e>
      card_type = MMC_CARD;   // card has not responded, this is a MMC card
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
800029a8:	06 9b       	mov	r11,r3
800029aa:	06 9c       	mov	r12,r3
800029ac:	f0 1f 00 55 	mcall	80002b00 <sd_mmc_spi_internal_init+0x288>
800029b0:	ac 8c       	st.b	r6[0x0],r12
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800029b2:	04 9b       	mov	r11,r2
800029b4:	02 9c       	mov	r12,r1
800029b6:	f0 1f 00 4f 	mcall	80002af0 <sd_mmc_spi_internal_init+0x278>
        // do retry counter
        retry++;
800029ba:	2f f7       	sub	r7,-1
800029bc:	5c 87       	casts.h	r7
        if(retry > 100)
800029be:	e8 07 19 00 	cp.h	r7,r4
800029c2:	e0 80 00 8e 	breq	80002ade <sd_mmc_spi_internal_init+0x266>
          return false;
      }
      while(r1 != 0x01);   // check memory enters idle_state
800029c6:	0d 88       	ld.ub	r8,r6[0x0]
800029c8:	ea 08 18 00 	cp.b	r8,r5
800029cc:	ce e1       	brne	800029a8 <sd_mmc_spi_internal_init+0x130>
800029ce:	30 07       	mov	r7,0

  // CONTINUE INTERNAL INITIALIZATION OF THE CARD
  // Continue sending CMD1 while memory card is in idle state
  retry = 0;
  do {
    switch(card_type) {
800029d0:	4c b4       	lddpc	r4,80002afc <sd_mmc_spi_internal_init+0x284>
800029d2:	30 15       	mov	r5,1
    case MMC_CARD:
      r1 = sd_mmc_spi_send_command(MMC_SEND_OP_COND, 0);
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
      break;
    case SD_CARD:
      sd_mmc_spi_send_command(SD_APP_CMD55,0);
800029d4:	0e 93       	mov	r3,r7
800029d6:	33 70       	mov	r0,55
      r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0);
800029d8:	4c b6       	lddpc	r6,80002b04 <sd_mmc_spi_internal_init+0x28c>
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800029da:	e0 62 00 ff 	mov	r2,255
800029de:	fe 71 24 00 	mov	r1,-56320

  // CONTINUE INTERNAL INITIALIZATION OF THE CARD
  // Continue sending CMD1 while memory card is in idle state
  retry = 0;
  do {
    switch(card_type) {
800029e2:	09 88       	ld.ub	r8,r4[0x0]
800029e4:	ea 08 18 00 	cp.b	r8,r5
800029e8:	c1 10       	breq	80002a0a <sd_mmc_spi_internal_init+0x192>
800029ea:	c0 63       	brcs	800029f6 <sd_mmc_spi_internal_init+0x17e>
800029ec:	30 29       	mov	r9,2
800029ee:	f2 08 18 00 	cp.b	r8,r9
800029f2:	c2 81       	brne	80002a42 <sd_mmc_spi_internal_init+0x1ca>
800029f4:	c1 98       	rjmp	80002a26 <sd_mmc_spi_internal_init+0x1ae>
    case MMC_CARD:
      r1 = sd_mmc_spi_send_command(MMC_SEND_OP_COND, 0);
800029f6:	06 9b       	mov	r11,r3
800029f8:	30 1c       	mov	r12,1
800029fa:	f0 1f 00 42 	mcall	80002b00 <sd_mmc_spi_internal_init+0x288>
800029fe:	ac 8c       	st.b	r6[0x0],r12
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80002a00:	04 9b       	mov	r11,r2
80002a02:	02 9c       	mov	r12,r1
80002a04:	f0 1f 00 3b 	mcall	80002af0 <sd_mmc_spi_internal_init+0x278>
      break;
80002a08:	c1 d8       	rjmp	80002a42 <sd_mmc_spi_internal_init+0x1ca>
    case SD_CARD:
      sd_mmc_spi_send_command(SD_APP_CMD55,0);
80002a0a:	06 9b       	mov	r11,r3
80002a0c:	00 9c       	mov	r12,r0
80002a0e:	f0 1f 00 3d 	mcall	80002b00 <sd_mmc_spi_internal_init+0x288>
      r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0);
80002a12:	06 9b       	mov	r11,r3
80002a14:	32 9c       	mov	r12,41
80002a16:	f0 1f 00 3b 	mcall	80002b00 <sd_mmc_spi_internal_init+0x288>
80002a1a:	ac 8c       	st.b	r6[0x0],r12
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80002a1c:	04 9b       	mov	r11,r2
80002a1e:	02 9c       	mov	r12,r1
80002a20:	f0 1f 00 34 	mcall	80002af0 <sd_mmc_spi_internal_init+0x278>
      break;
80002a24:	c0 f8       	rjmp	80002a42 <sd_mmc_spi_internal_init+0x1ca>
    case SD_CARD_2:
      // set high capacity bit mask
      sd_mmc_spi_send_command(SD_APP_CMD55,0);
80002a26:	06 9b       	mov	r11,r3
80002a28:	00 9c       	mov	r12,r0
80002a2a:	f0 1f 00 36 	mcall	80002b00 <sd_mmc_spi_internal_init+0x288>
      r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0x40000000);
80002a2e:	fc 1b 40 00 	movh	r11,0x4000
80002a32:	32 9c       	mov	r12,41
80002a34:	f0 1f 00 33 	mcall	80002b00 <sd_mmc_spi_internal_init+0x288>
80002a38:	ac 8c       	st.b	r6[0x0],r12
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80002a3a:	04 9b       	mov	r11,r2
80002a3c:	02 9c       	mov	r12,r1
80002a3e:	f0 1f 00 2d 	mcall	80002af0 <sd_mmc_spi_internal_init+0x278>
      break;
    }
     // do retry counter
     retry++;
80002a42:	2f f7       	sub	r7,-1
80002a44:	5c 87       	casts.h	r7
     if(retry == 50000)    // measured approx. 500 on several cards
80002a46:	fe 78 c3 50 	mov	r8,-15536
80002a4a:	f0 07 19 00 	cp.h	r7,r8
80002a4e:	c4 80       	breq	80002ade <sd_mmc_spi_internal_init+0x266>
        return false;
  } while (r1);
80002a50:	0d 89       	ld.ub	r9,r6[0x0]
80002a52:	30 08       	mov	r8,0
80002a54:	f0 09 18 00 	cp.b	r9,r8
80002a58:	cc 51       	brne	800029e2 <sd_mmc_spi_internal_init+0x16a>

  // CHECK FOR SDHC
  if(card_type == SD_CARD_2) {
80002a5a:	4a 98       	lddpc	r8,80002afc <sd_mmc_spi_internal_init+0x284>
80002a5c:	11 89       	ld.ub	r9,r8[0x0]
80002a5e:	30 28       	mov	r8,2
80002a60:	f0 09 18 00 	cp.b	r9,r8
80002a64:	c0 a1       	brne	80002a78 <sd_mmc_spi_internal_init+0x200>
    if_cond = sd_mmc_spi_check_hc();
80002a66:	f0 1f 00 2a 	mcall	80002b0c <sd_mmc_spi_internal_init+0x294>
    if (if_cond == -1) {
80002a6a:	5b fc       	cp.w	r12,-1
80002a6c:	c3 90       	breq	80002ade <sd_mmc_spi_internal_init+0x266>
      return false;
    } else if (if_cond == 1){
80002a6e:	58 1c       	cp.w	r12,1
80002a70:	c0 41       	brne	80002a78 <sd_mmc_spi_internal_init+0x200>
          card_type = SD_CARD_2_SDHC;
80002a72:	30 39       	mov	r9,3
80002a74:	4a 28       	lddpc	r8,80002afc <sd_mmc_spi_internal_init+0x284>
80002a76:	b0 89       	st.b	r8[0x0],r9
      }
  }

  // DISABLE CRC TO SIMPLIFY AND SPEED UP COMMUNICATIONS
  r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0);  // disable CRC (should be already initialized on SPI init)
80002a78:	30 0b       	mov	r11,0
80002a7a:	33 bc       	mov	r12,59
80002a7c:	f0 1f 00 21 	mcall	80002b00 <sd_mmc_spi_internal_init+0x288>
80002a80:	4a 17       	lddpc	r7,80002b04 <sd_mmc_spi_internal_init+0x28c>
80002a82:	ae 8c       	st.b	r7[0x0],r12
  spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80002a84:	e0 6b 00 ff 	mov	r11,255
80002a88:	fe 7c 24 00 	mov	r12,-56320
80002a8c:	f0 1f 00 19 	mcall	80002af0 <sd_mmc_spi_internal_init+0x278>

  // SET BLOCK LENGTH TO 512 BYTES
  r1 = sd_mmc_spi_send_command(MMC_SET_BLOCKLEN, 512);
80002a90:	e0 6b 02 00 	mov	r11,512
80002a94:	31 0c       	mov	r12,16
80002a96:	f0 1f 00 1b 	mcall	80002b00 <sd_mmc_spi_internal_init+0x288>
80002a9a:	ae 8c       	st.b	r7[0x0],r12
  spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80002a9c:	e0 6b 00 ff 	mov	r11,255
80002aa0:	fe 7c 24 00 	mov	r12,-56320
80002aa4:	f0 1f 00 13 	mcall	80002af0 <sd_mmc_spi_internal_init+0x278>
  if (r1 != 0x00)
80002aa8:	0f 89       	ld.ub	r9,r7[0x0]
80002aaa:	30 08       	mov	r8,0
80002aac:	f0 09 18 00 	cp.b	r9,r8
80002ab0:	c1 71       	brne	80002ade <sd_mmc_spi_internal_init+0x266>
    return false;    // card unsupported if block length of 512b is not accepted

  // GET CARD SPECIFIC DATA
  if (false ==  sd_mmc_spi_get_csd(csd))
80002ab2:	49 8c       	lddpc	r12,80002b10 <sd_mmc_spi_internal_init+0x298>
80002ab4:	f0 1f 00 18 	mcall	80002b14 <sd_mmc_spi_internal_init+0x29c>
80002ab8:	c1 30       	breq	80002ade <sd_mmc_spi_internal_init+0x266>
    return false;

  // GET CARD CAPACITY and NUMBER OF SECTORS
  sd_mmc_spi_get_capacity();
80002aba:	f0 1f 00 18 	mcall	80002b18 <sd_mmc_spi_internal_init+0x2a0>
#if (defined SD_MMC_READ_CID) && (SD_MMC_READ_CID == true)
  if (false ==  sd_mmc_spi_get_cid(cid))
    return false;
#endif

  sd_mmc_spi_init_done = true;
80002abe:	30 19       	mov	r9,1
80002ac0:	48 e8       	lddpc	r8,80002af8 <sd_mmc_spi_internal_init+0x280>
80002ac2:	b0 89       	st.b	r8[0x0],r9

  // Set SPI Speed to MAX
  sd_mmc_opt.baudrate = SD_MMC_SPI_MASTER_SPEED;
80002ac4:	48 7b       	lddpc	r11,80002ae0 <sd_mmc_spi_internal_init+0x268>
80002ac6:	e0 68 1b 00 	mov	r8,6912
80002aca:	ea 18 00 b7 	orh	r8,0xb7
80002ace:	97 18       	st.w	r11[0x4],r8
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);
80002ad0:	48 58       	lddpc	r8,80002ae4 <sd_mmc_spi_internal_init+0x26c>
80002ad2:	70 0a       	ld.w	r10,r8[0x0]
80002ad4:	fe 7c 24 00 	mov	r12,-56320
80002ad8:	f0 1f 00 04 	mcall	80002ae8 <sd_mmc_spi_internal_init+0x270>
80002adc:	da 3a       	popm	r0-r7,pc,r12=1
  return true;
80002ade:	d8 3a       	popm	r0-r7,pc,r12=0
80002ae0:	00 00       	add	r0,r0
80002ae2:	05 40       	ld.w	r0,--r2
80002ae4:	00 00       	add	r0,r0
80002ae6:	05 50       	ld.sh	r0,--r2
80002ae8:	80 00       	ld.sh	r0,r0[0x0]
80002aea:	2c 70       	sub	r0,-57
80002aec:	80 00       	ld.sh	r0,r0[0x0]
80002aee:	2b fc       	sub	r12,-65
80002af0:	80 00       	ld.sh	r0,r0[0x0]
80002af2:	2d 2e       	sub	lr,-46
80002af4:	80 00       	ld.sh	r0,r0[0x0]
80002af6:	2c 48       	sub	r8,-60
80002af8:	00 00       	add	r0,r0
80002afa:	05 54       	ld.sh	r4,--r2
80002afc:	00 00       	add	r0,r0
80002afe:	0a 22       	rsub	r2,r5
80002b00:	80 00       	ld.sh	r0,r0[0x0]
80002b02:	22 c0       	sub	r0,44
80002b04:	00 00       	add	r0,r0
80002b06:	0a 34       	cp.w	r4,r5
80002b08:	80 00       	ld.sh	r0,r0[0x0]
80002b0a:	25 68       	sub	r8,86
80002b0c:	80 00       	ld.sh	r0,r0[0x0]
80002b0e:	24 dc       	sub	r12,77
80002b10:	00 00       	add	r0,r0
80002b12:	0a 24       	rsub	r4,r5
80002b14:	80 00       	ld.sh	r0,r0[0x0]
80002b16:	27 84       	sub	r4,120
80002b18:	80 00       	ld.sh	r0,r0[0x0]
80002b1a:	20 08       	sub	r8,0

80002b1c <sd_mmc_spi_mem_check>:
//!
//! @return bit
//!   The memory is ready     -> true
//!   The memory check failed -> false
bool sd_mmc_spi_mem_check(void)
{
80002b1c:	d4 01       	pushm	lr
  if (sd_mmc_spi_check_presence())
80002b1e:	f0 1f 00 07 	mcall	80002b38 <sd_mmc_spi_mem_check+0x1c>
80002b22:	c0 a0       	breq	80002b36 <sd_mmc_spi_mem_check+0x1a>
  {
    if (sd_mmc_spi_init_done == false)
80002b24:	48 68       	lddpc	r8,80002b3c <sd_mmc_spi_mem_check+0x20>
80002b26:	11 89       	ld.ub	r9,r8[0x0]
80002b28:	30 08       	mov	r8,0
80002b2a:	f0 09 18 00 	cp.b	r9,r8
80002b2e:	c0 20       	breq	80002b32 <sd_mmc_spi_mem_check+0x16>
80002b30:	da 0a       	popm	pc,r12=1
    {
      return sd_mmc_spi_internal_init();
80002b32:	f0 1f 00 04 	mcall	80002b40 <sd_mmc_spi_mem_check+0x24>
    }
    else
      return true;
  }
  return false;
}
80002b36:	d8 02       	popm	pc
80002b38:	80 00       	ld.sh	r0,r0[0x0]
80002b3a:	23 00       	sub	r0,48
80002b3c:	00 00       	add	r0,r0
80002b3e:	05 54       	ld.sh	r4,--r2
80002b40:	80 00       	ld.sh	r0,r0[0x0]
80002b42:	28 78       	sub	r8,-121

80002b44 <sd_mmc_spi_init>:
//!
//!
//! @return bit
//!   The memory is ready     -> true (always)
bool sd_mmc_spi_init(spi_options_t spiOptions, unsigned int pba_hz)
{
80002b44:	eb cd 40 10 	pushm	r4,lr
80002b48:	fa c4 ff f8 	sub	r4,sp,-8
  // Keep SPI options internally
  sd_mmc_pba_hz = pba_hz;
80002b4c:	48 88       	lddpc	r8,80002b6c <sd_mmc_spi_init+0x28>
80002b4e:	91 0c       	st.w	r8[0x0],r12
  memcpy( &sd_mmc_opt, &spiOptions, sizeof(spi_options_t) );
80002b50:	48 88       	lddpc	r8,80002b70 <sd_mmc_spi_init+0x2c>
80002b52:	e8 ea 00 00 	ld.d	r10,r4[0]
80002b56:	f0 eb 00 00 	st.d	r8[0],r10
80002b5a:	e8 ea 00 08 	ld.d	r10,r4[8]
80002b5e:	f0 eb 00 08 	st.d	r8[8],r10

  // Initialize the SD/MMC controller.
  return sd_mmc_spi_internal_init();
80002b62:	f0 1f 00 05 	mcall	80002b74 <sd_mmc_spi_init+0x30>
}
80002b66:	e3 cd 80 10 	ldm	sp++,r4,pc
80002b6a:	00 00       	add	r0,r0
80002b6c:	00 00       	add	r0,r0
80002b6e:	05 50       	ld.sh	r0,--r2
80002b70:	00 00       	add	r0,r0
80002b72:	05 40       	ld.w	r0,--r2
80002b74:	80 00       	ld.sh	r0,r0[0x0]
80002b76:	28 78       	sub	r8,-121

80002b78 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80002b78:	f8 c8 00 01 	sub	r8,r12,1
80002b7c:	f0 0b 00 0b 	add	r11,r8,r11
80002b80:	f6 0c 0d 0a 	divu	r10,r11,r12
80002b84:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
80002b86:	f4 c8 00 01 	sub	r8,r10,1
80002b8a:	e0 48 00 fe 	cp.w	r8,254
80002b8e:	e0 88 00 03 	brls	80002b94 <getBaudDiv+0x1c>
80002b92:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
80002b94:	5c 8c       	casts.h	r12
}
80002b96:	5e fc       	retal	r12

80002b98 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
80002b98:	f7 39 00 0d 	ld.ub	r9,r11[13]
80002b9c:	30 18       	mov	r8,1
80002b9e:	f0 09 18 00 	cp.b	r9,r8
80002ba2:	e0 88 00 04 	brls	80002baa <spi_initMaster+0x12>
80002ba6:	30 2c       	mov	r12,2
80002ba8:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
80002baa:	e0 68 00 80 	mov	r8,128
80002bae:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80002bb0:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
80002bb2:	30 19       	mov	r9,1
80002bb4:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
80002bb8:	f7 39 00 0d 	ld.ub	r9,r11[13]
80002bbc:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80002bc0:	30 09       	mov	r9,0
80002bc2:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80002bc6:	30 fa       	mov	r10,15
80002bc8:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
80002bcc:	99 18       	st.w	r12[0x4],r8
80002bce:	5e f9       	retal	r9

80002bd0 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80002bd0:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80002bd2:	30 18       	mov	r8,1
80002bd4:	f0 0b 18 00 	cp.b	r11,r8
80002bd8:	5f be       	srhi	lr
80002bda:	f0 0a 18 00 	cp.b	r10,r8
80002bde:	5f b8       	srhi	r8
80002be0:	fd e8 10 08 	or	r8,lr,r8
80002be4:	c0 30       	breq	80002bea <spi_selectionMode+0x1a>
80002be6:	30 2c       	mov	r12,2
80002be8:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
80002bea:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80002bec:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80002bf0:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80002bf4:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80002bf8:	99 18       	st.w	r12[0x4],r8
80002bfa:	d8 0a       	popm	pc,r12=0

80002bfc <spi_selectChip>:
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80002bfc:	78 18       	ld.w	r8,r12[0x4]
80002bfe:	ea 18 00 0f 	orh	r8,0xf
80002c02:	99 18       	st.w	r12[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80002c04:	78 18       	ld.w	r8,r12[0x4]
80002c06:	e2 18 00 04 	andl	r8,0x4,COH
80002c0a:	c0 f0       	breq	80002c28 <spi_selectChip+0x2c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80002c0c:	30 e8       	mov	r8,14
80002c0e:	f0 0b 18 00 	cp.b	r11,r8
80002c12:	e0 8b 00 19 	brhi	80002c44 <spi_selectChip+0x48>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80002c16:	78 18       	ld.w	r8,r12[0x4]
80002c18:	b1 6b       	lsl	r11,0x10
80002c1a:	ea 1b ff f0 	orh	r11,0xfff0
80002c1e:	e8 1b ff ff 	orl	r11,0xffff
80002c22:	10 6b       	and	r11,r8
80002c24:	99 1b       	st.w	r12[0x4],r11
80002c26:	5e fd       	retal	0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80002c28:	30 38       	mov	r8,3
80002c2a:	f0 0b 18 00 	cp.b	r11,r8
80002c2e:	e0 8b 00 0b 	brhi	80002c44 <spi_selectChip+0x48>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80002c32:	78 18       	ld.w	r8,r12[0x4]
80002c34:	2f 0b       	sub	r11,-16
80002c36:	30 19       	mov	r9,1
80002c38:	f2 0b 09 4b 	lsl	r11,r9,r11
80002c3c:	5c db       	com	r11
80002c3e:	10 6b       	and	r11,r8
80002c40:	99 1b       	st.w	r12[0x4],r11
80002c42:	5e fd       	retal	0
80002c44:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80002c46:	5e fc       	retal	r12

80002c48 <spi_unselectChip>:

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80002c48:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80002c4c:	c0 58       	rjmp	80002c56 <spi_unselectChip+0xe>
		if (!timeout--) {
80002c4e:	58 08       	cp.w	r8,0
80002c50:	c0 21       	brne	80002c54 <spi_unselectChip+0xc>
80002c52:	5e ff       	retal	1
80002c54:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80002c56:	78 49       	ld.w	r9,r12[0x10]
80002c58:	e2 19 02 00 	andl	r9,0x200,COH
80002c5c:	cf 90       	breq	80002c4e <spi_unselectChip+0x6>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80002c5e:	78 18       	ld.w	r8,r12[0x4]
80002c60:	ea 18 00 0f 	orh	r8,0xf
80002c64:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80002c66:	fc 18 01 00 	movh	r8,0x100
80002c6a:	99 08       	st.w	r12[0x0],r8
80002c6c:	5e fd       	retal	0
80002c6e:	d7 03       	nop

80002c70 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80002c70:	eb cd 40 f8 	pushm	r3-r7,lr
80002c74:	18 95       	mov	r5,r12
80002c76:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80002c78:	f7 36 00 0c 	ld.ub	r6,r11[12]
80002c7c:	30 38       	mov	r8,3
80002c7e:	f0 06 18 00 	cp.b	r6,r8
80002c82:	e0 8b 00 4d 	brhi	80002d1c <spi_setupChipReg+0xac>
			options->stay_act > 1 ||
80002c86:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80002c8a:	30 18       	mov	r8,1
80002c8c:	f0 04 18 00 	cp.b	r4,r8
80002c90:	e0 8b 00 46 	brhi	80002d1c <spi_setupChipReg+0xac>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80002c94:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80002c98:	30 78       	mov	r8,7
80002c9a:	f0 03 18 00 	cp.b	r3,r8
80002c9e:	e0 88 00 3f 	brls	80002d1c <spi_setupChipReg+0xac>
80002ca2:	31 08       	mov	r8,16
80002ca4:	f0 03 18 00 	cp.b	r3,r8
80002ca8:	e0 8b 00 3a 	brhi	80002d1c <spi_setupChipReg+0xac>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80002cac:	14 9b       	mov	r11,r10
80002cae:	6e 1c       	ld.w	r12,r7[0x4]
80002cb0:	f0 1f 00 1d 	mcall	80002d24 <spi_setupChipReg+0xb4>

	if (baudDiv < 0) {
80002cb4:	c3 45       	brlt	80002d1c <spi_setupChipReg+0xac>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
80002cb6:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80002cb8:	ec 09 16 01 	lsr	r9,r6,0x1
80002cbc:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80002cc0:	ec 16 00 01 	eorl	r6,0x1
80002cc4:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80002cc8:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
80002ccc:	20 83       	sub	r3,8
80002cce:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
80002cd2:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80002cd6:	ef 39 00 09 	ld.ub	r9,r7[9]
80002cda:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80002cde:	ef 39 00 0a 	ld.ub	r9,r7[10]
80002ce2:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
80002ce6:	0f 89       	ld.ub	r9,r7[0x0]
80002ce8:	30 1a       	mov	r10,1
80002cea:	f4 09 18 00 	cp.b	r9,r10
80002cee:	c0 e0       	breq	80002d0a <spi_setupChipReg+0x9a>
80002cf0:	c0 a3       	brcs	80002d04 <spi_setupChipReg+0x94>
80002cf2:	30 2a       	mov	r10,2
80002cf4:	f4 09 18 00 	cp.b	r9,r10
80002cf8:	c0 c0       	breq	80002d10 <spi_setupChipReg+0xa0>
80002cfa:	30 3a       	mov	r10,3
80002cfc:	f4 09 18 00 	cp.b	r9,r10
80002d00:	c0 e1       	brne	80002d1c <spi_setupChipReg+0xac>
80002d02:	c0 a8       	rjmp	80002d16 <spi_setupChipReg+0xa6>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80002d04:	8b c8       	st.w	r5[0x30],r8
80002d06:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
		break;

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80002d0a:	8b d8       	st.w	r5[0x34],r8
80002d0c:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
		break;

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80002d10:	8b e8       	st.w	r5[0x38],r8
80002d12:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
		break;

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80002d16:	8b f8       	st.w	r5[0x3c],r8
80002d18:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
		break;
80002d1c:	30 2c       	mov	r12,2
		}
	}
#endif

	return SPI_OK;
}
80002d1e:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002d22:	00 00       	add	r0,r0
80002d24:	80 00       	ld.sh	r0,r0[0x0]
80002d26:	2b 78       	sub	r8,-73

80002d28 <spi_enable>:

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80002d28:	30 18       	mov	r8,1
80002d2a:	99 08       	st.w	r12[0x0],r8
}
80002d2c:	5e fc       	retal	r12

80002d2e <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80002d2e:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80002d32:	c0 58       	rjmp	80002d3c <spi_write+0xe>
		if (!timeout--) {
80002d34:	58 08       	cp.w	r8,0
80002d36:	c0 21       	brne	80002d3a <spi_write+0xc>
80002d38:	5e ff       	retal	1
80002d3a:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80002d3c:	78 49       	ld.w	r9,r12[0x10]
80002d3e:	e2 19 00 02 	andl	r9,0x2,COH
80002d42:	cf 90       	breq	80002d34 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80002d44:	5c 7b       	castu.h	r11
80002d46:	99 3b       	st.w	r12[0xc],r11
80002d48:	5e fd       	retal	0

80002d4a <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80002d4a:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80002d4e:	c0 58       	rjmp	80002d58 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80002d50:	58 08       	cp.w	r8,0
80002d52:	c0 21       	brne	80002d56 <spi_read+0xc>
80002d54:	5e ff       	retal	1
80002d56:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80002d58:	78 49       	ld.w	r9,r12[0x10]
80002d5a:	e2 19 02 01 	andl	r9,0x201,COH
80002d5e:	e0 49 02 01 	cp.w	r9,513
80002d62:	cf 71       	brne	80002d50 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80002d64:	78 28       	ld.w	r8,r12[0x8]
80002d66:	b6 08       	st.h	r11[0x0],r8
80002d68:	5e fd       	retal	0
80002d6a:	d7 03       	nop

80002d6c <tpa6130_abdac_tx_pdca_int_handler>:
  .output_impedance    = TPA6130_OUTPUT_IMPEDANCE_DEFAULT,
  .i2c_address_version = TPA6130_I2C_ADDRESS_VERSION_DEFAULT,
};

ISR(tpa6130_abdac_tx_pdca_int_handler, TPA6130_ABDAC_PDCA_IRQ_GROUP, TPA6130_ABDAC_PDCA_INT_LEVEL)
{
80002d6c:	d4 01       	pushm	lr
  if (pdca_get_transfer_status(TPA6130_ABDAC_PDCA_CHANNEL) & PDCA_TRANSFER_COMPLETE)
80002d6e:	30 0c       	mov	r12,0
80002d70:	f0 1f 00 13 	mcall	80002dbc <tpa6130_abdac_tx_pdca_int_handler+0x50>
80002d74:	e2 1c 00 02 	andl	r12,0x2,COH
80002d78:	c0 d0       	breq	80002d92 <tpa6130_abdac_tx_pdca_int_handler+0x26>
  {
    pdca_disable_interrupt_transfer_complete(TPA6130_ABDAC_PDCA_CHANNEL);
80002d7a:	30 0c       	mov	r12,0
80002d7c:	f0 1f 00 11 	mcall	80002dc0 <tpa6130_abdac_tx_pdca_int_handler+0x54>
    if (tpa6130_output_param.callback_opt & AUDIO_DAC_OUT_OF_SAMPLE_CB)
80002d80:	49 18       	lddpc	r8,80002dc4 <tpa6130_abdac_tx_pdca_int_handler+0x58>
80002d82:	70 28       	ld.w	r8,r8[0x8]
80002d84:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002d88:	c0 50       	breq	80002d92 <tpa6130_abdac_tx_pdca_int_handler+0x26>
      tpa6130_output_param.callback(AUDIO_DAC_OUT_OF_SAMPLE_CB);
80002d8a:	48 f8       	lddpc	r8,80002dc4 <tpa6130_abdac_tx_pdca_int_handler+0x58>
80002d8c:	70 18       	ld.w	r8,r8[0x4]
80002d8e:	30 1c       	mov	r12,1
80002d90:	5d 18       	icall	r8
  }

  if (pdca_get_transfer_status(TPA6130_ABDAC_PDCA_CHANNEL) & PDCA_TRANSFER_COUNTER_RELOAD_IS_ZERO)
80002d92:	30 0c       	mov	r12,0
80002d94:	f0 1f 00 0a 	mcall	80002dbc <tpa6130_abdac_tx_pdca_int_handler+0x50>
80002d98:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002d9c:	c0 d0       	breq	80002db6 <tpa6130_abdac_tx_pdca_int_handler+0x4a>
  {
    pdca_disable_interrupt_reload_counter_zero(TPA6130_ABDAC_PDCA_CHANNEL);
80002d9e:	30 0c       	mov	r12,0
80002da0:	f0 1f 00 0a 	mcall	80002dc8 <tpa6130_abdac_tx_pdca_int_handler+0x5c>
    if (tpa6130_output_param.callback_opt & AUDIO_DAC_RELOAD_CB)
80002da4:	48 88       	lddpc	r8,80002dc4 <tpa6130_abdac_tx_pdca_int_handler+0x58>
80002da6:	70 28       	ld.w	r8,r8[0x8]
80002da8:	e2 18 00 02 	andl	r8,0x2,COH
80002dac:	c0 50       	breq	80002db6 <tpa6130_abdac_tx_pdca_int_handler+0x4a>
      tpa6130_output_param.callback(AUDIO_DAC_RELOAD_CB);
80002dae:	48 68       	lddpc	r8,80002dc4 <tpa6130_abdac_tx_pdca_int_handler+0x58>
80002db0:	70 18       	ld.w	r8,r8[0x4]
80002db2:	30 2c       	mov	r12,2
80002db4:	5d 18       	icall	r8
  }
}
80002db6:	d4 02       	popm	lr
80002db8:	d6 03       	rete
80002dba:	00 00       	add	r0,r0
80002dbc:	80 00       	ld.sh	r0,r0[0x0]
80002dbe:	42 78       	lddsp	r8,sp[0x9c]
80002dc0:	80 00       	ld.sh	r0,r0[0x0]
80002dc2:	42 b0       	lddsp	r0,sp[0xac]
80002dc4:	00 00       	add	r0,r0
80002dc6:	05 58       	ld.sh	r8,--r2
80002dc8:	80 00       	ld.sh	r0,r0[0x0]
80002dca:	42 88       	lddsp	r8,sp[0xa0]

80002dcc <tpa6130_write_data>:
 *  \param reg Register index. Use the defines in this file.
 *  \param data Register data. Macros from this file can be used
 *  to ease writing to the bitfields.
 */
static void tpa6130_write_data(uint8_t reg, uint8_t data)
{
80002dcc:	d4 21       	pushm	r4-r7,lr
80002dce:	20 6d       	sub	sp,24
80002dd0:	18 94       	mov	r4,r12
80002dd2:	16 95       	mov	r5,r11
  uint16_t message = (reg << 8) | data;
80002dd4:	f7 ec 10 88 	or	r8,r11,r12<<0x8
80002dd8:	fb 58 00 16 	st.h	sp[22],r8
  {
    .chip = TPA6130_TWI_ADDRESS,
    .addr_length = 0,//AVR32_TWI_MMR_IADRSZ_NO_ADDR,
    .buffer = &message,
    .length = sizeof(message)
  };
80002ddc:	30 08       	mov	r8,0
80002dde:	30 09       	mov	r9,0
80002de0:	fa e9 00 00 	st.d	sp[0],r8
80002de4:	fa e9 00 08 	st.d	sp[8],r8
80002de8:	36 08       	mov	r8,96
80002dea:	ba 88       	st.b	sp[0x0],r8
80002dec:	fa c8 ff ea 	sub	r8,sp,-22
80002df0:	50 38       	stdsp	sp[0xc],r8
80002df2:	30 28       	mov	r8,2
80002df4:	50 48       	stdsp	sp[0x10],r8

  do
  {
     twi_status=twi_master_write(TPA6130_TWI, &twi_package);
80002df6:	1a 96       	mov	r6,sp
80002df8:	fe 77 2c 00 	mov	r7,-54272
80002dfc:	1a 9b       	mov	r11,sp
80002dfe:	0e 9c       	mov	r12,r7
80002e00:	f0 1f 00 05 	mcall	80002e14 <tpa6130_write_data+0x48>
  }
  while( twi_status != TWI_SUCCESS );
80002e04:	cf c1       	brne	80002dfc <tpa6130_write_data+0x30>

  /* Save write value to shadow registers */
  *(((uint8_t *) &tpa6130_shadow_regs) + reg - 1) = data;
80002e06:	48 58       	lddpc	r8,80002e18 <tpa6130_write_data+0x4c>
80002e08:	f0 04 00 04 	add	r4,r8,r4
80002e0c:	e9 65 ff ff 	st.b	r4[-1],r5
}
80002e10:	2f ad       	sub	sp,-24
80002e12:	d8 22       	popm	r4-r7,pc
80002e14:	80 00       	ld.sh	r0,r0[0x0]
80002e16:	46 cc       	lddsp	r12,sp[0x1b0]
80002e18:	00 00       	add	r0,r0
80002e1a:	00 08       	add	r8,r0

80002e1c <tpa6130_set_volume>:
 *  it to max.
 *  A volume of 0 will mute both channels. Any other value will unmute
 *  them.
 */
void tpa6130_set_volume(int8_t volume)
{
80002e1c:	d4 01       	pushm	lr
  int8_t new_volume = volume;

  if(volume > TPA6130_VOL_MAX)
80002e1e:	33 f8       	mov	r8,63
80002e20:	f0 0c 18 00 	cp.b	r12,r8
80002e24:	e0 8a 00 04 	brle	80002e2c <tpa6130_set_volume+0x10>
80002e28:	33 fb       	mov	r11,63
80002e2a:	c0 b8       	rjmp	80002e40 <tpa6130_set_volume+0x24>
  {
    new_volume = TPA6130_VOL_MAX;
  }
  else if(volume <= TPA6130_VOL_MIN )
80002e2c:	30 08       	mov	r8,0
80002e2e:	f0 0c 18 00 	cp.b	r12,r8
80002e32:	e0 89 00 05 	brgt	80002e3c <tpa6130_set_volume+0x20>
80002e36:	e0 6b 00 c0 	mov	r11,192
80002e3a:	c0 38       	rjmp	80002e40 <tpa6130_set_volume+0x24>
80002e3c:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
  {
    // MUTE Left and Right;
    new_volume = MUTE_L|MUTE_R;
  }

  tpa6130_write_data(TPA6130_VOLUME_AND_MUTE, new_volume );
80002e40:	30 2c       	mov	r12,2
80002e42:	f0 1f 00 02 	mcall	80002e48 <tpa6130_set_volume+0x2c>
}
80002e46:	d8 02       	popm	pc
80002e48:	80 00       	ld.sh	r0,r0[0x0]
80002e4a:	2d cc       	sub	r12,-36

80002e4c <tpa6130_dac_output>:
 * which contain two (16-bit) samples, one for each channel.
 *
 * \note The DACs must have been started beforehand.
 */
bool tpa6130_dac_output(void *sample_buffer, size_t sample_length)
{
80002e4c:	eb cd 40 c0 	pushm	r6-r7,lr
80002e50:	18 96       	mov	r6,r12
80002e52:	16 97       	mov	r7,r11
  //int global_interrupt_enabled;

  /*Wait until the PDCA loads the reload value to its transfer
   * counter register(TCRR=0). Then we are ready to set up a new
   * transfer */
  if(!(pdca_get_transfer_status(TPA6130_ABDAC_PDCA_CHANNEL) &
80002e54:	30 0c       	mov	r12,0
80002e56:	f0 1f 00 11 	mcall	80002e98 <tpa6130_dac_output+0x4c>
80002e5a:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002e5e:	c1 b0       	breq	80002e94 <tpa6130_dac_output+0x48>
  {
    return false;
  }

  /* Nothing to do if we get no data. */
  if(sample_length)
80002e60:	58 07       	cp.w	r7,0
80002e62:	c1 80       	breq	80002e92 <tpa6130_dac_output+0x46>
    //if((global_interrupt_enabled = cpu_irq_is_enabled()))
    //  cpu_irq_disable();

    /*FIXME This assumes a stereo 16-bit sample size */
    // one sample here consists of 2x16-bit (16-bit stereo)
    pdca_reload_channel(TPA6130_ABDAC_PDCA_CHANNEL,
80002e64:	0e 9a       	mov	r10,r7
80002e66:	0c 9b       	mov	r11,r6
80002e68:	30 0c       	mov	r12,0
80002e6a:	f0 1f 00 0d 	mcall	80002e9c <tpa6130_dac_output+0x50>
    //if(global_interrupt_enabled)
    //  cpu_irq_enable();

    /*TODO enable transfer complete interrupt
     * Is it possible to move this to setup or other places?*/
    if(tpa6130_output_param.callback_opt & AUDIO_DAC_OUT_OF_SAMPLE_CB)
80002e6e:	48 d8       	lddpc	r8,80002ea0 <tpa6130_dac_output+0x54>
80002e70:	70 28       	ld.w	r8,r8[0x8]
80002e72:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002e76:	c0 40       	breq	80002e7e <tpa6130_dac_output+0x32>
      pdca_enable_interrupt_transfer_complete(TPA6130_ABDAC_PDCA_CHANNEL);
80002e78:	30 0c       	mov	r12,0
80002e7a:	f0 1f 00 0b 	mcall	80002ea4 <tpa6130_dac_output+0x58>
    if (tpa6130_output_param.callback_opt & AUDIO_DAC_RELOAD_CB)
80002e7e:	48 98       	lddpc	r8,80002ea0 <tpa6130_dac_output+0x54>
80002e80:	70 28       	ld.w	r8,r8[0x8]
80002e82:	e2 18 00 02 	andl	r8,0x2,COH
80002e86:	c0 60       	breq	80002e92 <tpa6130_dac_output+0x46>
      pdca_enable_interrupt_reload_counter_zero(TPA6130_ABDAC_PDCA_CHANNEL);
80002e88:	30 0c       	mov	r12,0
80002e8a:	f0 1f 00 08 	mcall	80002ea8 <tpa6130_dac_output+0x5c>
80002e8e:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80002e92:	30 1c       	mov	r12,1
  }
  return true;
}
80002e94:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002e98:	80 00       	ld.sh	r0,r0[0x0]
80002e9a:	42 78       	lddsp	r8,sp[0x9c]
80002e9c:	80 00       	ld.sh	r0,r0[0x0]
80002e9e:	42 d8       	lddsp	r8,sp[0xb4]
80002ea0:	00 00       	add	r0,r0
80002ea2:	05 58       	ld.sh	r8,--r2
80002ea4:	80 00       	ld.sh	r0,r0[0x0]
80002ea6:	42 58       	lddsp	r8,sp[0x94]
80002ea8:	80 00       	ld.sh	r0,r0[0x0]
80002eaa:	42 68       	lddsp	r8,sp[0x98]

80002eac <tpa6130_read_data>:
 *  \param reg Register index.
 *  \param shadow Read from device (shadow=false) or from shadowed register
 *  (shadow=true).
 */
static uint8_t tpa6130_read_data(uint8_t reg, bool shadow)
{
80002eac:	d4 01       	pushm	lr
80002eae:	20 6d       	sub	sp,24
  uint8_t data;
  /*If we want to read from the shadowed registers */
  if(shadow)
80002eb0:	58 0b       	cp.w	r11,0
80002eb2:	c0 90       	breq	80002ec4 <tpa6130_read_data+0x18>
  {
    data = *((uint8_t *) &tpa6130_shadow_regs + reg - 1);
80002eb4:	48 d8       	lddpc	r8,80002ee8 <tpa6130_read_data+0x3c>
80002eb6:	f0 0c 00 0c 	add	r12,r8,r12
80002eba:	f9 38 ff ff 	ld.ub	r8,r12[-1]
80002ebe:	fb 68 00 17 	st.b	sp[23],r8
80002ec2:	c0 f8       	rjmp	80002ee0 <tpa6130_read_data+0x34>
      .chip = TPA6130_TWI_ADDRESS,
      .addr_length = 1,//AVR32_TWI_MMR_IADRSZ_ONE_BYTE,
      .addr = reg,
      .buffer = &data,
      .length = sizeof(data)
    };
80002ec4:	36 08       	mov	r8,96
80002ec6:	ba 88       	st.b	sp[0x0],r8
80002ec8:	50 1c       	stdsp	sp[0x4],r12
80002eca:	30 18       	mov	r8,1
80002ecc:	50 28       	stdsp	sp[0x8],r8
80002ece:	fa c9 ff e9 	sub	r9,sp,-23
80002ed2:	50 39       	stdsp	sp[0xc],r9
80002ed4:	50 48       	stdsp	sp[0x10],r8
    twi_master_read(TPA6130_TWI, &twi_package);
80002ed6:	1a 9b       	mov	r11,sp
80002ed8:	fe 7c 2c 00 	mov	r12,-54272
80002edc:	f0 1f 00 04 	mcall	80002eec <tpa6130_read_data+0x40>
  //print_dbg(" = 0x");
  //print_dbg_hex(data);
  //print_dbg("\n");

  return data;
}
80002ee0:	fb 3c 00 17 	ld.ub	r12,sp[23]
80002ee4:	2f ad       	sub	sp,-24
80002ee6:	d8 02       	popm	pc
80002ee8:	00 00       	add	r0,r0
80002eea:	00 08       	add	r8,r0
80002eec:	80 00       	ld.sh	r0,r0[0x0]
80002eee:	47 98       	lddsp	r8,sp[0x1e4]

80002ef0 <tpa6130_powerup>:
  tpa6130_write_data(TPA6130_CONTROL, data | SW_SHUTDOWN);
}
/*! \brief Powers up the amplifier from low power mode.
 */
void tpa6130_powerup(void)
{
80002ef0:	d4 01       	pushm	lr
  uint8_t data;
  data = tpa6130_read_data(TPA6130_CONTROL, TWI_READ_HW);
80002ef2:	30 0b       	mov	r11,0
80002ef4:	30 1c       	mov	r12,1
80002ef6:	f0 1f 00 05 	mcall	80002f08 <tpa6130_powerup+0x18>
  tpa6130_write_data(TPA6130_CONTROL, data & (~SW_SHUTDOWN));
80002efa:	18 9b       	mov	r11,r12
80002efc:	e2 1b 00 fe 	andl	r11,0xfe,COH
80002f00:	30 1c       	mov	r12,1
80002f02:	f0 1f 00 03 	mcall	80002f0c <tpa6130_powerup+0x1c>
}
80002f06:	d8 02       	popm	pc
80002f08:	80 00       	ld.sh	r0,r0[0x0]
80002f0a:	2e ac       	sub	r12,-22
80002f0c:	80 00       	ld.sh	r0,r0[0x0]
80002f0e:	2d cc       	sub	r12,-36

80002f10 <tpa6130_shutdown>:

/*! \brief Shuts down the amplifier and sets it into low power mode.
 *  This is the software low power mode described in the datasheet.
 */
void tpa6130_shutdown(void)
{
80002f10:	d4 01       	pushm	lr
  uint8_t data;
  data = tpa6130_read_data(TPA6130_CONTROL, TWI_READ_HW);
80002f12:	30 0b       	mov	r11,0
80002f14:	30 1c       	mov	r12,1
80002f16:	f0 1f 00 05 	mcall	80002f28 <tpa6130_shutdown+0x18>
  tpa6130_write_data(TPA6130_CONTROL, data | SW_SHUTDOWN);
80002f1a:	18 9b       	mov	r11,r12
80002f1c:	a1 ab       	sbr	r11,0x0
80002f1e:	5c 5b       	castu.b	r11
80002f20:	30 1c       	mov	r12,1
80002f22:	f0 1f 00 03 	mcall	80002f2c <tpa6130_shutdown+0x1c>
}
80002f26:	d8 02       	popm	pc
80002f28:	80 00       	ld.sh	r0,r0[0x0]
80002f2a:	2e ac       	sub	r12,-22
80002f2c:	80 00       	ld.sh	r0,r0[0x0]
80002f2e:	2d cc       	sub	r12,-36

80002f30 <tpa6130_dac_stop>:
/*! \brief Stops the ABDAC and puts the amplifier in low power mode.
 *  Additionally it sets all used pins to the GPIO state.
 *  The counter part of this function is tpa6130_dac_start(...)
 */
void tpa6130_dac_stop(void)
{
80002f30:	d4 01       	pushm	lr
  /* Disable amplifier 1st */
  tpa6130_shutdown();
80002f32:	f0 1f 00 0b 	mcall	80002f5c <tpa6130_dac_stop+0x2c>
  /* Flush the dac */
  // Don't flush the DAC when stop
  //tpa6130_dac_flush();

  /* Disable ABDAC */
  abdac_disable(TPA6130_ABDAC);
80002f36:	fe 7c 40 00 	mov	r12,-49152
80002f3a:	f0 1f 00 0a 	mcall	80002f60 <tpa6130_dac_stop+0x30>

  /* Stop  PDCA */
  pdca_disable(TPA6130_ABDAC_PDCA_CHANNEL);
80002f3e:	30 0c       	mov	r12,0
80002f40:	f0 1f 00 09 	mcall	80002f64 <tpa6130_dac_stop+0x34>

  /* Set used GPIO pins to GPIO state */
  gpio_enable_gpio(TPA6130_ABDAC_GPIO_MAP,
80002f44:	30 4b       	mov	r11,4
80002f46:	48 9c       	lddpc	r12,80002f68 <tpa6130_dac_stop+0x38>
80002f48:	f0 1f 00 09 	mcall	80002f6c <tpa6130_dac_stop+0x3c>
    sizeof(TPA6130_ABDAC_GPIO_MAP)
    / sizeof(TPA6130_ABDAC_GPIO_MAP[0]));

  tpa6130_output_param.num_channels = 0;
80002f4c:	48 98       	lddpc	r8,80002f70 <tpa6130_dac_stop+0x40>
80002f4e:	30 09       	mov	r9,0
80002f50:	b0 89       	st.b	r8[0x0],r9
  tpa6130_output_param.callback     = NULL;
80002f52:	30 09       	mov	r9,0
80002f54:	91 19       	st.w	r8[0x4],r9
  tpa6130_output_param.callback_opt = 0;
80002f56:	91 29       	st.w	r8[0x8],r9
}
80002f58:	d8 02       	popm	pc
80002f5a:	00 00       	add	r0,r0
80002f5c:	80 00       	ld.sh	r0,r0[0x0]
80002f5e:	2f 10       	sub	r0,-15
80002f60:	80 00       	ld.sh	r0,r0[0x0]
80002f62:	3c 10       	mov	r0,-63
80002f64:	80 00       	ld.sh	r0,r0[0x0]
80002f66:	42 38       	lddsp	r8,sp[0x8c]
80002f68:	80 00       	ld.sh	r0,r0[0x0]
80002f6a:	cc 18       	rjmp	800030ec <et024006_SetLimits+0x2c>
80002f6c:	80 00       	ld.sh	r0,r0[0x0]
80002f6e:	40 f4       	lddsp	r4,sp[0x3c]
80002f70:	00 00       	add	r0,r0
80002f72:	05 58       	ld.sh	r8,--r2

80002f74 <tpa6130_init>:
 *  specified in the conf_tpa6130.h file (stereo, mono ..).
 *
 *  \returns A positive value upon success and a negative value upon failure.
 */
int8_t tpa6130_init(void)
{
80002f74:	d4 01       	pushm	lr
  /* Check if the device responds on the TWI bus*/
  if(twi_probe(TPA6130_TWI, TPA6130_TWI_ADDRESS) != TWI_SUCCESS)
80002f76:	36 0b       	mov	r11,96
80002f78:	fe 7c 2c 00 	mov	r12,-54272
80002f7c:	f0 1f 00 0e 	mcall	80002fb4 <tpa6130_init+0x40>
80002f80:	c0 40       	breq	80002f88 <tpa6130_init+0x14>
80002f82:	e0 6c 00 fd 	mov	r12,253
80002f86:	d8 02       	popm	pc
  return TWI_NO_CHIP_FOUND;
  /* If the device has no valid version we can not use it */
  if(tpa6130_read_data(TPA6130_I2C_ADDRESS_VERSION, TWI_READ_HW)!= VERSION)
80002f88:	30 0b       	mov	r11,0
80002f8a:	30 4c       	mov	r12,4
80002f8c:	f0 1f 00 0b 	mcall	80002fb8 <tpa6130_init+0x44>
80002f90:	30 28       	mov	r8,2
80002f92:	f0 0c 18 00 	cp.b	r12,r8
80002f96:	c0 40       	breq	80002f9e <tpa6130_init+0x2a>
80002f98:	e0 6c 00 f8 	mov	r12,248
80002f9c:	d8 02       	popm	pc
  {
    return -8;
  }
  /* un-mute the output channels, the volume is still 0 and
   * should be increased by an application (fade-in/fade-out) */
  tpa6130_write_data(TPA6130_VOLUME_AND_MUTE, tpa6130_shadow_regs.volume_and_mute);
80002f9e:	48 88       	lddpc	r8,80002fbc <tpa6130_init+0x48>
80002fa0:	11 9b       	ld.ub	r11,r8[0x1]
80002fa2:	30 2c       	mov	r12,2
80002fa4:	f0 1f 00 07 	mcall	80002fc0 <tpa6130_init+0x4c>
  /* set stereo/mono mode and enable both amplifiers (left/right) */
  tpa6130_write_data(TPA6130_CONTROL,(TPA6130_MODE << 4) | HP_EN_L | HP_EN_R);
80002fa8:	e0 6b 00 c0 	mov	r11,192
80002fac:	30 1c       	mov	r12,1
80002fae:	f0 1f 00 05 	mcall	80002fc0 <tpa6130_init+0x4c>
80002fb2:	d8 0a       	popm	pc,r12=0
80002fb4:	80 00       	ld.sh	r0,r0[0x0]
80002fb6:	47 70       	lddsp	r0,sp[0x1dc]
80002fb8:	80 00       	ld.sh	r0,r0[0x0]
80002fba:	2e ac       	sub	r12,-22
80002fbc:	00 00       	add	r0,r0
80002fbe:	00 08       	add	r8,r0
80002fc0:	80 00       	ld.sh	r0,r0[0x0]
80002fc2:	2d cc       	sub	r12,-36

80002fc4 <tpa6130_dac_setup>:
                       uint8_t bits_per_sample,
                       bool swap_channels,
                       void (*callback)(uint32_t arg),
                       uint32_t callback_opt,
                       uint32_t pba_hz)
{
80002fc4:	eb cd 40 c0 	pushm	r6-r7,lr
80002fc8:	20 6d       	sub	sp,24
80002fca:	18 97       	mov	r7,r12
80002fcc:	12 96       	mov	r6,r9
80002fce:	40 9a       	lddsp	r10,sp[0x24]
  // save input parameters to local driver data
  tpa6130_output_param.num_channels = num_channels;
80002fd0:	49 a9       	lddpc	r9,80003038 <tpa6130_dac_setup+0x74>
80002fd2:	b2 8b       	st.b	r9[0x0],r11
  tpa6130_output_param.callback     = callback;
80002fd4:	93 18       	st.w	r9[0x4],r8
  tpa6130_output_param.callback_opt = callback_opt;
80002fd6:	93 2a       	st.w	r9[0x8],r10

  /* Probe for amplifier and initialize it */
  tpa6130_init();
80002fd8:	f0 1f 00 19 	mcall	8000303c <tpa6130_dac_setup+0x78>
   * The generic clock input must be greater than 256*sample_rate_hz
   * or the setup of the ABDAC will fail silently here.
   * TODO we could add asserts here to detect wrong settings during
   * compile time.
   */
  if(!abdac_set_dac_sample_rate(sample_rate_hz)) {
80002fdc:	0e 9c       	mov	r12,r7
80002fde:	f0 1f 00 19 	mcall	80003040 <tpa6130_dac_setup+0x7c>
80002fe2:	c0 a1       	brne	80002ff6 <tpa6130_dac_setup+0x32>
    // if it is not possible to set correctly the sample rate
    // Use default set function
    abdac_set_dac_hz(TPA6130_ABDAC, TPA6130_ABDAC_GCLK_INPUT_HZ,sample_rate_hz);
80002fe4:	0e 9a       	mov	r10,r7
80002fe6:	e0 6b 1b 00 	mov	r11,6912
80002fea:	ea 1b 00 b7 	orh	r11,0xb7
80002fee:	fe 7c 40 00 	mov	r12,-49152
80002ff2:	f0 1f 00 15 	mcall	80003044 <tpa6130_dac_setup+0x80>
  }
#endif

  if(swap_channels)
80002ff6:	58 06       	cp.w	r6,0
80002ff8:	c0 50       	breq	80003002 <tpa6130_dac_setup+0x3e>
  {
    abdac_swap_channels(TPA6130_ABDAC);
80002ffa:	fe 7c 40 00 	mov	r12,-49152
80002ffe:	f0 1f 00 13 	mcall	80003048 <tpa6130_dac_setup+0x84>
  }
  abdac_enable(TPA6130_ABDAC);
80003002:	fe 7c 40 00 	mov	r12,-49152
80003006:	f0 1f 00 12 	mcall	8000304c <tpa6130_dac_setup+0x88>
    .size   = 0,
    .r_addr   = 0,
    .r_size   = 0,
    .pid    = TPA6130_ABDAC_PDCA_PID,
    .transfer_size  = PDCA_TRANSFER_SIZE_WORD
  };
8000300a:	49 28       	lddpc	r8,80003050 <tpa6130_dac_setup+0x8c>
8000300c:	1a 9b       	mov	r11,sp
8000300e:	f0 e6 00 00 	ld.d	r6,r8[0]
80003012:	fa e7 00 00 	st.d	sp[0],r6
80003016:	f0 e6 00 08 	ld.d	r6,r8[8]
8000301a:	fa e7 00 08 	st.d	sp[8],r6
8000301e:	f0 e8 00 10 	ld.d	r8,r8[16]
80003022:	fa e9 00 10 	st.d	sp[16],r8

  /* Initialize the PCDA for the ABDAC
   * The channel number can be set in the configuration file
   * with the define TPA6130_ABDAC_PDCA_CHANNEL.
   */
  pdca_init_channel(TPA6130_ABDAC_PDCA_CHANNEL,
80003026:	30 0c       	mov	r12,0
80003028:	f0 1f 00 0b 	mcall	80003054 <tpa6130_dac_setup+0x90>
    &tpa6130_abdac_pdca_options);
  /* Enable the PDCA channel. Since we did not provide any data
   * yet the channel is in idle mode */
  pdca_enable(TPA6130_ABDAC_PDCA_CHANNEL);
8000302c:	30 0c       	mov	r12,0
8000302e:	f0 1f 00 0b 	mcall	80003058 <tpa6130_dac_setup+0x94>

}
80003032:	2f ad       	sub	sp,-24
80003034:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003038:	00 00       	add	r0,r0
8000303a:	05 58       	ld.sh	r8,--r2
8000303c:	80 00       	ld.sh	r0,r0[0x0]
8000303e:	2f 74       	sub	r4,-9
80003040:	80 00       	ld.sh	r0,r0[0x0]
80003042:	3c bc       	mov	r12,-53
80003044:	80 00       	ld.sh	r0,r0[0x0]
80003046:	3c 3e       	mov	lr,-61
80003048:	80 00       	ld.sh	r0,r0[0x0]
8000304a:	3c 26       	mov	r6,-62
8000304c:	80 00       	ld.sh	r0,r0[0x0]
8000304e:	3b fc       	mov	r12,-65
80003050:	80 00       	ld.sh	r0,r0[0x0]
80003052:	cc 00       	breq	80002fd2 <tpa6130_dac_setup+0xe>
80003054:	80 00       	ld.sh	r0,r0[0x0]
80003056:	43 10       	lddsp	r0,sp[0xc4]
80003058:	80 00       	ld.sh	r0,r0[0x0]
8000305a:	42 48       	lddsp	r8,sp[0x90]

8000305c <tpa6130_dac_start>:
                       uint8_t bits_per_sample,
                       bool swap_channels,
                       void (*callback)(uint32_t arg),
                       uint32_t callback_opt,
                       uint32_t pba_hz)
{
8000305c:	eb cd 40 fe 	pushm	r1-r7,lr
80003060:	fa c4 ff e0 	sub	r4,sp,-32
80003064:	18 92       	mov	r2,r12
80003066:	16 93       	mov	r3,r11
80003068:	14 95       	mov	r5,r10
8000306a:	12 97       	mov	r7,r9
8000306c:	10 96       	mov	r6,r8
8000306e:	68 01       	ld.w	r1,r4[0x0]
80003070:	68 14       	ld.w	r4,r4[0x4]
  /* stop ABDAC if running*/
  tpa6130_dac_stop();
80003072:	f0 1f 00 0d 	mcall	800030a4 <tpa6130_dac_start+0x48>

  /* configure used pins for ABDAC */
  gpio_enable_module(TPA6130_ABDAC_GPIO_MAP,
80003076:	30 4b       	mov	r11,4
80003078:	48 cc       	lddpc	r12,800030a8 <tpa6130_dac_start+0x4c>
8000307a:	f0 1f 00 0d 	mcall	800030ac <tpa6130_dac_start+0x50>
    sizeof(TPA6130_ABDAC_GPIO_MAP) /
    sizeof(TPA6130_ABDAC_GPIO_MAP[0]));

  /* configure and start PDC and ABDAC*/
  tpa6130_dac_setup(sample_rate_hz,
8000307e:	1a d4       	st.w	--sp,r4
80003080:	1a d1       	st.w	--sp,r1
80003082:	0c 98       	mov	r8,r6
80003084:	0e 99       	mov	r9,r7
80003086:	0a 9a       	mov	r10,r5
80003088:	06 9b       	mov	r11,r3
8000308a:	04 9c       	mov	r12,r2
8000308c:	f0 1f 00 09 	mcall	800030b0 <tpa6130_dac_start+0x54>
    pba_hz);

  /* Register a interrupt service routine for the ABDAC channel of
   * the PDCA
   */
  irq_register_handler(tpa6130_abdac_tx_pdca_int_handler, TPA6130_ABDAC_PDCA_IRQ, 1);
80003090:	30 1a       	mov	r10,1
80003092:	36 0b       	mov	r11,96
80003094:	48 8c       	lddpc	r12,800030b4 <tpa6130_dac_start+0x58>
80003096:	f0 1f 00 09 	mcall	800030b8 <tpa6130_dac_start+0x5c>

  tpa6130_powerup();
8000309a:	f0 1f 00 09 	mcall	800030bc <tpa6130_dac_start+0x60>
8000309e:	2f ed       	sub	sp,-8

}
800030a0:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800030a4:	80 00       	ld.sh	r0,r0[0x0]
800030a6:	2f 30       	sub	r0,-13
800030a8:	80 00       	ld.sh	r0,r0[0x0]
800030aa:	cc 18       	rjmp	8000322c <et024006_PrintString+0xa4>
800030ac:	80 00       	ld.sh	r0,r0[0x0]
800030ae:	40 ac       	lddsp	r12,sp[0x28]
800030b0:	80 00       	ld.sh	r0,r0[0x0]
800030b2:	2f c4       	sub	r4,-4
800030b4:	80 00       	ld.sh	r0,r0[0x0]
800030b6:	2d 6c       	sub	r12,-42
800030b8:	80 00       	ld.sh	r0,r0[0x0]
800030ba:	41 6c       	lddsp	r12,sp[0x58]
800030bc:	80 00       	ld.sh	r0,r0[0x0]
800030be:	2e f0       	sub	r0,-17

800030c0 <et024006_SetLimits>:
/*! \brief Sets the display limits according to the corner coordinates.
 *  Writing to the display will result in writing to the area specified through
 *  this function.
 */
void et024006_SetLimits( uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2 )
{
800030c0:	eb cd 40 80 	pushm	r7,lr

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800030c4:	fc 1e c0 00 	movh	lr,0xc000
800030c8:	30 28       	mov	r8,2
800030ca:	bc 08       	st.h	lr[0x0],r8
  *ET024006_PARAM_ADDR = (uint16_t) value;
800030cc:	ef dc c1 08 	bfextu	r7,r12,0x8,0x8
800030d0:	fc 18 c0 20 	movh	r8,0xc020
800030d4:	b0 07       	st.h	r8[0x0],r7

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800030d6:	30 37       	mov	r7,3
800030d8:	bc 07       	st.h	lr[0x0],r7
  *ET024006_PARAM_ADDR = (uint16_t) value;
800030da:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800030dc:	30 4c       	mov	r12,4
800030de:	bc 0c       	st.h	lr[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
800030e0:	f9 da c1 08 	bfextu	r12,r10,0x8,0x8
800030e4:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800030e6:	30 5c       	mov	r12,5
800030e8:	bc 0c       	st.h	lr[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
800030ea:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800030ec:	30 6a       	mov	r10,6
800030ee:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800030f0:	f5 db c1 08 	bfextu	r10,r11,0x8,0x8
800030f4:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800030f6:	30 7a       	mov	r10,7
800030f8:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800030fa:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800030fc:	30 8a       	mov	r10,8
800030fe:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003100:	f5 d9 c1 08 	bfextu	r10,r9,0x8,0x8
80003104:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003106:	30 9a       	mov	r10,9
80003108:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000310a:	b0 09       	st.h	r8[0x0],r9
  et024006_WriteRegister( HIMAX_COL_ADDR_END1, (x2 & 0xff) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START2, (y1 >> 8) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START1, (y1 & 0xff) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_END2, (y2 >> 8) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_END1, (y2 & 0xff) );
}
8000310c:	e3 cd 80 80 	ldm	sp++,r7,pc

80003110 <et024006_DrawPixel>:
  return color;
}


void et024006_DrawPixel( uint16_t x, uint16_t y, et024006_color_t color )
{
80003110:	eb cd 40 80 	pushm	r7,lr
80003114:	14 97       	mov	r7,r10
  // Sanity check on parameters.
  Assert( x < ET024006_WIDTH );
  Assert( y < ET024006_HEIGHT );

  // Set up draw area and write the two bytes of pixel data.
  et024006_SetLimits( x, y, x, y );
80003116:	5c 7b       	castu.h	r11
80003118:	5c 7c       	castu.h	r12
8000311a:	16 99       	mov	r9,r11
8000311c:	18 9a       	mov	r10,r12
8000311e:	f0 1f 00 06 	mcall	80003134 <et024006_DrawPixel+0x24>
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003122:	32 29       	mov	r9,34
80003124:	fc 18 c0 00 	movh	r8,0xc000
80003128:	b0 09       	st.h	r8[0x0],r9
  et024006_SendSPI( ET024006_ID | ET024006_BS0 | ET024006_RS );
  et024006_SendSPI( color & 0xff );
  et024006_SendSPI( color >> 8 );
  et024006_DeselectSPI();
#else
  *ET024006_PARAM_ADDR = color;
8000312a:	fc 18 c0 20 	movh	r8,0xc020
8000312e:	b0 07       	st.h	r8[0x0],r7
#endif
}
80003130:	e3 cd 80 80 	ldm	sp++,r7,pc
80003134:	80 00       	ld.sh	r0,r0[0x0]
80003136:	30 c0       	mov	r0,12

80003138 <et024006_SetQuickLimits>:

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003138:	fc 19 c0 00 	movh	r9,0xc000
8000313c:	30 28       	mov	r8,2
8000313e:	b2 08       	st.h	r9[0x0],r8
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003140:	f5 dc c1 08 	bfextu	r10,r12,0x8,0x8
80003144:	fc 18 c0 20 	movh	r8,0xc020
80003148:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000314a:	30 3a       	mov	r10,3
8000314c:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000314e:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003150:	30 6a       	mov	r10,6
80003152:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003154:	f5 db c1 08 	bfextu	r10,r11,0x8,0x8
80003158:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000315a:	30 7a       	mov	r10,7
8000315c:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000315e:	b0 0b       	st.h	r8[0x0],r11
{
  et024006_WriteRegister( HIMAX_COL_ADDR_START2, (x >> 8) );
  et024006_WriteRegister( HIMAX_COL_ADDR_START1, (x & 0xff) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START2, (y >> 8) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START1, (y & 0xff) );
}
80003160:	5e fc       	retal	r12
80003162:	d7 03       	nop

80003164 <et024006_DrawQuickPixel>:
  et024006_WriteRegister( HIMAX_ROW_ADDR_END1, (y & 0xff) );
}


void et024006_DrawQuickPixel( uint16_t x, uint16_t y, et024006_color_t color )
{
80003164:	eb cd 40 80 	pushm	r7,lr
80003168:	14 97       	mov	r7,r10
  // Sanity check on parameters.
  Assert( x < ET024006_WIDTH );
  Assert( y < ET024006_HEIGHT );

  // Set up draw area and write the two bytes of pixel data.
  et024006_SetQuickLimits( x, y );
8000316a:	5c 7b       	castu.h	r11
8000316c:	5c 7c       	castu.h	r12
8000316e:	f0 1f 00 06 	mcall	80003184 <et024006_DrawQuickPixel+0x20>
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003172:	32 29       	mov	r9,34
80003174:	fc 18 c0 00 	movh	r8,0xc000
80003178:	b0 09       	st.h	r8[0x0],r9
  et024006_SendSPI( color & 0xff );
  et024006_SendSPI( color >> 8 );
  et024006_DeselectSPI();
#endif
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  *ET024006_PARAM_ADDR = color;
8000317a:	fc 18 c0 20 	movh	r8,0xc020
8000317e:	b0 07       	st.h	r8[0x0],r7
#endif

}
80003180:	e3 cd 80 80 	ldm	sp++,r7,pc
80003184:	80 00       	ld.sh	r0,r0[0x0]
80003186:	31 38       	mov	r8,19

80003188 <et024006_PrintString>:
void et024006_PrintString(char *lcd_string, const unsigned char *font_style,
                          uint16_t x,
                          uint16_t y,
                          uint16_t fcolor,
                          int bcolor)
{
80003188:	d4 31       	pushm	r0-r7,lr
8000318a:	20 dd       	sub	sp,52
8000318c:	18 97       	mov	r7,r12
8000318e:	50 6b       	stdsp	sp[0x18],r11
80003190:	50 8a       	stdsp	sp[0x20],r10
80003192:	50 29       	stdsp	sp[0x8],r9
80003194:	10 94       	mov	r4,r8
80003196:	41 63       	lddsp	r3,sp[0x58]
  unsigned char mask = 0, xfont, yfont, font_size;
  const unsigned char *data;
  uint16_t saved_x = x;

  // if string is empty there is nothing to do
  if( *lcd_string == '\0')
80003198:	19 89       	ld.ub	r9,r12[0x0]
8000319a:	30 08       	mov	r8,0
8000319c:	f0 09 18 00 	cp.b	r9,r8
800031a0:	e0 80 01 0c 	breq	800033b8 <et024006_PrintString+0x230>
    return;

  data = font_style;  // point to the start of the font table
  xfont = *data;  // get font x width
800031a4:	16 98       	mov	r8,r11
800031a6:	11 3a       	ld.ub	r10,r8++
800031a8:	50 4a       	stdsp	sp[0x10],r10
  data++;
  yfont = *data;  // get font y length
800031aa:	11 89       	ld.ub	r9,r8[0x0]
800031ac:	50 39       	stdsp	sp[0xc],r9
  data++;
  font_size = *data;  // get data bytes per font
800031ae:	11 98       	ld.ub	r8,r8[0x1]
800031b0:	50 58       	stdsp	sp[0x14],r8

  // If transparent mode
  if(bcolor == -1)
800031b2:	5b f3       	cp.w	r3,-1
800031b4:	e0 81 00 8d 	brne	800032ce <et024006_PrintString+0x146>
  {
    // set window to display size
    et024006_SetLimits( 0, 0, ET024006_WIDTH - 1, ET024006_HEIGHT - 1 );
800031b8:	e0 69 00 ef 	mov	r9,239
800031bc:	e0 6a 01 3f 	mov	r10,319
800031c0:	30 0b       	mov	r11,0
800031c2:	16 9c       	mov	r12,r11
800031c4:	f0 1f 00 7e 	mcall	800033bc <et024006_PrintString+0x234>
        data =  (font_style + font_size) +  // header offset
          (font_size * (int)(*lcd_string - 32)); // character select
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;
800031c8:	40 58       	lddsp	r8,sp[0x14]
800031ca:	50 c8       	stdsp	sp[0x30],r8
800031cc:	f0 08 00 18 	add	r8,r8,r8<<0x1
800031d0:	a5 78       	lsl	r8,0x5
800031d2:	40 69       	lddsp	r9,sp[0x18]
800031d4:	10 09       	add	r9,r8
800031d6:	50 b9       	stdsp	sp[0x2c],r9
800031d8:	ee c8 ff ff 	sub	r8,r7,-1
800031dc:	50 98       	stdsp	sp[0x24],r8
800031de:	40 8a       	lddsp	r10,sp[0x20]
800031e0:	5c 8a       	casts.h	r10
800031e2:	50 aa       	stdsp	sp[0x28],r10
      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
        {
          if (*data & mask) // if pixel data then put dot
800031e4:	30 03       	mov	r3,0
          {
            et024006_DrawQuickPixel( col, row, fcolor );
800031e6:	08 90       	mov	r0,r4
800031e8:	5c 70       	castu.h	r0
    // set window to display size
    et024006_SetLimits( 0, 0, ET024006_WIDTH - 1, ET024006_HEIGHT - 1 );

    do
    {
      if(*lcd_string =='\n') {
800031ea:	40 99       	lddsp	r9,sp[0x24]
800031ec:	f3 38 ff ff 	ld.ub	r8,r9[-1]
800031f0:	30 aa       	mov	r10,10
800031f2:	f4 08 18 00 	cp.b	r8,r10
800031f6:	c0 b1       	brne	8000320c <et024006_PrintString+0x84>
        x = saved_x;
        y += yfont;
800031f8:	40 28       	lddsp	r8,sp[0x8]
800031fa:	40 39       	lddsp	r9,sp[0xc]
800031fc:	12 08       	add	r8,r9
800031fe:	5c 88       	casts.h	r8
80003200:	50 28       	stdsp	sp[0x8],r8
80003202:	40 98       	lddsp	r8,sp[0x24]
80003204:	40 8a       	lddsp	r10,sp[0x20]
80003206:	5c 8a       	casts.h	r10
80003208:	50 aa       	stdsp	sp[0x28],r10
        lcd_string++;  // next character in string
        continue;
8000320a:	c5 a8       	rjmp	800032be <et024006_PrintString+0x136>
      } else if(*lcd_string =='\t') {
8000320c:	30 99       	mov	r9,9
8000320e:	f2 08 18 00 	cp.b	r8,r9
80003212:	c0 81       	brne	80003222 <et024006_PrintString+0x9a>
        x += xfont;
80003214:	40 a8       	lddsp	r8,sp[0x28]
80003216:	40 49       	lddsp	r9,sp[0x10]
80003218:	12 08       	add	r8,r9
8000321a:	5c 88       	casts.h	r8
8000321c:	50 a8       	stdsp	sp[0x28],r8
8000321e:	40 98       	lddsp	r8,sp[0x24]
        lcd_string++;  // next character in string
        continue;
80003220:	c4 f8       	rjmp	800032be <et024006_PrintString+0x136>
      }
      // Checks if the character can be printed
      if (*lcd_string >= 32 && *lcd_string < (32 + 96))
80003222:	f0 ca 00 20 	sub	r10,r8,32
80003226:	35 f9       	mov	r9,95
80003228:	f2 0a 18 00 	cp.b	r10,r9
8000322c:	e0 88 00 04 	brls	80003234 <et024006_PrintString+0xac>
80003230:	40 b5       	lddsp	r5,sp[0x2c]
80003232:	c0 a8       	rjmp	80003246 <et024006_PrintString+0xbe>
      {
        // point to character data in font table
        data =  (font_style + font_size) +  // header offset
80003234:	22 08       	sub	r8,32
80003236:	40 ca       	lddsp	r10,sp[0x30]
80003238:	f0 0a 02 45 	mul	r5,r8,r10
8000323c:	40 59       	lddsp	r9,sp[0x14]
8000323e:	12 05       	add	r5,r9
80003240:	40 68       	lddsp	r8,sp[0x18]
80003242:	f0 05 00 05 	add	r5,r8,r5
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
80003246:	40 22       	lddsp	r2,sp[0x8]
80003248:	5c 72       	castu.h	r2
8000324a:	40 3a       	lddsp	r10,sp[0xc]
8000324c:	e4 0a 00 0a 	add	r10,r2,r10
80003250:	50 1a       	stdsp	sp[0x4],r10
80003252:	04 3a       	cp.w	r10,r2
80003254:	e0 8a 00 2f 	brle	800032b2 <et024006_PrintString+0x12a>
80003258:	40 21       	lddsp	r1,sp[0x8]
8000325a:	5c 81       	casts.h	r1
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
8000325c:	40 a9       	lddsp	r9,sp[0x28]
8000325e:	5c 79       	castu.h	r9
80003260:	50 09       	stdsp	sp[0x0],r9
80003262:	12 94       	mov	r4,r9
80003264:	40 48       	lddsp	r8,sp[0x10]
80003266:	10 04       	add	r4,r8
80003268:	40 aa       	lddsp	r10,sp[0x28]
8000326a:	5c 8a       	casts.h	r10
8000326c:	50 7a       	stdsp	sp[0x1c],r10
8000326e:	c1 b8       	rjmp	800032a4 <et024006_PrintString+0x11c>
        {
          if (*data & mask) // if pixel data then put dot
          {
            et024006_DrawQuickPixel( col, row, fcolor );
          }
          mask >>= 1;
80003270:	a1 96       	lsr	r6,0x1
      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
        {
          if (*data & mask) // if pixel data then put dot
80003272:	0b 88       	ld.ub	r8,r5[0x0]
80003274:	ed e8 00 08 	and	r8,r6,r8
80003278:	e6 08 18 00 	cp.b	r8,r3
8000327c:	c0 50       	breq	80003286 <et024006_PrintString+0xfe>
          {
            et024006_DrawQuickPixel( col, row, fcolor );
8000327e:	00 9a       	mov	r10,r0
80003280:	04 9b       	mov	r11,r2
80003282:	f0 1f 00 50 	mcall	800033c0 <et024006_PrintString+0x238>
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
80003286:	2f f7       	sub	r7,-1
80003288:	5c 87       	casts.h	r7
8000328a:	0e 9c       	mov	r12,r7
8000328c:	5c 7c       	castu.h	r12
8000328e:	08 3c       	cp.w	r12,r4
80003290:	cf 05       	brlt	80003270 <et024006_PrintString+0xe8>
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
80003292:	2f f1       	sub	r1,-1
80003294:	5c 81       	casts.h	r1
80003296:	e5 d1 c0 10 	bfextu	r2,r1,0x0,0x10
8000329a:	40 19       	lddsp	r9,sp[0x4]
8000329c:	04 39       	cp.w	r9,r2
8000329e:	e0 8a 00 0a 	brle	800032b2 <et024006_PrintString+0x12a>
            et024006_DrawQuickPixel( col, row, fcolor );
          }
          mask >>= 1;
        }
        // Next row data
        data++;
800032a2:	2f f5       	sub	r5,-1
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
800032a4:	40 0c       	lddsp	r12,sp[0x0]
800032a6:	08 3c       	cp.w	r12,r4
800032a8:	cf 54       	brge	80003292 <et024006_PrintString+0x10a>
800032aa:	40 77       	lddsp	r7,sp[0x1c]
800032ac:	e0 66 00 80 	mov	r6,128
800032b0:	ce 1b       	rjmp	80003272 <et024006_PrintString+0xea>
        }
        // Next row data
        data++;
      }
      // move to next character start pixel
      x += xfont;
800032b2:	40 a8       	lddsp	r8,sp[0x28]
800032b4:	40 4a       	lddsp	r10,sp[0x10]
800032b6:	14 08       	add	r8,r10
800032b8:	5c 88       	casts.h	r8
800032ba:	50 a8       	stdsp	sp[0x28],r8
800032bc:	40 98       	lddsp	r8,sp[0x24]
800032be:	40 99       	lddsp	r9,sp[0x24]
800032c0:	2f f9       	sub	r9,-1
800032c2:	50 99       	stdsp	sp[0x24],r9
      lcd_string++;  // next character in string

    }while(*lcd_string !='\0');  // keep spitting chars out until end of string
800032c4:	11 88       	ld.ub	r8,r8[0x0]
800032c6:	e6 08 18 00 	cp.b	r8,r3
800032ca:	c9 01       	brne	800031ea <et024006_PrintString+0x62>
800032cc:	c7 68       	rjmp	800033b8 <et024006_PrintString+0x230>
800032ce:	f8 c8 ff ff 	sub	r8,r12,-1
800032d2:	50 08       	stdsp	sp[0x0],r8
800032d4:	40 8c       	lddsp	r12,sp[0x20]
800032d6:	5c 8c       	casts.h	r12
      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
        {
          if (*data & mask) // if pixel data then put dot
800032d8:	30 06       	mov	r6,0
          {
            *ET024006_PARAM_ADDR = fcolor;
          }
          else  // else use background color
          {
            *ET024006_PARAM_ADDR = bcolor;
800032da:	5c 83       	casts.h	r3
800032dc:	fc 15 c0 20 	movh	r5,0xc020
  }
  else
  {
    do
    {
      if(*lcd_string =='\n') {
800032e0:	40 0a       	lddsp	r10,sp[0x0]
800032e2:	f5 31 ff ff 	ld.ub	r1,r10[-1]
800032e6:	30 a8       	mov	r8,10
800032e8:	f0 01 18 00 	cp.b	r1,r8
800032ec:	c0 b1       	brne	80003302 <et024006_PrintString+0x17a>
        x = saved_x;
        y += yfont;
800032ee:	40 28       	lddsp	r8,sp[0x8]
800032f0:	40 39       	lddsp	r9,sp[0xc]
800032f2:	12 08       	add	r8,r9
800032f4:	5c 88       	casts.h	r8
800032f6:	50 28       	stdsp	sp[0x8],r8
800032f8:	14 98       	mov	r8,r10
800032fa:	40 8a       	lddsp	r10,sp[0x20]
800032fc:	5c 8a       	casts.h	r10
800032fe:	50 1a       	stdsp	sp[0x4],r10
        lcd_string++;  // next character in string
        continue;
80003300:	c5 28       	rjmp	800033a4 <et024006_PrintString+0x21c>
      } else if(*lcd_string =='\t') {
80003302:	30 98       	mov	r8,9
80003304:	f0 01 18 00 	cp.b	r1,r8
80003308:	c0 71       	brne	80003316 <et024006_PrintString+0x18e>
        x += xfont;
8000330a:	40 49       	lddsp	r9,sp[0x10]
8000330c:	12 0c       	add	r12,r9
8000330e:	5c 8c       	casts.h	r12
80003310:	50 1c       	stdsp	sp[0x4],r12
80003312:	40 08       	lddsp	r8,sp[0x0]
        lcd_string++;  // next character in string
        continue;
80003314:	c4 88       	rjmp	800033a4 <et024006_PrintString+0x21c>
      // point to character data in font table
      data =  (font_style + font_size) +  // header offset
        (font_size * (int)(*lcd_string - 32)); // character select

      // set a window for the character
      et024006_SetLimits( x, y, x + xfont - 1, y + yfont - 1 );
80003316:	40 32       	lddsp	r2,sp[0xc]
80003318:	40 47       	lddsp	r7,sp[0x10]
8000331a:	f8 07 00 08 	add	r8,r12,r7
8000331e:	5c 88       	casts.h	r8
80003320:	50 18       	stdsp	sp[0x4],r8
80003322:	04 99       	mov	r9,r2
80003324:	20 19       	sub	r9,1
80003326:	40 28       	lddsp	r8,sp[0x8]
80003328:	10 09       	add	r9,r8
8000332a:	40 1a       	lddsp	r10,sp[0x4]
8000332c:	20 1a       	sub	r10,1
8000332e:	5c 79       	castu.h	r9
80003330:	5c 7a       	castu.h	r10
80003332:	10 9b       	mov	r11,r8
80003334:	5c 7b       	castu.h	r11
80003336:	5c 7c       	castu.h	r12
80003338:	f0 1f 00 21 	mcall	800033bc <et024006_PrintString+0x234>
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000333c:	32 29       	mov	r9,34
8000333e:	fc 18 c0 00 	movh	r8,0xc000
80003342:	b0 09       	st.h	r8[0x0],r9

      // set a window for the character
      et024006_SetLimits( x, y, x + xfont - 1, y + yfont - 1 );
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
80003344:	40 3a       	lddsp	r10,sp[0xc]
80003346:	58 0a       	cp.w	r10,0
80003348:	c2 d0       	breq	800033a2 <et024006_PrintString+0x21a>
        x += xfont;
        lcd_string++;  // next character in string
        continue;
      }
      // point to character data in font table
      data =  (font_style + font_size) +  // header offset
8000334a:	e2 ce 00 20 	sub	lr,r1,32
8000334e:	40 59       	lddsp	r9,sp[0x14]
80003350:	f2 0e 02 4e 	mul	lr,r9,lr
80003354:	12 0e       	add	lr,r9
80003356:	40 68       	lddsp	r8,sp[0x18]
80003358:	f0 0e 00 0e 	add	lr,r8,lr
8000335c:	30 0c       	mov	r12,0
      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
        {
          if (*data & mask) // if pixel data then put dot
8000335e:	e0 60 00 80 	mov	r0,128
80003362:	18 91       	mov	r1,r12
80003364:	c1 98       	rjmp	80003396 <et024006_PrintString+0x20e>
          }
          else  // else use background color
          {
            *ET024006_PARAM_ADDR = bcolor;
          }
          mask >>= 1;
80003366:	a1 99       	lsr	r9,0x1
      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
        {
          if (*data & mask) // if pixel data then put dot
80003368:	f3 eb 00 0a 	and	r10,r9,r11
          {
            *ET024006_PARAM_ADDR = fcolor;
8000336c:	ec 0a 18 00 	cp.b	r10,r6
80003370:	e8 0a 17 10 	movne	r10,r4
80003374:	eb fa 1c 00 	st.hne	r5[0x0],r10
          }
          else  // else use background color
          {
            *ET024006_PARAM_ADDR = bcolor;
80003378:	eb f3 0c 00 	st.heq	r5[0x0],r3
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
8000337c:	2f f8       	sub	r8,-1
8000337e:	5c 88       	casts.h	r8
80003380:	f0 07 19 00 	cp.h	r7,r8
80003384:	fe 9b ff f1 	brhi	80003366 <et024006_PrintString+0x1de>

      // set a window for the character
      et024006_SetLimits( x, y, x + xfont - 1, y + yfont - 1 );
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
80003388:	2f fc       	sub	r12,-1
8000338a:	5c 8c       	casts.h	r12
8000338c:	f8 02 19 00 	cp.h	r2,r12
80003390:	e0 88 00 09 	brls	800033a2 <et024006_PrintString+0x21a>
          }
          mask >>= 1;
        }

        // Next row data
        data++;
80003394:	2f fe       	sub	lr,-1
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
80003396:	58 07       	cp.w	r7,0
80003398:	cf 80       	breq	80003388 <et024006_PrintString+0x200>
        {
          if (*data & mask) // if pixel data then put dot
8000339a:	1d 8b       	ld.ub	r11,lr[0x0]
8000339c:	00 99       	mov	r9,r0
8000339e:	02 98       	mov	r8,r1
800033a0:	ce 4b       	rjmp	80003368 <et024006_PrintString+0x1e0>
800033a2:	40 08       	lddsp	r8,sp[0x0]
800033a4:	40 09       	lddsp	r9,sp[0x0]
800033a6:	2f f9       	sub	r9,-1
800033a8:	50 09       	stdsp	sp[0x0],r9
      }
      // move to next character start pixel
      x += xfont;
      lcd_string++;  // next character in string

    }while(*lcd_string !='\0');  // keep spitting chars out until end of string
800033aa:	11 88       	ld.ub	r8,r8[0x0]
800033ac:	ec 08 18 00 	cp.b	r8,r6
800033b0:	c0 40       	breq	800033b8 <et024006_PrintString+0x230>
800033b2:	40 1c       	lddsp	r12,sp[0x4]
800033b4:	5c 8c       	casts.h	r12
800033b6:	c9 5b       	rjmp	800032e0 <et024006_PrintString+0x158>
  }
}
800033b8:	2f 3d       	sub	sp,-52
800033ba:	d8 32       	popm	r0-r7,pc
800033bc:	80 00       	ld.sh	r0,r0[0x0]
800033be:	30 c0       	mov	r0,12
800033c0:	80 00       	ld.sh	r0,r0[0x0]
800033c2:	31 64       	mov	r4,22

800033c4 <et024006_DrawLine>:
  et024006_DrawFilledRect( x, y, 1, length, color );
}


void et024006_DrawLine( uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, et024006_color_t color )
{
800033c4:	d4 31       	pushm	r0-r7,lr
800033c6:	20 3d       	sub	sp,12
800033c8:	18 95       	mov	r5,r12
800033ca:	16 94       	mov	r4,r11
800033cc:	14 93       	mov	r3,r10
800033ce:	12 92       	mov	r2,r9
800033d0:	10 91       	mov	r1,r8
  et024006_SetLimits( 0, 0, ET024006_WIDTH - 1, ET024006_HEIGHT - 1 );
800033d2:	e0 69 00 ef 	mov	r9,239
800033d6:	e0 6a 01 3f 	mov	r10,319
800033da:	30 0b       	mov	r11,0
800033dc:	16 9c       	mov	r12,r11
800033de:	f0 1f 00 3e 	mcall	800034d4 <et024006_DrawLine+0x110>
  Assert( y2 < ET024006_HEIGHT );

  // Compute deltas, ie. "width" and "height" of line, then
  // compute x and y direction, and make deltas positive for later use.
  int16_t xinc = 1; // Start off assuming direction is positive, ie. right.
  int16_t dx = x2 - x1;
800033e2:	0a 13       	sub	r3,r5
800033e4:	5c 83       	casts.h	r3
  if (dx < 0){
800033e6:	30 08       	mov	r8,0
800033e8:	f0 03 19 00 	cp.h	r3,r8
800033ec:	c0 35       	brlt	800033f2 <et024006_DrawLine+0x2e>
800033ee:	30 10       	mov	r0,1
800033f0:	c0 48       	rjmp	800033f8 <et024006_DrawLine+0x34>
    xinc = -1;
    dx = -dx;
800033f2:	5c 33       	neg	r3
800033f4:	5c 83       	casts.h	r3
800033f6:	3f f0       	mov	r0,-1
  }
  int16_t yinc = 1; // Start off assuming direction is positive, ie. down.
  int16_t dy = y2 - y1;
800033f8:	08 12       	sub	r2,r4
800033fa:	5c 82       	casts.h	r2
  if (dy < 0){
800033fc:	30 08       	mov	r8,0
800033fe:	f0 02 19 00 	cp.h	r2,r8
80003402:	c0 45       	brlt	8000340a <et024006_DrawLine+0x46>
80003404:	30 18       	mov	r8,1
80003406:	50 18       	stdsp	sp[0x4],r8
80003408:	c0 58       	rjmp	80003412 <et024006_DrawLine+0x4e>
    yinc = -1;
    dy = -dy;
8000340a:	5c 32       	neg	r2
8000340c:	5c 82       	casts.h	r2
8000340e:	3f f9       	mov	r9,-1
80003410:	50 19       	stdsp	sp[0x4],r9
  // Set up current point.
  uint16_t x = x1;
  uint16_t y = y1;
  uint16_t i;
  // A "flat" line (dx>dy) is handled differently from a "steep" line (dx<dy).
  if (dx > dy) {
80003412:	e4 03 19 00 	cp.h	r3,r2
80003416:	e0 8a 00 2e 	brle	80003472 <et024006_DrawLine+0xae>
    // Walk along X, draw pixel, and step Y when required.
    int16_t e = dx >> 1;
    for ( i = 0; i <= dx; ++i) {
8000341a:	50 03       	stdsp	sp[0x0],r3
8000341c:	58 03       	cp.w	r3,0
8000341e:	c5 85       	brlt	800034ce <et024006_DrawLine+0x10a>
  uint16_t y = y1;
  uint16_t i;
  // A "flat" line (dx>dy) is handled differently from a "steep" line (dx<dy).
  if (dx > dy) {
    // Walk along X, draw pixel, and step Y when required.
    int16_t e = dx >> 1;
80003420:	e6 07 14 01 	asr	r7,r3,0x1
80003424:	5c 84       	casts.h	r4
80003426:	5c 85       	casts.h	r5
80003428:	30 06       	mov	r6,0
    for ( i = 0; i <= dx; ++i) {
      et024006_DrawQuickPixel(x,y,color);
8000342a:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
      // Sub-pixel "error" overflowed, so we step Y and reset the "error".
      if (e <= 0){
8000342e:	30 01       	mov	r1,0
80003430:	50 23       	stdsp	sp[0x8],r3
80003432:	1c 93       	mov	r3,lr
  // A "flat" line (dx>dy) is handled differently from a "steep" line (dx<dy).
  if (dx > dy) {
    // Walk along X, draw pixel, and step Y when required.
    int16_t e = dx >> 1;
    for ( i = 0; i <= dx; ++i) {
      et024006_DrawQuickPixel(x,y,color);
80003434:	06 9a       	mov	r10,r3
80003436:	08 9b       	mov	r11,r4
80003438:	5c 7b       	castu.h	r11
8000343a:	f9 d5 c0 10 	bfextu	r12,r5,0x0,0x10
8000343e:	f0 1f 00 27 	mcall	800034d8 <et024006_DrawLine+0x114>
      // Sub-pixel "error" overflowed, so we step Y and reset the "error".
      if (e <= 0){
80003442:	e2 07 19 00 	cp.h	r7,r1
80003446:	e0 89 00 08 	brgt	80003456 <et024006_DrawLine+0x92>
        e += dx;
8000344a:	40 29       	lddsp	r9,sp[0x8]
8000344c:	12 07       	add	r7,r9
8000344e:	5c 87       	casts.h	r7
        y += yinc;
80003450:	40 18       	lddsp	r8,sp[0x4]
80003452:	10 04       	add	r4,r8
80003454:	5c 84       	casts.h	r4
  uint16_t i;
  // A "flat" line (dx>dy) is handled differently from a "steep" line (dx<dy).
  if (dx > dy) {
    // Walk along X, draw pixel, and step Y when required.
    int16_t e = dx >> 1;
    for ( i = 0; i <= dx; ++i) {
80003456:	2f f6       	sub	r6,-1
80003458:	5c 86       	casts.h	r6
8000345a:	f1 d6 c0 10 	bfextu	r8,r6,0x0,0x10
8000345e:	40 09       	lddsp	r9,sp[0x0]
80003460:	12 38       	cp.w	r8,r9
80003462:	e0 89 00 36 	brgt	800034ce <et024006_DrawLine+0x10a>
      if (e <= 0){
        e += dx;
        y += yinc;
      }
      // Walk one step along X.
      e -= dy;
80003466:	04 17       	sub	r7,r2
80003468:	5c 87       	casts.h	r7
8000346a:	e0 05 00 05 	add	r5,r0,r5
8000346e:	5c 85       	casts.h	r5
80003470:	ce 2b       	rjmp	80003434 <et024006_DrawLine+0x70>
      x += xinc;
    }
  } else {
    // Walk along Y, draw pixel, and step X when required.
    int16_t e = dy >> 1;
    for (i = 0; i <= dy; ++i) {
80003472:	50 02       	stdsp	sp[0x0],r2
80003474:	58 02       	cp.w	r2,0
80003476:	c2 c5       	brlt	800034ce <et024006_DrawLine+0x10a>
      e -= dy;
      x += xinc;
    }
  } else {
    // Walk along Y, draw pixel, and step X when required.
    int16_t e = dy >> 1;
80003478:	e4 07 14 01 	asr	r7,r2,0x1
8000347c:	5c 84       	casts.h	r4
8000347e:	5c 85       	casts.h	r5
80003480:	30 06       	mov	r6,0
    for (i = 0; i <= dy; ++i) {
      et024006_DrawQuickPixel(x,y,color);
80003482:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
      // Sub-pixel "error" overflowed, so we step X and reset the "error".
      if (e <= 0){
80003486:	30 01       	mov	r1,0
80003488:	50 22       	stdsp	sp[0x8],r2
8000348a:	40 12       	lddsp	r2,sp[0x4]
8000348c:	50 10       	stdsp	sp[0x4],r0
8000348e:	1c 90       	mov	r0,lr
    }
  } else {
    // Walk along Y, draw pixel, and step X when required.
    int16_t e = dy >> 1;
    for (i = 0; i <= dy; ++i) {
      et024006_DrawQuickPixel(x,y,color);
80003490:	00 9a       	mov	r10,r0
80003492:	08 9b       	mov	r11,r4
80003494:	5c 7b       	castu.h	r11
80003496:	f9 d5 c0 10 	bfextu	r12,r5,0x0,0x10
8000349a:	f0 1f 00 10 	mcall	800034d8 <et024006_DrawLine+0x114>
      // Sub-pixel "error" overflowed, so we step X and reset the "error".
      if (e <= 0){
8000349e:	e2 07 19 00 	cp.h	r7,r1
800034a2:	e0 89 00 08 	brgt	800034b2 <et024006_DrawLine+0xee>
        e += dy;
800034a6:	40 29       	lddsp	r9,sp[0x8]
800034a8:	12 07       	add	r7,r9
800034aa:	5c 87       	casts.h	r7
        x += xinc;
800034ac:	40 18       	lddsp	r8,sp[0x4]
800034ae:	10 05       	add	r5,r8
800034b0:	5c 85       	casts.h	r5
      x += xinc;
    }
  } else {
    // Walk along Y, draw pixel, and step X when required.
    int16_t e = dy >> 1;
    for (i = 0; i <= dy; ++i) {
800034b2:	2f f6       	sub	r6,-1
800034b4:	5c 86       	casts.h	r6
800034b6:	f1 d6 c0 10 	bfextu	r8,r6,0x0,0x10
800034ba:	40 09       	lddsp	r9,sp[0x0]
800034bc:	12 38       	cp.w	r8,r9
800034be:	e0 89 00 08 	brgt	800034ce <et024006_DrawLine+0x10a>
      if (e <= 0){
        e += dy;
        x += xinc;
      }
      // Walk one step along Y.
      e -= dx;
800034c2:	06 17       	sub	r7,r3
800034c4:	5c 87       	casts.h	r7
800034c6:	e4 04 00 04 	add	r4,r2,r4
800034ca:	5c 84       	casts.h	r4
800034cc:	ce 2b       	rjmp	80003490 <et024006_DrawLine+0xcc>
      y += yinc;
    }
  }
}
800034ce:	2f dd       	sub	sp,-12
800034d0:	d8 32       	popm	r0-r7,pc
800034d2:	00 00       	add	r0,r0
800034d4:	80 00       	ld.sh	r0,r0[0x0]
800034d6:	30 c0       	mov	r0,12
800034d8:	80 00       	ld.sh	r0,r0[0x0]
800034da:	31 64       	mov	r4,22

800034dc <et024006_DuplicatePixel>:
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800034dc:	32 29       	mov	r9,34
800034de:	fc 18 c0 00 	movh	r8,0xc000
800034e2:	b0 09       	st.h	r8[0x0],r9
  Assert( count > 0 );

  et024006_SelectRegister( HIMAX_SRAMWRITE );
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  //uint8_t countLowByte = count;
  while (count >= 8) {
800034e4:	58 7b       	cp.w	r11,7
800034e6:	e0 88 00 13 	brls	8000350c <et024006_DuplicatePixel+0x30>
800034ea:	16 99       	mov	r9,r11
    *ET024006_PARAM_ADDR = color;
800034ec:	fc 18 c0 20 	movh	r8,0xc020
800034f0:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
800034f2:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
800034f4:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
800034f6:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
800034f8:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
800034fa:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
800034fc:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
800034fe:	b0 0c       	st.h	r8[0x0],r12
    count-=8;
80003500:	20 89       	sub	r9,8
  Assert( count > 0 );

  et024006_SelectRegister( HIMAX_SRAMWRITE );
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  //uint8_t countLowByte = count;
  while (count >= 8) {
80003502:	58 79       	cp.w	r9,7
80003504:	fe 9b ff f6 	brhi	800034f0 <et024006_DuplicatePixel+0x14>



/* --- Pixel block operations --- */

void et024006_DuplicatePixel( et024006_color_t color, uint32_t count )
80003508:	f7 db c0 03 	bfextu	r11,r11,0x0,0x3
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    count-=8;
  }
  while (count > 0) {
8000350c:	58 0b       	cp.w	r11,0
8000350e:	5e 0c       	reteq	r12
    *ET024006_PARAM_ADDR = color;
80003510:	fc 18 c0 20 	movh	r8,0xc020
80003514:	b0 0c       	st.h	r8[0x0],r12
    --count;
80003516:	20 1b       	sub	r11,1
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    count-=8;
  }
  while (count > 0) {
80003518:	cf e1       	brne	80003514 <et024006_DuplicatePixel+0x38>
8000351a:	5e fc       	retal	r12

8000351c <et024006_DrawFilledRect>:
  }
}


void et024006_DrawFilledRect( uint16_t x, uint16_t y, uint16_t width, uint16_t height, et024006_color_t color )
{
8000351c:	eb cd 40 e0 	pushm	r5-r7,lr
80003520:	14 97       	mov	r7,r10
80003522:	12 96       	mov	r6,r9
80003524:	10 95       	mov	r5,r8
  // More sanity check.
  Assert( x2 < ET024006_WIDTH );
  Assert( y2 < ET024006_HEIGHT );

  // Set up draw area and copy pixel color until area is full.
  et024006_SetLimits( x, y, x2, y2 );
80003526:	f6 c9 00 01 	sub	r9,r11,1
8000352a:	0c 09       	add	r9,r6
8000352c:	f8 ca 00 01 	sub	r10,r12,1
80003530:	0e 0a       	add	r10,r7
80003532:	5c 79       	castu.h	r9
80003534:	5c 7a       	castu.h	r10
80003536:	5c 7b       	castu.h	r11
80003538:	5c 7c       	castu.h	r12
8000353a:	f0 1f 00 07 	mcall	80003554 <et024006_DrawFilledRect+0x38>
  uint32_t count = (uint32_t) width * height;
  et024006_DuplicatePixel( color, count );
8000353e:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80003542:	5c 77       	castu.h	r7
80003544:	af 3b       	mul	r11,r7
80003546:	f9 d5 c0 10 	bfextu	r12,r5,0x0,0x10
8000354a:	f0 1f 00 04 	mcall	80003558 <et024006_DrawFilledRect+0x3c>
}
8000354e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003552:	00 00       	add	r0,r0
80003554:	80 00       	ld.sh	r0,r0[0x0]
80003556:	30 c0       	mov	r0,12
80003558:	80 00       	ld.sh	r0,r0[0x0]
8000355a:	34 dc       	mov	r12,77

8000355c <et024006_DrawVertLine>:
  et024006_DrawFilledRect( x, y, length, 1, color );
}


void et024006_DrawVertLine( uint16_t x, uint16_t y, uint16_t length, et024006_color_t color )
{
8000355c:	d4 01       	pushm	lr
  et024006_DrawFilledRect( x, y, 1, length, color );
8000355e:	f1 d9 c0 10 	bfextu	r8,r9,0x0,0x10
80003562:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80003566:	30 1a       	mov	r10,1
80003568:	5c 7b       	castu.h	r11
8000356a:	5c 7c       	castu.h	r12
8000356c:	f0 1f 00 02 	mcall	80003574 <et024006_DrawVertLine+0x18>
}
80003570:	d8 02       	popm	pc
80003572:	00 00       	add	r0,r0
80003574:	80 00       	ld.sh	r0,r0[0x0]
80003576:	35 1c       	mov	r12,81

80003578 <et024006_DrawFilledCircle>:
	uint16_t x,
	uint16_t y,
	uint16_t radius,
	uint16_t color,
	uint8_t quadrantMask )
{
80003578:	d4 31       	pushm	r0-r7,lr
8000357a:	20 5d       	sub	sp,20
8000357c:	18 92       	mov	r2,r12
8000357e:	16 90       	mov	r0,r11
	// Draw only a pixel if radius is zero.
	if (radius == 0) {
80003580:	58 0a       	cp.w	r10,0
80003582:	c0 81       	brne	80003592 <et024006_DrawFilledCircle+0x1a>
		et024006_DrawPixel( x, y, color );
80003584:	f5 d9 c0 10 	bfextu	r10,r9,0x0,0x10
80003588:	5c 7b       	castu.h	r11
8000358a:	5c 7c       	castu.h	r12
8000358c:	f0 1f 00 4f 	mcall	800036c8 <et024006_DrawFilledCircle+0x150>
		return;
80003590:	c9 98       	rjmp	800036c2 <et024006_DrawFilledCircle+0x14a>
	}

	// Set up start iterators.
	uint16_t offsetX = 0;
	uint16_t offsetY = radius;
	int16_t error = 3 - 2 * radius;
80003592:	f4 04 10 fe 	mul	r4,r10,-2
80003596:	2f d4       	sub	r4,-3
80003598:	5c 84       	casts.h	r4
8000359a:	e7 dc b0 10 	bfexts	r3,r12,0x0,0x10
8000359e:	ef da b0 10 	bfexts	r7,r10,0x0,0x10
800035a2:	30 15       	mov	r5,1
800035a4:	30 06       	mov	r6,0

	// Iterate offsetX from 0 to radius.
	while (offsetX <= offsetY) {
		// Draw vertical lines tracking each quadrant.
		if (quadrantMask & TFT_QUADRANT0) {
800035a6:	10 9a       	mov	r10,r8
800035a8:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800035ac:	50 18       	stdsp	sp[0x4],r8
			et024006_DrawVertLine( x + offsetY, y - offsetX,
800035ae:	e3 d9 c0 10 	bfextu	r1,r9,0x0,0x10
				offsetX + 1, color );
			et024006_DrawVertLine( x + offsetX, y - offsetY,
				offsetY + 1, color );
		}
		if (quadrantMask & TFT_QUADRANT1) {
800035b2:	14 99       	mov	r9,r10
800035b4:	e2 19 00 0c 	andl	r9,0xc,COH
800035b8:	50 29       	stdsp	sp[0x8],r9
			et024006_DrawVertLine( x - offsetY, y - offsetX,
				offsetX + 1, color );
			et024006_DrawVertLine( x - offsetX, y - offsetY,
				offsetY + 1, color );
		}
		if (quadrantMask & TFT_QUADRANT2) {
800035ba:	14 98       	mov	r8,r10
800035bc:	e2 18 00 30 	andl	r8,0x30,COH
800035c0:	50 38       	stdsp	sp[0xc],r8
			et024006_DrawVertLine( x - offsetY, y, offsetX + 1,
800035c2:	f3 db c0 10 	bfextu	r9,r11,0x0,0x10
800035c6:	50 09       	stdsp	sp[0x0],r9
				color );
			et024006_DrawVertLine( x - offsetX, y, offsetY + 1,
				color );
		}
		if (quadrantMask & TFT_QUADRANT3) {
800035c8:	e2 1a 00 c0 	andl	r10,0xc0,COH
800035cc:	50 4a       	stdsp	sp[0x10],r10
	int16_t error = 3 - 2 * radius;

	// Iterate offsetX from 0 to radius.
	while (offsetX <= offsetY) {
		// Draw vertical lines tracking each quadrant.
		if (quadrantMask & TFT_QUADRANT0) {
800035ce:	40 18       	lddsp	r8,sp[0x4]
800035d0:	58 08       	cp.w	r8,0
800035d2:	c1 70       	breq	80003600 <et024006_DrawFilledCircle+0x88>
			et024006_DrawVertLine( x + offsetY, y - offsetX,
800035d4:	e0 06 01 0b 	sub	r11,r0,r6
800035d8:	0e 9c       	mov	r12,r7
800035da:	04 0c       	add	r12,r2
800035dc:	02 99       	mov	r9,r1
800035de:	f5 d5 c0 10 	bfextu	r10,r5,0x0,0x10
800035e2:	5c 7b       	castu.h	r11
800035e4:	5c 7c       	castu.h	r12
800035e6:	f0 1f 00 3a 	mcall	800036cc <et024006_DrawFilledCircle+0x154>
				offsetX + 1, color );
			et024006_DrawVertLine( x + offsetX, y - offsetY,
800035ea:	0e 9a       	mov	r10,r7
800035ec:	2f fa       	sub	r10,-1
800035ee:	e0 07 01 0b 	sub	r11,r0,r7
800035f2:	02 99       	mov	r9,r1
800035f4:	5c 7a       	castu.h	r10
800035f6:	5c 7b       	castu.h	r11
800035f8:	f9 d3 c0 10 	bfextu	r12,r3,0x0,0x10
800035fc:	f0 1f 00 34 	mcall	800036cc <et024006_DrawFilledCircle+0x154>
				offsetY + 1, color );
		}
		if (quadrantMask & TFT_QUADRANT1) {
80003600:	40 28       	lddsp	r8,sp[0x8]
80003602:	58 08       	cp.w	r8,0
80003604:	c1 80       	breq	80003634 <et024006_DrawFilledCircle+0xbc>
			et024006_DrawVertLine( x - offsetY, y - offsetX,
80003606:	e0 06 01 0b 	sub	r11,r0,r6
8000360a:	e4 07 01 0c 	sub	r12,r2,r7
8000360e:	02 99       	mov	r9,r1
80003610:	f5 d5 c0 10 	bfextu	r10,r5,0x0,0x10
80003614:	5c 7b       	castu.h	r11
80003616:	5c 7c       	castu.h	r12
80003618:	f0 1f 00 2d 	mcall	800036cc <et024006_DrawFilledCircle+0x154>
				offsetX + 1, color );
			et024006_DrawVertLine( x - offsetX, y - offsetY,
8000361c:	0e 9a       	mov	r10,r7
8000361e:	2f fa       	sub	r10,-1
80003620:	e0 07 01 0b 	sub	r11,r0,r7
80003624:	e4 06 01 0c 	sub	r12,r2,r6
80003628:	02 99       	mov	r9,r1
8000362a:	5c 7a       	castu.h	r10
8000362c:	5c 7b       	castu.h	r11
8000362e:	5c 7c       	castu.h	r12
80003630:	f0 1f 00 27 	mcall	800036cc <et024006_DrawFilledCircle+0x154>
				offsetY + 1, color );
		}
		if (quadrantMask & TFT_QUADRANT2) {
80003634:	40 39       	lddsp	r9,sp[0xc]
80003636:	58 09       	cp.w	r9,0
80003638:	c1 40       	breq	80003660 <et024006_DrawFilledCircle+0xe8>
			et024006_DrawVertLine( x - offsetY, y, offsetX + 1,
8000363a:	e4 07 01 0c 	sub	r12,r2,r7
8000363e:	02 99       	mov	r9,r1
80003640:	f5 d5 c0 10 	bfextu	r10,r5,0x0,0x10
80003644:	40 0b       	lddsp	r11,sp[0x0]
80003646:	5c 7c       	castu.h	r12
80003648:	f0 1f 00 21 	mcall	800036cc <et024006_DrawFilledCircle+0x154>
				color );
			et024006_DrawVertLine( x - offsetX, y, offsetY + 1,
8000364c:	0e 9a       	mov	r10,r7
8000364e:	2f fa       	sub	r10,-1
80003650:	e4 06 01 0c 	sub	r12,r2,r6
80003654:	02 99       	mov	r9,r1
80003656:	5c 7a       	castu.h	r10
80003658:	40 0b       	lddsp	r11,sp[0x0]
8000365a:	5c 7c       	castu.h	r12
8000365c:	f0 1f 00 1c 	mcall	800036cc <et024006_DrawFilledCircle+0x154>
				color );
		}
		if (quadrantMask & TFT_QUADRANT3) {
80003660:	40 49       	lddsp	r9,sp[0x10]
80003662:	58 09       	cp.w	r9,0
80003664:	c1 30       	breq	8000368a <et024006_DrawFilledCircle+0x112>
			et024006_DrawVertLine( x + offsetY, y, offsetX + 1,
80003666:	0e 9c       	mov	r12,r7
80003668:	04 0c       	add	r12,r2
8000366a:	02 99       	mov	r9,r1
8000366c:	f5 d5 c0 10 	bfextu	r10,r5,0x0,0x10
80003670:	40 0b       	lddsp	r11,sp[0x0]
80003672:	5c 7c       	castu.h	r12
80003674:	f0 1f 00 16 	mcall	800036cc <et024006_DrawFilledCircle+0x154>
				color );
			et024006_DrawVertLine( x + offsetX, y, offsetY + 1,
80003678:	0e 9a       	mov	r10,r7
8000367a:	2f fa       	sub	r10,-1
8000367c:	02 99       	mov	r9,r1
8000367e:	5c 7a       	castu.h	r10
80003680:	40 0b       	lddsp	r11,sp[0x0]
80003682:	f9 d3 c0 10 	bfextu	r12,r3,0x0,0x10
80003686:	f0 1f 00 12 	mcall	800036cc <et024006_DrawFilledCircle+0x154>
				color );
		}

		// Update error value and step offsetY when required.
		if (error < 0) {
8000368a:	30 09       	mov	r9,0
8000368c:	f2 04 19 00 	cp.h	r4,r9
80003690:	c0 84       	brge	800036a0 <et024006_DrawFilledCircle+0x128>
			error += ((offsetX << 2) + 6);
80003692:	ec 08 15 02 	lsl	r8,r6,0x2
80003696:	f0 04 00 04 	add	r4,r8,r4
8000369a:	2f a4       	sub	r4,-6
8000369c:	5c 84       	casts.h	r4
8000369e:	c0 98       	rjmp	800036b0 <et024006_DrawFilledCircle+0x138>
		} else {
			error += (((offsetX - offsetY) << 2) + 10);
800036a0:	2f 64       	sub	r4,-10
800036a2:	ec 07 01 08 	sub	r8,r6,r7
800036a6:	a3 68       	lsl	r8,0x2
800036a8:	10 04       	add	r4,r8
800036aa:	5c 84       	casts.h	r4
			--offsetY;
800036ac:	20 17       	sub	r7,1
800036ae:	5c 87       	casts.h	r7
		}

		// Next X.
		++offsetX;
800036b0:	2f f6       	sub	r6,-1
800036b2:	5c 86       	casts.h	r6
800036b4:	2f f5       	sub	r5,-1
800036b6:	5c 85       	casts.h	r5
800036b8:	2f f3       	sub	r3,-1
800036ba:	5c 83       	casts.h	r3
	uint16_t offsetX = 0;
	uint16_t offsetY = radius;
	int16_t error = 3 - 2 * radius;

	// Iterate offsetX from 0 to radius.
	while (offsetX <= offsetY) {
800036bc:	ec 07 19 00 	cp.h	r7,r6
800036c0:	c8 72       	brcc	800035ce <et024006_DrawFilledCircle+0x56>
		}

		// Next X.
		++offsetX;
	}
}
800036c2:	2f bd       	sub	sp,-20
800036c4:	d8 32       	popm	r0-r7,pc
800036c6:	00 00       	add	r0,r0
800036c8:	80 00       	ld.sh	r0,r0[0x0]
800036ca:	31 10       	mov	r0,17
800036cc:	80 00       	ld.sh	r0,r0[0x0]
800036ce:	35 5c       	mov	r12,85

800036d0 <et024006_DrawHorizLine>:
  return color;
}


void et024006_DrawHorizLine( uint16_t x, uint16_t y, uint16_t length, et024006_color_t color )
{
800036d0:	d4 01       	pushm	lr
  et024006_DrawFilledRect( x, y, length, 1, color );
800036d2:	f1 d9 c0 10 	bfextu	r8,r9,0x0,0x10
800036d6:	30 19       	mov	r9,1
800036d8:	5c 7a       	castu.h	r10
800036da:	5c 7b       	castu.h	r11
800036dc:	5c 7c       	castu.h	r12
800036de:	f0 1f 00 02 	mcall	800036e4 <et024006_DrawHorizLine+0x14>
}
800036e2:	d8 02       	popm	pc
800036e4:	80 00       	ld.sh	r0,r0[0x0]
800036e6:	35 1c       	mov	r12,81

800036e8 <et024006_AdjustGamma>:

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800036e8:	fc 19 c0 00 	movh	r9,0xc000
800036ec:	34 6a       	mov	r10,70
800036ee:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800036f0:	fc 18 c0 20 	movh	r8,0xc020
800036f4:	e0 6b 00 94 	mov	r11,148
800036f8:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800036fa:	34 7b       	mov	r11,71
800036fc:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800036fe:	34 1b       	mov	r11,65
80003700:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003702:	34 8b       	mov	r11,72
80003704:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003706:	30 0b       	mov	r11,0
80003708:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000370a:	34 9b       	mov	r11,73
8000370c:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000370e:	33 3b       	mov	r11,51
80003710:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003712:	34 ab       	mov	r11,74
80003714:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003716:	32 5b       	mov	r11,37
80003718:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000371a:	34 bb       	mov	r11,75
8000371c:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000371e:	34 5b       	mov	r11,69
80003720:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003722:	34 cb       	mov	r11,76
80003724:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003726:	34 4b       	mov	r11,68
80003728:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000372a:	34 db       	mov	r11,77
8000372c:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000372e:	37 7b       	mov	r11,119
80003730:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003732:	34 eb       	mov	r11,78
80003734:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003736:	31 2b       	mov	r11,18
80003738:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000373a:	34 fb       	mov	r11,79
8000373c:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000373e:	e0 6b 00 cc 	mov	r11,204
80003742:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003744:	35 0b       	mov	r11,80
80003746:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003748:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000374a:	35 1a       	mov	r10,81
8000374c:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000374e:	e0 69 00 82 	mov	r9,130
80003752:	b0 09       	st.h	r8[0x0],r9
  et024006_WriteRegister( HIMAX_GAMMACTRL8, 0x77 );
  et024006_WriteRegister( HIMAX_GAMMACTRL9, 0x12 );
  et024006_WriteRegister( HIMAX_GAMMACTRL10, 0xCC );
  et024006_WriteRegister( HIMAX_GAMMACTRL11, 0x46 );
  et024006_WriteRegister( HIMAX_GAMMACTRL12, 0x82 );
}
80003754:	5e fc       	retal	r12
80003756:	d7 03       	nop

80003758 <et024006_Init>:
 *  @param cpu_hz CPU speed in Hz. This is needed for power up timings.
 *  @param hsb_hz HSB bus speed in Hz. This parameter is needed to set up the SMC.
 *  If SPI mode is used then this parameter is ignored.
 */
void et024006_Init( unsigned long cpu_hz, unsigned long hsb_hz )
{
80003758:	eb cd 40 c0 	pushm	r6-r7,lr
  tft_data.cpu_hz = cpu_hz;
8000375c:	fe f7 04 80 	ld.w	r7,pc[1152]
80003760:	8f 0c       	st.w	r7[0x0],r12
  tft_data.hsb_hz = hsb_hz;
80003762:	8f 1b       	st.w	r7[0x4],r11

#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_SPI)
  et024006_InitSPI();
#endif
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  smc_init(tft_data.hsb_hz);
80003764:	16 9c       	mov	r12,r11
80003766:	f0 1f 01 1f 	mcall	80003be0 <et024006_Init+0x488>
static void et024006_SetupInterface( void )
{

  // et024006_TE (tearing sync) signal from display is input
  // without any pull resistors
  gpio_enable_gpio_pin(ET024006DHU_TE_PIN);
8000376a:	35 5c       	mov	r12,85
8000376c:	f0 1f 01 1e 	mcall	80003be4 <et024006_Init+0x48c>

  // Backlight pin (PWM) for display is output
  gpio_enable_module_pin(ET024006DHU_BL_PIN, ET024006DHU_BL_FUNCTION);
80003770:	30 2b       	mov	r11,2
80003772:	33 2c       	mov	r12,50
80003774:	f0 1f 01 1d 	mcall	80003be8 <et024006_Init+0x490>
  // Turns backlight ON
  /*TODO Add backlight driver */

  // Reset pin for display is output
  gpio_set_gpio_pin(ET024006DHU_RESET_PIN);
80003778:	35 2c       	mov	r12,82
8000377a:	f0 1f 01 1d 	mcall	80003bec <et024006_Init+0x494>
/*! \brief Does a hard reset of the display.
 */
static void et024006_ResetDisplay( void )
{
  // clear reset line
  gpio_clr_gpio_pin(ET024006DHU_RESET_PIN);
8000377e:	35 2c       	mov	r12,82
80003780:	f0 1f 01 1c 	mcall	80003bf0 <et024006_Init+0x498>
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
80003784:	6e 07       	ld.w	r7,r7[0x0]
80003786:	33 28       	mov	r8,50
80003788:	ee 08 06 46 	mulu.d	r6,r7,r8
8000378c:	ee 78 42 40 	mov	r8,1000000
80003790:	30 09       	mov	r9,0
80003792:	ee 7a 42 3f 	mov	r10,999999
80003796:	30 0b       	mov	r11,0
80003798:	ec 0a 00 0a 	add	r10,r6,r10
8000379c:	ee 0b 00 4b 	adc	r11,r7,r11
800037a0:	f0 1f 01 15 	mcall	80003bf4 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800037a4:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800037a8:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800037ac:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800037b0:	14 38       	cp.w	r8,r10
800037b2:	e0 88 00 09 	brls	800037c4 <et024006_Init+0x6c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800037b6:	12 38       	cp.w	r8,r9
800037b8:	fe 98 ff fa 	brls	800037ac <et024006_Init+0x54>
800037bc:	12 3a       	cp.w	r10,r9
800037be:	e0 83 00 a2 	brlo	80003902 <et024006_Init+0x1aa>
800037c2:	cf 5b       	rjmp	800037ac <et024006_Init+0x54>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800037c4:	12 38       	cp.w	r8,r9
800037c6:	e0 8b 00 9e 	brhi	80003902 <et024006_Init+0x1aa>
800037ca:	12 3a       	cp.w	r10,r9
800037cc:	e0 83 00 9b 	brlo	80003902 <et024006_Init+0x1aa>
800037d0:	ce eb       	rjmp	800037ac <et024006_Init+0x54>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800037d2:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800037d6:	14 38       	cp.w	r8,r10
800037d8:	e0 88 00 09 	brls	800037ea <et024006_Init+0x92>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800037dc:	12 38       	cp.w	r8,r9
800037de:	fe 98 ff fa 	brls	800037d2 <et024006_Init+0x7a>
800037e2:	12 3a       	cp.w	r10,r9
800037e4:	e0 83 00 a9 	brlo	80003936 <et024006_Init+0x1de>
800037e8:	cf 5b       	rjmp	800037d2 <et024006_Init+0x7a>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800037ea:	12 38       	cp.w	r8,r9
800037ec:	e0 8b 00 a5 	brhi	80003936 <et024006_Init+0x1de>
800037f0:	12 3a       	cp.w	r10,r9
800037f2:	e0 83 00 a2 	brlo	80003936 <et024006_Init+0x1de>
800037f6:	ce eb       	rjmp	800037d2 <et024006_Init+0x7a>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800037f8:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800037fc:	14 38       	cp.w	r8,r10
800037fe:	e0 88 00 09 	brls	80003810 <et024006_Init+0xb8>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80003802:	12 38       	cp.w	r8,r9
80003804:	fe 98 ff fa 	brls	800037f8 <et024006_Init+0xa0>
80003808:	12 3a       	cp.w	r10,r9
8000380a:	e0 83 01 1e 	brlo	80003a46 <et024006_Init+0x2ee>
8000380e:	cf 5b       	rjmp	800037f8 <et024006_Init+0xa0>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80003810:	12 38       	cp.w	r8,r9
80003812:	e0 8b 01 1a 	brhi	80003a46 <et024006_Init+0x2ee>
80003816:	12 3a       	cp.w	r10,r9
80003818:	e0 83 01 17 	brlo	80003a46 <et024006_Init+0x2ee>
8000381c:	ce eb       	rjmp	800037f8 <et024006_Init+0xa0>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000381e:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80003822:	14 38       	cp.w	r8,r10
80003824:	e0 88 00 09 	brls	80003836 <et024006_Init+0xde>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80003828:	12 38       	cp.w	r8,r9
8000382a:	fe 98 ff fa 	brls	8000381e <et024006_Init+0xc6>
8000382e:	12 3a       	cp.w	r10,r9
80003830:	e0 83 01 29 	brlo	80003a82 <et024006_Init+0x32a>
80003834:	cf 5b       	rjmp	8000381e <et024006_Init+0xc6>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80003836:	12 38       	cp.w	r8,r9
80003838:	e0 8b 01 25 	brhi	80003a82 <et024006_Init+0x32a>
8000383c:	12 3a       	cp.w	r10,r9
8000383e:	e0 83 01 22 	brlo	80003a82 <et024006_Init+0x32a>
80003842:	ce eb       	rjmp	8000381e <et024006_Init+0xc6>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80003844:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80003848:	14 38       	cp.w	r8,r10
8000384a:	e0 88 00 09 	brls	8000385c <et024006_Init+0x104>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000384e:	12 38       	cp.w	r8,r9
80003850:	fe 98 ff fa 	brls	80003844 <et024006_Init+0xec>
80003854:	12 3a       	cp.w	r10,r9
80003856:	e0 83 01 35 	brlo	80003ac0 <et024006_Init+0x368>
8000385a:	cf 5b       	rjmp	80003844 <et024006_Init+0xec>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000385c:	12 38       	cp.w	r8,r9
8000385e:	e0 8b 01 31 	brhi	80003ac0 <et024006_Init+0x368>
80003862:	12 3a       	cp.w	r10,r9
80003864:	e0 83 01 2e 	brlo	80003ac0 <et024006_Init+0x368>
80003868:	ce eb       	rjmp	80003844 <et024006_Init+0xec>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000386a:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000386e:	14 38       	cp.w	r8,r10
80003870:	e0 88 00 09 	brls	80003882 <et024006_Init+0x12a>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80003874:	12 38       	cp.w	r8,r9
80003876:	fe 98 ff fa 	brls	8000386a <et024006_Init+0x112>
8000387a:	12 3a       	cp.w	r10,r9
8000387c:	e0 83 01 40 	brlo	80003afc <et024006_Init+0x3a4>
80003880:	cf 5b       	rjmp	8000386a <et024006_Init+0x112>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80003882:	12 38       	cp.w	r8,r9
80003884:	e0 8b 01 3c 	brhi	80003afc <et024006_Init+0x3a4>
80003888:	12 3a       	cp.w	r10,r9
8000388a:	e0 83 01 39 	brlo	80003afc <et024006_Init+0x3a4>
8000388e:	ce eb       	rjmp	8000386a <et024006_Init+0x112>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80003890:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80003894:	14 38       	cp.w	r8,r10
80003896:	e0 88 00 09 	brls	800038a8 <et024006_Init+0x150>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000389a:	12 38       	cp.w	r8,r9
8000389c:	fe 98 ff fa 	brls	80003890 <et024006_Init+0x138>
800038a0:	12 3a       	cp.w	r10,r9
800038a2:	e0 83 01 4b 	brlo	80003b38 <et024006_Init+0x3e0>
800038a6:	cf 5b       	rjmp	80003890 <et024006_Init+0x138>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800038a8:	12 38       	cp.w	r8,r9
800038aa:	e0 8b 01 47 	brhi	80003b38 <et024006_Init+0x3e0>
800038ae:	12 3a       	cp.w	r10,r9
800038b0:	e0 83 01 44 	brlo	80003b38 <et024006_Init+0x3e0>
800038b4:	ce eb       	rjmp	80003890 <et024006_Init+0x138>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800038b6:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800038ba:	14 38       	cp.w	r8,r10
800038bc:	e0 88 00 09 	brls	800038ce <et024006_Init+0x176>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800038c0:	12 38       	cp.w	r8,r9
800038c2:	fe 98 ff fa 	brls	800038b6 <et024006_Init+0x15e>
800038c6:	12 3a       	cp.w	r10,r9
800038c8:	e0 83 01 56 	brlo	80003b74 <et024006_Init+0x41c>
800038cc:	cf 5b       	rjmp	800038b6 <et024006_Init+0x15e>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800038ce:	12 38       	cp.w	r8,r9
800038d0:	e0 8b 01 52 	brhi	80003b74 <et024006_Init+0x41c>
800038d4:	12 3a       	cp.w	r10,r9
800038d6:	e0 83 01 4f 	brlo	80003b74 <et024006_Init+0x41c>
800038da:	ce eb       	rjmp	800038b6 <et024006_Init+0x15e>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800038dc:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800038e0:	14 38       	cp.w	r8,r10
800038e2:	e0 88 00 09 	brls	800038f4 <et024006_Init+0x19c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800038e6:	12 38       	cp.w	r8,r9
800038e8:	fe 98 ff fa 	brls	800038dc <et024006_Init+0x184>
800038ec:	12 3a       	cp.w	r10,r9
800038ee:	e0 83 01 64 	brlo	80003bb6 <et024006_Init+0x45e>
800038f2:	cf 5b       	rjmp	800038dc <et024006_Init+0x184>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800038f4:	12 38       	cp.w	r8,r9
800038f6:	e0 8b 01 60 	brhi	80003bb6 <et024006_Init+0x45e>
800038fa:	12 3a       	cp.w	r10,r9
800038fc:	e0 83 01 5d 	brlo	80003bb6 <et024006_Init+0x45e>
80003900:	ce eb       	rjmp	800038dc <et024006_Init+0x184>
  // 50us delay
  cpu_delay_us( 50, tft_data.cpu_hz );

  gpio_set_gpio_pin(ET024006DHU_RESET_PIN);
80003902:	35 2c       	mov	r12,82
80003904:	f0 1f 00 ba 	mcall	80003bec <et024006_Init+0x494>
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80003908:	fe f8 02 d4 	ld.w	r8,pc[724]
8000390c:	70 07       	ld.w	r7,r8[0x0]
8000390e:	30 58       	mov	r8,5
80003910:	ee 08 06 46 	mulu.d	r6,r7,r8
80003914:	e0 68 03 e8 	mov	r8,1000
80003918:	30 09       	mov	r9,0
8000391a:	e0 6a 03 e7 	mov	r10,999
8000391e:	30 0b       	mov	r11,0
80003920:	ec 0a 00 0a 	add	r10,r6,r10
80003924:	ee 0b 00 4b 	adc	r11,r7,r11
80003928:	f0 1f 00 b3 	mcall	80003bf4 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000392c:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80003930:	f0 0a 00 0a 	add	r10,r8,r10
80003934:	c4 fb       	rjmp	800037d2 <et024006_Init+0x7a>
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  smc_init(tft_data.hsb_hz);
#endif
  et024006_SetupInterface();
  et024006_ResetDisplay();
  et024006_AdjustGamma();
80003936:	f0 1f 00 b1 	mcall	80003bf8 <et024006_Init+0x4a0>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000393a:	fc 19 c0 00 	movh	r9,0xc000
8000393e:	30 1a       	mov	r10,1
80003940:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003942:	fc 18 c0 20 	movh	r8,0xc020
80003946:	30 6b       	mov	r11,6
80003948:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000394a:	33 ab       	mov	r11,58
8000394c:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000394e:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003950:	33 bb       	mov	r11,59
80003952:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003954:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003956:	33 ca       	mov	r10,60
80003958:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000395a:	e0 6a 00 f0 	mov	r10,240
8000395e:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003960:	33 db       	mov	r11,61
80003962:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003964:	30 07       	mov	r7,0
80003966:	b0 07       	st.h	r8[0x0],r7

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003968:	33 eb       	mov	r11,62
8000396a:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000396c:	33 8b       	mov	r11,56
8000396e:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003970:	34 0c       	mov	r12,64
80003972:	b2 0c       	st.h	r9[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003974:	30 fe       	mov	lr,15
80003976:	b0 0e       	st.h	r8[0x0],lr

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003978:	34 1e       	mov	lr,65
8000397a:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000397c:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000397e:	32 7a       	mov	r10,39
80003980:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003982:	30 2a       	mov	r10,2
80003984:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003986:	32 8e       	mov	lr,40
80003988:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000398a:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000398c:	32 9e       	mov	lr,41
8000398e:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003990:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003992:	32 ae       	mov	lr,42
80003994:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003996:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003998:	32 ce       	mov	lr,44
8000399a:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000399c:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000399e:	32 de       	mov	lr,45
800039a0:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
800039a2:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800039a4:	31 9a       	mov	r10,25
800039a6:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800039a8:	34 9a       	mov	r10,73
800039aa:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800039ac:	e0 6a 00 93 	mov	r10,147
800039b0:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800039b2:	30 8a       	mov	r10,8
800039b4:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800039b6:	31 6a       	mov	r10,22
800039b8:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800039ba:	36 8a       	mov	r10,104
800039bc:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800039be:	32 3a       	mov	r10,35
800039c0:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800039c2:	e0 6a 00 95 	mov	r10,149
800039c6:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800039c8:	32 4e       	mov	lr,36
800039ca:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
800039cc:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800039ce:	32 5a       	mov	r10,37
800039d0:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800039d2:	e0 6a 00 ff 	mov	r10,255
800039d6:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800039d8:	e0 6a 00 90 	mov	r10,144
800039dc:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800039de:	37 fa       	mov	r10,127
800039e0:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800039e2:	33 5a       	mov	r10,53
800039e4:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800039e6:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800039e8:	33 6a       	mov	r10,54
800039ea:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800039ec:	37 8a       	mov	r10,120
800039ee:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800039f0:	31 da       	mov	r10,29
800039f2:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800039f4:	30 7a       	mov	r10,7
800039f6:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800039f8:	31 ea       	mov	r10,30
800039fa:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800039fc:	b0 07       	st.h	r8[0x0],r7

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800039fe:	31 fa       	mov	r10,31
80003a00:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003a02:	30 4a       	mov	r10,4
80003a04:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003a06:	32 0a       	mov	r10,32
80003a08:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003a0a:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003a0c:	34 4a       	mov	r10,68
80003a0e:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003a10:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003a12:	34 5a       	mov	r10,69
80003a14:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003a16:	31 29       	mov	r9,18
80003a18:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80003a1a:	4f 18       	lddpc	r8,80003bdc <et024006_Init+0x484>
80003a1c:	70 07       	ld.w	r7,r8[0x0]
80003a1e:	30 a8       	mov	r8,10
80003a20:	ee 08 06 46 	mulu.d	r6,r7,r8
80003a24:	e0 68 03 e8 	mov	r8,1000
80003a28:	30 09       	mov	r9,0
80003a2a:	e0 6a 03 e7 	mov	r10,999
80003a2e:	30 0b       	mov	r11,0
80003a30:	ec 0a 00 0a 	add	r10,r6,r10
80003a34:	ee 0b 00 4b 	adc	r11,r7,r11
80003a38:	f0 1f 00 6f 	mcall	80003bf4 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80003a3c:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80003a40:	f0 0a 00 0a 	add	r10,r8,r10
80003a44:	cd aa       	rjmp	800037f8 <et024006_Init+0xa0>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003a46:	31 c9       	mov	r9,28
80003a48:	fc 18 c0 00 	movh	r8,0xc000
80003a4c:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003a4e:	30 49       	mov	r9,4
80003a50:	fc 18 c0 20 	movh	r8,0xc020
80003a54:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80003a56:	4e 28       	lddpc	r8,80003bdc <et024006_Init+0x484>
80003a58:	70 07       	ld.w	r7,r8[0x0]
80003a5a:	31 48       	mov	r8,20
80003a5c:	ee 08 06 46 	mulu.d	r6,r7,r8
80003a60:	e0 68 03 e8 	mov	r8,1000
80003a64:	30 09       	mov	r9,0
80003a66:	e0 6a 03 e7 	mov	r10,999
80003a6a:	30 0b       	mov	r11,0
80003a6c:	ec 0a 00 0a 	add	r10,r6,r10
80003a70:	ee 0b 00 4b 	adc	r11,r7,r11
80003a74:	f0 1f 00 60 	mcall	80003bf4 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80003a78:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80003a7c:	f0 0a 00 0a 	add	r10,r8,r10
80003a80:	cc fa       	rjmp	8000381e <et024006_Init+0xc6>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003a82:	34 39       	mov	r9,67
80003a84:	fc 18 c0 00 	movh	r8,0xc000
80003a88:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003a8a:	e0 69 00 80 	mov	r9,128
80003a8e:	fc 18 c0 20 	movh	r8,0xc020
80003a92:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80003a94:	4d 28       	lddpc	r8,80003bdc <et024006_Init+0x484>
80003a96:	70 07       	ld.w	r7,r8[0x0]
80003a98:	30 58       	mov	r8,5
80003a9a:	ee 08 06 46 	mulu.d	r6,r7,r8
80003a9e:	e0 68 03 e8 	mov	r8,1000
80003aa2:	30 09       	mov	r9,0
80003aa4:	e0 6a 03 e7 	mov	r10,999
80003aa8:	30 0b       	mov	r11,0
80003aaa:	ec 0a 00 0a 	add	r10,r6,r10
80003aae:	ee 0b 00 4b 	adc	r11,r7,r11
80003ab2:	f0 1f 00 51 	mcall	80003bf4 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80003ab6:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80003aba:	f0 0a 00 0a 	add	r10,r8,r10
80003abe:	cc 3a       	rjmp	80003844 <et024006_Init+0xec>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003ac0:	31 b9       	mov	r9,27
80003ac2:	fc 18 c0 00 	movh	r8,0xc000
80003ac6:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003ac8:	30 89       	mov	r9,8
80003aca:	fc 18 c0 20 	movh	r8,0xc020
80003ace:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80003ad0:	4c 38       	lddpc	r8,80003bdc <et024006_Init+0x484>
80003ad2:	70 07       	ld.w	r7,r8[0x0]
80003ad4:	32 88       	mov	r8,40
80003ad6:	ee 08 06 46 	mulu.d	r6,r7,r8
80003ada:	e0 68 03 e8 	mov	r8,1000
80003ade:	30 09       	mov	r9,0
80003ae0:	e0 6a 03 e7 	mov	r10,999
80003ae4:	30 0b       	mov	r11,0
80003ae6:	ec 0a 00 0a 	add	r10,r6,r10
80003aea:	ee 0b 00 4b 	adc	r11,r7,r11
80003aee:	f0 1f 00 42 	mcall	80003bf4 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80003af2:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80003af6:	f0 0a 00 0a 	add	r10,r8,r10
80003afa:	cb 8a       	rjmp	8000386a <et024006_Init+0x112>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003afc:	31 b9       	mov	r9,27
80003afe:	fc 18 c0 00 	movh	r8,0xc000
80003b02:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003b04:	31 09       	mov	r9,16
80003b06:	fc 18 c0 20 	movh	r8,0xc020
80003b0a:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80003b0c:	4b 48       	lddpc	r8,80003bdc <et024006_Init+0x484>
80003b0e:	70 07       	ld.w	r7,r8[0x0]
80003b10:	32 88       	mov	r8,40
80003b12:	ee 08 06 46 	mulu.d	r6,r7,r8
80003b16:	e0 68 03 e8 	mov	r8,1000
80003b1a:	30 09       	mov	r9,0
80003b1c:	e0 6a 03 e7 	mov	r10,999
80003b20:	30 0b       	mov	r11,0
80003b22:	ec 0a 00 0a 	add	r10,r6,r10
80003b26:	ee 0b 00 4b 	adc	r11,r7,r11
80003b2a:	f0 1f 00 33 	mcall	80003bf4 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80003b2e:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80003b32:	f0 0a 00 0a 	add	r10,r8,r10
80003b36:	ca da       	rjmp	80003890 <et024006_Init+0x138>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003b38:	32 69       	mov	r9,38
80003b3a:	fc 18 c0 00 	movh	r8,0xc000
80003b3e:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003b40:	30 49       	mov	r9,4
80003b42:	fc 18 c0 20 	movh	r8,0xc020
80003b46:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80003b48:	4a 58       	lddpc	r8,80003bdc <et024006_Init+0x484>
80003b4a:	70 07       	ld.w	r7,r8[0x0]
80003b4c:	32 88       	mov	r8,40
80003b4e:	ee 08 06 46 	mulu.d	r6,r7,r8
80003b52:	e0 68 03 e8 	mov	r8,1000
80003b56:	30 09       	mov	r9,0
80003b58:	e0 6a 03 e7 	mov	r10,999
80003b5c:	30 0b       	mov	r11,0
80003b5e:	ec 0a 00 0a 	add	r10,r6,r10
80003b62:	ee 0b 00 4b 	adc	r11,r7,r11
80003b66:	f0 1f 00 24 	mcall	80003bf4 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80003b6a:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80003b6e:	f0 0a 00 0a 	add	r10,r8,r10
80003b72:	ca 2a       	rjmp	800038b6 <et024006_Init+0x15e>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003b74:	fc 19 c0 00 	movh	r9,0xc000
80003b78:	32 6a       	mov	r10,38
80003b7a:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003b7c:	fc 18 c0 20 	movh	r8,0xc020
80003b80:	32 4b       	mov	r11,36
80003b82:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003b84:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003b86:	32 c9       	mov	r9,44
80003b88:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80003b8a:	49 58       	lddpc	r8,80003bdc <et024006_Init+0x484>
80003b8c:	70 07       	ld.w	r7,r8[0x0]
80003b8e:	32 88       	mov	r8,40
80003b90:	ee 08 06 46 	mulu.d	r6,r7,r8
80003b94:	e0 68 03 e8 	mov	r8,1000
80003b98:	30 09       	mov	r9,0
80003b9a:	e0 6a 03 e7 	mov	r10,999
80003b9e:	30 0b       	mov	r11,0
80003ba0:	ec 0a 00 0a 	add	r10,r6,r10
80003ba4:	ee 0b 00 4b 	adc	r11,r7,r11
80003ba8:	f0 1f 00 13 	mcall	80003bf4 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80003bac:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80003bb0:	f0 0a 00 0a 	add	r10,r8,r10
80003bb4:	c9 4a       	rjmp	800038dc <et024006_Init+0x184>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003bb6:	fc 19 c0 00 	movh	r9,0xc000
80003bba:	32 68       	mov	r8,38
80003bbc:	b2 08       	st.h	r9[0x0],r8
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003bbe:	fc 18 c0 20 	movh	r8,0xc020
80003bc2:	33 ca       	mov	r10,60
80003bc4:	b0 0a       	st.h	r8[0x0],r10
}

__always_inline static uint8_t et024006_ReadRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003bc6:	37 0a       	mov	r10,112
80003bc8:	b2 0a       	st.h	r9[0x0],r10
  return *ET024006_PARAM_ADDR;
80003bca:	90 0b       	ld.sh	r11,r8[0x0]
80003bcc:	5c 5b       	castu.b	r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80003bce:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80003bd0:	16 99       	mov	r9,r11
80003bd2:	a3 b9       	sbr	r9,0x3
80003bd4:	b0 09       	st.h	r8[0x0],r9
  et024006_GeneralSettings();
  et024006_InterfaceSettings();
  et024006_PowerSettings();
  et024006_PowerUp();
  et024006_PowerOn();
}
80003bd6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003bda:	00 00       	add	r0,r0
80003bdc:	00 00       	add	r0,r0
80003bde:	05 64       	ld.uh	r4,--r2
80003be0:	80 00       	ld.sh	r0,r0[0x0]
80003be2:	3f 30       	mov	r0,-13
80003be4:	80 00       	ld.sh	r0,r0[0x0]
80003be6:	40 dc       	lddsp	r12,sp[0x34]
80003be8:	80 00       	ld.sh	r0,r0[0x0]
80003bea:	40 5a       	lddsp	r10,sp[0x14]
80003bec:	80 00       	ld.sh	r0,r0[0x0]
80003bee:	41 32       	lddsp	r2,sp[0x4c]
80003bf0:	80 00       	ld.sh	r0,r0[0x0]
80003bf2:	41 4e       	lddsp	lr,sp[0x50]
80003bf4:	80 00       	ld.sh	r0,r0[0x0]
80003bf6:	79 88       	ld.w	r8,r12[0x60]
80003bf8:	80 00       	ld.sh	r0,r0[0x0]
80003bfa:	36 e8       	mov	r8,110

80003bfc <abdac_enable>:
#include "abdac.h"

void abdac_enable(volatile avr32_abdac_t *abdac)
{
  volatile avr32_pm_t *pm = &AVR32_PM;
  pm->gcctrl[ABDAC_GCLK] |= GCLK_BIT(CEN);
80003bfc:	fe 78 0c 00 	mov	r8,-62464
80003c00:	71 d9       	ld.w	r9,r8[0x74]
80003c02:	a3 a9       	sbr	r9,0x2
80003c04:	f1 49 00 74 	st.w	r8[116],r9
  abdac->cr |= (unsigned int) ABDAC_BIT(CR_EN);
80003c08:	78 28       	ld.w	r8,r12[0x8]
80003c0a:	bf b8       	sbr	r8,0x1f
80003c0c:	99 28       	st.w	r12[0x8],r8
}
80003c0e:	5e fc       	retal	r12

80003c10 <abdac_disable>:

void abdac_disable(volatile avr32_abdac_t *abdac)
{
  volatile avr32_pm_t *pm = &AVR32_PM;
  abdac->cr &= ~ABDAC_BIT(CR_EN);
80003c10:	78 28       	ld.w	r8,r12[0x8]
80003c12:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80003c16:	99 28       	st.w	r12[0x8],r8
  pm->gcctrl[ABDAC_GCLK] &= ~GCLK_BIT(CEN);
80003c18:	fe 78 0c 00 	mov	r8,-62464
80003c1c:	71 d9       	ld.w	r9,r8[0x74]
80003c1e:	a3 c9       	cbr	r9,0x2
80003c20:	f1 49 00 74 	st.w	r8[116],r9
}
80003c24:	5e fc       	retal	r12

80003c26 <abdac_swap_channels>:

void abdac_swap_channels(volatile avr32_abdac_t *abdac)
{
  if(abdac->cr & ABDAC_BIT(CR_SWAP))
80003c26:	78 28       	ld.w	r8,r12[0x8]
80003c28:	e6 18 40 00 	andh	r8,0x4000,COH
80003c2c:	c0 50       	breq	80003c36 <abdac_swap_channels+0x10>
    abdac->cr &= ~ABDAC_BIT(CR_SWAP);
80003c2e:	78 28       	ld.w	r8,r12[0x8]
80003c30:	bf c8       	cbr	r8,0x1e
80003c32:	99 28       	st.w	r12[0x8],r8
80003c34:	5e fc       	retal	r12
  else
    abdac->cr |= ABDAC_BIT(CR_SWAP);
80003c36:	78 28       	ld.w	r8,r12[0x8]
80003c38:	bf a8       	sbr	r8,0x1e
80003c3a:	99 28       	st.w	r12[0x8],r8
80003c3c:	5e fc       	retal	r12

80003c3e <abdac_set_dac_hz>:
{
  volatile avr32_pm_t *pm = &AVR32_PM;
  unsigned short div;

  // Use OSC0
  pm->GCCTRL[ABDAC_GCLK].pllsel=0;// Oscillator source
80003c3e:	fe 78 0c 00 	mov	r8,-62464
80003c42:	71 d9       	ld.w	r9,r8[0x74]
80003c44:	30 0c       	mov	r12,0
80003c46:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
80003c4a:	f1 49 00 74 	st.w	r8[116],r9
  pm->GCCTRL[ABDAC_GCLK].oscsel=0;// OSC0
80003c4e:	71 d9       	ld.w	r9,r8[0x74]
80003c50:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80003c54:	f1 49 00 74 	st.w	r8[116],r9

  if (bus_hz < (256 * dac_hz)) {
80003c58:	a9 6a       	lsl	r10,0x8
80003c5a:	16 3a       	cp.w	r10,r11
80003c5c:	e0 88 00 09 	brls	80003c6e <abdac_set_dac_hz+0x30>
    // Disable diven to get the highest sample rate
    pm->GCCTRL[ABDAC_GCLK].diven=0;
80003c60:	71 d9       	ld.w	r9,r8[0x74]
80003c62:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80003c66:	f1 49 00 74 	st.w	r8[116],r9
80003c6a:	31 6c       	mov	r12,22
    return EINVAL;
80003c6c:	5e fc       	retal	r12
  }

  div = bus_hz / (256 * dac_hz);
80003c6e:	f6 0a 0d 08 	divu	r8,r11,r10
80003c72:	5c 88       	casts.h	r8

  if (div > 1) {
80003c74:	30 19       	mov	r9,1
80003c76:	f2 08 19 00 	cp.h	r8,r9
80003c7a:	e0 88 00 14 	brls	80003ca2 <abdac_set_dac_hz+0x64>
    // Enable DIV
    pm->GCCTRL[ABDAC_GCLK].div= (div / 2) - 1;
80003c7e:	f9 d8 c0 2f 	bfextu	r12,r8,0x1,0xf
80003c82:	20 1c       	sub	r12,1
80003c84:	5c 5c       	castu.b	r12
80003c86:	fe 79 0c 00 	mov	r9,-62464
80003c8a:	73 da       	ld.w	r10,r9[0x74]
80003c8c:	f5 dc d1 08 	bfins	r10,r12,0x8,0x8
80003c90:	f3 4a 00 74 	st.w	r9[116],r10
    pm->GCCTRL[ABDAC_GCLK].diven=1;
80003c94:	73 da       	ld.w	r10,r9[0x74]
80003c96:	30 1c       	mov	r12,1
80003c98:	f5 dc d0 81 	bfins	r10,r12,0x4,0x1
80003c9c:	f3 4a 00 74 	st.w	r9[116],r10
80003ca0:	c0 98       	rjmp	80003cb2 <abdac_set_dac_hz+0x74>
  } else {
    // Disable DIV
    pm->GCCTRL[ABDAC_GCLK].diven=0;
80003ca2:	fe 79 0c 00 	mov	r9,-62464
80003ca6:	73 da       	ld.w	r10,r9[0x74]
80003ca8:	30 0c       	mov	r12,0
80003caa:	f5 dc d0 81 	bfins	r10,r12,0x4,0x1
80003cae:	f3 4a 00 74 	st.w	r9[116],r10
  }

  return (bus_hz / (256 * div));
80003cb2:	5c 78       	castu.h	r8
80003cb4:	a9 68       	lsl	r8,0x8
80003cb6:	f6 08 0d 0a 	divu	r10,r11,r8
80003cba:	5e fa       	retal	r10

80003cbc <abdac_set_dac_sample_rate>:
  //
  // Reminder : The frequency of this ABDAC clock must be 256
  // times the frequency of the desired samplerate

  volatile avr32_pm_t *pm = &AVR32_PM;
  switch(dac_hz) {
80003cbc:	e0 4c 56 22 	cp.w	r12,22050
80003cc0:	e0 80 00 8d 	breq	80003dda <abdac_set_dac_sample_rate+0x11e>
80003cc4:	e0 8b 00 12 	brhi	80003ce8 <abdac_set_dac_sample_rate+0x2c>
80003cc8:	e0 4c 2b 11 	cp.w	r12,11025
80003ccc:	c3 b0       	breq	80003d42 <abdac_set_dac_sample_rate+0x86>
80003cce:	e0 8b 00 06 	brhi	80003cda <abdac_set_dac_sample_rate+0x1e>
80003cd2:	e0 4c 1f 40 	cp.w	r12,8000
80003cd6:	c1 b1       	brne	80003d0c <abdac_set_dac_sample_rate+0x50>
80003cd8:	c1 b8       	rjmp	80003d0e <abdac_set_dac_sample_rate+0x52>
80003cda:	e0 4c 2e e0 	cp.w	r12,12000
80003cde:	c4 b0       	breq	80003d74 <abdac_set_dac_sample_rate+0xb8>
80003ce0:	e0 4c 3e 80 	cp.w	r12,16000
80003ce4:	c1 41       	brne	80003d0c <abdac_set_dac_sample_rate+0x50>
80003ce6:	c6 18       	rjmp	80003da8 <abdac_set_dac_sample_rate+0xec>
80003ce8:	e0 4c 7d 00 	cp.w	r12,32000
80003cec:	e0 80 00 aa 	breq	80003e40 <abdac_set_dac_sample_rate+0x184>
80003cf0:	e0 8b 00 06 	brhi	80003cfc <abdac_set_dac_sample_rate+0x40>
80003cf4:	e0 4c 5d c0 	cp.w	r12,24000
80003cf8:	c0 a1       	brne	80003d0c <abdac_set_dac_sample_rate+0x50>
80003cfa:	c8 98       	rjmp	80003e0c <abdac_set_dac_sample_rate+0x150>
80003cfc:	e0 4c ac 44 	cp.w	r12,44100
80003d00:	e0 80 00 b9 	breq	80003e72 <abdac_set_dac_sample_rate+0x1b6>
80003d04:	e0 4c bb 80 	cp.w	r12,48000
80003d08:	e0 80 00 ce 	breq	80003ea4 <abdac_set_dac_sample_rate+0x1e8>
80003d0c:	5e fd       	retal	0
    case 8000:// PLL0/30/256
         pm->GCCTRL[ABDAC_GCLK].div= 14; // div by 2*(14+1)=30
80003d0e:	fe 78 0c 00 	mov	r8,-62464
80003d12:	71 d9       	ld.w	r9,r8[0x74]
80003d14:	30 ea       	mov	r10,14
80003d16:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
80003d1a:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80003d1e:	71 d9       	ld.w	r9,r8[0x74]
80003d20:	30 1c       	mov	r12,1
80003d22:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80003d26:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
80003d2a:	71 d9       	ld.w	r9,r8[0x74]
80003d2c:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
80003d30:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=0;// PLL 0
80003d34:	71 d9       	ld.w	r9,r8[0x74]
80003d36:	30 0a       	mov	r10,0
80003d38:	f3 da d0 01 	bfins	r9,r10,0x0,0x1
80003d3c:	f1 49 00 74 	st.w	r8[116],r9
      break;
80003d40:	5e fc       	retal	r12
    case 11025:// OSC1/4/256
         pm->GCCTRL[ABDAC_GCLK].div= 1;  // div by 2*(1+1)=4
80003d42:	fe 78 0c 00 	mov	r8,-62464
80003d46:	71 d9       	ld.w	r9,r8[0x74]
80003d48:	30 1c       	mov	r12,1
80003d4a:	f3 dc d1 08 	bfins	r9,r12,0x8,0x8
80003d4e:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80003d52:	71 d9       	ld.w	r9,r8[0x74]
80003d54:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80003d58:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=0;// Oscillator source
80003d5c:	71 d9       	ld.w	r9,r8[0x74]
80003d5e:	30 0a       	mov	r10,0
80003d60:	f3 da d0 21 	bfins	r9,r10,0x1,0x1
80003d64:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// OSC1
80003d68:	71 d9       	ld.w	r9,r8[0x74]
80003d6a:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80003d6e:	f1 49 00 74 	st.w	r8[116],r9
        break;
80003d72:	5e fc       	retal	r12
    case 12000:// PLL0/20/256
         pm->GCCTRL[ABDAC_GCLK].div= 9;  // div by 2*(9+1)=20
80003d74:	fe 78 0c 00 	mov	r8,-62464
80003d78:	71 d9       	ld.w	r9,r8[0x74]
80003d7a:	30 9a       	mov	r10,9
80003d7c:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
80003d80:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80003d84:	71 d9       	ld.w	r9,r8[0x74]
80003d86:	30 1c       	mov	r12,1
80003d88:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80003d8c:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
80003d90:	71 d9       	ld.w	r9,r8[0x74]
80003d92:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
80003d96:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=0;// PLL 0
80003d9a:	71 d9       	ld.w	r9,r8[0x74]
80003d9c:	30 0a       	mov	r10,0
80003d9e:	f3 da d0 01 	bfins	r9,r10,0x0,0x1
80003da2:	f1 49 00 74 	st.w	r8[116],r9
        break;
80003da6:	5e fc       	retal	r12
    case 16000:// PLL1/12/256
         pm->GCCTRL[ABDAC_GCLK].div= 5;  // div by 2*(5+1)=12
80003da8:	fe 78 0c 00 	mov	r8,-62464
80003dac:	71 d9       	ld.w	r9,r8[0x74]
80003dae:	30 5a       	mov	r10,5
80003db0:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
80003db4:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80003db8:	71 d9       	ld.w	r9,r8[0x74]
80003dba:	30 1c       	mov	r12,1
80003dbc:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80003dc0:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
80003dc4:	71 d9       	ld.w	r9,r8[0x74]
80003dc6:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
80003dca:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// PLL 1
80003dce:	71 d9       	ld.w	r9,r8[0x74]
80003dd0:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80003dd4:	f1 49 00 74 	st.w	r8[116],r9
        break;
80003dd8:	5e fc       	retal	r12
    case 22050:// OSC1/2/256
         pm->GCCTRL[ABDAC_GCLK].div= 0;  // div by 2*(0+1)=2
80003dda:	fe 78 0c 00 	mov	r8,-62464
80003dde:	71 d9       	ld.w	r9,r8[0x74]
80003de0:	30 0a       	mov	r10,0
80003de2:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
80003de6:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // div Enable
80003dea:	71 d9       	ld.w	r9,r8[0x74]
80003dec:	30 1c       	mov	r12,1
80003dee:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80003df2:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=0;// Oscillator source
80003df6:	71 d9       	ld.w	r9,r8[0x74]
80003df8:	f3 da d0 21 	bfins	r9,r10,0x1,0x1
80003dfc:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// OSC1
80003e00:	71 d9       	ld.w	r9,r8[0x74]
80003e02:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80003e06:	f1 49 00 74 	st.w	r8[116],r9
        break;
80003e0a:	5e fc       	retal	r12
    case 24000:// PLL0/10/256
         pm->GCCTRL[ABDAC_GCLK].div= 4;  // div by 2*(4+1)=10
80003e0c:	fe 78 0c 00 	mov	r8,-62464
80003e10:	71 d9       	ld.w	r9,r8[0x74]
80003e12:	30 4a       	mov	r10,4
80003e14:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
80003e18:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80003e1c:	71 d9       	ld.w	r9,r8[0x74]
80003e1e:	30 1c       	mov	r12,1
80003e20:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80003e24:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
80003e28:	71 d9       	ld.w	r9,r8[0x74]
80003e2a:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
80003e2e:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=0;// PLL 0
80003e32:	71 d9       	ld.w	r9,r8[0x74]
80003e34:	30 0a       	mov	r10,0
80003e36:	f3 da d0 01 	bfins	r9,r10,0x0,0x1
80003e3a:	f1 49 00 74 	st.w	r8[116],r9
        break;
80003e3e:	5e fc       	retal	r12
    case 32000:// PLL1/6/256
         pm->GCCTRL[ABDAC_GCLK].div= 2;  // div by 2*(2+1)=6
80003e40:	fe 78 0c 00 	mov	r8,-62464
80003e44:	71 d9       	ld.w	r9,r8[0x74]
80003e46:	30 2a       	mov	r10,2
80003e48:	f3 da d1 08 	bfins	r9,r10,0x8,0x8
80003e4c:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80003e50:	71 d9       	ld.w	r9,r8[0x74]
80003e52:	30 1c       	mov	r12,1
80003e54:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80003e58:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
80003e5c:	71 d9       	ld.w	r9,r8[0x74]
80003e5e:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
80003e62:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// PLL 1
80003e66:	71 d9       	ld.w	r9,r8[0x74]
80003e68:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80003e6c:	f1 49 00 74 	st.w	r8[116],r9
        break;
80003e70:	5e fc       	retal	r12
    case 44100:// OSC1/256
         pm->GCCTRL[ABDAC_GCLK].div= 0;  // No Div factor
80003e72:	fe 78 0c 00 	mov	r8,-62464
80003e76:	71 da       	ld.w	r10,r8[0x74]
80003e78:	30 09       	mov	r9,0
80003e7a:	f5 d9 d1 08 	bfins	r10,r9,0x8,0x8
80003e7e:	f1 4a 00 74 	st.w	r8[116],r10
         pm->GCCTRL[ABDAC_GCLK].diven=0; // div disable
80003e82:	71 da       	ld.w	r10,r8[0x74]
80003e84:	f5 d9 d0 81 	bfins	r10,r9,0x4,0x1
80003e88:	f1 4a 00 74 	st.w	r8[116],r10
         pm->GCCTRL[ABDAC_GCLK].pllsel=0;// Oscillator source
80003e8c:	71 da       	ld.w	r10,r8[0x74]
80003e8e:	f5 d9 d0 21 	bfins	r10,r9,0x1,0x1
80003e92:	f1 4a 00 74 	st.w	r8[116],r10
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// OSC1
80003e96:	71 d9       	ld.w	r9,r8[0x74]
80003e98:	30 1c       	mov	r12,1
80003e9a:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80003e9e:	f1 49 00 74 	st.w	r8[116],r9
        break;
80003ea2:	5e fc       	retal	r12
    case 48000:// PLL1/4/256
         pm->GCCTRL[ABDAC_GCLK].div= 1;  // div by 2*(1+1)=4
80003ea4:	fe 78 0c 00 	mov	r8,-62464
80003ea8:	71 d9       	ld.w	r9,r8[0x74]
80003eaa:	30 1c       	mov	r12,1
80003eac:	f3 dc d1 08 	bfins	r9,r12,0x8,0x8
80003eb0:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].diven=1; // Div Enable
80003eb4:	71 d9       	ld.w	r9,r8[0x74]
80003eb6:	f3 dc d0 81 	bfins	r9,r12,0x4,0x1
80003eba:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].pllsel=1;// PLL source
80003ebe:	71 d9       	ld.w	r9,r8[0x74]
80003ec0:	f3 dc d0 21 	bfins	r9,r12,0x1,0x1
80003ec4:	f1 49 00 74 	st.w	r8[116],r9
         pm->GCCTRL[ABDAC_GCLK].oscsel=1;// PLL 1
80003ec8:	71 d9       	ld.w	r9,r8[0x74]
80003eca:	f3 dc d0 01 	bfins	r9,r12,0x0,0x1
80003ece:	f1 49 00 74 	st.w	r8[116],r9
  // this can be reached on J16-pin8
  //pm->gcctrl[2] = pm->gcctrl[ABDAC_GCLK];
  //pm->GCCTRL[2].cen = 1;
  //gpio_enable_module_pin(AVR32_PM_GCLK_2_1_PIN, AVR32_PM_GCLK_2_1_FUNCTION);
  return true;
}
80003ed2:	5e fc       	retal	r12

80003ed4 <adc_configure>:
	adc->mr |= 1 << AVR32_ADC_LOWRES_OFFSET;
#endif

	/* Set Sample/Hold time to max so that the ADC capacitor should be
	 * loaded entirely */
	adc->mr |= 0xF << AVR32_ADC_SHTIM_OFFSET;
80003ed4:	78 18       	ld.w	r8,r12[0x4]
80003ed6:	ea 18 0f 00 	orh	r8,0xf00
80003eda:	99 18       	st.w	r12[0x4],r8

	/* Set Startup to max so that the ADC capacitor should be loaded
	 * entirely */
	adc->mr |= 0x1F << AVR32_ADC_STARTUP_OFFSET;
80003edc:	78 18       	ld.w	r8,r12[0x4]
80003ede:	ea 18 00 1f 	orh	r8,0x1f
80003ee2:	99 18       	st.w	r12[0x4],r8
}
80003ee4:	5e fc       	retal	r12

80003ee6 <adc_start>:
void adc_start(volatile avr32_adc_t *adc)
{
	Assert( adc != NULL );

	/* start conversion */
	adc->cr = AVR32_ADC_START_MASK;
80003ee6:	30 28       	mov	r8,2
80003ee8:	99 08       	st.w	r12[0x0],r8
}
80003eea:	5e fc       	retal	r12

80003eec <adc_enable>:
	Assert( adc != NULL );
	Assert( channel <= AVR32_ADC_CHANNELS_MSB ); /* check if channel exist
	                                              **/

	/* enable channel */
	adc->cher = (1 << channel);
80003eec:	30 18       	mov	r8,1
80003eee:	f0 0b 09 48 	lsl	r8,r8,r11
80003ef2:	99 48       	st.w	r12[0x10],r8
}
80003ef4:	5e fc       	retal	r12

80003ef6 <adc_check_eoc>:
	Assert( adc != NULL );
	Assert( channel <= AVR32_ADC_CHANNELS_MSB ); /* check if channel exist
	                                              **/

	/* get SR register : EOC bit for channel */
	return ((adc->sr & (1 << channel)) ? true : false);
80003ef6:	78 78       	ld.w	r8,r12[0x1c]
80003ef8:	30 19       	mov	r9,1
80003efa:	f2 0b 09 49 	lsl	r9,r9,r11
80003efe:	f3 e8 00 08 	and	r8,r9,r8
}
80003f02:	5f 1c       	srne	r12
80003f04:	5e fc       	retal	r12
80003f06:	d7 03       	nop

80003f08 <adc_get_value>:
 * \param *adc Base address of the ADC
 * \param  channel   channel to handle (0 to 7)
 * \return The value acquired (unsigned long)
 */
uint32_t adc_get_value(volatile avr32_adc_t *adc, uint16_t channel)
{
80003f08:	eb cd 40 e0 	pushm	r5-r7,lr
80003f0c:	18 97       	mov	r7,r12
80003f0e:	16 95       	mov	r5,r11
	Assert( adc != NULL );
	Assert( channel <= AVR32_ADC_CHANNELS_MSB );

	/* wait for end of conversion */
	while (adc_check_eoc(adc, channel) != true) {
80003f10:	ed db c0 10 	bfextu	r6,r11,0x0,0x10
80003f14:	0c 9b       	mov	r11,r6
80003f16:	0e 9c       	mov	r12,r7
80003f18:	f0 1f 00 05 	mcall	80003f2c <adc_get_value+0x24>
80003f1c:	cf c0       	breq	80003f14 <adc_get_value+0xc>
	}

	return *((uint32_t *)((&(adc->cdr0)) + channel));
80003f1e:	2d 07       	sub	r7,-48
80003f20:	5c 75       	castu.h	r5
}
80003f22:	ee 05 03 2c 	ld.w	r12,r7[r5<<0x2]
80003f26:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003f2a:	00 00       	add	r0,r0
80003f2c:	80 00       	ld.sh	r0,r0[0x0]
80003f2e:	3e f6       	mov	r6,-17

80003f30 <smc_init>:

static void smc_enable_muxed_pins(void);


void smc_init(unsigned long hsb_hz)
{
80003f30:	eb cd 40 fc 	pushm	r2-r7,lr
  unsigned long hsb_mhz_up = (hsb_hz + 999999) / 1000000;
80003f34:	ee 78 42 3f 	mov	r8,999999
80003f38:	f8 08 00 09 	add	r9,r12,r8
80003f3c:	e0 68 de 83 	mov	r8,56963
80003f40:	ea 18 43 1b 	orh	r8,0x431b
80003f44:	f2 08 06 48 	mulu.d	r8,r9,r8
80003f48:	f2 08 16 12 	lsr	r8,r9,0x12
//! Whether to use the NCS0 pin
#ifdef SMC_USE_NCS0
  #include SMC_COMPONENT_CS0

  // Setup SMC for NCS0
  SMC_CS_SETUP(0)
80003f4c:	f0 08 00 25 	add	r5,r8,r8<<0x2
80003f50:	a3 65       	lsl	r5,0x2
80003f52:	ea c5 fc 19 	sub	r5,r5,-999
80003f56:	e0 69 4d d3 	mov	r9,19923
80003f5a:	ea 19 10 62 	orh	r9,0x1062
80003f5e:	ea 09 06 44 	mulu.d	r4,r5,r9
80003f62:	a7 85       	lsr	r5,0x6
80003f64:	f0 0a 15 04 	lsl	r10,r8,0x4
80003f68:	f4 08 01 07 	sub	r7,r10,r8
80003f6c:	a1 77       	lsl	r7,0x1
80003f6e:	ee c7 fc 19 	sub	r7,r7,-999
80003f72:	ee 09 06 46 	mulu.d	r6,r7,r9
80003f76:	0e 94       	mov	r4,r7
80003f78:	a7 84       	lsr	r4,0x6
80003f7a:	f4 08 01 07 	sub	r7,r10,r8
80003f7e:	a3 67       	lsl	r7,0x2
80003f80:	ee c7 fc 19 	sub	r7,r7,-999
80003f84:	ee 09 06 46 	mulu.d	r6,r7,r9
80003f88:	a7 87       	lsr	r7,0x6
80003f8a:	f0 03 10 5a 	mul	r3,r8,90
80003f8e:	e6 c3 fc 19 	sub	r3,r3,-999
80003f92:	e6 09 06 42 	mulu.d	r2,r3,r9
80003f96:	e6 0c 16 06 	lsr	r12,r3,0x6
80003f9a:	e0 63 00 d2 	mov	r3,210
80003f9e:	f0 03 02 43 	mul	r3,r8,r3
80003fa2:	e6 c3 fc 19 	sub	r3,r3,-999
80003fa6:	e6 09 06 42 	mulu.d	r2,r3,r9
80003faa:	e6 06 16 06 	lsr	r6,r3,0x6
80003fae:	f4 08 01 0b 	sub	r11,r10,r8
80003fb2:	a5 6b       	lsl	r11,0x4
80003fb4:	f6 cb fc 19 	sub	r11,r11,-999
80003fb8:	f6 09 06 4a 	mulu.d	r10,r11,r9
80003fbc:	f6 0e 16 06 	lsr	lr,r11,0x6
80003fc0:	f0 03 10 64 	mul	r3,r8,100
80003fc4:	e6 c3 fc 19 	sub	r3,r3,-999
80003fc8:	e6 09 06 42 	mulu.d	r2,r3,r9
80003fcc:	a7 83       	lsr	r3,0x6
80003fce:	e0 6a 01 0e 	mov	r10,270
80003fd2:	b5 38       	mul	r8,r10
80003fd4:	f0 c8 fc 19 	sub	r8,r8,-999
80003fd8:	f0 09 06 48 	mulu.d	r8,r8,r9
80003fdc:	a7 89       	lsr	r9,0x6
80003fde:	ec 04 00 0a 	add	r10,r6,r4
80003fe2:	1c 3a       	cp.w	r10,lr
80003fe4:	f4 0e 17 20 	movhs	lr,r10
80003fe8:	ee 05 00 0b 	add	r11,r7,r5
80003fec:	18 3b       	cp.w	r11,r12
80003fee:	f6 0c 17 20 	movhs	r12,r11
80003ff2:	06 3b       	cp.w	r11,r3
80003ff4:	e6 0b 17 30 	movlo	r11,r3
80003ff8:	12 3a       	cp.w	r10,r9
80003ffa:	f4 09 17 20 	movhs	r9,r10
80003ffe:	eb e4 11 05 	or	r5,r5,r4<<0x10
80004002:	fe 6a 1c 00 	mov	r10,-123904
80004006:	95 05       	st.w	r10[0x0],r5
80004008:	ef e6 11 07 	or	r7,r7,r6<<0x10
8000400c:	ef ec 10 87 	or	r7,r7,r12<<0x8
80004010:	ef ee 11 87 	or	r7,r7,lr<<0x18
80004014:	95 17       	st.w	r10[0x4],r7
80004016:	1c 39       	cp.w	r9,lr
80004018:	f2 0e 17 20 	movhs	lr,r9
8000401c:	18 3b       	cp.w	r11,r12
8000401e:	f8 0b 17 30 	movlo	r11,r12
80004022:	f7 ee 11 0b 	or	r11,r11,lr<<0x10
80004026:	95 2b       	st.w	r10[0x8],r11
80004028:	e0 68 10 03 	mov	r8,4099
8000402c:	95 38       	st.w	r10[0xc],r8
8000402e:	30 19       	mov	r9,1
80004030:	48 48       	lddpc	r8,80004040 <smc_init+0x110>
80004032:	b0 89       	st.b	r8[0x0],r9
        {ATPASTE2(EBI_NCS_5,_PIN),ATPASTE2(EBI_NCS_5,_FUNCTION)},
    #endif
#endif
 };

  gpio_enable_module(SMC_EBI_GPIO_MAP, sizeof(SMC_EBI_GPIO_MAP) / sizeof(SMC_EBI_GPIO_MAP[0]));
80004034:	31 4b       	mov	r11,20
80004036:	48 4c       	lddpc	r12,80004044 <smc_init+0x114>
80004038:	f0 1f 00 04 	mcall	80004048 <smc_init+0x118>
  #undef NCS_CONTROLLED_WRITE
  #undef NWAIT_MODE
#endif
  // Put the multiplexed MCU pins used for the SM under control of the SMC.
  smc_enable_muxed_pins();
}
8000403c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80004040:	00 00       	add	r0,r0
80004042:	05 6c       	ld.uh	r12,--r2
80004044:	80 00       	ld.sh	r0,r0[0x0]
80004046:	cf 40       	breq	8000402e <smc_init+0xfe>
80004048:	80 00       	ld.sh	r0,r0[0x0]
8000404a:	40 ac       	lddsp	r12,sp[0x28]

8000404c <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
8000404c:	fe 68 14 00 	mov	r8,-125952
80004050:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
80004052:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
80004056:	91 09       	st.w	r8[0x0],r9
}
80004058:	5e fc       	retal	r12

8000405a <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000405a:	f8 08 16 05 	lsr	r8,r12,0x5
8000405e:	a9 68       	lsl	r8,0x8
80004060:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80004064:	58 1b       	cp.w	r11,1
80004066:	c0 d0       	breq	80004080 <gpio_enable_module_pin+0x26>
80004068:	c0 63       	brcs	80004074 <gpio_enable_module_pin+0x1a>
8000406a:	58 2b       	cp.w	r11,2
8000406c:	c1 00       	breq	8000408c <gpio_enable_module_pin+0x32>
8000406e:	58 3b       	cp.w	r11,3
80004070:	c1 40       	breq	80004098 <gpio_enable_module_pin+0x3e>
80004072:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80004074:	30 19       	mov	r9,1
80004076:	f2 0c 09 49 	lsl	r9,r9,r12
8000407a:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000407c:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000407e:	c1 28       	rjmp	800040a2 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80004080:	30 19       	mov	r9,1
80004082:	f2 0c 09 49 	lsl	r9,r9,r12
80004086:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80004088:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000408a:	c0 c8       	rjmp	800040a2 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000408c:	30 19       	mov	r9,1
8000408e:	f2 0c 09 49 	lsl	r9,r9,r12
80004092:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80004094:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004096:	c0 68       	rjmp	800040a2 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80004098:	30 19       	mov	r9,1
8000409a:	f2 0c 09 49 	lsl	r9,r9,r12
8000409e:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800040a0:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800040a2:	30 19       	mov	r9,1
800040a4:	f2 0c 09 4c 	lsl	r12,r9,r12
800040a8:	91 2c       	st.w	r8[0x8],r12
800040aa:	5e fd       	retal	0

800040ac <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
800040ac:	d4 21       	pushm	r4-r7,lr
800040ae:	18 97       	mov	r7,r12
800040b0:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800040b2:	58 0b       	cp.w	r11,0
800040b4:	c0 31       	brne	800040ba <gpio_enable_module+0xe>
800040b6:	30 05       	mov	r5,0
800040b8:	c0 d8       	rjmp	800040d2 <gpio_enable_module+0x26>
800040ba:	30 06       	mov	r6,0
800040bc:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800040be:	6e 1b       	ld.w	r11,r7[0x4]
800040c0:	6e 0c       	ld.w	r12,r7[0x0]
800040c2:	f0 1f 00 06 	mcall	800040d8 <gpio_enable_module+0x2c>
800040c6:	18 45       	or	r5,r12
		gpiomap++;
800040c8:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800040ca:	2f f6       	sub	r6,-1
800040cc:	0c 34       	cp.w	r4,r6
800040ce:	fe 9b ff f8 	brhi	800040be <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
800040d2:	0a 9c       	mov	r12,r5
800040d4:	d8 22       	popm	r4-r7,pc
800040d6:	00 00       	add	r0,r0
800040d8:	80 00       	ld.sh	r0,r0[0x0]
800040da:	40 5a       	lddsp	r10,sp[0x14]

800040dc <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800040dc:	f8 08 16 05 	lsr	r8,r12,0x5
800040e0:	a9 68       	lsl	r8,0x8
800040e2:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
800040e6:	30 19       	mov	r9,1
800040e8:	f2 0c 09 4c 	lsl	r12,r9,r12
800040ec:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
800040f0:	91 1c       	st.w	r8[0x4],r12
}
800040f2:	5e fc       	retal	r12

800040f4 <gpio_enable_gpio>:
 *
 * \param gpiomap The pin map.
 * \param size The number of pins in \a gpiomap.
 */
void gpio_enable_gpio(const gpio_map_t gpiomap, uint32_t size)
{
800040f4:	eb cd 40 e0 	pushm	r5-r7,lr
800040f8:	18 97       	mov	r7,r12
800040fa:	16 96       	mov	r6,r11
	uint32_t i;

	for (i = 0; i < size; i++) {
800040fc:	58 0b       	cp.w	r11,0
800040fe:	c0 a0       	breq	80004112 <gpio_enable_gpio+0x1e>
80004100:	30 05       	mov	r5,0
		gpio_enable_gpio_pin(gpiomap->pin);
80004102:	6e 0c       	ld.w	r12,r7[0x0]
80004104:	f0 1f 00 05 	mcall	80004118 <gpio_enable_gpio+0x24>
		gpiomap++;
80004108:	2f 87       	sub	r7,-8
 */
void gpio_enable_gpio(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t i;

	for (i = 0; i < size; i++) {
8000410a:	2f f5       	sub	r5,-1
8000410c:	0a 36       	cp.w	r6,r5
8000410e:	fe 9b ff fa 	brhi	80004102 <gpio_enable_gpio+0xe>
80004112:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004116:	00 00       	add	r0,r0
80004118:	80 00       	ld.sh	r0,r0[0x0]
8000411a:	40 dc       	lddsp	r12,sp[0x34]

8000411c <gpio_get_pin_value>:
 *
 * \return The pin value.
 */
bool gpio_get_pin_value(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000411c:	f8 08 16 05 	lsr	r8,r12,0x5
80004120:	a9 68       	lsl	r8,0x8
80004122:	e0 28 f0 00 	sub	r8,61440
	
	return (gpio_port->pvr >> (pin & 0x1F)) & 1;
80004126:	71 88       	ld.w	r8,r8[0x60]
80004128:	f0 0c 0a 4c 	lsr	r12,r8,r12
}
8000412c:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80004130:	5e fc       	retal	r12

80004132 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004132:	f8 08 16 05 	lsr	r8,r12,0x5
80004136:	a9 68       	lsl	r8,0x8
80004138:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
8000413c:	30 19       	mov	r9,1
8000413e:	f2 0c 09 4c 	lsl	r12,r9,r12
80004142:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80004146:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000414a:	91 1c       	st.w	r8[0x4],r12
}
8000414c:	5e fc       	retal	r12

8000414e <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000414e:	f8 08 16 05 	lsr	r8,r12,0x5
80004152:	a9 68       	lsl	r8,0x8
80004154:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80004158:	30 19       	mov	r9,1
8000415a:	f2 0c 09 4c 	lsl	r12,r9,r12
8000415e:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80004162:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80004166:	91 1c       	st.w	r8[0x4],r12
}
80004168:	5e fc       	retal	r12
8000416a:	d7 03       	nop

8000416c <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
8000416c:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80004170:	49 99       	lddpc	r9,800041d4 <INTC_register_interrupt+0x68>
80004172:	f2 08 00 39 	add	r9,r9,r8<<0x3
80004176:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000417a:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
8000417c:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80004180:	58 0a       	cp.w	r10,0
80004182:	c0 91       	brne	80004194 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004184:	49 59       	lddpc	r9,800041d8 <INTC_register_interrupt+0x6c>
80004186:	49 6a       	lddpc	r10,800041dc <INTC_register_interrupt+0x70>
80004188:	12 1a       	sub	r10,r9
8000418a:	fe 79 08 00 	mov	r9,-63488
8000418e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004192:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80004194:	58 1a       	cp.w	r10,1
80004196:	c0 a1       	brne	800041aa <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80004198:	49 09       	lddpc	r9,800041d8 <INTC_register_interrupt+0x6c>
8000419a:	49 2a       	lddpc	r10,800041e0 <INTC_register_interrupt+0x74>
8000419c:	12 1a       	sub	r10,r9
8000419e:	bf aa       	sbr	r10,0x1e
800041a0:	fe 79 08 00 	mov	r9,-63488
800041a4:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800041a8:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
800041aa:	58 2a       	cp.w	r10,2
800041ac:	c0 a1       	brne	800041c0 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
800041ae:	48 b9       	lddpc	r9,800041d8 <INTC_register_interrupt+0x6c>
800041b0:	48 da       	lddpc	r10,800041e4 <INTC_register_interrupt+0x78>
800041b2:	12 1a       	sub	r10,r9
800041b4:	bf ba       	sbr	r10,0x1f
800041b6:	fe 79 08 00 	mov	r9,-63488
800041ba:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800041be:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800041c0:	48 69       	lddpc	r9,800041d8 <INTC_register_interrupt+0x6c>
800041c2:	48 aa       	lddpc	r10,800041e8 <INTC_register_interrupt+0x7c>
800041c4:	12 1a       	sub	r10,r9
800041c6:	ea 1a c0 00 	orh	r10,0xc000
800041ca:	fe 79 08 00 	mov	r9,-63488
800041ce:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800041d2:	5e fc       	retal	r12
800041d4:	80 00       	ld.sh	r0,r0[0x0]
800041d6:	cf e0       	breq	800041d2 <INTC_register_interrupt+0x66>
800041d8:	80 00       	ld.sh	r0,r0[0x0]
800041da:	ca 00       	breq	8000411a <gpio_enable_gpio+0x26>
800041dc:	80 00       	ld.sh	r0,r0[0x0]
800041de:	cb 04       	brge	8000413e <gpio_set_gpio_pin+0xc>
800041e0:	80 00       	ld.sh	r0,r0[0x0]
800041e2:	cb 12       	brcc	80004144 <gpio_set_gpio_pin+0x12>
800041e4:	80 00       	ld.sh	r0,r0[0x0]
800041e6:	cb 20       	breq	8000414a <gpio_set_gpio_pin+0x18>
800041e8:	80 00       	ld.sh	r0,r0[0x0]
800041ea:	cb 2e       	rcall	80003f4e <smc_init+0x1e>

800041ec <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
800041ec:	fe 78 08 00 	mov	r8,-63488
800041f0:	e0 69 00 83 	mov	r9,131
800041f4:	f2 0c 01 0c 	sub	r12,r9,r12
800041f8:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
800041fc:	f2 ca ff c0 	sub	r10,r9,-64
80004200:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80004204:	58 08       	cp.w	r8,0
80004206:	c0 21       	brne	8000420a <_get_interrupt_handler+0x1e>
80004208:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
8000420a:	f0 08 12 00 	clz	r8,r8
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000420e:	48 5a       	lddpc	r10,80004220 <_get_interrupt_handler+0x34>
80004210:	f4 09 00 39 	add	r9,r10,r9<<0x3
80004214:	f0 08 11 1f 	rsub	r8,r8,31
80004218:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000421a:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
8000421e:	5e fc       	retal	r12
80004220:	80 00       	ld.sh	r0,r0[0x0]
80004222:	cf e0       	breq	8000421e <_get_interrupt_handler+0x32>

80004224 <pdca_get_handler>:
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
80004224:	30 e8       	mov	r8,14
80004226:	f0 0c 18 00 	cp.b	r12,r8
8000422a:	e0 88 00 03 	brls	80004230 <pdca_get_handler+0xc>
8000422e:	5e fe       	retal	-1

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
80004230:	a7 6c       	lsl	r12,0x6
80004232:	e0 3c 00 00 	sub	r12,65536
	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
		return (volatile avr32_pdca_channel_t *)PDCA_INVALID_ARGUMENT;
	}

	return pdca_channel;
}
80004236:	5e fc       	retal	r12

80004238 <pdca_disable>:

	return (pdca_channel->sr & AVR32_PDCA_TEN_MASK) != 0;
}

void pdca_disable(uint8_t pdca_ch_number)
{
80004238:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
8000423a:	f0 1f 00 03 	mcall	80004244 <pdca_disable+0xc>
			pdca_ch_number);

	/* Disable transfer */
	pdca_channel->cr = AVR32_PDCA_TDIS_MASK;
8000423e:	30 28       	mov	r8,2
80004240:	99 58       	st.w	r12[0x14],r8
}
80004242:	d8 02       	popm	pc
80004244:	80 00       	ld.sh	r0,r0[0x0]
80004246:	42 24       	lddsp	r4,sp[0x88]

80004248 <pdca_enable>:

void pdca_enable(uint8_t pdca_ch_number)
{
80004248:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
8000424a:	f0 1f 00 03 	mcall	80004254 <pdca_enable+0xc>
			pdca_ch_number);

	/* Enable transfer */
	pdca_channel->cr = AVR32_PDCA_TEN_MASK;
8000424e:	30 18       	mov	r8,1
80004250:	99 58       	st.w	r12[0x14],r8
}
80004252:	d8 02       	popm	pc
80004254:	80 00       	ld.sh	r0,r0[0x0]
80004256:	42 24       	lddsp	r4,sp[0x88]

80004258 <pdca_enable_interrupt_transfer_complete>:

	cpu_irq_restore(flags);
}

void pdca_enable_interrupt_transfer_complete(uint8_t pdca_ch_number)
{
80004258:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
8000425a:	f0 1f 00 03 	mcall	80004264 <pdca_enable_interrupt_transfer_complete+0xc>
			pdca_ch_number);

	pdca_channel->ier = AVR32_PDCA_TRC_MASK;
8000425e:	30 28       	mov	r8,2
80004260:	99 88       	st.w	r12[0x20],r8
}
80004262:	d8 02       	popm	pc
80004264:	80 00       	ld.sh	r0,r0[0x0]
80004266:	42 24       	lddsp	r4,sp[0x88]

80004268 <pdca_enable_interrupt_reload_counter_zero>:

	cpu_irq_restore(flags);
}

void pdca_enable_interrupt_reload_counter_zero(uint8_t pdca_ch_number)
{
80004268:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
8000426a:	f0 1f 00 03 	mcall	80004274 <pdca_enable_interrupt_reload_counter_zero+0xc>
			pdca_ch_number);

	pdca_channel->ier = AVR32_PDCA_RCZ_MASK;
8000426e:	30 18       	mov	r8,1
80004270:	99 88       	st.w	r12[0x20],r8
}
80004272:	d8 02       	popm	pc
80004274:	80 00       	ld.sh	r0,r0[0x0]
80004276:	42 24       	lddsp	r4,sp[0x88]

80004278 <pdca_get_transfer_status>:

uint32_t pdca_get_transfer_status(uint8_t pdca_ch_number)
{
80004278:	d4 01       	pushm	lr
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
8000427a:	f0 1f 00 03 	mcall	80004284 <pdca_get_transfer_status+0xc>
			pdca_ch_number);

	return pdca_channel->isr;
8000427e:	78 bc       	ld.w	r12,r12[0x2c]
}
80004280:	d8 02       	popm	pc
80004282:	00 00       	add	r0,r0
80004284:	80 00       	ld.sh	r0,r0[0x0]
80004286:	42 24       	lddsp	r4,sp[0x88]

80004288 <pdca_disable_interrupt_reload_counter_zero>:

	pdca_channel->ier = AVR32_PDCA_TRC_MASK;
}

void pdca_disable_interrupt_reload_counter_zero(uint8_t pdca_ch_number)
{
80004288:	d4 01       	pushm	lr
8000428a:	20 1d       	sub	sp,4
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
8000428c:	f0 1f 00 08 	mcall	800042ac <pdca_disable_interrupt_reload_counter_zero+0x24>

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80004290:	e1 b8 00 00 	mfsr	r8,0x0
80004294:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
80004296:	d3 03       	ssrf	0x10

	return flags;
80004298:	40 08       	lddsp	r8,sp[0x0]
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	pdca_channel->idr = AVR32_PDCA_RCZ_MASK;
8000429a:	30 19       	mov	r9,1
8000429c:	99 99       	st.w	r12[0x24],r9
	pdca_channel->isr;
8000429e:	78 b9       	ld.w	r9,r12[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800042a0:	e6 18 00 01 	andh	r8,0x1,COH
800042a4:	c0 21       	brne	800042a8 <pdca_disable_interrupt_reload_counter_zero+0x20>
      cpu_irq_enable();
800042a6:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
800042a8:	2f fd       	sub	sp,-4
800042aa:	d8 02       	popm	pc
800042ac:	80 00       	ld.sh	r0,r0[0x0]
800042ae:	42 24       	lddsp	r4,sp[0x88]

800042b0 <pdca_disable_interrupt_transfer_complete>:

	pdca_channel->ier = AVR32_PDCA_TERR_MASK;
}

void pdca_disable_interrupt_transfer_complete(uint8_t pdca_ch_number)
{
800042b0:	d4 01       	pushm	lr
800042b2:	20 1d       	sub	sp,4
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
800042b4:	f0 1f 00 08 	mcall	800042d4 <pdca_disable_interrupt_transfer_complete+0x24>

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800042b8:	e1 b8 00 00 	mfsr	r8,0x0
800042bc:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
800042be:	d3 03       	ssrf	0x10

	return flags;
800042c0:	40 08       	lddsp	r8,sp[0x0]
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	pdca_channel->idr = AVR32_PDCA_TRC_MASK;
800042c2:	30 29       	mov	r9,2
800042c4:	99 99       	st.w	r12[0x24],r9
	pdca_channel->isr;
800042c6:	78 b9       	ld.w	r9,r12[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800042c8:	e6 18 00 01 	andh	r8,0x1,COH
800042cc:	c0 21       	brne	800042d0 <pdca_disable_interrupt_transfer_complete+0x20>
      cpu_irq_enable();
800042ce:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
800042d0:	2f fd       	sub	sp,-4
800042d2:	d8 02       	popm	pc
800042d4:	80 00       	ld.sh	r0,r0[0x0]
800042d6:	42 24       	lddsp	r4,sp[0x88]

800042d8 <pdca_reload_channel>:
	return pdca_channel->tcrr;
}

void pdca_reload_channel(uint8_t pdca_ch_number, volatile void *addr,
		uint32_t size)
{
800042d8:	eb cd 40 c0 	pushm	r6-r7,lr
800042dc:	20 1d       	sub	sp,4
800042de:	16 96       	mov	r6,r11
800042e0:	14 97       	mov	r7,r10
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
800042e2:	f0 1f 00 0b 	mcall	8000430c <pdca_reload_channel+0x34>

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800042e6:	e1 b8 00 00 	mfsr	r8,0x0
800042ea:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
800042ec:	d3 03       	ssrf	0x10

	return flags;
800042ee:	40 08       	lddsp	r8,sp[0x0]
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	/* set up next memory address */
	pdca_channel->marr = (uint32_t)addr;
800042f0:	99 36       	st.w	r12[0xc],r6
	/* set up next memory size */
	pdca_channel->tcrr = size;
800042f2:	99 47       	st.w	r12[0x10],r7
	pdca_channel->cr = AVR32_PDCA_ECLR_MASK;
800042f4:	e0 69 01 00 	mov	r9,256
800042f8:	99 59       	st.w	r12[0x14],r9
	pdca_channel->isr;
800042fa:	78 b9       	ld.w	r9,r12[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800042fc:	e6 18 00 01 	andh	r8,0x1,COH
80004300:	c0 21       	brne	80004304 <pdca_reload_channel+0x2c>
      cpu_irq_enable();
80004302:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
80004304:	2f fd       	sub	sp,-4
80004306:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000430a:	00 00       	add	r0,r0
8000430c:	80 00       	ld.sh	r0,r0[0x0]
8000430e:	42 24       	lddsp	r4,sp[0x88]

80004310 <pdca_init_channel>:
	return pdca_channel;
}

uint32_t pdca_init_channel(uint8_t pdca_ch_number,
		const pdca_channel_options_t *opt)
{
80004310:	eb cd 40 e0 	pushm	r5-r7,lr
80004314:	20 1d       	sub	sp,4
80004316:	18 95       	mov	r5,r12
80004318:	16 96       	mov	r6,r11
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
8000431a:	f0 1f 00 13 	mcall	80004364 <pdca_init_channel+0x54>
8000431e:	18 97       	mov	r7,r12
			pdca_ch_number);

	pdca_disable_interrupt_transfer_complete(pdca_ch_number); 
80004320:	0a 9c       	mov	r12,r5
80004322:	f0 1f 00 12 	mcall	80004368 <pdca_init_channel+0x58>
	pdca_disable_interrupt_reload_counter_zero(pdca_ch_number);
80004326:	0a 9c       	mov	r12,r5
80004328:	f0 1f 00 11 	mcall	8000436c <pdca_init_channel+0x5c>

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000432c:	e1 b8 00 00 	mfsr	r8,0x0
80004330:	50 08       	stdsp	sp[0x0],r8
	cpu_irq_disable();
80004332:	d3 03       	ssrf	0x10

	return flags;
80004334:	40 08       	lddsp	r8,sp[0x0]
	
	irqflags_t flags = cpu_irq_save();

	pdca_channel->mar = (uint32_t)opt->addr;
80004336:	6c 09       	ld.w	r9,r6[0x0]
80004338:	8f 09       	st.w	r7[0x0],r9
	pdca_channel->tcr = opt->size;
8000433a:	6c 19       	ld.w	r9,r6[0x4]
8000433c:	8f 29       	st.w	r7[0x8],r9
	pdca_channel->psr = opt->pid;
8000433e:	6c 49       	ld.w	r9,r6[0x10]
80004340:	8f 19       	st.w	r7[0x4],r9
	pdca_channel->marr = (uint32_t)opt->r_addr;
80004342:	6c 29       	ld.w	r9,r6[0x8]
80004344:	8f 39       	st.w	r7[0xc],r9
	pdca_channel->tcrr = opt->r_size;
80004346:	6c 39       	ld.w	r9,r6[0xc]
80004348:	8f 49       	st.w	r7[0x10],r9
	pdca_channel->mr =
8000434a:	6c 59       	ld.w	r9,r6[0x14]
8000434c:	8f 69       	st.w	r7[0x18],r9
#if (AVR32_PDCA_H_VERSION >= 120)
			opt->etrig << AVR32_PDCA_ETRIG_OFFSET |
#endif
			opt->transfer_size << AVR32_PDCA_SIZE_OFFSET;
	pdca_channel->cr = AVR32_PDCA_ECLR_MASK;
8000434e:	e0 69 01 00 	mov	r9,256
80004352:	8f 59       	st.w	r7[0x14],r9
	pdca_channel->isr;
80004354:	6e b9       	ld.w	r9,r7[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80004356:	e6 18 00 01 	andh	r8,0x1,COH
8000435a:	c0 21       	brne	8000435e <pdca_init_channel+0x4e>
      cpu_irq_enable();
8000435c:	d5 03       	csrf	0x10
	
	cpu_irq_restore(flags);

	return PDCA_SUCCESS;
}
8000435e:	2f fd       	sub	sp,-4
80004360:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80004364:	80 00       	ld.sh	r0,r0[0x0]
80004366:	42 24       	lddsp	r4,sp[0x88]
80004368:	80 00       	ld.sh	r0,r0[0x0]
8000436a:	42 b0       	lddsp	r0,sp[0xac]
8000436c:	80 00       	ld.sh	r0,r0[0x0]
8000436e:	42 88       	lddsp	r8,sp[0xa0]

80004370 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80004370:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
80004372:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80004376:	99 a8       	st.w	r12[0x28],r8
}
80004378:	5e fc       	retal	r12
8000437a:	d7 03       	nop

8000437c <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
8000437c:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
8000437e:	ec 5b bb 9f 	cp.w	r11,899999
80004382:	e0 8b 00 04 	brhi	8000438a <pm_enable_osc0_crystal+0xe>
80004386:	30 4b       	mov	r11,4
80004388:	c1 38       	rjmp	800043ae <pm_enable_osc0_crystal+0x32>
8000438a:	e0 68 c6 bf 	mov	r8,50879
8000438e:	ea 18 00 2d 	orh	r8,0x2d
80004392:	10 3b       	cp.w	r11,r8
80004394:	e0 8b 00 04 	brhi	8000439c <pm_enable_osc0_crystal+0x20>
80004398:	30 5b       	mov	r11,5
8000439a:	c0 a8       	rjmp	800043ae <pm_enable_osc0_crystal+0x32>
8000439c:	e0 68 12 00 	mov	r8,4608
800043a0:	ea 18 00 7a 	orh	r8,0x7a
800043a4:	10 3b       	cp.w	r11,r8
800043a6:	f9 bb 03 06 	movlo	r11,6
800043aa:	f9 bb 02 07 	movhs	r11,7
800043ae:	f0 1f 00 02 	mcall	800043b4 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
800043b2:	d8 02       	popm	pc
800043b4:	80 00       	ld.sh	r0,r0[0x0]
800043b6:	43 70       	lddsp	r0,sp[0xdc]

800043b8 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800043b8:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
800043ba:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800043be:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
800043c0:	78 08       	ld.w	r8,r12[0x0]
800043c2:	a3 a8       	sbr	r8,0x2
800043c4:	99 08       	st.w	r12[0x0],r8
}
800043c6:	5e fc       	retal	r12

800043c8 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800043c8:	79 58       	ld.w	r8,r12[0x54]
800043ca:	e2 18 00 80 	andl	r8,0x80,COH
800043ce:	cf d0       	breq	800043c8 <pm_wait_for_clk0_ready>
}
800043d0:	5e fc       	retal	r12
800043d2:	d7 03       	nop

800043d4 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
800043d4:	eb cd 40 80 	pushm	r7,lr
800043d8:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
800043da:	f0 1f 00 04 	mcall	800043e8 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
800043de:	0e 9c       	mov	r12,r7
800043e0:	f0 1f 00 03 	mcall	800043ec <pm_enable_clk0+0x18>
}
800043e4:	e3 cd 80 80 	ldm	sp++,r7,pc
800043e8:	80 00       	ld.sh	r0,r0[0x0]
800043ea:	43 b8       	lddsp	r8,sp[0xec]
800043ec:	80 00       	ld.sh	r0,r0[0x0]
800043ee:	43 c8       	lddsp	r8,sp[0xf0]

800043f0 <pm_set_osc1_mode>:
 * \param mode Oscillator 1 mode (i.e. AVR32_PM_OSCCTRL1_MODE_x).
 */
static void pm_set_osc1_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl1_t u_avr32_pm_oscctrl1 = {pm->oscctrl1};
800043f0:	78 b8       	ld.w	r8,r12[0x2c]
  // Modify
  u_avr32_pm_oscctrl1.OSCCTRL1.mode = mode;
800043f2:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl1 = u_avr32_pm_oscctrl1.oscctrl1;
800043f6:	99 b8       	st.w	r12[0x2c],r8
}
800043f8:	5e fc       	retal	r12
800043fa:	d7 03       	nop

800043fc <pm_enable_osc1_crystal>:
  pm_set_osc1_mode(pm, AVR32_PM_OSCCTRL1_MODE_EXT_CLOCK);
}


void pm_enable_osc1_crystal(volatile avr32_pm_t *pm, unsigned int fosc1)
{
800043fc:	d4 01       	pushm	lr
  pm_set_osc1_mode(pm, (fosc1 <  900000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G0 :
800043fe:	ec 5b bb 9f 	cp.w	r11,899999
80004402:	e0 8b 00 04 	brhi	8000440a <pm_enable_osc1_crystal+0xe>
80004406:	30 4b       	mov	r11,4
80004408:	c1 38       	rjmp	8000442e <pm_enable_osc1_crystal+0x32>
8000440a:	e0 68 c6 bf 	mov	r8,50879
8000440e:	ea 18 00 2d 	orh	r8,0x2d
80004412:	10 3b       	cp.w	r11,r8
80004414:	e0 8b 00 04 	brhi	8000441c <pm_enable_osc1_crystal+0x20>
80004418:	30 5b       	mov	r11,5
8000441a:	c0 a8       	rjmp	8000442e <pm_enable_osc1_crystal+0x32>
8000441c:	e0 68 12 00 	mov	r8,4608
80004420:	ea 18 00 7a 	orh	r8,0x7a
80004424:	10 3b       	cp.w	r11,r8
80004426:	f9 bb 03 06 	movlo	r11,6
8000442a:	f9 bb 02 07 	movhs	r11,7
8000442e:	f0 1f 00 02 	mcall	80004434 <pm_enable_osc1_crystal+0x38>
                       (fosc1 < 3000000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G1 :
                       (fosc1 < 8000000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G3);
}
80004432:	d8 02       	popm	pc
80004434:	80 00       	ld.sh	r0,r0[0x0]
80004436:	43 f0       	lddsp	r0,sp[0xfc]

80004438 <pm_enable_clk1_no_wait>:


void pm_enable_clk1_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl1_t u_avr32_pm_oscctrl1 = {pm->oscctrl1};
80004438:	78 b8       	ld.w	r8,r12[0x2c]
  // Modify
  u_avr32_pm_oscctrl1.OSCCTRL1.startup = startup;
8000443a:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl1 = u_avr32_pm_oscctrl1.oscctrl1;
8000443e:	99 b8       	st.w	r12[0x2c],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC1EN_MASK;
80004440:	78 08       	ld.w	r8,r12[0x0]
80004442:	a3 b8       	sbr	r8,0x3
80004444:	99 08       	st.w	r12[0x0],r8
}
80004446:	5e fc       	retal	r12

80004448 <pm_wait_for_clk1_ready>:


void pm_wait_for_clk1_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC1RDY_MASK));
80004448:	79 58       	ld.w	r8,r12[0x54]
8000444a:	e2 18 01 00 	andl	r8,0x100,COH
8000444e:	cf d0       	breq	80004448 <pm_wait_for_clk1_ready>
}
80004450:	5e fc       	retal	r12
80004452:	d7 03       	nop

80004454 <pm_enable_clk1>:
                                           AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G3);
}


void pm_enable_clk1(volatile avr32_pm_t *pm, unsigned int startup)
{
80004454:	eb cd 40 80 	pushm	r7,lr
80004458:	18 97       	mov	r7,r12
  pm_enable_clk1_no_wait(pm, startup);
8000445a:	f0 1f 00 04 	mcall	80004468 <pm_enable_clk1+0x14>
  pm_wait_for_clk1_ready(pm);
8000445e:	0e 9c       	mov	r12,r7
80004460:	f0 1f 00 03 	mcall	8000446c <pm_enable_clk1+0x18>
}
80004464:	e3 cd 80 80 	ldm	sp++,r7,pc
80004468:	80 00       	ld.sh	r0,r0[0x0]
8000446a:	44 38       	lddsp	r8,sp[0x10c]
8000446c:	80 00       	ld.sh	r0,r0[0x0]
8000446e:	44 48       	lddsp	r8,sp[0x110]

80004470 <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
80004470:	eb cd 40 d0 	pushm	r4,r6-r7,lr
80004474:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
80004478:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
8000447a:	09 f7       	ld.ub	r7,r4[0x7]
8000447c:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
80004480:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
80004484:	09 b4       	ld.ub	r4,r4[0x3]
80004486:	08 96       	mov	r6,r4
80004488:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
8000448c:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
80004490:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
80004494:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
80004498:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
8000449c:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
800044a0:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
800044a4:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
800044a8:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
800044aa:	79 58       	ld.w	r8,r12[0x54]
800044ac:	e2 18 00 20 	andl	r8,0x20,COH
800044b0:	cf d0       	breq	800044aa <pm_cksel+0x3a>
}
800044b2:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

800044b6 <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
800044b6:	eb cd 40 80 	pushm	r7,lr
800044ba:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
800044bc:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
800044be:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
800044c2:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
800044c6:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
800044ca:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
800044ce:	2f 8b       	sub	r11,-8
800044d0:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
800044d4:	e3 cd 80 80 	ldm	sp++,r7,pc

800044d8 <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
800044d8:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
800044da:	2f 8b       	sub	r11,-8
800044dc:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
800044e0:	f5 e9 10 19 	or	r9,r10,r9<<0x1
800044e4:	f3 e8 10 28 	or	r8,r9,r8<<0x2
800044e8:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
800044ec:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
800044f0:	d8 02       	popm	pc

800044f2 <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
800044f2:	2f 8b       	sub	r11,-8
800044f4:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
800044f8:	a1 a8       	sbr	r8,0x0
800044fa:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
800044fe:	5e fc       	retal	r12

80004500 <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80004500:	79 58       	ld.w	r8,r12[0x54]
80004502:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004506:	cf d0       	breq	80004500 <pm_wait_for_pll0_locked>
}
80004508:	5e fc       	retal	r12

8000450a <pm_wait_for_pll1_locked>:


void pm_wait_for_pll1_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK1_MASK));
8000450a:	79 58       	ld.w	r8,r12[0x54]
8000450c:	e2 18 00 02 	andl	r8,0x2,COH
80004510:	cf d0       	breq	8000450a <pm_wait_for_pll1_locked>
}
80004512:	5e fc       	retal	r12

80004514 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80004514:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80004516:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
8000451a:	99 08       	st.w	r12[0x0],r8
}
8000451c:	5e fc       	retal	r12
8000451e:	d7 03       	nop

80004520 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80004520:	eb cd 40 c0 	pushm	r6-r7,lr
80004524:	18 97       	mov	r7,r12
80004526:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80004528:	f0 1f 00 06 	mcall	80004540 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
8000452c:	0c 9b       	mov	r11,r6
8000452e:	0e 9c       	mov	r12,r7
80004530:	f0 1f 00 05 	mcall	80004544 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80004534:	30 1b       	mov	r11,1
80004536:	0e 9c       	mov	r12,r7
80004538:	f0 1f 00 04 	mcall	80004548 <pm_switch_to_osc0+0x28>
}
8000453c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004540:	80 00       	ld.sh	r0,r0[0x0]
80004542:	43 7c       	lddsp	r12,sp[0xdc]
80004544:	80 00       	ld.sh	r0,r0[0x0]
80004546:	43 d4       	lddsp	r4,sp[0xf4]
80004548:	80 00       	ld.sh	r0,r0[0x0]
8000454a:	45 14       	lddsp	r4,sp[0x144]

8000454c <pwm_channel_init>:

int pwm_channel_init( unsigned int channel_id, const avr32_pwm_channel_t *pwm_channel)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;

  if (pwm_channel == 0) // Null pointer.
8000454c:	58 0b       	cp.w	r11,0
8000454e:	c1 90       	breq	80004580 <pwm_channel_init+0x34>
    return PWM_INVALID_ARGUMENT;
  if (channel_id > AVR32_PWM_LINES_MSB) // Control input values.
80004550:	58 6c       	cp.w	r12,6
80004552:	e0 8b 00 17 	brhi	80004580 <pwm_channel_init+0x34>
    return PWM_INVALID_INPUT;

  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode.
80004556:	76 0a       	ld.w	r10,r11[0x0]
80004558:	fe 78 30 00 	mov	r8,-53248
8000455c:	f8 c9 ff f0 	sub	r9,r12,-16
80004560:	a5 79       	lsl	r9,0x5
80004562:	f0 09 00 09 	add	r9,r8,r9
80004566:	93 0a       	st.w	r9[0x0],r10
  pwm->channel[channel_id].cdty= pwm_channel->cdty; // Duty cycle, should be < CPRD.
80004568:	76 19       	ld.w	r9,r11[0x4]
8000456a:	a5 7c       	lsl	r12,0x5
8000456c:	f0 0c 00 0c 	add	r12,r8,r12
80004570:	f8 c8 fd fc 	sub	r8,r12,-516
80004574:	91 09       	st.w	r8[0x0],r9
  pwm->channel[channel_id].cprd= pwm_channel->cprd; // Channel period.
80004576:	76 28       	ld.w	r8,r11[0x8]
80004578:	f8 cc fd f8 	sub	r12,r12,-520
8000457c:	99 08       	st.w	r12[0x0],r8
8000457e:	5e fd       	retal	0

  return PWM_SUCCESS;
80004580:	5e ff       	retal	1

80004582 <pwm_start_channels>:
}


int pwm_start_channels(unsigned long channels_bitmask)
{
  if (channels_bitmask & ~((1 << (AVR32_PWM_LINES_MSB + 1)) - 1))
80004582:	18 98       	mov	r8,r12
80004584:	e0 18 ff 80 	andl	r8,0xff80
80004588:	c0 20       	breq	8000458c <pwm_start_channels+0xa>
8000458a:	5e ff       	retal	1
    return PWM_INVALID_INPUT;

  AVR32_PWM.ena = channels_bitmask; // Enable channels.
8000458c:	fe 78 30 00 	mov	r8,-53248
80004590:	91 1c       	st.w	r8[0x4],r12
80004592:	5e fd       	retal	0

80004594 <pwm_async_update_channel>:

int pwm_async_update_channel(unsigned int channel_id, const avr32_pwm_channel_t *pwm_channel)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;

  if (channel_id > AVR32_PWM_LINES_MSB)
80004594:	58 6c       	cp.w	r12,6
80004596:	e0 88 00 03 	brls	8000459c <pwm_async_update_channel+0x8>
8000459a:	5e ff       	retal	1
     return PWM_INVALID_INPUT;

  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode register: update of the period or duty cycle.
8000459c:	76 0a       	ld.w	r10,r11[0x0]
8000459e:	fe 78 30 00 	mov	r8,-53248
800045a2:	f8 c9 ff f0 	sub	r9,r12,-16
800045a6:	a5 79       	lsl	r9,0x5
800045a8:	f0 09 00 09 	add	r9,r8,r9
800045ac:	93 0a       	st.w	r9[0x0],r10
  pwm->channel[channel_id].cupd= pwm_channel->cupd; // Channel update CPRDx or CDTYx according to CPD value in CMRx.
800045ae:	76 49       	ld.w	r9,r11[0x10]
800045b0:	a5 7c       	lsl	r12,0x5
800045b2:	18 08       	add	r8,r12
800045b4:	f0 c8 fd f0 	sub	r8,r8,-528
800045b8:	91 09       	st.w	r8[0x0],r9
800045ba:	5e fd       	retal	0

800045bc <pwm_init>:


int pwm_init(const pwm_opt_t *opt)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
800045bc:	e1 b8 00 00 	mfsr	r8,0x0

  if (opt == 0 ) // Null pointer.
800045c0:	58 0c       	cp.w	r12,0
800045c2:	c0 21       	brne	800045c6 <pwm_init+0xa>
800045c4:	5e ff       	retal	1
    return PWM_INVALID_INPUT;

  // Disable interrupt.
  if (global_interrupt_enabled) Disable_global_interrupt();
800045c6:	e6 18 00 01 	andh	r8,0x1,COH
800045ca:	c0 91       	brne	800045dc <pwm_init+0x20>
800045cc:	d3 03       	ssrf	0x10
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
800045ce:	fe 78 30 00 	mov	r8,-53248
800045d2:	37 f9       	mov	r9,127
800045d4:	91 59       	st.w	r8[0x14],r9
  pwm->isr;
800045d6:	70 78       	ld.w	r8,r8[0x1c]
  if (global_interrupt_enabled) Enable_global_interrupt();
800045d8:	d5 03       	csrf	0x10
800045da:	c0 68       	rjmp	800045e6 <pwm_init+0x2a>
  if (opt == 0 ) // Null pointer.
    return PWM_INVALID_INPUT;

  // Disable interrupt.
  if (global_interrupt_enabled) Disable_global_interrupt();
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
800045dc:	fe 78 30 00 	mov	r8,-53248
800045e0:	37 f9       	mov	r9,127
800045e2:	91 59       	st.w	r8[0x14],r9
  pwm->isr;
800045e4:	70 78       	ld.w	r8,r8[0x1c]
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
    ((opt->diva)<<AVR32_PWM_DIVA_OFFSET) |
800045e6:	78 08       	ld.w	r8,r12[0x0]
800045e8:	78 39       	ld.w	r9,r12[0xc]
800045ea:	a9 69       	lsl	r9,0x8
800045ec:	f3 e8 11 09 	or	r9,r9,r8<<0x10
800045f0:	78 18       	ld.w	r8,r12[0x4]
800045f2:	10 49       	or	r9,r8
800045f4:	78 28       	ld.w	r8,r12[0x8]
800045f6:	f3 e8 11 89 	or	r9,r9,r8<<0x18
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
  pwm->isr;
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
800045fa:	fe 78 30 00 	mov	r8,-53248
800045fe:	91 09       	st.w	r8[0x0],r9
80004600:	5e fd       	retal	0
80004602:	d7 03       	nop

80004604 <twi_master_interrupt_handler>:
__interrupt
#endif
static void twi_master_interrupt_handler(void)
{
  // get masked status register value
  int status = twi_inst->sr & twi_it_mask;
80004604:	4a 78       	lddpc	r8,800046a0 <twi_master_interrupt_handler+0x9c>
80004606:	70 08       	ld.w	r8,r8[0x0]
80004608:	70 89       	ld.w	r9,r8[0x20]
8000460a:	4a 7a       	lddpc	r10,800046a4 <twi_master_interrupt_handler+0xa0>
8000460c:	74 0a       	ld.w	r10,r10[0x0]
8000460e:	f5 e9 00 09 	and	r9,r10,r9

  // this is a NACK
  if (status & AVR32_TWI_SR_NACK_MASK)
80004612:	12 9a       	mov	r10,r9
80004614:	e2 1a 01 00 	andl	r10,0x100,COH
80004618:	c3 91       	brne	8000468a <twi_master_interrupt_handler+0x86>
  {
    goto nack;
  }
  // this is a RXRDY
  else if (status & AVR32_TWI_SR_RXRDY_MASK)
8000461a:	12 9a       	mov	r10,r9
8000461c:	e2 1a 00 02 	andl	r10,0x2,COH
80004620:	c1 70       	breq	8000464e <twi_master_interrupt_handler+0x4a>
  {
    // get data from Receive Holding Register
    *twi_rx_data = twi_inst->rhr;
80004622:	4a 29       	lddpc	r9,800046a8 <twi_master_interrupt_handler+0xa4>
80004624:	72 0a       	ld.w	r10,r9[0x0]
80004626:	70 cb       	ld.w	r11,r8[0x30]
80004628:	b4 8b       	st.b	r10[0x0],r11
    twi_rx_data++;
8000462a:	72 0a       	ld.w	r10,r9[0x0]
8000462c:	2f fa       	sub	r10,-1
8000462e:	93 0a       	st.w	r9[0x0],r10
    // last byte to receive
    if(--twi_rx_nb_bytes==1)
80004630:	49 f9       	lddpc	r9,800046ac <twi_master_interrupt_handler+0xa8>
80004632:	72 0a       	ld.w	r10,r9[0x0]
80004634:	20 1a       	sub	r10,1
80004636:	93 0a       	st.w	r9[0x0],r10
80004638:	72 09       	ld.w	r9,r9[0x0]
    {
      // set stop bit
      twi_inst->cr = AVR32_TWI_STOP_MASK;
8000463a:	58 19       	cp.w	r9,1
8000463c:	f9 b9 00 02 	moveq	r9,2
80004640:	f1 f9 0a 00 	st.weq	r8[0x0],r9
    }
    // receive complete
    if (twi_rx_nb_bytes==0)
80004644:	49 a9       	lddpc	r9,800046ac <twi_master_interrupt_handler+0xa8>
80004646:	72 09       	ld.w	r9,r9[0x0]
80004648:	58 09       	cp.w	r9,0
8000464a:	c2 30       	breq	80004690 <twi_master_interrupt_handler+0x8c>
8000464c:	d6 03       	rete
      // finish the receive operation
      goto complete;
    }
  }
  // this is a TXRDY
  else if (status & AVR32_TWI_SR_TXRDY_MASK)
8000464e:	12 9a       	mov	r10,r9
80004650:	e2 1a 00 04 	andl	r10,0x4,COH
80004654:	c1 70       	breq	80004682 <twi_master_interrupt_handler+0x7e>
  {
    // decrease transmited bytes number
    twi_tx_nb_bytes--;
80004656:	49 79       	lddpc	r9,800046b0 <twi_master_interrupt_handler+0xac>
80004658:	72 0a       	ld.w	r10,r9[0x0]
8000465a:	20 1a       	sub	r10,1
8000465c:	93 0a       	st.w	r9[0x0],r10
    // no more bytes to transmit
    if (twi_tx_nb_bytes <= 0)
8000465e:	72 09       	ld.w	r9,r9[0x0]
80004660:	58 09       	cp.w	r9,0
80004662:	e0 89 00 0a 	brgt	80004676 <twi_master_interrupt_handler+0x72>
    {
      // enable TXCOMP IT and unmask all others IT
      twi_it_mask = AVR32_TWI_IER_TXCOMP_MASK;
80004666:	49 09       	lddpc	r9,800046a4 <twi_master_interrupt_handler+0xa0>
80004668:	30 1a       	mov	r10,1
8000466a:	93 0a       	st.w	r9[0x0],r10
      twi_inst->idr = ~0UL;
8000466c:	3f fa       	mov	r10,-1
8000466e:	91 aa       	st.w	r8[0x28],r10
      twi_inst->ier = twi_it_mask;
80004670:	72 09       	ld.w	r9,r9[0x0]
80004672:	91 99       	st.w	r8[0x24],r9
80004674:	d6 03       	rete
    }
    else
    {
      // put the byte in the Transmit Holding Register
      twi_inst->thr = *twi_tx_data++;
80004676:	49 0a       	lddpc	r10,800046b4 <twi_master_interrupt_handler+0xb0>
80004678:	74 09       	ld.w	r9,r10[0x0]
8000467a:	13 3b       	ld.ub	r11,r9++
8000467c:	91 db       	st.w	r8[0x34],r11
8000467e:	95 09       	st.w	r10[0x0],r9
80004680:	d6 03       	rete
    }
  }
  // this is a TXCOMP
  else if (status & AVR32_TWI_SR_TXCOMP_MASK)
80004682:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80004686:	c0 51       	brne	80004690 <twi_master_interrupt_handler+0x8c>
80004688:	d6 03       	rete
  }

  return;

nack:
  twi_nack = true;
8000468a:	30 1a       	mov	r10,1
8000468c:	48 b9       	lddpc	r9,800046b8 <twi_master_interrupt_handler+0xb4>
8000468e:	b2 8a       	st.b	r9[0x0],r10

complete:
  // disable all interrupts
  twi_inst->idr = ~0UL;
80004690:	3f f9       	mov	r9,-1
80004692:	91 a9       	st.w	r8[0x28],r9
  twi_inst->sr;
80004694:	70 88       	ld.w	r8,r8[0x20]
  twi_busy = false;
80004696:	30 09       	mov	r9,0
80004698:	48 98       	lddpc	r8,800046bc <twi_master_interrupt_handler+0xb8>
8000469a:	b0 89       	st.b	r8[0x0],r9
8000469c:	d6 03       	rete
8000469e:	00 00       	add	r0,r0
800046a0:	00 00       	add	r0,r0
800046a2:	06 6c       	and	r12,r3
800046a4:	00 00       	add	r0,r0
800046a6:	06 68       	and	r8,r3
800046a8:	00 00       	add	r0,r0
800046aa:	06 78       	tst	r8,r3
800046ac:	00 00       	add	r0,r0
800046ae:	06 74       	tst	r4,r3
800046b0:	00 00       	add	r0,r0
800046b2:	06 64       	and	r4,r3
800046b4:	00 00       	add	r0,r0
800046b6:	06 70       	tst	r0,r3
800046b8:	00 00       	add	r0,r0
800046ba:	06 61       	and	r1,r3
800046bc:	00 00       	add	r0,r0
800046be:	06 60       	and	r0,r3

800046c0 <twi_is_busy>:
}


bool twi_is_busy(void)
{
  if( twi_busy ) {
800046c0:	48 28       	lddpc	r8,800046c8 <twi_is_busy+0x8>
800046c2:	11 8c       	ld.ub	r12,r8[0x0]
    return true;          // Still receiving/transmitting...
  }
  else {
    return false;
  }
}
800046c4:	5e fc       	retal	r12
800046c6:	00 00       	add	r0,r0
800046c8:	00 00       	add	r0,r0
800046ca:	06 60       	and	r0,r3

800046cc <twi_master_write>:
  return TWI_SUCCESS;
}


int twi_master_write(volatile avr32_twi_t *twi, const twi_package_t *package)
{
800046cc:	eb cd 40 c0 	pushm	r6-r7,lr
800046d0:	18 96       	mov	r6,r12
800046d2:	16 97       	mov	r7,r11
  // No data to send
  if (package->length == 0)
800046d4:	76 48       	ld.w	r8,r11[0x10]
800046d6:	58 08       	cp.w	r8,0
800046d8:	c0 51       	brne	800046e2 <twi_master_write+0x16>
800046da:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
  {
    return TWI_INVALID_ARGUMENT;
  }

  while( twi_is_busy() ) {
    cpu_relax();
800046de:	fe cf ff fc 	sub	pc,pc,-4
  if (package->length == 0)
  {
    return TWI_INVALID_ARGUMENT;
  }

  while( twi_is_busy() ) {
800046e2:	f0 1f 00 1d 	mcall	80004754 <twi_master_write+0x88>
800046e6:	cf c1       	brne	800046de <twi_master_write+0x12>
    cpu_relax();
  };

  twi_nack = false;
800046e8:	30 09       	mov	r9,0
800046ea:	49 c8       	lddpc	r8,80004758 <twi_master_write+0x8c>
800046ec:	b0 89       	st.b	r8[0x0],r9
  twi_busy = true;
800046ee:	30 19       	mov	r9,1
800046f0:	49 b8       	lddpc	r8,8000475c <twi_master_write+0x90>
800046f2:	b0 89       	st.b	r8[0x0],r9

  // Enable master transfer, disable slave
  twi->cr =   AVR32_TWI_CR_MSEN_MASK
800046f4:	32 48       	mov	r8,36
800046f6:	8d 08       	st.w	r6[0x0],r8
            | AVR32_TWI_CR_SVDIS_MASK
#endif
            ;

  // set write mode, slave address and 3 internal address byte length
  twi->mmr = (0 << AVR32_TWI_MMR_MREAD_OFFSET) |
800046f8:	6e 28       	ld.w	r8,r7[0x8]
800046fa:	a9 68       	lsl	r8,0x8
800046fc:	e2 18 03 00 	andl	r8,0x300,COH
80004700:	0f 89       	ld.ub	r9,r7[0x0]
80004702:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80004706:	8d 18       	st.w	r6[0x4],r8
             (package->chip << AVR32_TWI_MMR_DADR_OFFSET) |
             ((package->addr_length << AVR32_TWI_MMR_IADRSZ_OFFSET) & AVR32_TWI_MMR_IADRSZ_MASK);

  // Set pointer to TWIM instance for IT
  twi_inst = twi;
80004708:	49 68       	lddpc	r8,80004760 <twi_master_write+0x94>
8000470a:	91 06       	st.w	r8[0x0],r6

  // set internal address for remote chip
  twi->iadr = package->addr;
8000470c:	6e 18       	ld.w	r8,r7[0x4]
8000470e:	8d 38       	st.w	r6[0xc],r8

  // get a pointer to applicative data
  twi_tx_data = package->buffer;
80004710:	6e 39       	ld.w	r9,r7[0xc]
80004712:	49 58       	lddpc	r8,80004764 <twi_master_write+0x98>
80004714:	91 09       	st.w	r8[0x0],r9

  // get a copy of nb bytes to write
  twi_tx_nb_bytes = package->length;
80004716:	6e 4a       	ld.w	r10,r7[0x10]
80004718:	49 49       	lddpc	r9,80004768 <twi_master_write+0x9c>
8000471a:	93 0a       	st.w	r9[0x0],r10

  // put the first byte in the Transmit Holding Register
  twi->thr = *twi_tx_data++;
8000471c:	70 09       	ld.w	r9,r8[0x0]
8000471e:	13 3a       	ld.ub	r10,r9++
80004720:	8d da       	st.w	r6[0x34],r10
80004722:	91 09       	st.w	r8[0x0],r9

  // mask NACK and TXRDY interrupts
  twi_it_mask = AVR32_TWI_IER_NACK_MASK | AVR32_TWI_IER_TXRDY_MASK;
80004724:	49 28       	lddpc	r8,8000476c <twi_master_write+0xa0>
80004726:	e0 69 01 04 	mov	r9,260
8000472a:	91 09       	st.w	r8[0x0],r9

  // update IMR through IER
  twi->ier = twi_it_mask;
8000472c:	70 08       	ld.w	r8,r8[0x0]
8000472e:	8d 98       	st.w	r6[0x24],r8

  // send data
  while( twi_is_busy() ) {
80004730:	c0 38       	rjmp	80004736 <twi_master_write+0x6a>
    cpu_relax();
80004732:	fe cf ff fc 	sub	pc,pc,-4

  // update IMR through IER
  twi->ier = twi_it_mask;

  // send data
  while( twi_is_busy() ) {
80004736:	f0 1f 00 08 	mcall	80004754 <twi_master_write+0x88>
8000473a:	cf c1       	brne	80004732 <twi_master_write+0x66>
    cpu_relax();
  }

  // Disable master transfer
  twi->cr =  AVR32_TWI_CR_MSDIS_MASK;
8000473c:	30 88       	mov	r8,8
8000473e:	8d 08       	st.w	r6[0x0],r8

  if( twi_nack )
80004740:	48 68       	lddpc	r8,80004758 <twi_master_write+0x8c>
80004742:	11 8c       	ld.ub	r12,r8[0x0]
80004744:	58 0c       	cp.w	r12,0
80004746:	f9 bc 01 fb 	movne	r12,-5
8000474a:	f9 bc 00 00 	moveq	r12,0
    return TWI_RECEIVE_NACK;

  return TWI_SUCCESS;
}
8000474e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004752:	00 00       	add	r0,r0
80004754:	80 00       	ld.sh	r0,r0[0x0]
80004756:	46 c0       	lddsp	r0,sp[0x1b0]
80004758:	00 00       	add	r0,r0
8000475a:	06 61       	and	r1,r3
8000475c:	00 00       	add	r0,r0
8000475e:	06 60       	and	r0,r3
80004760:	00 00       	add	r0,r0
80004762:	06 6c       	and	r12,r3
80004764:	00 00       	add	r0,r0
80004766:	06 70       	tst	r0,r3
80004768:	00 00       	add	r0,r0
8000476a:	06 64       	and	r4,r3
8000476c:	00 00       	add	r0,r0
8000476e:	06 68       	and	r8,r3

80004770 <twi_probe>:
  if (global_interrupt_enabled) Enable_global_interrupt();
}


int twi_probe(volatile avr32_twi_t *twi, char chip_addr)
{
80004770:	d4 01       	pushm	lr
80004772:	20 6d       	sub	sp,24
  twi_package_t package;
  char data[1] = {0};
80004774:	30 08       	mov	r8,0
80004776:	ba 88       	st.b	sp[0x0],r8

  // data to send
  package.buffer = data;
80004778:	50 4d       	stdsp	sp[0x10],sp
  // chip address
  package.chip = chip_addr;
8000477a:	ba cb       	st.b	sp[0x4],r11
  // frame length
  package.length = 1;
8000477c:	30 18       	mov	r8,1
8000477e:	50 58       	stdsp	sp[0x14],r8
  // address length
  package.addr_length = 0;
80004780:	30 08       	mov	r8,0
80004782:	50 38       	stdsp	sp[0xc],r8
  // internal chip address
  package.addr = 0;
80004784:	50 28       	stdsp	sp[0x8],r8
  // perform a master write access
  return (twi_master_write(twi, &package));
80004786:	fa cb ff fc 	sub	r11,sp,-4
8000478a:	f0 1f 00 03 	mcall	80004794 <twi_probe+0x24>
}
8000478e:	2f ad       	sub	sp,-24
80004790:	d8 02       	popm	pc
80004792:	00 00       	add	r0,r0
80004794:	80 00       	ld.sh	r0,r0[0x0]
80004796:	46 cc       	lddsp	r12,sp[0x1b0]

80004798 <twi_master_read>:


int twi_master_read(volatile avr32_twi_t *twi, const twi_package_t *package)
{
80004798:	eb cd 40 c0 	pushm	r6-r7,lr
8000479c:	18 96       	mov	r6,r12
8000479e:	16 97       	mov	r7,r11
  // check argument
  if (package->length == 0)
800047a0:	76 48       	ld.w	r8,r11[0x10]
800047a2:	58 08       	cp.w	r8,0
800047a4:	c0 51       	brne	800047ae <twi_master_read+0x16>
800047a6:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
  {
    return TWI_INVALID_ARGUMENT;
  }

  while( twi_is_busy() ) {
    cpu_relax();
800047aa:	fe cf ff fc 	sub	pc,pc,-4
  if (package->length == 0)
  {
    return TWI_INVALID_ARGUMENT;
  }

  while( twi_is_busy() ) {
800047ae:	f0 1f 00 1f 	mcall	80004828 <twi_master_read+0x90>
800047b2:	cf c1       	brne	800047aa <twi_master_read+0x12>
    cpu_relax();
  };

  twi_nack = false;
800047b4:	30 09       	mov	r9,0
800047b6:	49 e8       	lddpc	r8,8000482c <twi_master_read+0x94>
800047b8:	b0 89       	st.b	r8[0x0],r9
  twi_busy = true;
800047ba:	30 19       	mov	r9,1
800047bc:	49 d8       	lddpc	r8,80004830 <twi_master_read+0x98>
800047be:	b0 89       	st.b	r8[0x0],r9

  // set read mode, slave address and 3 internal address byte length
  twi->mmr = (package->chip << AVR32_TWI_MMR_DADR_OFFSET) |
800047c0:	0f 89       	ld.ub	r9,r7[0x0]
800047c2:	6e 28       	ld.w	r8,r7[0x8]
800047c4:	a9 68       	lsl	r8,0x8
800047c6:	e2 18 03 00 	andl	r8,0x300,COH
800047ca:	f1 e9 11 08 	or	r8,r8,r9<<0x10
800047ce:	ad a8       	sbr	r8,0xc
800047d0:	8d 18       	st.w	r6[0x4],r8
             ((package->addr_length << AVR32_TWI_MMR_IADRSZ_OFFSET) & AVR32_TWI_MMR_IADRSZ_MASK) |
             (1 << AVR32_TWI_MMR_MREAD_OFFSET);

  // Set pointer to TWIM instance for IT
  twi_inst = twi;
800047d2:	49 98       	lddpc	r8,80004834 <twi_master_read+0x9c>
800047d4:	91 06       	st.w	r8[0x0],r6

  // set internal address for remote chip
  twi->iadr = package->addr;
800047d6:	6e 18       	ld.w	r8,r7[0x4]
800047d8:	8d 38       	st.w	r6[0xc],r8

  // get a pointer to applicative data
  twi_rx_data = package->buffer;
800047da:	6e 39       	ld.w	r9,r7[0xc]
800047dc:	49 78       	lddpc	r8,80004838 <twi_master_read+0xa0>
800047de:	91 09       	st.w	r8[0x0],r9

  // get a copy of nb bytes to read
  twi_rx_nb_bytes = package->length;
800047e0:	6e 49       	ld.w	r9,r7[0x10]
800047e2:	49 78       	lddpc	r8,8000483c <twi_master_read+0xa4>
800047e4:	91 09       	st.w	r8[0x0],r9

  // Enable master transfer
  twi->cr =  AVR32_TWI_CR_MSEN_MASK;
800047e6:	30 49       	mov	r9,4
800047e8:	8d 09       	st.w	r6[0x0],r9

  // Send start condition
  twi->cr = AVR32_TWI_START_MASK;
800047ea:	30 19       	mov	r9,1
800047ec:	8d 09       	st.w	r6[0x0],r9

  // only one byte to receive
  if(twi_rx_nb_bytes == 1)
800047ee:	70 08       	ld.w	r8,r8[0x0]
  {
    // set stop bit
    twi->cr = AVR32_TWI_STOP_MASK;
800047f0:	12 38       	cp.w	r8,r9
800047f2:	f9 b8 00 02 	moveq	r8,2
800047f6:	ed f8 0a 00 	st.weq	r6[0x0],r8
  }

  // mask NACK and RXRDY interrupts
  twi_it_mask = AVR32_TWI_IER_NACK_MASK | AVR32_TWI_IER_RXRDY_MASK;
800047fa:	49 28       	lddpc	r8,80004840 <twi_master_read+0xa8>
800047fc:	e0 69 01 02 	mov	r9,258
80004800:	91 09       	st.w	r8[0x0],r9

  // update IMR through IER
  twi->ier = twi_it_mask;
80004802:	70 08       	ld.w	r8,r8[0x0]
80004804:	8d 98       	st.w	r6[0x24],r8

  // get data
  while( twi_is_busy() ) {
80004806:	c0 38       	rjmp	8000480c <twi_master_read+0x74>
    cpu_relax();
80004808:	fe cf ff fc 	sub	pc,pc,-4

  // update IMR through IER
  twi->ier = twi_it_mask;

  // get data
  while( twi_is_busy() ) {
8000480c:	f0 1f 00 07 	mcall	80004828 <twi_master_read+0x90>
80004810:	cf c1       	brne	80004808 <twi_master_read+0x70>
    cpu_relax();
  }

  // Disable master transfer
  twi->cr =  AVR32_TWI_CR_MSDIS_MASK;
80004812:	30 88       	mov	r8,8
80004814:	8d 08       	st.w	r6[0x0],r8

  if( twi_nack )
80004816:	48 68       	lddpc	r8,8000482c <twi_master_read+0x94>
80004818:	11 8c       	ld.ub	r12,r8[0x0]
8000481a:	58 0c       	cp.w	r12,0
8000481c:	f9 bc 01 fb 	movne	r12,-5
80004820:	f9 bc 00 00 	moveq	r12,0
    return TWI_RECEIVE_NACK;

  return TWI_SUCCESS;
}
80004824:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004828:	80 00       	ld.sh	r0,r0[0x0]
8000482a:	46 c0       	lddsp	r0,sp[0x1b0]
8000482c:	00 00       	add	r0,r0
8000482e:	06 61       	and	r1,r3
80004830:	00 00       	add	r0,r0
80004832:	06 60       	and	r0,r3
80004834:	00 00       	add	r0,r0
80004836:	06 6c       	and	r12,r3
80004838:	00 00       	add	r0,r0
8000483a:	06 78       	tst	r8,r3
8000483c:	00 00       	add	r0,r0
8000483e:	06 74       	tst	r4,r3
80004840:	00 00       	add	r0,r0
80004842:	06 68       	and	r8,r3

80004844 <twi_master_init>:
  return TWI_SUCCESS;
}


int twi_master_init(volatile avr32_twi_t *twi, const twi_options_t *opt)
{
80004844:	eb cd 40 c0 	pushm	r6-r7,lr
80004848:	18 97       	mov	r7,r12
8000484a:	16 96       	mov	r6,r11
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
8000484c:	e1 b8 00 00 	mfsr	r8,0x0
  int status = TWI_SUCCESS;

  // Set pointer to TWIM instance for IT
  twi_inst = twi;
80004850:	4a 09       	lddpc	r9,800048d0 <twi_master_init+0x8c>
80004852:	93 0c       	st.w	r9[0x0],r12

  // Disable TWI interrupts
  if (global_interrupt_enabled) Disable_global_interrupt();
80004854:	e6 18 00 01 	andh	r8,0x1,COH
80004858:	c0 a1       	brne	8000486c <twi_master_init+0x28>
8000485a:	d3 03       	ssrf	0x10
  twi->idr = ~0UL;
8000485c:	3f f8       	mov	r8,-1
8000485e:	99 a8       	st.w	r12[0x28],r8
  twi->sr;
80004860:	78 88       	ld.w	r8,r12[0x20]

  // Reset TWI
  twi->cr = AVR32_TWI_CR_SWRST_MASK;
80004862:	e0 68 00 80 	mov	r8,128
80004866:	99 08       	st.w	r12[0x0],r8
  if (global_interrupt_enabled) Enable_global_interrupt();
80004868:	d5 03       	csrf	0x10
8000486a:	c0 78       	rjmp	80004878 <twi_master_init+0x34>
  // Set pointer to TWIM instance for IT
  twi_inst = twi;

  // Disable TWI interrupts
  if (global_interrupt_enabled) Disable_global_interrupt();
  twi->idr = ~0UL;
8000486c:	3f f8       	mov	r8,-1
8000486e:	99 a8       	st.w	r12[0x28],r8
  twi->sr;
80004870:	78 88       	ld.w	r8,r12[0x20]

  // Reset TWI
  twi->cr = AVR32_TWI_CR_SWRST_MASK;
80004872:	e0 68 00 80 	mov	r8,128
80004876:	99 08       	st.w	r12[0x0],r8
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Dummy read in SR
  twi->sr;
80004878:	6e 88       	ld.w	r8,r7[0x20]

  // Disable all interrupts
  Disable_global_interrupt();
8000487a:	d3 03       	ssrf	0x10

  // Register TWI handler on level 2
  INTC_register_interrupt( &twi_master_interrupt_handler, AVR32_TWI_IRQ, AVR32_INTC_INT1);
8000487c:	30 1a       	mov	r10,1
8000487e:	e0 6b 01 60 	mov	r11,352
80004882:	49 5c       	lddpc	r12,800048d4 <twi_master_init+0x90>
80004884:	f0 1f 00 15 	mcall	800048d8 <twi_master_init+0x94>

  // Enable all interrupts
  Enable_global_interrupt();
80004888:	d5 03       	csrf	0x10
static int twi_set_speed(volatile avr32_twi_t *twi, unsigned int speed, unsigned long pba_hz)
{
  unsigned int ckdiv = 0;
  unsigned int c_lh_div;

  c_lh_div = pba_hz / (speed * 2) - 4;
8000488a:	6c 19       	ld.w	r9,r6[0x4]
8000488c:	a1 79       	lsl	r9,0x1
8000488e:	6c 08       	ld.w	r8,r6[0x0]
80004890:	f0 09 0d 08 	divu	r8,r8,r9
80004894:	20 48       	sub	r8,4

  // cldiv must fit in 8 bits, ckdiv must fit in 3 bits
  while ((c_lh_div > 0xFF) && (ckdiv < 0x7))
80004896:	e0 48 00 ff 	cp.w	r8,255
8000489a:	e0 8b 00 04 	brhi	800048a2 <twi_master_init+0x5e>
8000489e:	30 09       	mov	r9,0
800048a0:	c0 f8       	rjmp	800048be <twi_master_init+0x7a>
800048a2:	30 09       	mov	r9,0
800048a4:	30 0c       	mov	r12,0
  {
    // increase clock divider
    ckdiv++;
800048a6:	2f f9       	sub	r9,-1
    // divide cldiv value
    c_lh_div /= 2;
800048a8:	a1 98       	lsr	r8,0x1
  unsigned int c_lh_div;

  c_lh_div = pba_hz / (speed * 2) - 4;

  // cldiv must fit in 8 bits, ckdiv must fit in 3 bits
  while ((c_lh_div > 0xFF) && (ckdiv < 0x7))
800048aa:	e0 48 00 ff 	cp.w	r8,255
800048ae:	5f bb       	srhi	r11
800048b0:	58 69       	cp.w	r9,6
800048b2:	5f 8a       	srls	r10
800048b4:	f7 ea 00 0a 	and	r10,r11,r10
800048b8:	f8 0a 18 00 	cp.b	r10,r12
800048bc:	cf 51       	brne	800048a6 <twi_master_init+0x62>
    // divide cldiv value
    c_lh_div /= 2;
  }

  // set clock waveform generator register
  twi->cwgr = ((c_lh_div << AVR32_TWI_CWGR_CLDIV_OFFSET) |
800048be:	b1 69       	lsl	r9,0x10
800048c0:	f3 e8 10 89 	or	r9,r9,r8<<0x8
800048c4:	f3 e8 10 08 	or	r8,r9,r8
800048c8:	8f 48       	st.w	r7[0x10],r8

  // Probe the component
  //status = twi_probe(twi, opt->chip);

  return status;
}
800048ca:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
800048ce:	00 00       	add	r0,r0
800048d0:	00 00       	add	r0,r0
800048d2:	06 6c       	and	r12,r3
800048d4:	80 00       	ld.sh	r0,r0[0x0]
800048d6:	46 04       	lddsp	r4,sp[0x180]
800048d8:	80 00       	ld.sh	r0,r0[0x0]
800048da:	41 6c       	lddsp	r12,sp[0x58]

800048dc <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
800048dc:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
800048de:	f6 08 15 04 	lsl	r8,r11,0x4
800048e2:	14 38       	cp.w	r8,r10
800048e4:	f9 b8 08 10 	movls	r8,16
800048e8:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
800048ec:	f0 0b 02 4b 	mul	r11,r8,r11
800048f0:	f6 09 16 01 	lsr	r9,r11,0x1
800048f4:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
800048f8:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
800048fc:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80004900:	f2 cb 00 01 	sub	r11,r9,1
80004904:	e0 4b ff fe 	cp.w	r11,65534
80004908:	e0 88 00 03 	brls	8000490e <usart_set_async_baudrate+0x32>
8000490c:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
8000490e:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80004910:	e8 6e 00 00 	mov	lr,524288
80004914:	59 08       	cp.w	r8,16
80004916:	fc 08 17 10 	movne	r8,lr
8000491a:	f9 b8 00 00 	moveq	r8,0
8000491e:	e4 1b ff f7 	andh	r11,0xfff7
80004922:	e0 1b fe cf 	andl	r11,0xfecf
80004926:	16 48       	or	r8,r11
80004928:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
8000492a:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
8000492e:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80004932:	99 89       	st.w	r12[0x20],r9
80004934:	d8 0a       	popm	pc,r12=0

80004936 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80004936:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80004938:	e2 18 00 02 	andl	r8,0x2,COH
8000493c:	c0 31       	brne	80004942 <usart_write_char+0xc>
8000493e:	30 2c       	mov	r12,2
80004940:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80004942:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80004946:	99 7b       	st.w	r12[0x1c],r11
80004948:	5e fd       	retal	0
8000494a:	d7 03       	nop

8000494c <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
8000494c:	eb cd 40 e0 	pushm	r5-r7,lr
80004950:	18 96       	mov	r6,r12
80004952:	16 95       	mov	r5,r11
80004954:	e0 67 27 0f 	mov	r7,9999
80004958:	c0 68       	rjmp	80004964 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
8000495a:	58 07       	cp.w	r7,0
8000495c:	c0 31       	brne	80004962 <usart_putchar+0x16>
8000495e:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80004962:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80004964:	0a 9b       	mov	r11,r5
80004966:	0c 9c       	mov	r12,r6
80004968:	f0 1f 00 03 	mcall	80004974 <usart_putchar+0x28>
8000496c:	cf 71       	brne	8000495a <usart_putchar+0xe>

  return USART_SUCCESS;
}
8000496e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004972:	00 00       	add	r0,r0
80004974:	80 00       	ld.sh	r0,r0[0x0]
80004976:	49 36       	lddpc	r6,800049c0 <usart_getchar+0x24>

80004978 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80004978:	78 58       	ld.w	r8,r12[0x14]
8000497a:	e2 18 00 e0 	andl	r8,0xe0,COH
8000497e:	c0 30       	breq	80004984 <usart_read_char+0xc>
80004980:	30 4c       	mov	r12,4
80004982:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80004984:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80004986:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000498a:	c0 31       	brne	80004990 <usart_read_char+0x18>
8000498c:	30 3c       	mov	r12,3
8000498e:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80004990:	78 68       	ld.w	r8,r12[0x18]
80004992:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80004996:	97 08       	st.w	r11[0x0],r8
80004998:	5e fd       	retal	0
8000499a:	d7 03       	nop

8000499c <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
8000499c:	eb cd 40 c0 	pushm	r6-r7,lr
800049a0:	20 1d       	sub	sp,4
800049a2:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
800049a4:	1a 97       	mov	r7,sp
800049a6:	1a 9b       	mov	r11,sp
800049a8:	0c 9c       	mov	r12,r6
800049aa:	f0 1f 00 07 	mcall	800049c4 <usart_getchar+0x28>
800049ae:	58 3c       	cp.w	r12,3
800049b0:	cf b0       	breq	800049a6 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
800049b2:	58 4c       	cp.w	r12,4
800049b4:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
800049b8:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
800049bc:	2f fd       	sub	sp,-4
800049be:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800049c2:	00 00       	add	r0,r0
800049c4:	80 00       	ld.sh	r0,r0[0x0]
800049c6:	49 78       	lddpc	r8,80004a20 <usart_init_rs232+0x8>

800049c8 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
800049c8:	eb cd 40 c0 	pushm	r6-r7,lr
800049cc:	18 96       	mov	r6,r12
800049ce:	16 97       	mov	r7,r11
  while (*string != '\0')
800049d0:	17 8b       	ld.ub	r11,r11[0x0]
800049d2:	58 0b       	cp.w	r11,0
800049d4:	c0 80       	breq	800049e4 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
800049d6:	2f f7       	sub	r7,-1
800049d8:	0c 9c       	mov	r12,r6
800049da:	f0 1f 00 04 	mcall	800049e8 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
800049de:	0f 8b       	ld.ub	r11,r7[0x0]
800049e0:	58 0b       	cp.w	r11,0
800049e2:	cf a1       	brne	800049d6 <usart_write_line+0xe>
800049e4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800049e8:	80 00       	ld.sh	r0,r0[0x0]
800049ea:	49 4c       	lddpc	r12,80004a38 <usart_init_rs232+0x20>

800049ec <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
800049ec:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
800049f0:	e6 18 00 01 	andh	r8,0x1,COH
800049f4:	c0 71       	brne	80004a02 <usart_reset+0x16>
800049f6:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
800049f8:	3f f8       	mov	r8,-1
800049fa:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800049fc:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
800049fe:	d5 03       	csrf	0x10
80004a00:	c0 48       	rjmp	80004a08 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80004a02:	3f f8       	mov	r8,-1
80004a04:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80004a06:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80004a08:	30 08       	mov	r8,0
80004a0a:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80004a0c:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80004a0e:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80004a10:	ea 68 61 0c 	mov	r8,680204
80004a14:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80004a16:	5e fc       	retal	r12

80004a18 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80004a18:	eb cd 40 e0 	pushm	r5-r7,lr
80004a1c:	18 96       	mov	r6,r12
80004a1e:	16 97       	mov	r7,r11
80004a20:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80004a22:	f0 1f 00 2f 	mcall	80004adc <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80004a26:	58 07       	cp.w	r7,0
80004a28:	c5 80       	breq	80004ad8 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80004a2a:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004a2c:	30 49       	mov	r9,4
80004a2e:	f2 08 18 00 	cp.b	r8,r9
80004a32:	e0 88 00 53 	brls	80004ad8 <usart_init_rs232+0xc0>
80004a36:	30 99       	mov	r9,9
80004a38:	f2 08 18 00 	cp.b	r8,r9
80004a3c:	e0 8b 00 4e 	brhi	80004ad8 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80004a40:	0f d9       	ld.ub	r9,r7[0x5]
80004a42:	30 78       	mov	r8,7
80004a44:	f0 09 18 00 	cp.b	r9,r8
80004a48:	e0 8b 00 48 	brhi	80004ad8 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80004a4c:	8e 39       	ld.sh	r9,r7[0x6]
80004a4e:	e0 68 01 01 	mov	r8,257
80004a52:	f0 09 19 00 	cp.h	r9,r8
80004a56:	e0 8b 00 41 	brhi	80004ad8 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80004a5a:	ef 39 00 08 	ld.ub	r9,r7[8]
80004a5e:	30 38       	mov	r8,3
80004a60:	f0 09 18 00 	cp.b	r9,r8
80004a64:	e0 8b 00 3a 	brhi	80004ad8 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80004a68:	0a 9a       	mov	r10,r5
80004a6a:	6e 0b       	ld.w	r11,r7[0x0]
80004a6c:	0c 9c       	mov	r12,r6
80004a6e:	f0 1f 00 1d 	mcall	80004ae0 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004a72:	58 1c       	cp.w	r12,1
80004a74:	c3 20       	breq	80004ad8 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80004a76:	0f c8       	ld.ub	r8,r7[0x4]
80004a78:	30 99       	mov	r9,9
80004a7a:	f2 08 18 00 	cp.b	r8,r9
80004a7e:	c0 51       	brne	80004a88 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80004a80:	6c 18       	ld.w	r8,r6[0x4]
80004a82:	b1 b8       	sbr	r8,0x11
80004a84:	8d 18       	st.w	r6[0x4],r8
80004a86:	c0 68       	rjmp	80004a92 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80004a88:	6c 19       	ld.w	r9,r6[0x4]
80004a8a:	20 58       	sub	r8,5
80004a8c:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80004a90:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80004a92:	6c 19       	ld.w	r9,r6[0x4]
80004a94:	ef 3a 00 08 	ld.ub	r10,r7[8]
80004a98:	0f d8       	ld.ub	r8,r7[0x5]
80004a9a:	a9 78       	lsl	r8,0x9
80004a9c:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80004aa0:	12 48       	or	r8,r9
80004aa2:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80004aa4:	8e 38       	ld.sh	r8,r7[0x6]
80004aa6:	30 29       	mov	r9,2
80004aa8:	f2 08 19 00 	cp.h	r8,r9
80004aac:	e0 88 00 09 	brls	80004abe <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80004ab0:	6c 18       	ld.w	r8,r6[0x4]
80004ab2:	ad b8       	sbr	r8,0xd
80004ab4:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80004ab6:	8e b8       	ld.uh	r8,r7[0x6]
80004ab8:	20 28       	sub	r8,2
80004aba:	8d a8       	st.w	r6[0x28],r8
80004abc:	c0 68       	rjmp	80004ac8 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80004abe:	6c 19       	ld.w	r9,r6[0x4]
80004ac0:	5c 78       	castu.h	r8
80004ac2:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80004ac6:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80004ac8:	6c 18       	ld.w	r8,r6[0x4]
80004aca:	e0 18 ff f0 	andl	r8,0xfff0
80004ace:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80004ad0:	35 08       	mov	r8,80
80004ad2:	8d 08       	st.w	r6[0x0],r8
80004ad4:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80004ad8:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80004adc:	80 00       	ld.sh	r0,r0[0x0]
80004ade:	49 ec       	lddpc	r12,80004b54 <_stext+0x8>
80004ae0:	80 00       	ld.sh	r0,r0[0x0]
80004ae2:	48 dc       	lddpc	r12,80004b14 <print_ulong+0x24>

80004ae4 <print>:
  print_hex(DBG_USART, n);
}


void print(volatile avr32_usart_t *usart, const char *str)
{
80004ae4:	d4 01       	pushm	lr
  // Invoke the USART driver to transmit the input string with the given USART.
  usart_write_line(usart, str);
80004ae6:	f0 1f 00 02 	mcall	80004aec <print+0x8>
}
80004aea:	d8 02       	popm	pc
80004aec:	80 00       	ld.sh	r0,r0[0x0]
80004aee:	49 c8       	lddpc	r8,80004b5c <_stext+0x10>

80004af0 <print_ulong>:
  usart_putchar(usart, c);
}


void print_ulong(volatile avr32_usart_t *usart, unsigned long n)
{
80004af0:	eb cd 40 e0 	pushm	r5-r7,lr
80004af4:	20 3d       	sub	sp,12
  char tmp[11];
  int i = sizeof(tmp) - 1;

  // Convert the given number to an ASCII decimal representation.
  tmp[i] = '\0';
80004af6:	30 08       	mov	r8,0
80004af8:	fb 68 00 0a 	st.b	sp[10],r8
80004afc:	30 a9       	mov	r9,10
  do
  {
    tmp[--i] = '0' + n % 10;
80004afe:	1a 95       	mov	r5,sp
80004b00:	e0 6e cc cd 	mov	lr,52429
80004b04:	ea 1e cc cc 	orh	lr,0xcccc
80004b08:	20 19       	sub	r9,1
80004b0a:	f6 0e 06 46 	mulu.d	r6,r11,lr
80004b0e:	0e 98       	mov	r8,r7
80004b10:	a3 98       	lsr	r8,0x3
80004b12:	f0 08 00 2a 	add	r10,r8,r8<<0x2
80004b16:	f6 0a 01 1b 	sub	r11,r11,r10<<0x1
80004b1a:	2d 0b       	sub	r11,-48
80004b1c:	ea 09 0b 0b 	st.b	r5[r9],r11
    n /= 10;
80004b20:	10 9b       	mov	r11,r8
  } while (n);
80004b22:	58 08       	cp.w	r8,0
80004b24:	cf 21       	brne	80004b08 <print_ulong+0x18>

  // Transmit the resulting string with the given USART.
  print(usart, tmp + i);
80004b26:	1a 9b       	mov	r11,sp
80004b28:	12 0b       	add	r11,r9
80004b2a:	f0 1f 00 03 	mcall	80004b34 <print_ulong+0x44>
}
80004b2e:	2f dd       	sub	sp,-12
80004b30:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004b34:	80 00       	ld.sh	r0,r0[0x0]
80004b36:	4a e4       	lddpc	r4,80004bec <init_sys_clocks+0x5c>

80004b38 <print_dbg_ulong>:
  print_char(DBG_USART, c);
}


void print_dbg_ulong(unsigned long n)
{
80004b38:	d4 01       	pushm	lr
  // Redirection to the debug USART.
  print_ulong(DBG_USART, n);
80004b3a:	18 9b       	mov	r11,r12
80004b3c:	fe 7c 14 00 	mov	r12,-60416
80004b40:	f0 1f 00 02 	mcall	80004b48 <print_dbg_ulong+0x10>
}
80004b44:	d8 02       	popm	pc
80004b46:	00 00       	add	r0,r0
80004b48:	80 00       	ld.sh	r0,r0[0x0]
80004b4a:	4a f0       	lddpc	r0,80004c04 <init_sys_clocks+0x74>

80004b4c <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80004b4c:	e0 7d 00 00 	mov	sp,65536

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80004b50:	fe c0 81 50 	sub	r0,pc,-32432

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80004b54:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80004b58:	d5 53       	csrf	0x15
  cp      r0, r1
80004b5a:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
80004b5c:	e0 61 05 38 	mov	r1,1336
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80004b60:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80004b62:	c0 62       	brcc	80004b6e <idata_load_loop_end>
  cp      r0, r1
80004b64:	48 92       	lddpc	r2,80004b88 <udata_clear_loop_end+0x4>

80004b66 <idata_load_loop>:
  brlo    idata_load_loop
80004b66:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80004b68:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80004b6a:	02 30       	cp.w	r0,r1
  cp      r0, r1
80004b6c:	cf d3       	brcs	80004b66 <idata_load_loop>

80004b6e <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80004b6e:	e0 60 05 38 	mov	r0,1336
  mov     r2, 0
  mov     r3, 0
80004b72:	e0 61 10 60 	mov	r1,4192
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80004b76:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80004b78:	c0 62       	brcc	80004b84 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80004b7a:	30 02       	mov	r2,0
80004b7c:	30 03       	mov	r3,0

80004b7e <udata_clear_loop>:
80004b7e:	a1 22       	st.d	r0++,r2
80004b80:	02 30       	cp.w	r0,r1
80004b82:	cf e3       	brcs	80004b7e <udata_clear_loop>

80004b84 <udata_clear_loop_end>:
80004b84:	fe cf ff 00 	sub	pc,pc,-256
80004b88:	80 02       	ld.sh	r2,r0[0x0]
80004b8a:	fa c8 5e fc 	sub	r8,sp,24316

80004b8c <master_callback>:
		adc_underrun_callback();;
	}
	else if( arg == AUDIO_ADC_RELOAD_CB ){
		adc_reload_callback();;
	}
}
80004b8c:	5e fc       	retal	r12
80004b8e:	d7 03       	nop

80004b90 <init_sys_clocks>:
void adc_reload_callback(void){
  // Nothing todo
}


void init_sys_clocks(void)	{
80004b90:	eb cd 40 c0 	pushm	r6-r7,lr
	// Switch to OSC0 to speed up the booting
	pm_switch_to_osc0(&AVR32_PM, FOSC0, OSC0_STARTUP);
80004b94:	30 3a       	mov	r10,3
80004b96:	e0 6b 1b 00 	mov	r11,6912
80004b9a:	ea 1b 00 b7 	orh	r11,0xb7
80004b9e:	fe 7c 0c 00 	mov	r12,-62464
80004ba2:	f0 1f 00 2e 	mcall	80004c58 <init_sys_clocks+0xc8>

	// Start oscillator1
	pm_enable_osc1_crystal(&AVR32_PM, FOSC1);
80004ba6:	e0 6b 44 00 	mov	r11,17408
80004baa:	ea 1b 00 ac 	orh	r11,0xac
80004bae:	fe 7c 0c 00 	mov	r12,-62464
80004bb2:	f0 1f 00 2b 	mcall	80004c5c <init_sys_clocks+0xcc>
	pm_enable_clk1(&AVR32_PM, OSC1_STARTUP);
80004bb6:	30 3b       	mov	r11,3
80004bb8:	fe 7c 0c 00 	mov	r12,-62464
80004bbc:	f0 1f 00 29 	mcall	80004c60 <init_sys_clocks+0xd0>

	// Set PLL0 (fed from OSC1 = 11.2896 MHz) to 124.1856 MHz
	// We use OSC1 since we need a correct master clock for the SSC module to generate
	// the correct sample rate
	pm_pll_setup(&AVR32_PM, 0,  // pll.
80004bc0:	31 06       	mov	r6,16
80004bc2:	1a d6       	st.w	--sp,r6
80004bc4:	30 18       	mov	r8,1
80004bc6:	10 99       	mov	r9,r8
80004bc8:	30 aa       	mov	r10,10
80004bca:	30 0b       	mov	r11,0
80004bcc:	fe 7c 0c 00 	mov	r12,-62464
80004bd0:	f0 1f 00 25 	mcall	80004c64 <init_sys_clocks+0xd4>
	1,   // osc.
	16); // lockcount.

	// Set PLL operating range and divider (fpll = fvco/2)
	// -> PLL0 output = 62.0928 MHz
	pm_pll_set_option(&AVR32_PM, 0, // pll.
80004bd4:	30 08       	mov	r8,0
80004bd6:	30 19       	mov	r9,1
80004bd8:	12 9a       	mov	r10,r9
80004bda:	10 9b       	mov	r11,r8
80004bdc:	fe 7c 0c 00 	mov	r12,-62464
80004be0:	f0 1f 00 22 	mcall	80004c68 <init_sys_clocks+0xd8>
	1,  // pll_freq.
	1,  // pll_div2.
	0); // pll_wbwdisable.

	// start PLL0 and wait for the lock
	pm_pll_enable(&AVR32_PM, 0);
80004be4:	30 0b       	mov	r11,0
80004be6:	fe 7c 0c 00 	mov	r12,-62464
80004bea:	f0 1f 00 21 	mcall	80004c6c <init_sys_clocks+0xdc>
	pm_wait_for_pll0_locked(&AVR32_PM);
80004bee:	fe 7c 0c 00 	mov	r12,-62464
80004bf2:	f0 1f 00 20 	mcall	80004c70 <init_sys_clocks+0xe0>
	// Set all peripheral clocks torun at master clock rate
	pm_cksel(&AVR32_PM,
80004bf6:	30 07       	mov	r7,0
80004bf8:	1a d7       	st.w	--sp,r7
80004bfa:	1a d7       	st.w	--sp,r7
80004bfc:	0e 98       	mov	r8,r7
80004bfe:	0e 99       	mov	r9,r7
80004c00:	0e 9a       	mov	r10,r7
80004c02:	0e 9b       	mov	r11,r7
80004c04:	fe 7c 0c 00 	mov	r12,-62464
80004c08:	f0 1f 00 1b 	mcall	80004c74 <init_sys_clocks+0xe4>
	0,   // pbbsel.
	0,   // hsbdiv.
	0);  // hsbsel.

	// Set one waitstate for the flash
	flashc_set_wait_state(1);
80004c0c:	30 1c       	mov	r12,1
80004c0e:	f0 1f 00 1b 	mcall	80004c78 <init_sys_clocks+0xe8>

	// Switch to PLL0 as the master clock
	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCCTRL_MCSEL_PLL0);
80004c12:	30 2b       	mov	r11,2
80004c14:	fe 7c 0c 00 	mov	r12,-62464
80004c18:	f0 1f 00 19 	mcall	80004c7c <init_sys_clocks+0xec>

	// Use 12MHz from OSC0 and generate 96 MHz
	pm_pll_setup(&AVR32_PM, 1,  // pll.
80004c1c:	1a d6       	st.w	--sp,r6
80004c1e:	0e 98       	mov	r8,r7
80004c20:	30 19       	mov	r9,1
80004c22:	30 7a       	mov	r10,7
80004c24:	12 9b       	mov	r11,r9
80004c26:	fe 7c 0c 00 	mov	r12,-62464
80004c2a:	f0 1f 00 0f 	mcall	80004c64 <init_sys_clocks+0xd4>
	7,   // mul.
	1,   // div.
	0,   // osc.
	16); // lockcount.

	pm_pll_set_option(&AVR32_PM, 1, // pll.
80004c2e:	0e 98       	mov	r8,r7
80004c30:	30 19       	mov	r9,1
80004c32:	12 9a       	mov	r10,r9
80004c34:	12 9b       	mov	r11,r9
80004c36:	fe 7c 0c 00 	mov	r12,-62464
80004c3a:	f0 1f 00 0c 	mcall	80004c68 <init_sys_clocks+0xd8>
	1,  // pll_freq: choose the range 80-180MHz.
	1,  // pll_div2.
	0); // pll_wbwdisable.

	// start PLL1 and wait forl lock
	pm_pll_enable(&AVR32_PM, 1);
80004c3e:	30 1b       	mov	r11,1
80004c40:	fe 7c 0c 00 	mov	r12,-62464
80004c44:	f0 1f 00 0a 	mcall	80004c6c <init_sys_clocks+0xdc>

	// Wait for PLL1 locked.
	pm_wait_for_pll1_locked(&AVR32_PM);
80004c48:	fe 7c 0c 00 	mov	r12,-62464
80004c4c:	f0 1f 00 0d 	mcall	80004c80 <init_sys_clocks+0xf0>
80004c50:	0c 0d       	add	sp,r6

}
80004c52:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004c56:	00 00       	add	r0,r0
80004c58:	80 00       	ld.sh	r0,r0[0x0]
80004c5a:	45 20       	lddsp	r0,sp[0x148]
80004c5c:	80 00       	ld.sh	r0,r0[0x0]
80004c5e:	43 fc       	lddsp	r12,sp[0xfc]
80004c60:	80 00       	ld.sh	r0,r0[0x0]
80004c62:	44 54       	lddsp	r4,sp[0x114]
80004c64:	80 00       	ld.sh	r0,r0[0x0]
80004c66:	44 b6       	lddsp	r6,sp[0x12c]
80004c68:	80 00       	ld.sh	r0,r0[0x0]
80004c6a:	44 d8       	lddsp	r8,sp[0x134]
80004c6c:	80 00       	ld.sh	r0,r0[0x0]
80004c6e:	44 f2       	lddsp	r2,sp[0x13c]
80004c70:	80 00       	ld.sh	r0,r0[0x0]
80004c72:	45 00       	lddsp	r0,sp[0x140]
80004c74:	80 00       	ld.sh	r0,r0[0x0]
80004c76:	44 70       	lddsp	r0,sp[0x11c]
80004c78:	80 00       	ld.sh	r0,r0[0x0]
80004c7a:	40 4c       	lddsp	r12,sp[0x10]
80004c7c:	80 00       	ld.sh	r0,r0[0x0]
80004c7e:	45 14       	lddsp	r4,sp[0x144]
80004c80:	80 00       	ld.sh	r0,r0[0x0]
80004c82:	45 0a       	lddsp	r10,sp[0x140]

80004c84 <main>:
			//gpio_clr_gpio_pin(LED3_GPIO);
			xSemaphoreGive(xMutexSD);
		}
	}
}
int main( void ){
80004c84:	d4 21       	pushm	r4-r7,lr
80004c86:	20 bd       	sub	sp,44
	init_sys_clocks();
80004c88:	f0 1f 01 04 	mcall	80005098 <main+0x414>
	
	et024006_Init( FPBA_HZ, FPBA_HZ );
80004c8c:	e0 6b 76 00 	mov	r11,30208
80004c90:	ea 1b 03 b3 	orh	r11,0x3b3
80004c94:	16 9c       	mov	r12,r11
80004c96:	f0 1f 01 02 	mcall	8000509c <main+0x418>
	pwm_opt_t opt = {
		.diva = 0,
		.divb = 0,
		.prea = 0,
		.preb = 0
	};
80004c9a:	30 07       	mov	r7,0
80004c9c:	50 07       	stdsp	sp[0x0],r7
80004c9e:	50 17       	stdsp	sp[0x4],r7
80004ca0:	50 27       	stdsp	sp[0x8],r7
80004ca2:	50 37       	stdsp	sp[0xc],r7
	pwm_init(&opt);
80004ca4:	1a 9c       	mov	r12,sp
80004ca6:	f0 1f 00 ff 	mcall	800050a0 <main+0x41c>
	pwm_channel6.CMR.calg = PWM_MODE_LEFT_ALIGNED;
80004caa:	fe fb 03 fa 	ld.w	r11,pc[1018]
80004cae:	76 08       	ld.w	r8,r11[0x0]
	pwm_channel6.CMR.cpol = PWM_POLARITY_HIGH; //PWM_POLARITY_LOW;//PWM_POLARITY_HIGH;
	pwm_channel6.CMR.cpd = PWM_UPDATE_DUTY;
80004cb0:	e0 18 f8 ff 	andl	r8,0xf8ff
	pwm_channel6.CMR.cpre = AVR32_PWM_CMR_CPRE_MCK_DIV_2;
80004cb4:	a9 b8       	sbr	r8,0x9
80004cb6:	30 19       	mov	r9,1
80004cb8:	f1 d9 d0 04 	bfins	r8,r9,0x0,0x4
80004cbc:	97 08       	st.w	r11[0x0],r8

	pwm_channel_init(6, &pwm_channel6);
80004cbe:	30 6c       	mov	r12,6
80004cc0:	f0 1f 00 fa 	mcall	800050a8 <main+0x424>
	pwm_start_channels(AVR32_PWM_ENA_CHID6_MASK);
80004cc4:	34 0c       	mov	r12,64
80004cc6:	f0 1f 00 fa 	mcall	800050ac <main+0x428>
int main( void ){
	init_sys_clocks();
	
	et024006_Init( FPBA_HZ, FPBA_HZ );
	tft_bl_init();
	et024006_DrawFilledRect(0 , 0, ET024006_WIDTH, ET024006_HEIGHT, BLACK);
80004cca:	0e 98       	mov	r8,r7
80004ccc:	e0 69 00 f0 	mov	r9,240
80004cd0:	e0 6a 01 40 	mov	r10,320
80004cd4:	0e 9b       	mov	r11,r7
80004cd6:	0e 9c       	mov	r12,r7
80004cd8:	f0 1f 00 f6 	mcall	800050b0 <main+0x42c>
	while(pwm_channel6.cdty < pwm_channel6.cprd){
80004cdc:	fe f7 03 c8 	ld.w	r7,pc[968]
		pwm_channel6.cdty++;
		pwm_channel6.cupd = pwm_channel6.cdty;
		//pwm_channel6.cdty--;
		pwm_async_update_channel(AVR32_PWM_ENA_CHID6, &pwm_channel6);
80004ce0:	30 66       	mov	r6,6
	init_sys_clocks();
	
	et024006_Init( FPBA_HZ, FPBA_HZ );
	tft_bl_init();
	et024006_DrawFilledRect(0 , 0, ET024006_WIDTH, ET024006_HEIGHT, BLACK);
	while(pwm_channel6.cdty < pwm_channel6.cprd){
80004ce2:	c1 e8       	rjmp	80004d1e <main+0x9a>
		pwm_channel6.cdty++;
80004ce4:	2f f8       	sub	r8,-1
80004ce6:	8f 18       	st.w	r7[0x4],r8
		pwm_channel6.cupd = pwm_channel6.cdty;
80004ce8:	8f 48       	st.w	r7[0x10],r8
		//pwm_channel6.cdty--;
		pwm_async_update_channel(AVR32_PWM_ENA_CHID6, &pwm_channel6);
80004cea:	0e 9b       	mov	r11,r7
80004cec:	0c 9c       	mov	r12,r6
80004cee:	f0 1f 00 f2 	mcall	800050b4 <main+0x430>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80004cf2:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80004cf6:	e0 79 d4 c0 	mov	r9,120000
80004cfa:	f0 09 00 0a 	add	r10,r8,r9
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80004cfe:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80004d02:	14 38       	cp.w	r8,r10
80004d04:	e0 88 00 08 	brls	80004d14 <main+0x90>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80004d08:	12 38       	cp.w	r8,r9
80004d0a:	fe 98 ff fa 	brls	80004cfe <main+0x7a>
80004d0e:	12 3a       	cp.w	r10,r9
80004d10:	c0 73       	brcs	80004d1e <main+0x9a>
80004d12:	cf 6b       	rjmp	80004cfe <main+0x7a>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80004d14:	12 38       	cp.w	r8,r9
80004d16:	e0 8b 00 04 	brhi	80004d1e <main+0x9a>
80004d1a:	12 3a       	cp.w	r10,r9
80004d1c:	cf 12       	brcc	80004cfe <main+0x7a>
	init_sys_clocks();
	
	et024006_Init( FPBA_HZ, FPBA_HZ );
	tft_bl_init();
	et024006_DrawFilledRect(0 , 0, ET024006_WIDTH, ET024006_HEIGHT, BLACK);
	while(pwm_channel6.cdty < pwm_channel6.cprd){
80004d1e:	6e 18       	ld.w	r8,r7[0x4]
80004d20:	6e 29       	ld.w	r9,r7[0x8]
80004d22:	12 38       	cp.w	r8,r9
80004d24:	ce 03       	brcs	80004ce4 <main+0x60>
		//pwm_channel6.cdty--;
		pwm_async_update_channel(AVR32_PWM_ENA_CHID6, &pwm_channel6);
		delay_ms(10);
	}
	//
	et024006_DrawFilledRect(0 , 0, ET024006_WIDTH, ET024006_HEIGHT, BLACK );
80004d26:	30 08       	mov	r8,0
80004d28:	e0 69 00 f0 	mov	r9,240
80004d2c:	e0 6a 01 40 	mov	r10,320
80004d30:	10 9b       	mov	r11,r8
80004d32:	10 9c       	mov	r12,r8
80004d34:	f0 1f 00 df 	mcall	800050b0 <main+0x42c>
	//Temperatura
	et024006_DrawFilledRect(10 , 40, 20, 140, WHITE );
80004d38:	e0 68 ff ff 	mov	r8,65535
80004d3c:	e0 69 00 8c 	mov	r9,140
80004d40:	31 4a       	mov	r10,20
80004d42:	32 8b       	mov	r11,40
80004d44:	30 ac       	mov	r12,10
80004d46:	f0 1f 00 db 	mcall	800050b0 <main+0x42c>
	//gas
	et024006_DrawFilledRect(140, 100, 60, 40, RED );
80004d4a:	e0 68 f8 00 	mov	r8,63488
80004d4e:	32 89       	mov	r9,40
80004d50:	33 ca       	mov	r10,60
80004d52:	36 4b       	mov	r11,100
80004d54:	e0 6c 00 8c 	mov	r12,140
80004d58:	f0 1f 00 d6 	mcall	800050b0 <main+0x42c>
	et024006_DrawFilledRect(145, 105, 50, 30, BLACK );
80004d5c:	30 08       	mov	r8,0
80004d5e:	31 e9       	mov	r9,30
80004d60:	33 2a       	mov	r10,50
80004d62:	36 9b       	mov	r11,105
80004d64:	e0 6c 00 91 	mov	r12,145
80004d68:	f0 1f 00 d2 	mcall	800050b0 <main+0x42c>
	et024006_DrawHorizLine(120,100,100,RED);
80004d6c:	e0 69 f8 00 	mov	r9,63488
80004d70:	36 4a       	mov	r10,100
80004d72:	14 9b       	mov	r11,r10
80004d74:	37 8c       	mov	r12,120
80004d76:	f0 1f 00 d1 	mcall	800050b8 <main+0x434>
	et024006_DrawLine(120,100,170,60,RED);
80004d7a:	e0 68 f8 00 	mov	r8,63488
80004d7e:	33 c9       	mov	r9,60
80004d80:	e0 6a 00 aa 	mov	r10,170
80004d84:	36 4b       	mov	r11,100
80004d86:	37 8c       	mov	r12,120
80004d88:	f0 1f 00 cd 	mcall	800050bc <main+0x438>
	et024006_DrawLine(170,60,220,100,RED);
80004d8c:	e0 68 f8 00 	mov	r8,63488
80004d90:	36 49       	mov	r9,100
80004d92:	e0 6a 00 dc 	mov	r10,220
80004d96:	33 cb       	mov	r11,60
80004d98:	e0 6c 00 aa 	mov	r12,170
80004d9c:	f0 1f 00 c8 	mcall	800050bc <main+0x438>
	//iluminosidad
	et024006_DrawFilledCircle(280,90,30,BLUE,0xFF);
80004da0:	e0 68 00 ff 	mov	r8,255
80004da4:	31 f9       	mov	r9,31
80004da6:	31 ea       	mov	r10,30
80004da8:	35 ab       	mov	r11,90
80004daa:	e0 6c 01 18 	mov	r12,280
80004dae:	f0 1f 00 c5 	mcall	800050c0 <main+0x43c>
	et024006_DrawFilledCircle(280,90,29,BLACK,0xFF);
80004db2:	e0 68 00 ff 	mov	r8,255
80004db6:	30 09       	mov	r9,0
80004db8:	31 da       	mov	r10,29
80004dba:	35 ab       	mov	r11,90
80004dbc:	e0 6c 01 18 	mov	r12,280
80004dc0:	f0 1f 00 c0 	mcall	800050c0 <main+0x43c>
	et024006_DrawLine(240,120,250,110,BLUE);
80004dc4:	31 f8       	mov	r8,31
80004dc6:	36 e9       	mov	r9,110
80004dc8:	e0 6a 00 fa 	mov	r10,250
80004dcc:	37 8b       	mov	r11,120
80004dce:	e0 6c 00 f0 	mov	r12,240
80004dd2:	f0 1f 00 bb 	mcall	800050bc <main+0x438>
	et024006_DrawLine(240,100,245,90,BLUE);
80004dd6:	31 f8       	mov	r8,31
80004dd8:	35 a9       	mov	r9,90
80004dda:	e0 6a 00 f5 	mov	r10,245
80004dde:	36 4b       	mov	r11,100
80004de0:	e0 6c 00 f0 	mov	r12,240
80004de4:	f0 1f 00 b6 	mcall	800050bc <main+0x438>
	et024006_DrawLine(240,70,245,80,BLUE);
80004de8:	31 f8       	mov	r8,31
80004dea:	35 09       	mov	r9,80
80004dec:	e0 6a 00 f5 	mov	r10,245
80004df0:	34 6b       	mov	r11,70
80004df2:	e0 6c 00 f0 	mov	r12,240
80004df6:	f0 1f 00 b2 	mcall	800050bc <main+0x438>
	et024006_DrawLine(240,50,250,60,BLUE);
80004dfa:	31 f8       	mov	r8,31
80004dfc:	33 c9       	mov	r9,60
80004dfe:	e0 6a 00 fa 	mov	r10,250
80004e02:	33 2b       	mov	r11,50
80004e04:	e0 6c 00 f0 	mov	r12,240
80004e08:	f0 1f 00 ad 	mcall	800050bc <main+0x438>
	et024006_DrawVertLine(270,40,10,BLUE);
80004e0c:	31 f9       	mov	r9,31
80004e0e:	30 aa       	mov	r10,10
80004e10:	32 8b       	mov	r11,40
80004e12:	e0 6c 01 0e 	mov	r12,270
80004e16:	f0 1f 00 ac 	mcall	800050c4 <main+0x440>
	et024006_DrawVertLine(290,40,10,BLUE);
80004e1a:	31 f9       	mov	r9,31
80004e1c:	30 aa       	mov	r10,10
80004e1e:	32 8b       	mov	r11,40
80004e20:	e0 6c 01 22 	mov	r12,290
80004e24:	f0 1f 00 a8 	mcall	800050c4 <main+0x440>
	et024006_DrawLine(310,60,320,50,BLUE);
80004e28:	31 f8       	mov	r8,31
80004e2a:	33 29       	mov	r9,50
80004e2c:	e0 6a 01 40 	mov	r10,320
80004e30:	33 cb       	mov	r11,60
80004e32:	e0 6c 01 36 	mov	r12,310
80004e36:	f0 1f 00 a2 	mcall	800050bc <main+0x438>
	et024006_DrawLine(315,80,320,70,BLUE);
80004e3a:	31 f8       	mov	r8,31
80004e3c:	34 69       	mov	r9,70
80004e3e:	e0 6a 01 40 	mov	r10,320
80004e42:	35 0b       	mov	r11,80
80004e44:	e0 6c 01 3b 	mov	r12,315
80004e48:	f0 1f 00 9d 	mcall	800050bc <main+0x438>
	et024006_DrawLine(315,90,320,100,BLUE);
80004e4c:	31 f8       	mov	r8,31
80004e4e:	36 49       	mov	r9,100
80004e50:	e0 6a 01 40 	mov	r10,320
80004e54:	35 ab       	mov	r11,90
80004e56:	e0 6c 01 3b 	mov	r12,315
80004e5a:	f0 1f 00 99 	mcall	800050bc <main+0x438>
	et024006_DrawLine(310,110,320,120,BLUE);
80004e5e:	31 f8       	mov	r8,31
80004e60:	37 89       	mov	r9,120
80004e62:	e0 6a 01 40 	mov	r10,320
80004e66:	36 eb       	mov	r11,110
80004e68:	e0 6c 01 36 	mov	r12,310
80004e6c:	f0 1f 00 94 	mcall	800050bc <main+0x438>
	et024006_DrawLine(270,140, 290, 140, BLUE);
80004e70:	31 f8       	mov	r8,31
80004e72:	e0 69 00 8c 	mov	r9,140
80004e76:	e0 6a 01 22 	mov	r10,290
80004e7a:	12 9b       	mov	r11,r9
80004e7c:	e0 6c 01 0e 	mov	r12,270
80004e80:	f0 1f 00 8f 	mcall	800050bc <main+0x438>
	et024006_DrawLine(270,135, 290, 135, BLUE);
80004e84:	31 f8       	mov	r8,31
80004e86:	e0 69 00 87 	mov	r9,135
80004e8a:	e0 6a 01 22 	mov	r10,290
80004e8e:	12 9b       	mov	r11,r9
80004e90:	e0 6c 01 0e 	mov	r12,270
80004e94:	f0 1f 00 8a 	mcall	800050bc <main+0x438>
	et024006_DrawLine(270,130, 290, 130, BLUE);
80004e98:	31 f8       	mov	r8,31
80004e9a:	e0 69 00 82 	mov	r9,130
80004e9e:	e0 6a 01 22 	mov	r10,290
80004ea2:	12 9b       	mov	r11,r9
80004ea4:	e0 6c 01 0e 	mov	r12,270
80004ea8:	f0 1f 00 85 	mcall	800050bc <main+0x438>
	et024006_DrawLine(270,125, 290, 125, BLUE);
80004eac:	31 f8       	mov	r8,31
80004eae:	37 d9       	mov	r9,125
80004eb0:	e0 6a 01 22 	mov	r10,290
80004eb4:	12 9b       	mov	r11,r9
80004eb6:	e0 6c 01 0e 	mov	r12,270
80004eba:	f0 1f 00 81 	mcall	800050bc <main+0x438>
	et024006_DrawLine(270,120, 290, 120, BLUE);
80004ebe:	31 f8       	mov	r8,31
80004ec0:	37 89       	mov	r9,120
80004ec2:	e0 6a 01 22 	mov	r10,290
80004ec6:	12 9b       	mov	r11,r9
80004ec8:	e0 6c 01 0e 	mov	r12,270
80004ecc:	f0 1f 00 7c 	mcall	800050bc <main+0x438>
	et024006_DrawLine(270,140, 270, 120, BLUE);
80004ed0:	31 f8       	mov	r8,31
80004ed2:	37 89       	mov	r9,120
80004ed4:	e0 6a 01 0e 	mov	r10,270
80004ed8:	e0 6b 00 8c 	mov	r11,140
80004edc:	14 9c       	mov	r12,r10
80004ede:	f0 1f 00 78 	mcall	800050bc <main+0x438>
	et024006_DrawLine(290,140, 290, 120, BLUE);
80004ee2:	31 f8       	mov	r8,31
80004ee4:	37 89       	mov	r9,120
80004ee6:	e0 6a 01 22 	mov	r10,290
80004eea:	e0 6b 00 8c 	mov	r11,140
80004eee:	14 9c       	mov	r12,r10
80004ef0:	f0 1f 00 73 	mcall	800050bc <main+0x438>
		{SD_MMC_SPI_MISO_PIN, SD_MMC_SPI_MISO_FUNCTION},  // MISO.
		{SD_MMC_SPI_MOSI_PIN, SD_MMC_SPI_MOSI_FUNCTION},  // MOSI.
		{SD_MMC_SPI_NPCS_PIN, SD_MMC_SPI_NPCS_FUNCTION}   // Chip Select NPCS.
	};
	
	gpio_enable_module(GPIO_MAP,sizeof(GPIO_MAP) / sizeof(GPIO_MAP[0]));
80004ef4:	30 ab       	mov	r11,10
80004ef6:	4f 5c       	lddpc	r12,800050c8 <main+0x444>
80004ef8:	f0 1f 00 75 	mcall	800050cc <main+0x448>
	  const twi_options_t TPA6130_TWI_OPTIONS ={
		  .pba_hz = 62092800,
		  .speed  = TPA6130_TWI_MASTER_SPEED,
		  .chip   = TPA6130_TWI_ADDRESS
	  };
80004efc:	4f 58       	lddpc	r8,800050d0 <main+0x44c>
80004efe:	fa cb ff e0 	sub	r11,sp,-32
80004f02:	f0 e6 00 00 	ld.d	r6,r8[0]
80004f06:	f6 e7 00 00 	st.d	r11[0],r6
80004f0a:	70 28       	ld.w	r8,r8[0x8]
80004f0c:	97 28       	st.w	r11[0x8],r8
	  // Initialize as master.
	twi_master_init(TPA6130_TWI, &TPA6130_TWI_OPTIONS);
80004f0e:	fe 7c 2c 00 	mov	r12,-54272
80004f12:	f0 1f 00 71 	mcall	800050d4 <main+0x450>
	tpa6130_init();
80004f16:	f0 1f 00 71 	mcall	800050d8 <main+0x454>
	tpa6130_dac_start(DEFAULT_DAC_SAMPLE_RATE_HZ,//Sample Rate
80004f1a:	e0 66 76 00 	mov	r6,30208
80004f1e:	ea 16 03 b3 	orh	r6,0x3b3
80004f22:	1a d6       	st.w	--sp,r6
80004f24:	30 38       	mov	r8,3
80004f26:	1a d8       	st.w	--sp,r8
80004f28:	4e d8       	lddpc	r8,800050dc <main+0x458>
80004f2a:	30 09       	mov	r9,0
80004f2c:	31 0a       	mov	r10,16
80004f2e:	30 2b       	mov	r11,2
80004f30:	e0 6c 2b 11 	mov	r12,11025
80004f34:	f0 1f 00 6b 	mcall	800050e0 <main+0x45c>
		DEFAULT_DAC_SWAP_CHANNELS,//Swap Left right channel
		master_callback,
		AUDIO_DAC_OUT_OF_SAMPLE_CB
		| AUDIO_DAC_RELOAD_CB,
		62092800);//Frecuencia del reloj sncrono PLL0
	tpa6130_set_volume(0x3F);//6 bits
80004f38:	33 fc       	mov	r12,63
80004f3a:	f0 1f 00 6b 	mcall	800050e4 <main+0x460>
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Initialize USART in RS232 mode.
	usart_init_rs232(&AVR32_USART0, &USART_OPTIONS,62092800);	
80004f3e:	0c 9a       	mov	r10,r6
80004f40:	4e ab       	lddpc	r11,800050e8 <main+0x464>
80004f42:	fe 7c 14 00 	mov	r12,-60416
80004f46:	f0 1f 00 6a 	mcall	800050ec <main+0x468>
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80004f4a:	4e a8       	lddpc	r8,800050f0 <main+0x46c>
80004f4c:	fa c7 ff e8 	sub	r7,sp,-24
80004f50:	f0 ea 00 00 	ld.d	r10,r8[0]
80004f54:	ee eb 00 00 	st.d	r7[0],r10
80004f58:	f0 e8 00 08 	ld.d	r8,r8[8]
80004f5c:	ee e9 00 08 	st.d	r7[8],r8
	// Initialize as master.
	spi_initMaster(SD_MMC_SPI, &spiOptions);
80004f60:	0e 9b       	mov	r11,r7
80004f62:	fe 7c 24 00 	mov	r12,-56320
80004f66:	f0 1f 00 64 	mcall	800050f4 <main+0x470>
	// Set SPI selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(SD_MMC_SPI, 0, 0, 0);
80004f6a:	30 09       	mov	r9,0
80004f6c:	12 9a       	mov	r10,r9
80004f6e:	12 9b       	mov	r11,r9
80004f70:	fe 7c 24 00 	mov	r12,-56320
80004f74:	f0 1f 00 61 	mcall	800050f8 <main+0x474>
	// Enable SPI module.
	spi_enable(SD_MMC_SPI);
80004f78:	fe 7c 24 00 	mov	r12,-56320
80004f7c:	f0 1f 00 60 	mcall	800050fc <main+0x478>
	// Initialize SD/MMC driver with SPI clock (PBA).
	sd_mmc_spi_init(spiOptions, FPBA_HZ);
80004f80:	20 4d       	sub	sp,16
80004f82:	ee e8 00 00 	ld.d	r8,r7[0]
80004f86:	fa e9 00 00 	st.d	sp[0],r8
80004f8a:	ee e8 00 08 	ld.d	r8,r7[8]
80004f8e:	fa e9 00 08 	st.d	sp[8],r8
80004f92:	0c 9c       	mov	r12,r6
80004f94:	f0 1f 00 5b 	mcall	80005100 <main+0x47c>
	
	AVR32_ADC.mr |= 0x1 << AVR32_ADC_MR_PRESCAL_OFFSET;
80004f98:	fe 77 3c 00 	mov	r7,-50176
80004f9c:	6e 18       	ld.w	r8,r7[0x4]
80004f9e:	a9 a8       	sbr	r8,0x8
80004fa0:	8f 18       	st.w	r7[0x4],r8
	adc_configure(&AVR32_ADC);
80004fa2:	0e 9c       	mov	r12,r7
80004fa4:	f0 1f 00 58 	mcall	80005104 <main+0x480>
	adc_enable(&AVR32_ADC, 0);//Habilitar ADC canal 0
80004fa8:	30 0b       	mov	r11,0
80004faa:	0e 9c       	mov	r12,r7
80004fac:	f0 1f 00 57 	mcall	80005108 <main+0x484>
	adc_enable(&AVR32_ADC, 2);//Habilitar ADC canal 2
80004fb0:	30 2b       	mov	r11,2
80004fb2:	0e 9c       	mov	r12,r7
80004fb4:	f0 1f 00 55 	mcall	80005108 <main+0x484>
	
	
	xTaskCreate( vTareaADC, "Task 1",	1000, NULL,1,  &myTask1Handle);
80004fb8:	30 07       	mov	r7,0
80004fba:	1a d7       	st.w	--sp,r7
80004fbc:	1a d7       	st.w	--sp,r7
80004fbe:	4d 48       	lddpc	r8,8000510c <main+0x488>
80004fc0:	1a d8       	st.w	--sp,r8
80004fc2:	30 18       	mov	r8,1
80004fc4:	0e 99       	mov	r9,r7
80004fc6:	e0 6a 03 e8 	mov	r10,1000
80004fca:	4d 2b       	lddpc	r11,80005110 <main+0x48c>
80004fcc:	4d 2c       	lddpc	r12,80005114 <main+0x490>
80004fce:	f0 1f 00 53 	mcall	80005118 <main+0x494>
	xTaskCreate( vTareaAudioTemperatura, "Task 2", 1000, NULL, 1, &myTask2Handle);
80004fd2:	2f 7d       	sub	sp,-36
80004fd4:	1a d7       	st.w	--sp,r7
80004fd6:	1a d7       	st.w	--sp,r7
80004fd8:	4d 16       	lddpc	r6,8000511c <main+0x498>
80004fda:	1a d6       	st.w	--sp,r6
80004fdc:	30 18       	mov	r8,1
80004fde:	0e 99       	mov	r9,r7
80004fe0:	e0 6a 03 e8 	mov	r10,1000
80004fe4:	4c fb       	lddpc	r11,80005120 <main+0x49c>
80004fe6:	4d 0c       	lddpc	r12,80005124 <main+0x4a0>
80004fe8:	f0 1f 00 4c 	mcall	80005118 <main+0x494>
	xTaskCreate( vTareaLCD, "Task 3", 1000, NULL, 1, &myTask3Handle);
80004fec:	1a d7       	st.w	--sp,r7
80004fee:	1a d7       	st.w	--sp,r7
80004ff0:	4c e8       	lddpc	r8,80005128 <main+0x4a4>
80004ff2:	1a d8       	st.w	--sp,r8
80004ff4:	30 18       	mov	r8,1
80004ff6:	0e 99       	mov	r9,r7
80004ff8:	e0 6a 03 e8 	mov	r10,1000
80004ffc:	4c cb       	lddpc	r11,8000512c <main+0x4a8>
80004ffe:	4c dc       	lddpc	r12,80005130 <main+0x4ac>
80005000:	f0 1f 00 46 	mcall	80005118 <main+0x494>
	xTaskCreate( vTareaAudioGas, "Task 4", 1000, NULL, 1, &myTask4Handle);
80005004:	1a d7       	st.w	--sp,r7
80005006:	1a d7       	st.w	--sp,r7
80005008:	4c b5       	lddpc	r5,80005134 <main+0x4b0>
8000500a:	1a d5       	st.w	--sp,r5
8000500c:	30 18       	mov	r8,1
8000500e:	0e 99       	mov	r9,r7
80005010:	e0 6a 03 e8 	mov	r10,1000
80005014:	4c 9b       	lddpc	r11,80005138 <main+0x4b4>
80005016:	4c ac       	lddpc	r12,8000513c <main+0x4b8>
80005018:	f0 1f 00 40 	mcall	80005118 <main+0x494>
	xTaskCreate( vTareaAudioLuces, "Task 5", 1000, NULL, 1, &myTask5Handle);
8000501c:	2f 7d       	sub	sp,-36
8000501e:	1a d7       	st.w	--sp,r7
80005020:	1a d7       	st.w	--sp,r7
80005022:	4c 84       	lddpc	r4,80005140 <main+0x4bc>
80005024:	1a d4       	st.w	--sp,r4
80005026:	30 18       	mov	r8,1
80005028:	0e 99       	mov	r9,r7
8000502a:	e0 6a 03 e8 	mov	r10,1000
8000502e:	4c 6b       	lddpc	r11,80005144 <main+0x4c0>
80005030:	4c 6c       	lddpc	r12,80005148 <main+0x4c4>
80005032:	f0 1f 00 3a 	mcall	80005118 <main+0x494>
	xTaskCreate( vTareaSD, "Task 6", 1000, NULL, 1, &myTask6Handle);
80005036:	1a d7       	st.w	--sp,r7
80005038:	1a d7       	st.w	--sp,r7
8000503a:	4c 58       	lddpc	r8,8000514c <main+0x4c8>
8000503c:	1a d8       	st.w	--sp,r8
8000503e:	30 18       	mov	r8,1
80005040:	0e 99       	mov	r9,r7
80005042:	e0 6a 03 e8 	mov	r10,1000
80005046:	4c 3b       	lddpc	r11,80005150 <main+0x4cc>
80005048:	4c 3c       	lddpc	r12,80005154 <main+0x4d0>
8000504a:	f0 1f 00 34 	mcall	80005118 <main+0x494>
	xTaskCreate( vTareaSD_RX, "Task 7", 1000, NULL, 1, &myTask7Handle);
8000504e:	1a d7       	st.w	--sp,r7
80005050:	1a d7       	st.w	--sp,r7
80005052:	4c 28       	lddpc	r8,80005158 <main+0x4d4>
80005054:	1a d8       	st.w	--sp,r8
80005056:	30 18       	mov	r8,1
80005058:	0e 99       	mov	r9,r7
8000505a:	e0 6a 03 e8 	mov	r10,1000
8000505e:	4c 0b       	lddpc	r11,8000515c <main+0x4d8>
80005060:	4c 0c       	lddpc	r12,80005160 <main+0x4dc>
80005062:	f0 1f 00 2e 	mcall	80005118 <main+0x494>
	vTaskSuspend(myTask2Handle);
80005066:	2f 7d       	sub	sp,-36
80005068:	6c 0c       	ld.w	r12,r6[0x0]
8000506a:	f0 1f 00 3f 	mcall	80005164 <main+0x4e0>
	vTaskSuspend(myTask4Handle);
8000506e:	6a 0c       	ld.w	r12,r5[0x0]
80005070:	f0 1f 00 3d 	mcall	80005164 <main+0x4e0>
	vTaskSuspend(myTask5Handle);
80005074:	68 0c       	ld.w	r12,r4[0x0]
80005076:	f0 1f 00 3c 	mcall	80005164 <main+0x4e0>
	//vTaskSuspend(myTask7Handle);
	xMutex=xSemaphoreCreateMutex();
8000507a:	f0 1f 00 3c 	mcall	80005168 <main+0x4e4>
8000507e:	4b c8       	lddpc	r8,8000516c <main+0x4e8>
80005080:	91 0c       	st.w	r8[0x0],r12
	xMutexSD=xSemaphoreCreateMutex();
80005082:	f0 1f 00 3a 	mcall	80005168 <main+0x4e4>
80005086:	4b b8       	lddpc	r8,80005170 <main+0x4ec>
80005088:	91 0c       	st.w	r8[0x0],r12
	xMutexAudio=xSemaphoreCreateMutex();    
8000508a:	f0 1f 00 38 	mcall	80005168 <main+0x4e4>
8000508e:	4b a8       	lddpc	r8,80005174 <main+0x4f0>
80005090:	91 0c       	st.w	r8[0x0],r12
// 	gpio_enable_pin_interrupt(57, 1);
	
//	Enable_global_interrupt();

	//Start the scheduler so the tasks start executing. 
	vTaskStartScheduler(); 
80005092:	f0 1f 00 3a 	mcall	80005178 <main+0x4f4>
80005096:	c0 08       	rjmp	80005096 <main+0x412>
80005098:	80 00       	ld.sh	r0,r0[0x0]
8000509a:	4b 90       	lddpc	r0,8000517c <vTareaSD_RX>
8000509c:	80 00       	ld.sh	r0,r0[0x0]
8000509e:	37 58       	mov	r8,117
800050a0:	80 00       	ld.sh	r0,r0[0x0]
800050a2:	45 bc       	lddsp	r12,sp[0x16c]
800050a4:	00 00       	add	r0,r0
800050a6:	00 0c       	add	r12,r0
800050a8:	80 00       	ld.sh	r0,r0[0x0]
800050aa:	45 4c       	lddsp	r12,sp[0x150]
800050ac:	80 00       	ld.sh	r0,r0[0x0]
800050ae:	45 82       	lddsp	r2,sp[0x160]
800050b0:	80 00       	ld.sh	r0,r0[0x0]
800050b2:	35 1c       	mov	r12,81
800050b4:	80 00       	ld.sh	r0,r0[0x0]
800050b6:	45 94       	lddsp	r4,sp[0x164]
800050b8:	80 00       	ld.sh	r0,r0[0x0]
800050ba:	36 d0       	mov	r0,109
800050bc:	80 00       	ld.sh	r0,r0[0x0]
800050be:	33 c4       	mov	r4,60
800050c0:	80 00       	ld.sh	r0,r0[0x0]
800050c2:	35 78       	mov	r8,87
800050c4:	80 00       	ld.sh	r0,r0[0x0]
800050c6:	35 5c       	mov	r12,85
800050c8:	80 02       	ld.sh	r2,r0[0x0]
800050ca:	27 38       	sub	r8,115
800050cc:	80 00       	ld.sh	r0,r0[0x0]
800050ce:	40 ac       	lddsp	r12,sp[0x28]
800050d0:	80 01       	ld.sh	r1,r0[0x0]
800050d2:	7d 1c       	ld.w	r12,lr[0x44]
800050d4:	80 00       	ld.sh	r0,r0[0x0]
800050d6:	48 44       	lddpc	r4,800050e4 <main+0x460>
800050d8:	80 00       	ld.sh	r0,r0[0x0]
800050da:	2f 74       	sub	r4,-9
800050dc:	80 00       	ld.sh	r0,r0[0x0]
800050de:	4b 8c       	lddpc	r12,800051bc <vTareaSD_RX+0x40>
800050e0:	80 00       	ld.sh	r0,r0[0x0]
800050e2:	30 5c       	mov	r12,5
800050e4:	80 00       	ld.sh	r0,r0[0x0]
800050e6:	2e 1c       	sub	r12,-31
800050e8:	80 01       	ld.sh	r1,r0[0x0]
800050ea:	7d 10       	ld.w	r0,lr[0x44]
800050ec:	80 00       	ld.sh	r0,r0[0x0]
800050ee:	4a 18       	lddpc	r8,80005170 <main+0x4ec>
800050f0:	80 02       	ld.sh	r2,r0[0x0]
800050f2:	28 14       	sub	r4,-127
800050f4:	80 00       	ld.sh	r0,r0[0x0]
800050f6:	2b 98       	sub	r8,-71
800050f8:	80 00       	ld.sh	r0,r0[0x0]
800050fa:	2b d0       	sub	r0,-67
800050fc:	80 00       	ld.sh	r0,r0[0x0]
800050fe:	2d 28       	sub	r8,-46
80005100:	80 00       	ld.sh	r0,r0[0x0]
80005102:	2b 44       	sub	r4,-76
80005104:	80 00       	ld.sh	r0,r0[0x0]
80005106:	3e d4       	mov	r4,-19
80005108:	80 00       	ld.sh	r0,r0[0x0]
8000510a:	3e ec       	mov	r12,-18
8000510c:	00 00       	add	r0,r0
8000510e:	06 88       	andn	r8,r3
80005110:	80 02       	ld.sh	r2,r0[0x0]
80005112:	27 88       	sub	r8,120
80005114:	80 00       	ld.sh	r0,r0[0x0]
80005116:	5a 00       	cp.w	r0,-32
80005118:	80 00       	ld.sh	r0,r0[0x0]
8000511a:	6b 64       	ld.w	r4,r5[0x58]
8000511c:	00 00       	add	r0,r0
8000511e:	06 90       	mov	r0,r3
80005120:	80 02       	ld.sh	r2,r0[0x0]
80005122:	27 90       	sub	r0,121
80005124:	80 00       	ld.sh	r0,r0[0x0]
80005126:	59 84       	cp.w	r4,24
80005128:	00 00       	add	r0,r0
8000512a:	06 7c       	tst	r12,r3
8000512c:	80 02       	ld.sh	r2,r0[0x0]
8000512e:	27 98       	sub	r8,121
80005130:	80 00       	ld.sh	r0,r0[0x0]
80005132:	53 8c       	stdsp	sp[0xe0],r12
80005134:	00 00       	add	r0,r0
80005136:	06 84       	andn	r4,r3
80005138:	80 02       	ld.sh	r2,r0[0x0]
8000513a:	27 a0       	sub	r0,122
8000513c:	80 00       	ld.sh	r0,r0[0x0]
8000513e:	59 08       	cp.w	r8,16
80005140:	00 00       	add	r0,r0
80005142:	06 8c       	andn	r12,r3
80005144:	80 02       	ld.sh	r2,r0[0x0]
80005146:	27 a8       	sub	r8,122
80005148:	80 00       	ld.sh	r0,r0[0x0]
8000514a:	58 8c       	cp.w	r12,8
8000514c:	00 00       	add	r0,r0
8000514e:	06 94       	mov	r4,r3
80005150:	80 02       	ld.sh	r2,r0[0x0]
80005152:	27 b0       	sub	r0,123
80005154:	80 00       	ld.sh	r0,r0[0x0]
80005156:	52 50       	stdsp	sp[0x94],r0
80005158:	00 00       	add	r0,r0
8000515a:	06 80       	andn	r0,r3
8000515c:	80 02       	ld.sh	r2,r0[0x0]
8000515e:	27 b8       	sub	r8,123
80005160:	80 00       	ld.sh	r0,r0[0x0]
80005162:	51 7c       	stdsp	sp[0x5c],r12
80005164:	80 00       	ld.sh	r0,r0[0x0]
80005166:	69 50       	ld.w	r0,r4[0x54]
80005168:	80 00       	ld.sh	r0,r0[0x0]
8000516a:	63 64       	ld.w	r4,r1[0x58]
8000516c:	00 00       	add	r0,r0
8000516e:	0e 34       	cp.w	r4,r7
80005170:	00 00       	add	r0,r0
80005172:	0a 38       	cp.w	r8,r5
80005174:	00 00       	add	r0,r0
80005176:	10 54       	eor	r4,r8
80005178:	80 00       	ld.sh	r0,r0[0x0]
8000517a:	6d 4c       	ld.w	r12,r6[0x50]

8000517c <vTareaSD_RX>:
			xSemaphoreGive(xMutexSD);
			vTaskDelay(100);
		}
	}
}
void vTareaSD_RX( void *pvParameters ){
8000517c:	d4 31       	pushm	r0-r7,lr
	while(1){
		if(xSemaphoreTake(xMutexSD,0xFFFFFFFF)==1){
8000517e:	4a 73       	lddpc	r3,80005218 <vTareaSD_RX+0x9c>
80005180:	30 05       	mov	r5,0
80005182:	3f f4       	mov	r4,-1
				et024006_PrintString(buffer_rx_spi, (const unsigned char *)&FONT6x8, 0, 100+(k*10), RED, -1);
				rxFlag = 0;*/
					if (sd_mmc_spi_mem_check()){
						sd_mmc_spi_read_open(k);
						spi_write(SD_MMC_SPI,0xFF); // Write a first dummy data to synchronize transfer
						sd_mmc_spi_read_sector_to_ram(&buffer_rx_spi);
80005184:	4a 62       	lddpc	r2,8000521c <vTareaSD_RX+0xa0>
		}
	}
}
void vTareaSD_RX( void *pvParameters ){
	while(1){
		if(xSemaphoreTake(xMutexSD,0xFFFFFFFF)==1){
80005186:	0a 99       	mov	r9,r5
80005188:	08 9a       	mov	r10,r4
8000518a:	0a 9b       	mov	r11,r5
8000518c:	66 0c       	ld.w	r12,r3[0x0]
8000518e:	f0 1f 00 25 	mcall	80005220 <vTareaSD_RX+0xa4>
80005192:	58 1c       	cp.w	r12,1
80005194:	cf 91       	brne	80005186 <vTareaSD_RX+0xa>
			if(gpio_get_pin_value(QT1081_TOUCH_SENSOR_ENTER)==1){
80005196:	33 ac       	mov	r12,58
80005198:	f0 1f 00 23 	mcall	80005224 <vTareaSD_RX+0xa8>
8000519c:	c3 70       	breq	8000520a <vTareaSD_RX+0x8e>
			et024006_DrawFilledRect(0 , 0, ET024006_WIDTH, ET024006_HEIGHT, BLACK);
8000519e:	0a 98       	mov	r8,r5
800051a0:	e0 69 00 f0 	mov	r9,240
800051a4:	e0 6a 01 40 	mov	r10,320
800051a8:	0a 9b       	mov	r11,r5
800051aa:	0a 9c       	mov	r12,r5
800051ac:	f0 1f 00 1f 	mcall	80005228 <vTareaSD_RX+0xac>
			et024006_PrintString("Mensajes guardados en SD:", (const unsigned char *)&FONT6x8, 0, 90, RED, -1);
800051b0:	49 f1       	lddpc	r1,8000522c <vTareaSD_RX+0xb0>
800051b2:	1a d4       	st.w	--sp,r4
800051b4:	e0 68 f8 00 	mov	r8,63488
800051b8:	35 a9       	mov	r9,90
800051ba:	0a 9a       	mov	r10,r5
800051bc:	02 9b       	mov	r11,r1
800051be:	49 dc       	lddpc	r12,80005230 <vTareaSD_RX+0xb4>
800051c0:	f0 1f 00 1d 	mcall	80005234 <vTareaSD_RX+0xb8>
800051c4:	37 d6       	mov	r6,125
800051c6:	30 57       	mov	r7,5
800051c8:	2f fd       	sub	sp,-4
				while(rxFlag == 0);
				et024006_PrintString(buffer_rx_spi, (const unsigned char *)&FONT6x8, 0, 100+(k*10), RED, -1);
				rxFlag = 0;*/
					if (sd_mmc_spi_mem_check()){
						sd_mmc_spi_read_open(k);
						spi_write(SD_MMC_SPI,0xFF); // Write a first dummy data to synchronize transfer
800051ca:	e0 60 00 ff 	mov	r0,255
				pdca_channelrx->cr = AVR32_PDCA_TEN_MASK; // Enable RX PDCA transfer first
				pdca_channeltx->cr = AVR32_PDCA_TEN_MASK; // and TX PDCA transfer
				while(rxFlag == 0);
				et024006_PrintString(buffer_rx_spi, (const unsigned char *)&FONT6x8, 0, 100+(k*10), RED, -1);
				rxFlag = 0;*/
					if (sd_mmc_spi_mem_check()){
800051ce:	f0 1f 00 1b 	mcall	80005238 <vTareaSD_RX+0xbc>
800051d2:	c1 80       	breq	80005202 <vTareaSD_RX+0x86>
						sd_mmc_spi_read_open(k);
800051d4:	0e 9c       	mov	r12,r7
800051d6:	f0 1f 00 1a 	mcall	8000523c <vTareaSD_RX+0xc0>
						spi_write(SD_MMC_SPI,0xFF); // Write a first dummy data to synchronize transfer
800051da:	00 9b       	mov	r11,r0
800051dc:	fe 7c 24 00 	mov	r12,-56320
800051e0:	f0 1f 00 18 	mcall	80005240 <vTareaSD_RX+0xc4>
						sd_mmc_spi_read_sector_to_ram(&buffer_rx_spi);
800051e4:	04 9c       	mov	r12,r2
800051e6:	f0 1f 00 18 	mcall	80005244 <vTareaSD_RX+0xc8>
						et024006_PrintString(buffer_rx_spi, (const unsigned char *)&FONT6x8, 0, 100+(k*5), RED, -1);
800051ea:	1a d4       	st.w	--sp,r4
800051ec:	e0 68 f8 00 	mov	r8,63488
800051f0:	0c 99       	mov	r9,r6
800051f2:	0a 9a       	mov	r10,r5
800051f4:	02 9b       	mov	r11,r1
800051f6:	04 9c       	mov	r12,r2
800051f8:	f0 1f 00 0f 	mcall	80005234 <vTareaSD_RX+0xb8>
						
						sd_mmc_spi_read_close();
800051fc:	f0 1f 00 13 	mcall	80005248 <vTareaSD_RX+0xcc>
80005200:	2f fd       	sub	sp,-4
	while(1){
		if(xSemaphoreTake(xMutexSD,0xFFFFFFFF)==1){
			if(gpio_get_pin_value(QT1081_TOUCH_SENSOR_ENTER)==1){
			et024006_DrawFilledRect(0 , 0, ET024006_WIDTH, ET024006_HEIGHT, BLACK);
			et024006_PrintString("Mensajes guardados en SD:", (const unsigned char *)&FONT6x8, 0, 90, RED, -1);
				for(int k = 5; k <=20; k++){
80005202:	2f f7       	sub	r7,-1
80005204:	2f b6       	sub	r6,-5
80005206:	59 57       	cp.w	r7,21
80005208:	ce 31       	brne	800051ce <vTareaSD_RX+0x52>
				
					}
				}
			}
			//gpio_clr_gpio_pin(LED3_GPIO);
			xSemaphoreGive(xMutexSD);
8000520a:	0a 99       	mov	r9,r5
8000520c:	0a 9a       	mov	r10,r5
8000520e:	0a 9b       	mov	r11,r5
80005210:	66 0c       	ld.w	r12,r3[0x0]
80005212:	f0 1f 00 0f 	mcall	8000524c <vTareaSD_RX+0xd0>
80005216:	cb 8b       	rjmp	80005186 <vTareaSD_RX+0xa>
80005218:	00 00       	add	r0,r0
8000521a:	0a 38       	cp.w	r8,r5
8000521c:	00 00       	add	r0,r0
8000521e:	0a 44       	or	r4,r5
80005220:	80 00       	ld.sh	r0,r0[0x0]
80005222:	60 a8       	ld.w	r8,r0[0x28]
80005224:	80 00       	ld.sh	r0,r0[0x0]
80005226:	41 1c       	lddsp	r12,sp[0x44]
80005228:	80 00       	ld.sh	r0,r0[0x0]
8000522a:	35 1c       	mov	r12,81
8000522c:	80 00       	ld.sh	r0,r0[0x0]
8000522e:	cc 38       	rjmp	800053b4 <vTareaLCD+0x28>
80005230:	80 02       	ld.sh	r2,r0[0x0]
80005232:	27 c0       	sub	r0,124
80005234:	80 00       	ld.sh	r0,r0[0x0]
80005236:	31 88       	mov	r8,24
80005238:	80 00       	ld.sh	r0,r0[0x0]
8000523a:	2b 1c       	sub	r12,-79
8000523c:	80 00       	ld.sh	r0,r0[0x0]
8000523e:	21 dc       	sub	r12,29
80005240:	80 00       	ld.sh	r0,r0[0x0]
80005242:	2d 2e       	sub	lr,-46
80005244:	80 00       	ld.sh	r0,r0[0x0]
80005246:	26 20       	sub	r0,98
80005248:	80 00       	ld.sh	r0,r0[0x0]
8000524a:	21 d0       	sub	r0,29
8000524c:	80 00       	ld.sh	r0,r0[0x0]
8000524e:	62 64       	ld.w	r4,r1[0x18]

80005250 <vTareaSD>:
			}
		}
		vTaskDelay(100);
	}
}
void vTareaSD( void *pvParameters ){
80005250:	d4 31       	pushm	r0-r7,lr
80005252:	20 3d       	sub	sp,12
80005254:	30 54       	mov	r4,5
	int temperaturaSDRecibido;
	int gasSDRecibido;
	int iluminosidadSDRecibido;
	int seccion=5;
	while(1){
		if(xSemaphoreTake(xMutexSD,0xFFFFFFFF)==1){
80005256:	4c 06       	lddpc	r6,80005354 <vTareaSD+0x104>
80005258:	30 07       	mov	r7,0
8000525a:	3f f5       	mov	r5,-1
			if(temperaturaSDQueue!=0){
8000525c:	4b f2       	lddpc	r2,80005358 <vTareaSD+0x108>
					if(seccion >= 20){
						seccion = 5;
					}
				}
			}
			if(gasSDQueue!=0){
8000525e:	4c 01       	lddpc	r1,8000535c <vTareaSD+0x10c>
					if(seccion >= 20){
						seccion = 5;
					}
				}
			}
			if(iluminosidadSDQueue!=0){
80005260:	4c 00       	lddpc	r0,80005360 <vTareaSD+0x110>
				xQueueReceive(iluminosidadSDQueue,(void*)&iluminosidadSDRecibido,5);
80005262:	08 93       	mov	r3,r4
	int temperaturaSDRecibido;
	int gasSDRecibido;
	int iluminosidadSDRecibido;
	int seccion=5;
	while(1){
		if(xSemaphoreTake(xMutexSD,0xFFFFFFFF)==1){
80005264:	0e 99       	mov	r9,r7
80005266:	0a 9a       	mov	r10,r5
80005268:	0e 9b       	mov	r11,r7
8000526a:	6c 0c       	ld.w	r12,r6[0x0]
8000526c:	f0 1f 00 3e 	mcall	80005364 <vTareaSD+0x114>
80005270:	58 1c       	cp.w	r12,1
80005272:	cf 91       	brne	80005264 <vTareaSD+0x14>
			if(temperaturaSDQueue!=0){
80005274:	64 0c       	ld.w	r12,r2[0x0]
80005276:	58 0c       	cp.w	r12,0
80005278:	c2 00       	breq	800052b8 <vTareaSD+0x68>
				xQueueReceive(temperaturaSDQueue,(void*)&temperaturaSDRecibido,5);
8000527a:	0e 99       	mov	r9,r7
8000527c:	06 9a       	mov	r10,r3
8000527e:	fa cb ff f8 	sub	r11,sp,-8
80005282:	f0 1f 00 39 	mcall	80005364 <vTareaSD+0x114>
				float temperatura=(float)temperaturaSDRecibido;
				sprintf(buffer_rx,"%d",10000);//+(temperatura/80*23));
80005286:	4b 98       	lddpc	r8,80005368 <vTareaSD+0x118>
80005288:	70 0c       	ld.w	r12,r8[0x0]
8000528a:	e0 68 27 10 	mov	r8,10000
8000528e:	1a d8       	st.w	--sp,r8
80005290:	4b 7b       	lddpc	r11,8000536c <vTareaSD+0x11c>
80005292:	f0 1f 00 38 	mcall	80005370 <vTareaSD+0x120>
				if (sd_mmc_spi_mem_check()){
80005296:	f0 1f 00 38 	mcall	80005374 <vTareaSD+0x124>
8000529a:	2f fd       	sub	sp,-4
8000529c:	58 0c       	cp.w	r12,0
8000529e:	c0 d0       	breq	800052b8 <vTareaSD+0x68>
					sd_mmc_spi_write_open(seccion);
800052a0:	08 9c       	mov	r12,r4
800052a2:	f0 1f 00 36 	mcall	80005378 <vTareaSD+0x128>
					//et024006_PrintString(buffer_rx,(const unsigned char *)&FONT8x16,45,115,RED,-1);
					sd_mmc_spi_write_sector_from_ram(&buffer_rx);
800052a6:	4b 1c       	lddpc	r12,80005368 <vTareaSD+0x118>
800052a8:	f0 1f 00 35 	mcall	8000537c <vTareaSD+0x12c>
					sd_mmc_spi_write_close();
800052ac:	f0 1f 00 35 	mcall	80005380 <vTareaSD+0x130>
					seccion++;
800052b0:	2f f4       	sub	r4,-1
					if(seccion >= 20){
800052b2:	59 44       	cp.w	r4,20
800052b4:	f9 b4 04 05 	movge	r4,5
						seccion = 5;
					}
				}
			}
			if(gasSDQueue!=0){
800052b8:	62 0c       	ld.w	r12,r1[0x0]
800052ba:	58 0c       	cp.w	r12,0
800052bc:	c2 00       	breq	800052fc <vTareaSD+0xac>
				xQueueReceive(gasSDQueue,(void*)&gasSDRecibido,5);
800052be:	0e 99       	mov	r9,r7
800052c0:	06 9a       	mov	r10,r3
800052c2:	fa cb ff fc 	sub	r11,sp,-4
800052c6:	f0 1f 00 28 	mcall	80005364 <vTareaSD+0x114>
				if (sd_mmc_spi_mem_check()){
800052ca:	f0 1f 00 2b 	mcall	80005374 <vTareaSD+0x124>
800052ce:	c1 70       	breq	800052fc <vTareaSD+0xac>
					sd_mmc_spi_write_open(seccion);
800052d0:	08 9c       	mov	r12,r4
800052d2:	f0 1f 00 2a 	mcall	80005378 <vTareaSD+0x128>
					sprintf(buffer_rx,"%d",20000+gasSDRecibido);
800052d6:	4a 58       	lddpc	r8,80005368 <vTareaSD+0x118>
800052d8:	70 0c       	ld.w	r12,r8[0x0]
800052da:	40 18       	lddsp	r8,sp[0x4]
800052dc:	f0 c8 b1 e0 	sub	r8,r8,-20000
800052e0:	1a d8       	st.w	--sp,r8
800052e2:	4a 3b       	lddpc	r11,8000536c <vTareaSD+0x11c>
800052e4:	f0 1f 00 23 	mcall	80005370 <vTareaSD+0x120>
					//et024006_PrintString(buffer_rx,(const unsigned char *)&FONT8x16,45,115,RED,-1);
					sd_mmc_spi_write_sector_from_ram(&buffer_rx);
800052e8:	4a 0c       	lddpc	r12,80005368 <vTareaSD+0x118>
800052ea:	f0 1f 00 25 	mcall	8000537c <vTareaSD+0x12c>
					sd_mmc_spi_write_close();
800052ee:	f0 1f 00 25 	mcall	80005380 <vTareaSD+0x130>
					seccion++;
800052f2:	2f f4       	sub	r4,-1
					if(seccion >= 20){
800052f4:	2f fd       	sub	sp,-4
800052f6:	59 44       	cp.w	r4,20
800052f8:	f9 b4 04 05 	movge	r4,5
						seccion = 5;
					}
				}
			}
			if(iluminosidadSDQueue!=0){
800052fc:	60 0c       	ld.w	r12,r0[0x0]
800052fe:	58 0c       	cp.w	r12,0
80005300:	c1 f0       	breq	8000533e <vTareaSD+0xee>
				xQueueReceive(iluminosidadSDQueue,(void*)&iluminosidadSDRecibido,5);
80005302:	0e 99       	mov	r9,r7
80005304:	06 9a       	mov	r10,r3
80005306:	1a 9b       	mov	r11,sp
80005308:	f0 1f 00 17 	mcall	80005364 <vTareaSD+0x114>
				if (sd_mmc_spi_mem_check()){
8000530c:	f0 1f 00 1a 	mcall	80005374 <vTareaSD+0x124>
80005310:	c1 70       	breq	8000533e <vTareaSD+0xee>
					sd_mmc_spi_write_open(seccion);
80005312:	08 9c       	mov	r12,r4
80005314:	f0 1f 00 19 	mcall	80005378 <vTareaSD+0x128>
					sprintf(buffer_rx,"%d",30000+iluminosidadSDRecibido);
80005318:	49 48       	lddpc	r8,80005368 <vTareaSD+0x118>
8000531a:	70 0c       	ld.w	r12,r8[0x0]
8000531c:	40 08       	lddsp	r8,sp[0x0]
8000531e:	f0 c8 8a d0 	sub	r8,r8,-30000
80005322:	1a d8       	st.w	--sp,r8
80005324:	49 2b       	lddpc	r11,8000536c <vTareaSD+0x11c>
80005326:	f0 1f 00 13 	mcall	80005370 <vTareaSD+0x120>
					//et024006_PrintString(buffer_rx,(const unsigned char *)&FONT8x16,45,115,RED,-1);
					sd_mmc_spi_write_sector_from_ram(&buffer_rx);
8000532a:	49 0c       	lddpc	r12,80005368 <vTareaSD+0x118>
8000532c:	f0 1f 00 14 	mcall	8000537c <vTareaSD+0x12c>
					sd_mmc_spi_write_close();
80005330:	f0 1f 00 14 	mcall	80005380 <vTareaSD+0x130>
					seccion++;
80005334:	2f f4       	sub	r4,-1
					if(seccion >= 20){
80005336:	2f fd       	sub	sp,-4
80005338:	59 44       	cp.w	r4,20
8000533a:	f9 b4 04 05 	movge	r4,5
						seccion = 5;
					}
				}
			}
			xSemaphoreGive(xMutexSD);
8000533e:	0e 99       	mov	r9,r7
80005340:	0e 9a       	mov	r10,r7
80005342:	0e 9b       	mov	r11,r7
80005344:	6c 0c       	ld.w	r12,r6[0x0]
80005346:	f0 1f 00 10 	mcall	80005384 <vTareaSD+0x134>
			vTaskDelay(100);
8000534a:	36 4c       	mov	r12,100
8000534c:	f0 1f 00 0f 	mcall	80005388 <vTareaSD+0x138>
80005350:	c8 ab       	rjmp	80005264 <vTareaSD+0x14>
80005352:	00 00       	add	r0,r0
80005354:	00 00       	add	r0,r0
80005356:	0a 38       	cp.w	r8,r5
80005358:	00 00       	add	r0,r0
8000535a:	0e 3c       	cp.w	r12,r7
8000535c:	00 00       	add	r0,r0
8000535e:	10 4c       	or	r12,r8
80005360:	00 00       	add	r0,r0
80005362:	0a 40       	or	r0,r5
80005364:	80 00       	ld.sh	r0,r0[0x0]
80005366:	60 a8       	ld.w	r8,r0[0x28]
80005368:	00 00       	add	r0,r0
8000536a:	0e 30       	cp.w	r0,r7
8000536c:	80 02       	ld.sh	r2,r0[0x0]
8000536e:	27 dc       	sub	r12,125
80005370:	80 00       	ld.sh	r0,r0[0x0]
80005372:	84 70       	ld.sh	r0,r2[0xe]
80005374:	80 00       	ld.sh	r0,r0[0x0]
80005376:	2b 1c       	sub	r12,-79
80005378:	80 00       	ld.sh	r0,r0[0x0]
8000537a:	21 b4       	sub	r4,27
8000537c:	80 00       	ld.sh	r0,r0[0x0]
8000537e:	23 7c       	sub	r12,55
80005380:	80 00       	ld.sh	r0,r0[0x0]
80005382:	21 24       	sub	r4,18
80005384:	80 00       	ld.sh	r0,r0[0x0]
80005386:	62 64       	ld.w	r4,r1[0x18]
80005388:	80 00       	ld.sh	r0,r0[0x0]
8000538a:	6a 44       	ld.w	r4,r5[0x10]

8000538c <vTareaLCD>:
		while(!tpa6130_dac_output(NULL, 0));
		xSemaphoreGive(xMutexAudio);
	}
	}
}
void vTareaLCD( void *pvParameters ){
8000538c:	d4 31       	pushm	r0-r7,lr
8000538e:	20 3d       	sub	sp,12
	int gasRecibido;
	int iluminosidadRecibido;
	int temperaturaPrimeraVez=1;
	int gasPrimeraVez=1;
	while(1){
		if(temperaturaQueue!=0){
80005390:	fe f5 04 98 	ld.w	r5,pc[1176]
			xQueueReceive(temperaturaQueue,(void*)&temperaturaRecibido,5);	
80005394:	fa c4 ff f8 	sub	r4,sp,-8
80005398:	30 07       	mov	r7,0
8000539a:	30 56       	mov	r6,5
			float temperatura=(float)temperaturaRecibido;
			if((temperatura/80*11)>=14){
8000539c:	fc 13 42 a0 	movh	r3,0x42a0
800053a0:	fc 12 41 30 	movh	r2,0x4130
800053a4:	fc 11 41 60 	movh	r1,0x4160
					//tpa6130_dac_mute(1);
					//vTaskSuspend(myTask2Handle);	
				//}
 			}
 			else{
				 if(gpio_get_pin_value(QT1081_TOUCH_SENSOR_ENTER)==0){
800053a8:	33 a0       	mov	r0,58
	int gasRecibido;
	int iluminosidadRecibido;
	int temperaturaPrimeraVez=1;
	int gasPrimeraVez=1;
	while(1){
		if(temperaturaQueue!=0){
800053aa:	6a 0c       	ld.w	r12,r5[0x0]
800053ac:	58 0c       	cp.w	r12,0
800053ae:	c5 50       	breq	80005458 <vTareaLCD+0xcc>
			xQueueReceive(temperaturaQueue,(void*)&temperaturaRecibido,5);	
800053b0:	0e 99       	mov	r9,r7
800053b2:	0c 9a       	mov	r10,r6
800053b4:	08 9b       	mov	r11,r4
800053b6:	f0 1f 01 1e 	mcall	8000582c <vTareaLCD+0x4a0>
			float temperatura=(float)temperaturaRecibido;
			if((temperatura/80*11)>=14){
800053ba:	40 2c       	lddsp	r12,sp[0x8]
800053bc:	f0 1f 01 1d 	mcall	80005830 <vTareaLCD+0x4a4>
800053c0:	06 9b       	mov	r11,r3
800053c2:	f0 1f 01 1d 	mcall	80005834 <vTareaLCD+0x4a8>
800053c6:	04 9b       	mov	r11,r2
800053c8:	f0 1f 01 1c 	mcall	80005838 <vTareaLCD+0x4ac>
800053cc:	02 9b       	mov	r11,r1
800053ce:	f0 1f 01 1c 	mcall	8000583c <vTareaLCD+0x4b0>
800053d2:	c2 30       	breq	80005418 <vTareaLCD+0x8c>
				if(gpio_get_pin_value(QT1081_TOUCH_SENSOR_ENTER)==0){
800053d4:	00 9c       	mov	r12,r0
800053d6:	f0 1f 01 1b 	mcall	80005840 <vTareaLCD+0x4b4>
800053da:	c1 61       	brne	80005406 <vTareaLCD+0x7a>
					et024006_PrintString("Mensajes guardados en SD:", (const unsigned char *)&FONT6x8, 0, 90, BLACK, -1);
800053dc:	3f f8       	mov	r8,-1
800053de:	1a d8       	st.w	--sp,r8
800053e0:	0e 98       	mov	r8,r7
800053e2:	35 a9       	mov	r9,90
800053e4:	0e 9a       	mov	r10,r7
800053e6:	fe fb 04 5e 	ld.w	r11,pc[1118]
800053ea:	fe fc 04 5e 	ld.w	r12,pc[1118]
800053ee:	f0 1f 01 18 	mcall	8000584c <vTareaLCD+0x4c0>
 					et024006_DrawFilledRect(10 , 40, 20, 140, RED );
800053f2:	e0 68 f8 00 	mov	r8,63488
800053f6:	e0 69 00 8c 	mov	r9,140
800053fa:	31 4a       	mov	r10,20
800053fc:	32 8b       	mov	r11,40
800053fe:	30 ac       	mov	r12,10
80005400:	f0 1f 01 14 	mcall	80005850 <vTareaLCD+0x4c4>
80005404:	2f fd       	sub	sp,-4
				}
				gpio_clr_gpio_pin(LED0_GPIO);
80005406:	33 bc       	mov	r12,59
80005408:	f0 1f 01 13 	mcall	80005854 <vTareaLCD+0x4c8>
				//if(temperaturaPrimeraVez==1){
					//temperaturaPrimeraVez=0;
					//tpa6130_dac_mute(0);
					vTaskResume(myTask2Handle);
8000540c:	fe f8 04 4c 	ld.w	r8,pc[1100]
80005410:	70 0c       	ld.w	r12,r8[0x0]
80005412:	f0 1f 01 13 	mcall	8000585c <vTareaLCD+0x4d0>
80005416:	c2 18       	rjmp	80005458 <vTareaLCD+0xcc>
					//tpa6130_dac_mute(1);
					//vTaskSuspend(myTask2Handle);	
				//}
 			}
 			else{
				 if(gpio_get_pin_value(QT1081_TOUCH_SENSOR_ENTER)==0){
80005418:	00 9c       	mov	r12,r0
8000541a:	f0 1f 01 0a 	mcall	80005840 <vTareaLCD+0x4b4>
8000541e:	c1 51       	brne	80005448 <vTareaLCD+0xbc>
					 et024006_PrintString("Mensajes guardados en SD:", (const unsigned char *)&FONT6x8, 0, 90, BLACK, -1);
80005420:	3f f8       	mov	r8,-1
80005422:	1a d8       	st.w	--sp,r8
80005424:	0e 98       	mov	r8,r7
80005426:	35 a9       	mov	r9,90
80005428:	0e 9a       	mov	r10,r7
8000542a:	fe fb 04 1a 	ld.w	r11,pc[1050]
8000542e:	fe fc 04 1a 	ld.w	r12,pc[1050]
80005432:	f0 1f 01 07 	mcall	8000584c <vTareaLCD+0x4c0>
 					et024006_DrawFilledRect(10 , 40, 20, 140,BLUE );
80005436:	31 f8       	mov	r8,31
80005438:	e0 69 00 8c 	mov	r9,140
8000543c:	31 4a       	mov	r10,20
8000543e:	32 8b       	mov	r11,40
80005440:	30 ac       	mov	r12,10
80005442:	f0 1f 01 04 	mcall	80005850 <vTareaLCD+0x4c4>
80005446:	2f fd       	sub	sp,-4
				 }
					gpio_set_gpio_pin(LED0_GPIO);
80005448:	33 bc       	mov	r12,59
8000544a:	f0 1f 01 06 	mcall	80005860 <vTareaLCD+0x4d4>
					vTaskSuspend(myTask2Handle);
8000544e:	fe f8 04 0a 	ld.w	r8,pc[1034]
80005452:	70 0c       	ld.w	r12,r8[0x0]
80005454:	f0 1f 01 04 	mcall	80005864 <vTareaLCD+0x4d8>
			}
		}
		if(gasQueue!=0){
80005458:	fe f8 04 10 	ld.w	r8,pc[1040]
8000545c:	70 0c       	ld.w	r12,r8[0x0]
8000545e:	58 0c       	cp.w	r12,0
80005460:	c6 b0       	breq	80005536 <vTareaLCD+0x1aa>
			xQueueReceive(gasQueue,(void*)&gasRecibido,5);
80005462:	0e 99       	mov	r9,r7
80005464:	0c 9a       	mov	r10,r6
80005466:	fa cb ff fc 	sub	r11,sp,-4
8000546a:	f0 1f 00 f1 	mcall	8000582c <vTareaLCD+0x4a0>
			if(gasRecibido>=250){
8000546e:	40 18       	lddsp	r8,sp[0x4]
80005470:	e0 48 00 f9 	cp.w	r8,249
80005474:	e0 8a 00 2e 	brle	800054d0 <vTareaLCD+0x144>
				
 				et024006_DrawFilledRect(140, 100, 60, 40, RED );
80005478:	e0 68 f8 00 	mov	r8,63488
8000547c:	32 89       	mov	r9,40
8000547e:	33 ca       	mov	r10,60
80005480:	36 4b       	mov	r11,100
80005482:	e0 6c 00 8c 	mov	r12,140
80005486:	f0 1f 00 f3 	mcall	80005850 <vTareaLCD+0x4c4>
 				et024006_DrawHorizLine(120,100,100,RED);
8000548a:	e0 69 f8 00 	mov	r9,63488
8000548e:	36 4a       	mov	r10,100
80005490:	14 9b       	mov	r11,r10
80005492:	37 8c       	mov	r12,120
80005494:	f0 1f 00 f6 	mcall	8000586c <vTareaLCD+0x4e0>
 				et024006_DrawLine(120,100,170,60,RED);
80005498:	e0 68 f8 00 	mov	r8,63488
8000549c:	33 c9       	mov	r9,60
8000549e:	e0 6a 00 aa 	mov	r10,170
800054a2:	36 4b       	mov	r11,100
800054a4:	37 8c       	mov	r12,120
800054a6:	f0 1f 00 f3 	mcall	80005870 <vTareaLCD+0x4e4>
 				et024006_DrawLine(170,60,220,100,RED);
800054aa:	e0 68 f8 00 	mov	r8,63488
800054ae:	36 49       	mov	r9,100
800054b0:	e0 6a 00 dc 	mov	r10,220
800054b4:	33 cb       	mov	r11,60
800054b6:	e0 6c 00 aa 	mov	r12,170
800054ba:	f0 1f 00 ee 	mcall	80005870 <vTareaLCD+0x4e4>
				 gpio_clr_gpio_pin(LED1_GPIO);
800054be:	33 cc       	mov	r12,60
800054c0:	f0 1f 00 e5 	mcall	80005854 <vTareaLCD+0x4c8>
				//if(gasPrimeraVez==1){
					//gasPrimeraVez=0;
					//tpa6130_dac_mute(0);
					vTaskResume(myTask4Handle);
800054c4:	fe f8 03 b0 	ld.w	r8,pc[944]
800054c8:	70 0c       	ld.w	r12,r8[0x0]
800054ca:	f0 1f 00 e5 	mcall	8000585c <vTareaLCD+0x4d0>
800054ce:	c3 48       	rjmp	80005536 <vTareaLCD+0x1aa>
					//vTaskSuspend(myTask4Handle);
				//}
 			}
 			else{
				 
				 et024006_DrawFilledRect(140, 100, 60, 40, RED );
800054d0:	e0 68 f8 00 	mov	r8,63488
800054d4:	32 89       	mov	r9,40
800054d6:	33 ca       	mov	r10,60
800054d8:	36 4b       	mov	r11,100
800054da:	e0 6c 00 8c 	mov	r12,140
800054de:	f0 1f 00 dd 	mcall	80005850 <vTareaLCD+0x4c4>
				 et024006_DrawFilledRect(145, 105, 50, 30, BLACK );
800054e2:	0e 98       	mov	r8,r7
800054e4:	31 e9       	mov	r9,30
800054e6:	33 2a       	mov	r10,50
800054e8:	36 9b       	mov	r11,105
800054ea:	e0 6c 00 91 	mov	r12,145
800054ee:	f0 1f 00 d9 	mcall	80005850 <vTareaLCD+0x4c4>
				 et024006_DrawHorizLine(120,100,100,RED);
800054f2:	e0 69 f8 00 	mov	r9,63488
800054f6:	36 4a       	mov	r10,100
800054f8:	14 9b       	mov	r11,r10
800054fa:	37 8c       	mov	r12,120
800054fc:	f0 1f 00 dc 	mcall	8000586c <vTareaLCD+0x4e0>
				 et024006_DrawLine(120,100,170,60,RED);
80005500:	e0 68 f8 00 	mov	r8,63488
80005504:	33 c9       	mov	r9,60
80005506:	e0 6a 00 aa 	mov	r10,170
8000550a:	36 4b       	mov	r11,100
8000550c:	37 8c       	mov	r12,120
8000550e:	f0 1f 00 d9 	mcall	80005870 <vTareaLCD+0x4e4>
				 et024006_DrawLine(170,60,220,100,RED);
80005512:	e0 68 f8 00 	mov	r8,63488
80005516:	36 49       	mov	r9,100
80005518:	e0 6a 00 dc 	mov	r10,220
8000551c:	33 cb       	mov	r11,60
8000551e:	e0 6c 00 aa 	mov	r12,170
80005522:	f0 1f 00 d4 	mcall	80005870 <vTareaLCD+0x4e4>
				 gpio_set_gpio_pin(LED1_GPIO);
80005526:	33 cc       	mov	r12,60
80005528:	f0 1f 00 ce 	mcall	80005860 <vTareaLCD+0x4d4>
				 vTaskSuspend(myTask4Handle);
8000552c:	fe f8 03 48 	ld.w	r8,pc[840]
80005530:	70 0c       	ld.w	r12,r8[0x0]
80005532:	f0 1f 00 cd 	mcall	80005864 <vTareaLCD+0x4d8>
			 }
		}
		if(iluminosidadQueue!=0){
80005536:	fe f8 03 42 	ld.w	r8,pc[834]
8000553a:	70 0c       	ld.w	r12,r8[0x0]
8000553c:	58 0c       	cp.w	r12,0
8000553e:	e0 80 01 70 	breq	8000581e <vTareaLCD+0x492>
			xQueueReceive(iluminosidadQueue,(void*)&iluminosidadRecibido,5);
80005542:	0e 99       	mov	r9,r7
80005544:	0c 9a       	mov	r10,r6
80005546:	1a 9b       	mov	r11,sp
80005548:	f0 1f 00 b9 	mcall	8000582c <vTareaLCD+0x4a0>
			if(iluminosidadRecibido>=900){
8000554c:	40 08       	lddsp	r8,sp[0x0]
8000554e:	e0 48 03 83 	cp.w	r8,899
80005552:	e0 8a 00 b4 	brle	800056ba <vTareaLCD+0x32e>
				
				et024006_DrawFilledCircle(280,90,30,BLUE,0xFF);
80005556:	e0 68 00 ff 	mov	r8,255
8000555a:	31 f9       	mov	r9,31
8000555c:	31 ea       	mov	r10,30
8000555e:	35 ab       	mov	r11,90
80005560:	e0 6c 01 18 	mov	r12,280
80005564:	f0 1f 00 c6 	mcall	8000587c <vTareaLCD+0x4f0>
				et024006_DrawFilledCircle(280,90,29,BLACK,0xFF);
80005568:	e0 68 00 ff 	mov	r8,255
8000556c:	0e 99       	mov	r9,r7
8000556e:	31 da       	mov	r10,29
80005570:	35 ab       	mov	r11,90
80005572:	e0 6c 01 18 	mov	r12,280
80005576:	f0 1f 00 c2 	mcall	8000587c <vTareaLCD+0x4f0>
				et024006_DrawLine(240,120,250,110,BLUE);
8000557a:	31 f8       	mov	r8,31
8000557c:	36 e9       	mov	r9,110
8000557e:	e0 6a 00 fa 	mov	r10,250
80005582:	37 8b       	mov	r11,120
80005584:	e0 6c 00 f0 	mov	r12,240
80005588:	f0 1f 00 ba 	mcall	80005870 <vTareaLCD+0x4e4>
				et024006_DrawLine(240,100,245,90,BLUE);
8000558c:	31 f8       	mov	r8,31
8000558e:	35 a9       	mov	r9,90
80005590:	e0 6a 00 f5 	mov	r10,245
80005594:	36 4b       	mov	r11,100
80005596:	e0 6c 00 f0 	mov	r12,240
8000559a:	f0 1f 00 b6 	mcall	80005870 <vTareaLCD+0x4e4>
				et024006_DrawLine(240,70,245,80,BLUE);
8000559e:	31 f8       	mov	r8,31
800055a0:	35 09       	mov	r9,80
800055a2:	e0 6a 00 f5 	mov	r10,245
800055a6:	34 6b       	mov	r11,70
800055a8:	e0 6c 00 f0 	mov	r12,240
800055ac:	f0 1f 00 b1 	mcall	80005870 <vTareaLCD+0x4e4>
				et024006_DrawLine(240,50,250,60,BLUE);
800055b0:	31 f8       	mov	r8,31
800055b2:	33 c9       	mov	r9,60
800055b4:	e0 6a 00 fa 	mov	r10,250
800055b8:	33 2b       	mov	r11,50
800055ba:	e0 6c 00 f0 	mov	r12,240
800055be:	f0 1f 00 ad 	mcall	80005870 <vTareaLCD+0x4e4>
				et024006_DrawVertLine(270,40,10,BLUE);
800055c2:	31 f9       	mov	r9,31
800055c4:	30 aa       	mov	r10,10
800055c6:	32 8b       	mov	r11,40
800055c8:	e0 6c 01 0e 	mov	r12,270
800055cc:	f0 1f 00 ad 	mcall	80005880 <vTareaLCD+0x4f4>
				et024006_DrawVertLine(290,40,10,BLUE);
800055d0:	31 f9       	mov	r9,31
800055d2:	30 aa       	mov	r10,10
800055d4:	32 8b       	mov	r11,40
800055d6:	e0 6c 01 22 	mov	r12,290
800055da:	f0 1f 00 aa 	mcall	80005880 <vTareaLCD+0x4f4>
				et024006_DrawLine(310,60,320,50,BLUE);
800055de:	31 f8       	mov	r8,31
800055e0:	33 29       	mov	r9,50
800055e2:	e0 6a 01 40 	mov	r10,320
800055e6:	33 cb       	mov	r11,60
800055e8:	e0 6c 01 36 	mov	r12,310
800055ec:	f0 1f 00 a1 	mcall	80005870 <vTareaLCD+0x4e4>
				et024006_DrawLine(315,80,320,70,BLUE);
800055f0:	31 f8       	mov	r8,31
800055f2:	34 69       	mov	r9,70
800055f4:	e0 6a 01 40 	mov	r10,320
800055f8:	35 0b       	mov	r11,80
800055fa:	e0 6c 01 3b 	mov	r12,315
800055fe:	f0 1f 00 9d 	mcall	80005870 <vTareaLCD+0x4e4>
				et024006_DrawLine(315,90,320,100,BLUE);
80005602:	31 f8       	mov	r8,31
80005604:	36 49       	mov	r9,100
80005606:	e0 6a 01 40 	mov	r10,320
8000560a:	35 ab       	mov	r11,90
8000560c:	e0 6c 01 3b 	mov	r12,315
80005610:	f0 1f 00 98 	mcall	80005870 <vTareaLCD+0x4e4>
				et024006_DrawLine(310,110,320,120,BLUE);
80005614:	31 f8       	mov	r8,31
80005616:	37 89       	mov	r9,120
80005618:	e0 6a 01 40 	mov	r10,320
8000561c:	36 eb       	mov	r11,110
8000561e:	e0 6c 01 36 	mov	r12,310
80005622:	f0 1f 00 94 	mcall	80005870 <vTareaLCD+0x4e4>
				et024006_DrawLine(270,140, 290, 140, BLUE);
80005626:	31 f8       	mov	r8,31
80005628:	e0 69 00 8c 	mov	r9,140
8000562c:	e0 6a 01 22 	mov	r10,290
80005630:	12 9b       	mov	r11,r9
80005632:	e0 6c 01 0e 	mov	r12,270
80005636:	f0 1f 00 8f 	mcall	80005870 <vTareaLCD+0x4e4>
				et024006_DrawLine(270,135, 290, 135, BLUE);
8000563a:	31 f8       	mov	r8,31
8000563c:	e0 69 00 87 	mov	r9,135
80005640:	e0 6a 01 22 	mov	r10,290
80005644:	12 9b       	mov	r11,r9
80005646:	e0 6c 01 0e 	mov	r12,270
8000564a:	f0 1f 00 8a 	mcall	80005870 <vTareaLCD+0x4e4>
				et024006_DrawLine(270,130, 290, 130, BLUE);
8000564e:	31 f8       	mov	r8,31
80005650:	e0 69 00 82 	mov	r9,130
80005654:	e0 6a 01 22 	mov	r10,290
80005658:	12 9b       	mov	r11,r9
8000565a:	e0 6c 01 0e 	mov	r12,270
8000565e:	f0 1f 00 85 	mcall	80005870 <vTareaLCD+0x4e4>
				et024006_DrawLine(270,125, 290, 125, BLUE);
80005662:	31 f8       	mov	r8,31
80005664:	37 d9       	mov	r9,125
80005666:	e0 6a 01 22 	mov	r10,290
8000566a:	12 9b       	mov	r11,r9
8000566c:	e0 6c 01 0e 	mov	r12,270
80005670:	f0 1f 00 80 	mcall	80005870 <vTareaLCD+0x4e4>
				et024006_DrawLine(270,120, 290, 120, BLUE);
80005674:	31 f8       	mov	r8,31
80005676:	37 89       	mov	r9,120
80005678:	e0 6a 01 22 	mov	r10,290
8000567c:	12 9b       	mov	r11,r9
8000567e:	e0 6c 01 0e 	mov	r12,270
80005682:	f0 1f 00 7c 	mcall	80005870 <vTareaLCD+0x4e4>
				et024006_DrawLine(270,140, 270, 120, BLUE);
80005686:	31 f8       	mov	r8,31
80005688:	37 89       	mov	r9,120
8000568a:	e0 6a 01 0e 	mov	r10,270
8000568e:	e0 6b 00 8c 	mov	r11,140
80005692:	14 9c       	mov	r12,r10
80005694:	f0 1f 00 77 	mcall	80005870 <vTareaLCD+0x4e4>
				et024006_DrawLine(290,140, 290, 120, BLUE);
80005698:	31 f8       	mov	r8,31
8000569a:	37 89       	mov	r9,120
8000569c:	e0 6a 01 22 	mov	r10,290
800056a0:	e0 6b 00 8c 	mov	r11,140
800056a4:	14 9c       	mov	r12,r10
800056a6:	f0 1f 00 73 	mcall	80005870 <vTareaLCD+0x4e4>
				gpio_set_gpio_pin(LED2_GPIO);
800056aa:	0c 9c       	mov	r12,r6
800056ac:	f0 1f 00 6d 	mcall	80005860 <vTareaLCD+0x4d4>
				//if(gasPrimeraVez==1){
				//gasPrimeraVez=0;
				//tpa6130_dac_mute(0);
				vTaskResume(myTask5Handle);
800056b0:	4f 58       	lddpc	r8,80005884 <vTareaLCD+0x4f8>
800056b2:	70 0c       	ld.w	r12,r8[0x0]
800056b4:	f0 1f 00 6a 	mcall	8000585c <vTareaLCD+0x4d0>
800056b8:	cb 38       	rjmp	8000581e <vTareaLCD+0x492>
				//tpa6130_dac_mute(1);
				//vTaskSuspend(myTask4Handle);
				//}
			}
			else{
				et024006_DrawFilledCircle(280,90,30,BLUE,0xFF);
800056ba:	e0 68 00 ff 	mov	r8,255
800056be:	31 f9       	mov	r9,31
800056c0:	31 ea       	mov	r10,30
800056c2:	35 ab       	mov	r11,90
800056c4:	e0 6c 01 18 	mov	r12,280
800056c8:	f0 1f 00 6d 	mcall	8000587c <vTareaLCD+0x4f0>
				et024006_DrawFilledCircle(280,90,29,YELLOW,0xFF);
800056cc:	e0 68 00 ff 	mov	r8,255
800056d0:	e0 69 ff e0 	mov	r9,65504
800056d4:	31 da       	mov	r10,29
800056d6:	35 ab       	mov	r11,90
800056d8:	e0 6c 01 18 	mov	r12,280
800056dc:	f0 1f 00 68 	mcall	8000587c <vTareaLCD+0x4f0>
				et024006_DrawLine(240,120,250,110,BLUE);
800056e0:	31 f8       	mov	r8,31
800056e2:	36 e9       	mov	r9,110
800056e4:	e0 6a 00 fa 	mov	r10,250
800056e8:	37 8b       	mov	r11,120
800056ea:	e0 6c 00 f0 	mov	r12,240
800056ee:	f0 1f 00 61 	mcall	80005870 <vTareaLCD+0x4e4>
				et024006_DrawLine(240,100,245,90,BLUE);
800056f2:	31 f8       	mov	r8,31
800056f4:	35 a9       	mov	r9,90
800056f6:	e0 6a 00 f5 	mov	r10,245
800056fa:	36 4b       	mov	r11,100
800056fc:	e0 6c 00 f0 	mov	r12,240
80005700:	f0 1f 00 5c 	mcall	80005870 <vTareaLCD+0x4e4>
				et024006_DrawLine(240,70,245,80,BLUE);
80005704:	31 f8       	mov	r8,31
80005706:	35 09       	mov	r9,80
80005708:	e0 6a 00 f5 	mov	r10,245
8000570c:	34 6b       	mov	r11,70
8000570e:	e0 6c 00 f0 	mov	r12,240
80005712:	f0 1f 00 58 	mcall	80005870 <vTareaLCD+0x4e4>
				et024006_DrawLine(240,50,250,60,BLUE);
80005716:	31 f8       	mov	r8,31
80005718:	33 c9       	mov	r9,60
8000571a:	e0 6a 00 fa 	mov	r10,250
8000571e:	33 2b       	mov	r11,50
80005720:	e0 6c 00 f0 	mov	r12,240
80005724:	f0 1f 00 53 	mcall	80005870 <vTareaLCD+0x4e4>
				et024006_DrawVertLine(270,40,10,BLUE);
80005728:	31 f9       	mov	r9,31
8000572a:	30 aa       	mov	r10,10
8000572c:	32 8b       	mov	r11,40
8000572e:	e0 6c 01 0e 	mov	r12,270
80005732:	f0 1f 00 54 	mcall	80005880 <vTareaLCD+0x4f4>
				et024006_DrawVertLine(290,40,10,BLUE);
80005736:	31 f9       	mov	r9,31
80005738:	30 aa       	mov	r10,10
8000573a:	32 8b       	mov	r11,40
8000573c:	e0 6c 01 22 	mov	r12,290
80005740:	f0 1f 00 50 	mcall	80005880 <vTareaLCD+0x4f4>
				et024006_DrawLine(310,60,320,50,BLUE);
80005744:	31 f8       	mov	r8,31
80005746:	33 29       	mov	r9,50
80005748:	e0 6a 01 40 	mov	r10,320
8000574c:	33 cb       	mov	r11,60
8000574e:	e0 6c 01 36 	mov	r12,310
80005752:	f0 1f 00 48 	mcall	80005870 <vTareaLCD+0x4e4>
				et024006_DrawLine(315,80,320,70,BLUE);
80005756:	31 f8       	mov	r8,31
80005758:	34 69       	mov	r9,70
8000575a:	e0 6a 01 40 	mov	r10,320
8000575e:	35 0b       	mov	r11,80
80005760:	e0 6c 01 3b 	mov	r12,315
80005764:	f0 1f 00 43 	mcall	80005870 <vTareaLCD+0x4e4>
				et024006_DrawLine(315,90,320,100,BLUE);
80005768:	31 f8       	mov	r8,31
8000576a:	36 49       	mov	r9,100
8000576c:	e0 6a 01 40 	mov	r10,320
80005770:	35 ab       	mov	r11,90
80005772:	e0 6c 01 3b 	mov	r12,315
80005776:	f0 1f 00 3f 	mcall	80005870 <vTareaLCD+0x4e4>
				et024006_DrawLine(310,110,320,120,BLUE);
8000577a:	31 f8       	mov	r8,31
8000577c:	37 89       	mov	r9,120
8000577e:	e0 6a 01 40 	mov	r10,320
80005782:	36 eb       	mov	r11,110
80005784:	e0 6c 01 36 	mov	r12,310
80005788:	f0 1f 00 3a 	mcall	80005870 <vTareaLCD+0x4e4>
				et024006_DrawLine(270,140, 290, 140, BLUE);
8000578c:	31 f8       	mov	r8,31
8000578e:	e0 69 00 8c 	mov	r9,140
80005792:	e0 6a 01 22 	mov	r10,290
80005796:	12 9b       	mov	r11,r9
80005798:	e0 6c 01 0e 	mov	r12,270
8000579c:	f0 1f 00 35 	mcall	80005870 <vTareaLCD+0x4e4>
				et024006_DrawLine(270,135, 290, 135, BLUE);
800057a0:	31 f8       	mov	r8,31
800057a2:	e0 69 00 87 	mov	r9,135
800057a6:	e0 6a 01 22 	mov	r10,290
800057aa:	12 9b       	mov	r11,r9
800057ac:	e0 6c 01 0e 	mov	r12,270
800057b0:	f0 1f 00 30 	mcall	80005870 <vTareaLCD+0x4e4>
				et024006_DrawLine(270,130, 290, 130, BLUE);
800057b4:	31 f8       	mov	r8,31
800057b6:	e0 69 00 82 	mov	r9,130
800057ba:	e0 6a 01 22 	mov	r10,290
800057be:	12 9b       	mov	r11,r9
800057c0:	e0 6c 01 0e 	mov	r12,270
800057c4:	f0 1f 00 2b 	mcall	80005870 <vTareaLCD+0x4e4>
				et024006_DrawLine(270,125, 290, 125, BLUE);
800057c8:	31 f8       	mov	r8,31
800057ca:	37 d9       	mov	r9,125
800057cc:	e0 6a 01 22 	mov	r10,290
800057d0:	12 9b       	mov	r11,r9
800057d2:	e0 6c 01 0e 	mov	r12,270
800057d6:	f0 1f 00 27 	mcall	80005870 <vTareaLCD+0x4e4>
				et024006_DrawLine(270,120, 290, 120, BLUE);
800057da:	31 f8       	mov	r8,31
800057dc:	37 89       	mov	r9,120
800057de:	e0 6a 01 22 	mov	r10,290
800057e2:	12 9b       	mov	r11,r9
800057e4:	e0 6c 01 0e 	mov	r12,270
800057e8:	f0 1f 00 22 	mcall	80005870 <vTareaLCD+0x4e4>
				et024006_DrawLine(270,140, 270, 120, BLUE);
800057ec:	31 f8       	mov	r8,31
800057ee:	37 89       	mov	r9,120
800057f0:	e0 6a 01 0e 	mov	r10,270
800057f4:	e0 6b 00 8c 	mov	r11,140
800057f8:	14 9c       	mov	r12,r10
800057fa:	f0 1f 00 1e 	mcall	80005870 <vTareaLCD+0x4e4>
				et024006_DrawLine(290,140, 290, 120, BLUE);
800057fe:	31 f8       	mov	r8,31
80005800:	37 89       	mov	r9,120
80005802:	e0 6a 01 22 	mov	r10,290
80005806:	e0 6b 00 8c 	mov	r11,140
8000580a:	14 9c       	mov	r12,r10
8000580c:	f0 1f 00 19 	mcall	80005870 <vTareaLCD+0x4e4>
				gpio_clr_gpio_pin(LED2_GPIO);
80005810:	0c 9c       	mov	r12,r6
80005812:	f0 1f 00 11 	mcall	80005854 <vTareaLCD+0x4c8>
				vTaskSuspend(myTask5Handle);
80005816:	49 c8       	lddpc	r8,80005884 <vTareaLCD+0x4f8>
80005818:	70 0c       	ld.w	r12,r8[0x0]
8000581a:	f0 1f 00 13 	mcall	80005864 <vTareaLCD+0x4d8>
			}
		}
		vTaskDelay(100);
8000581e:	36 4c       	mov	r12,100
80005820:	f0 1f 00 1a 	mcall	80005888 <vTareaLCD+0x4fc>
	}
80005824:	fe 9f fd c3 	bral	800053aa <vTareaLCD+0x1e>
80005828:	00 00       	add	r0,r0
8000582a:	0e 48       	or	r8,r7
8000582c:	80 00       	ld.sh	r0,r0[0x0]
8000582e:	60 a8       	ld.w	r8,r0[0x28]
80005830:	80 00       	ld.sh	r0,r0[0x0]
80005832:	78 fa       	ld.w	r10,r12[0x3c]
80005834:	80 00       	ld.sh	r0,r0[0x0]
80005836:	76 b8       	ld.w	r8,r11[0x2c]
80005838:	80 00       	ld.sh	r0,r0[0x0]
8000583a:	78 18       	ld.w	r8,r12[0x4]
8000583c:	80 00       	ld.sh	r0,r0[0x0]
8000583e:	73 6c       	ld.w	r12,r9[0x58]
80005840:	80 00       	ld.sh	r0,r0[0x0]
80005842:	41 1c       	lddsp	r12,sp[0x44]
80005844:	80 00       	ld.sh	r0,r0[0x0]
80005846:	cc 38       	rjmp	800059cc <vTareaAudioTemperatura+0x48>
80005848:	80 02       	ld.sh	r2,r0[0x0]
8000584a:	27 c0       	sub	r0,124
8000584c:	80 00       	ld.sh	r0,r0[0x0]
8000584e:	31 88       	mov	r8,24
80005850:	80 00       	ld.sh	r0,r0[0x0]
80005852:	35 1c       	mov	r12,81
80005854:	80 00       	ld.sh	r0,r0[0x0]
80005856:	41 4e       	lddsp	lr,sp[0x50]
80005858:	00 00       	add	r0,r0
8000585a:	06 90       	mov	r0,r3
8000585c:	80 00       	ld.sh	r0,r0[0x0]
8000585e:	68 d0       	ld.w	r0,r4[0x34]
80005860:	80 00       	ld.sh	r0,r0[0x0]
80005862:	41 32       	lddsp	r2,sp[0x4c]
80005864:	80 00       	ld.sh	r0,r0[0x0]
80005866:	69 50       	ld.w	r0,r4[0x54]
80005868:	00 00       	add	r0,r0
8000586a:	0a 3c       	cp.w	r12,r5
8000586c:	80 00       	ld.sh	r0,r0[0x0]
8000586e:	36 d0       	mov	r0,109
80005870:	80 00       	ld.sh	r0,r0[0x0]
80005872:	33 c4       	mov	r4,60
80005874:	00 00       	add	r0,r0
80005876:	06 84       	andn	r4,r3
80005878:	00 00       	add	r0,r0
8000587a:	0e 2c       	rsub	r12,r7
8000587c:	80 00       	ld.sh	r0,r0[0x0]
8000587e:	35 78       	mov	r8,87
80005880:	80 00       	ld.sh	r0,r0[0x0]
80005882:	35 5c       	mov	r12,85
80005884:	00 00       	add	r0,r0
80005886:	06 8c       	andn	r12,r3
80005888:	80 00       	ld.sh	r0,r0[0x0]
8000588a:	6a 44       	ld.w	r4,r5[0x10]

8000588c <vTareaAudioLuces>:
		while(!tpa6130_dac_output(NULL, 0));
		xSemaphoreGive(xMutexAudio);
	}
	}
}
void vTareaAudioLuces( void *pvParameters ){
8000588c:	d4 31       	pushm	r0-r7,lr
8000588e:	30 07       	mov	r7,0
	int i=0;
	int count=0;
	while(true){
		if(xSemaphoreTake(xMutexAudio,0xFFFFFFFF)==1){
80005890:	49 83       	lddpc	r3,800058f0 <vTareaAudioLuces+0x64>
80005892:	0e 94       	mov	r4,r7
80005894:	3f f2       	mov	r2,-1
80005896:	49 81       	lddpc	r1,800058f4 <vTareaAudioLuces+0x68>
		while(!tpa6130_dac_output(NULL, 0));
		xSemaphoreGive(xMutexAudio);
	}
	}
}
void vTareaAudioLuces( void *pvParameters ){
80005898:	e2 c6 fe 00 	sub	r6,r1,-512
	int count=0;
	while(true){
		if(xSemaphoreTake(xMutexAudio,0xFFFFFFFF)==1){
		count=0;
		while(count < (SOUND_SAMPLES)){
			samples[count++] = ((uint8_t)lucesEncendidos[i]+0x80) << 8;
8000589c:	49 75       	lddpc	r5,800058f8 <vTareaAudioLuces+0x6c>
			samples[count++] = ((uint8_t)lucesEncendidos[i]+0x80) << 8;
			i++;
			if (i >= sizeof(lucesEncendidos)) i = 0;
		}
		tpa6130_dac_output((void *) samples,SOUND_SAMPLES/2);
8000589e:	e0 60 00 80 	mov	r0,128
}
void vTareaAudioLuces( void *pvParameters ){
	int i=0;
	int count=0;
	while(true){
		if(xSemaphoreTake(xMutexAudio,0xFFFFFFFF)==1){
800058a2:	08 99       	mov	r9,r4
800058a4:	04 9a       	mov	r10,r2
800058a6:	08 9b       	mov	r11,r4
800058a8:	66 0c       	ld.w	r12,r3[0x0]
800058aa:	f0 1f 00 15 	mcall	800058fc <vTareaAudioLuces+0x70>
800058ae:	58 1c       	cp.w	r12,1
800058b0:	cf 91       	brne	800058a2 <vTareaAudioLuces+0x16>
800058b2:	02 98       	mov	r8,r1
		count=0;
		while(count < (SOUND_SAMPLES)){
			samples[count++] = ((uint8_t)lucesEncendidos[i]+0x80) << 8;
800058b4:	ea 07 07 09 	ld.ub	r9,r5[r7]
800058b8:	28 09       	sub	r9,-128
800058ba:	a9 69       	lsl	r9,0x8
800058bc:	b0 09       	st.h	r8[0x0],r9
			samples[count++] = ((uint8_t)lucesEncendidos[i]+0x80) << 8;
800058be:	b0 19       	st.h	r8[0x2],r9
			i++;
800058c0:	2f f7       	sub	r7,-1
			if (i >= sizeof(lucesEncendidos)) i = 0;
800058c2:	e0 47 cd 0e 	cp.w	r7,52494
800058c6:	f9 b7 02 00 	movhs	r7,0
800058ca:	2f c8       	sub	r8,-4
	int i=0;
	int count=0;
	while(true){
		if(xSemaphoreTake(xMutexAudio,0xFFFFFFFF)==1){
		count=0;
		while(count < (SOUND_SAMPLES)){
800058cc:	0c 38       	cp.w	r8,r6
800058ce:	cf 31       	brne	800058b4 <vTareaAudioLuces+0x28>
			samples[count++] = ((uint8_t)lucesEncendidos[i]+0x80) << 8;
			samples[count++] = ((uint8_t)lucesEncendidos[i]+0x80) << 8;
			i++;
			if (i >= sizeof(lucesEncendidos)) i = 0;
		}
		tpa6130_dac_output((void *) samples,SOUND_SAMPLES/2);
800058d0:	00 9b       	mov	r11,r0
800058d2:	02 9c       	mov	r12,r1
800058d4:	f0 1f 00 0b 	mcall	80005900 <vTareaAudioLuces+0x74>
		while(!tpa6130_dac_output(NULL, 0));
800058d8:	08 9b       	mov	r11,r4
800058da:	08 9c       	mov	r12,r4
800058dc:	f0 1f 00 09 	mcall	80005900 <vTareaAudioLuces+0x74>
800058e0:	cf c0       	breq	800058d8 <vTareaAudioLuces+0x4c>
		xSemaphoreGive(xMutexAudio);
800058e2:	08 99       	mov	r9,r4
800058e4:	08 9a       	mov	r10,r4
800058e6:	08 9b       	mov	r11,r4
800058e8:	66 0c       	ld.w	r12,r3[0x0]
800058ea:	f0 1f 00 07 	mcall	80005904 <vTareaAudioLuces+0x78>
800058ee:	cd ab       	rjmp	800058a2 <vTareaAudioLuces+0x16>
800058f0:	00 00       	add	r0,r0
800058f2:	10 54       	eor	r4,r8
800058f4:	00 00       	add	r0,r0
800058f6:	0e 4c       	or	r12,r7
800058f8:	80 02       	ld.sh	r2,r0[0x0]
800058fa:	28 24       	sub	r4,-126
800058fc:	80 00       	ld.sh	r0,r0[0x0]
800058fe:	60 a8       	ld.w	r8,r0[0x28]
80005900:	80 00       	ld.sh	r0,r0[0x0]
80005902:	2e 4c       	sub	r12,-28
80005904:	80 00       	ld.sh	r0,r0[0x0]
80005906:	62 64       	ld.w	r4,r1[0x18]

80005908 <vTareaAudioGas>:
			xSemaphoreGive(xMutexAudio);
		}
		
	}
}
void vTareaAudioGas( void *pvParameters ){
80005908:	d4 31       	pushm	r0-r7,lr
8000590a:	30 07       	mov	r7,0
	int i=0;
	int count=0;
	while(true){
		if(xSemaphoreTake(xMutexAudio,0xFFFFFFFF)==1){
8000590c:	49 83       	lddpc	r3,8000596c <vTareaAudioGas+0x64>
8000590e:	0e 94       	mov	r4,r7
80005910:	3f f2       	mov	r2,-1
80005912:	49 81       	lddpc	r1,80005970 <vTareaAudioGas+0x68>
			xSemaphoreGive(xMutexAudio);
		}
		
	}
}
void vTareaAudioGas( void *pvParameters ){
80005914:	e2 c6 fe 00 	sub	r6,r1,-512
	int count=0;
	while(true){
		if(xSemaphoreTake(xMutexAudio,0xFFFFFFFF)==1){
		count=0;
		while(count < (SOUND_SAMPLES)){
			samples[count++] = ((uint8_t)gasDetectado[i]+0x80) << 8;
80005918:	49 75       	lddpc	r5,80005974 <vTareaAudioGas+0x6c>
			samples[count++] = ((uint8_t)gasDetectado[i]+0x80) << 8;
			i++;
			if (i >= sizeof(gasDetectado)) i = 0;
		}
		tpa6130_dac_output((void *) samples,SOUND_SAMPLES/2);
8000591a:	e0 60 00 80 	mov	r0,128
}
void vTareaAudioGas( void *pvParameters ){
	int i=0;
	int count=0;
	while(true){
		if(xSemaphoreTake(xMutexAudio,0xFFFFFFFF)==1){
8000591e:	08 99       	mov	r9,r4
80005920:	04 9a       	mov	r10,r2
80005922:	08 9b       	mov	r11,r4
80005924:	66 0c       	ld.w	r12,r3[0x0]
80005926:	f0 1f 00 15 	mcall	80005978 <vTareaAudioGas+0x70>
8000592a:	58 1c       	cp.w	r12,1
8000592c:	cf 91       	brne	8000591e <vTareaAudioGas+0x16>
8000592e:	02 98       	mov	r8,r1
		count=0;
		while(count < (SOUND_SAMPLES)){
			samples[count++] = ((uint8_t)gasDetectado[i]+0x80) << 8;
80005930:	ea 07 07 09 	ld.ub	r9,r5[r7]
80005934:	28 09       	sub	r9,-128
80005936:	a9 69       	lsl	r9,0x8
80005938:	b0 09       	st.h	r8[0x0],r9
			samples[count++] = ((uint8_t)gasDetectado[i]+0x80) << 8;
8000593a:	b0 19       	st.h	r8[0x2],r9
			i++;
8000593c:	2f f7       	sub	r7,-1
			if (i >= sizeof(gasDetectado)) i = 0;
8000593e:	e0 47 ac 8e 	cp.w	r7,44174
80005942:	f9 b7 02 00 	movhs	r7,0
80005946:	2f c8       	sub	r8,-4
	int i=0;
	int count=0;
	while(true){
		if(xSemaphoreTake(xMutexAudio,0xFFFFFFFF)==1){
		count=0;
		while(count < (SOUND_SAMPLES)){
80005948:	0c 38       	cp.w	r8,r6
8000594a:	cf 31       	brne	80005930 <vTareaAudioGas+0x28>
			samples[count++] = ((uint8_t)gasDetectado[i]+0x80) << 8;
			samples[count++] = ((uint8_t)gasDetectado[i]+0x80) << 8;
			i++;
			if (i >= sizeof(gasDetectado)) i = 0;
		}
		tpa6130_dac_output((void *) samples,SOUND_SAMPLES/2);
8000594c:	00 9b       	mov	r11,r0
8000594e:	02 9c       	mov	r12,r1
80005950:	f0 1f 00 0b 	mcall	8000597c <vTareaAudioGas+0x74>
		while(!tpa6130_dac_output(NULL, 0));
80005954:	08 9b       	mov	r11,r4
80005956:	08 9c       	mov	r12,r4
80005958:	f0 1f 00 09 	mcall	8000597c <vTareaAudioGas+0x74>
8000595c:	cf c0       	breq	80005954 <vTareaAudioGas+0x4c>
		xSemaphoreGive(xMutexAudio);
8000595e:	08 99       	mov	r9,r4
80005960:	08 9a       	mov	r10,r4
80005962:	08 9b       	mov	r11,r4
80005964:	66 0c       	ld.w	r12,r3[0x0]
80005966:	f0 1f 00 07 	mcall	80005980 <vTareaAudioGas+0x78>
8000596a:	cd ab       	rjmp	8000591e <vTareaAudioGas+0x16>
8000596c:	00 00       	add	r0,r0
8000596e:	10 54       	eor	r4,r8
80005970:	00 00       	add	r0,r0
80005972:	0e 4c       	or	r12,r7
80005974:	80 00       	ld.sh	r0,r0[0x0]
80005976:	d0 80       	acall	0x8
80005978:	80 00       	ld.sh	r0,r0[0x0]
8000597a:	60 a8       	ld.w	r8,r0[0x28]
8000597c:	80 00       	ld.sh	r0,r0[0x0]
8000597e:	2e 4c       	sub	r12,-28
80005980:	80 00       	ld.sh	r0,r0[0x0]
80005982:	62 64       	ld.w	r4,r1[0x18]

80005984 <vTareaAudioTemperatura>:
			xSemaphoreGive(xMutex);
		}
		vTaskDelay(1000);
	}
}
void vTareaAudioTemperatura( void *pvParameters ){
80005984:	d4 31       	pushm	r0-r7,lr
80005986:	30 07       	mov	r7,0
	int i=0;
	int count=0;
	while(true){
		if(xSemaphoreTake(xMutexAudio,0xFFFFFFFF)==1){
80005988:	49 83       	lddpc	r3,800059e8 <vTareaAudioTemperatura+0x64>
8000598a:	0e 94       	mov	r4,r7
8000598c:	3f f2       	mov	r2,-1
8000598e:	49 81       	lddpc	r1,800059ec <vTareaAudioTemperatura+0x68>
			xSemaphoreGive(xMutex);
		}
		vTaskDelay(1000);
	}
}
void vTareaAudioTemperatura( void *pvParameters ){
80005990:	e2 c6 fe 00 	sub	r6,r1,-512
	int count=0;
	while(true){
		if(xSemaphoreTake(xMutexAudio,0xFFFFFFFF)==1){
			count=0;
			while(count < (SOUND_SAMPLES)){
				samples[count++] = ((uint8_t)temperaturaAlta[i]+0x80) << 8;
80005994:	49 75       	lddpc	r5,800059f0 <vTareaAudioTemperatura+0x6c>
				samples[count++] = ((uint8_t)temperaturaAlta[i]+0x80) << 8;
				i++;
				if (i >= sizeof(temperaturaAlta)) i = 0;
			}
			tpa6130_dac_output((void *) samples,SOUND_SAMPLES/2);
80005996:	e0 60 00 80 	mov	r0,128
}
void vTareaAudioTemperatura( void *pvParameters ){
	int i=0;
	int count=0;
	while(true){
		if(xSemaphoreTake(xMutexAudio,0xFFFFFFFF)==1){
8000599a:	08 99       	mov	r9,r4
8000599c:	04 9a       	mov	r10,r2
8000599e:	08 9b       	mov	r11,r4
800059a0:	66 0c       	ld.w	r12,r3[0x0]
800059a2:	f0 1f 00 15 	mcall	800059f4 <vTareaAudioTemperatura+0x70>
800059a6:	58 1c       	cp.w	r12,1
800059a8:	cf 91       	brne	8000599a <vTareaAudioTemperatura+0x16>
800059aa:	02 98       	mov	r8,r1
			count=0;
			while(count < (SOUND_SAMPLES)){
				samples[count++] = ((uint8_t)temperaturaAlta[i]+0x80) << 8;
800059ac:	ea 07 07 09 	ld.ub	r9,r5[r7]
800059b0:	28 09       	sub	r9,-128
800059b2:	a9 69       	lsl	r9,0x8
800059b4:	b0 09       	st.h	r8[0x0],r9
				samples[count++] = ((uint8_t)temperaturaAlta[i]+0x80) << 8;
800059b6:	b0 19       	st.h	r8[0x2],r9
				i++;
800059b8:	2f f7       	sub	r7,-1
				if (i >= sizeof(temperaturaAlta)) i = 0;
800059ba:	e0 47 aa 0e 	cp.w	r7,43534
800059be:	f9 b7 02 00 	movhs	r7,0
800059c2:	2f c8       	sub	r8,-4
	int i=0;
	int count=0;
	while(true){
		if(xSemaphoreTake(xMutexAudio,0xFFFFFFFF)==1){
			count=0;
			while(count < (SOUND_SAMPLES)){
800059c4:	0c 38       	cp.w	r8,r6
800059c6:	cf 31       	brne	800059ac <vTareaAudioTemperatura+0x28>
				samples[count++] = ((uint8_t)temperaturaAlta[i]+0x80) << 8;
				samples[count++] = ((uint8_t)temperaturaAlta[i]+0x80) << 8;
				i++;
				if (i >= sizeof(temperaturaAlta)) i = 0;
			}
			tpa6130_dac_output((void *) samples,SOUND_SAMPLES/2);
800059c8:	00 9b       	mov	r11,r0
800059ca:	02 9c       	mov	r12,r1
800059cc:	f0 1f 00 0b 	mcall	800059f8 <vTareaAudioTemperatura+0x74>
			while(!tpa6130_dac_output(NULL, 0));
800059d0:	08 9b       	mov	r11,r4
800059d2:	08 9c       	mov	r12,r4
800059d4:	f0 1f 00 09 	mcall	800059f8 <vTareaAudioTemperatura+0x74>
800059d8:	cf c0       	breq	800059d0 <vTareaAudioTemperatura+0x4c>
			xSemaphoreGive(xMutexAudio);
800059da:	08 99       	mov	r9,r4
800059dc:	08 9a       	mov	r10,r4
800059de:	08 9b       	mov	r11,r4
800059e0:	66 0c       	ld.w	r12,r3[0x0]
800059e2:	f0 1f 00 07 	mcall	800059fc <vTareaAudioTemperatura+0x78>
800059e6:	cd ab       	rjmp	8000599a <vTareaAudioTemperatura+0x16>
800059e8:	00 00       	add	r0,r0
800059ea:	10 54       	eor	r4,r8
800059ec:	00 00       	add	r0,r0
800059ee:	0e 4c       	or	r12,r7
800059f0:	80 01       	ld.sh	r1,r0[0x0]
800059f2:	7d 28       	ld.w	r8,lr[0x48]
800059f4:	80 00       	ld.sh	r0,r0[0x0]
800059f6:	60 a8       	ld.w	r8,r0[0x28]
800059f8:	80 00       	ld.sh	r0,r0[0x0]
800059fa:	2e 4c       	sub	r12,-28
800059fc:	80 00       	ld.sh	r0,r0[0x0]
800059fe:	62 64       	ld.w	r4,r1[0x18]

80005a00 <vTareaADC>:
void adc_underrun_callback(void);
void adc_reload_callback(void);
void left_right_enter_isr(void);
void EIC(void);

void vTareaADC( void *pvParameters ){
80005a00:	d4 31       	pushm	r0-r7,lr
80005a02:	20 3d       	sub	sp,12
	//const char *pcTaskName = "Task 1 is running\r\n";
	int sensorTemperatura;
	int sensorgas;
	int sensorIluminosidad;
	int sensorContador=0;
	temperaturaQueue=xQueueCreate(5,sizeof(sensorTemperatura));
80005a04:	30 4b       	mov	r11,4
80005a06:	30 5c       	mov	r12,5
80005a08:	f0 1f 00 6d 	mcall	80005bbc <vTareaADC+0x1bc>
80005a0c:	4e d8       	lddpc	r8,80005bc0 <vTareaADC+0x1c0>
80005a0e:	91 0c       	st.w	r8[0x0],r12
	gasQueue=xQueueCreate(5,sizeof(sensorgas));
80005a10:	30 4b       	mov	r11,4
80005a12:	30 5c       	mov	r12,5
80005a14:	f0 1f 00 6a 	mcall	80005bbc <vTareaADC+0x1bc>
80005a18:	4e b8       	lddpc	r8,80005bc4 <vTareaADC+0x1c4>
80005a1a:	91 0c       	st.w	r8[0x0],r12
	iluminosidadQueue=xQueueCreate(5,sizeof(sensorIluminosidad));
80005a1c:	30 4b       	mov	r11,4
80005a1e:	30 5c       	mov	r12,5
80005a20:	f0 1f 00 67 	mcall	80005bbc <vTareaADC+0x1bc>
80005a24:	4e 98       	lddpc	r8,80005bc8 <vTareaADC+0x1c8>
80005a26:	91 0c       	st.w	r8[0x0],r12
	temperaturaSDQueue=xQueueCreate(5,sizeof(sensorTemperatura));
80005a28:	30 4b       	mov	r11,4
80005a2a:	30 5c       	mov	r12,5
80005a2c:	f0 1f 00 64 	mcall	80005bbc <vTareaADC+0x1bc>
80005a30:	4e 78       	lddpc	r8,80005bcc <vTareaADC+0x1cc>
80005a32:	91 0c       	st.w	r8[0x0],r12
	gasSDQueue=xQueueCreate(5,sizeof(sensorgas));
80005a34:	30 4b       	mov	r11,4
80005a36:	30 5c       	mov	r12,5
80005a38:	f0 1f 00 61 	mcall	80005bbc <vTareaADC+0x1bc>
80005a3c:	4e 58       	lddpc	r8,80005bd0 <vTareaADC+0x1d0>
80005a3e:	91 0c       	st.w	r8[0x0],r12
	iluminosidadSDQueue=xQueueCreate(5,sizeof(sensorIluminosidad));
80005a40:	30 4b       	mov	r11,4
80005a42:	30 5c       	mov	r12,5
80005a44:	f0 1f 00 5e 	mcall	80005bbc <vTareaADC+0x1bc>
80005a48:	4e 38       	lddpc	r8,80005bd4 <vTareaADC+0x1d4>
80005a4a:	91 0c       	st.w	r8[0x0],r12
80005a4c:	30 04       	mov	r4,0
	while(1){
		if(xSemaphoreTake(xMutex,0xFFFFFFFF)==1){
80005a4e:	4e 36       	lddpc	r6,80005bd8 <vTareaADC+0x1d8>
80005a50:	08 97       	mov	r7,r4
80005a52:	3f f5       	mov	r5,-1
				xQueueSend(gasQueue,&sensorgas,0);
				vTaskDelay(100);
				xQueueSend(gasSDQueue,&sensorgas,0);
			}
			else if(sensorContador==2){
				gpio_clr_gpio_pin(62);
80005a54:	33 e0       	mov	r0,62
				gpio_set_gpio_pin(63);
				vTaskDelay(100);
80005a56:	36 43       	mov	r3,100
				//usart_write_line(&AVR32_USART0, pcTaskName);
				adc_start(&AVR32_ADC);
80005a58:	fe 72 3c 00 	mov	r2,-50176
				//adc_value_temp = adc_get_value(&AVR32_ADC,0);
				sensorIluminosidad = adc_get_value(&AVR32_ADC,0);
				//gpio_clr_gpio_pin(21);
				sensorContador=0;
				usart_write_line(&AVR32_USART0,"    Iluminosidad:");
80005a5c:	fe 71 14 00 	mov	r1,-60416
	iluminosidadQueue=xQueueCreate(5,sizeof(sensorIluminosidad));
	temperaturaSDQueue=xQueueCreate(5,sizeof(sensorTemperatura));
	gasSDQueue=xQueueCreate(5,sizeof(sensorgas));
	iluminosidadSDQueue=xQueueCreate(5,sizeof(sensorIluminosidad));
	while(1){
		if(xSemaphoreTake(xMutex,0xFFFFFFFF)==1){
80005a60:	0e 99       	mov	r9,r7
80005a62:	0a 9a       	mov	r10,r5
80005a64:	0e 9b       	mov	r11,r7
80005a66:	6c 0c       	ld.w	r12,r6[0x0]
80005a68:	f0 1f 00 5d 	mcall	80005bdc <vTareaADC+0x1dc>
80005a6c:	58 1c       	cp.w	r12,1
80005a6e:	e0 81 00 a2 	brne	80005bb2 <vTareaADC+0x1b2>
			if(sensorContador==0){
80005a72:	58 04       	cp.w	r4,0
80005a74:	c3 a1       	brne	80005ae8 <vTareaADC+0xe8>
				gpio_clr_gpio_pin(62);
80005a76:	00 9c       	mov	r12,r0
80005a78:	f0 1f 00 5a 	mcall	80005be0 <vTareaADC+0x1e0>
				gpio_clr_gpio_pin(63);
80005a7c:	33 fc       	mov	r12,63
80005a7e:	f0 1f 00 59 	mcall	80005be0 <vTareaADC+0x1e0>
				vTaskDelay(100);
80005a82:	06 9c       	mov	r12,r3
80005a84:	f0 1f 00 58 	mcall	80005be4 <vTareaADC+0x1e4>
				//usart_write_line(&AVR32_USART0, pcTaskName);
				adc_start(&AVR32_ADC);
80005a88:	04 9c       	mov	r12,r2
80005a8a:	f0 1f 00 58 	mcall	80005be8 <vTareaADC+0x1e8>
				//adc_value_temp = adc_get_value(&AVR32_ADC,0);
				sensorTemperatura = adc_get_value(&AVR32_ADC,0);
80005a8e:	0e 9b       	mov	r11,r7
80005a90:	04 9c       	mov	r12,r2
80005a92:	f0 1f 00 57 	mcall	80005bec <vTareaADC+0x1ec>
80005a96:	50 2c       	stdsp	sp[0x8],r12
				//gpio_clr_gpio_pin(23);
				sensorContador=1;
				usart_write_line(&AVR32_USART0,"Temperatura:");
80005a98:	4d 6b       	lddpc	r11,80005bf0 <vTareaADC+0x1f0>
80005a9a:	02 9c       	mov	r12,r1
80005a9c:	f0 1f 00 56 	mcall	80005bf4 <vTareaADC+0x1f4>
				//usart_write_line(&AVR32_USART0,sensorTemperatura);
				//sensorTemperatura=sensorTemperatura/1023*50000/10;
				float temperatura=(float)sensorTemperatura;
				//const char *pcTaskName = "Task 1 is running\r\n";
				print_dbg_ulong(temperatura/80*11);
80005aa0:	fa c4 ff f4 	sub	r4,sp,-12
80005aa4:	09 4c       	ld.w	r12,--r4
80005aa6:	f0 1f 00 55 	mcall	80005bf8 <vTareaADC+0x1f8>
80005aaa:	fc 1b 42 a0 	movh	r11,0x42a0
80005aae:	f0 1f 00 54 	mcall	80005bfc <vTareaADC+0x1fc>
80005ab2:	fc 1b 41 30 	movh	r11,0x4130
80005ab6:	f0 1f 00 53 	mcall	80005c00 <vTareaADC+0x200>
80005aba:	f0 1f 00 53 	mcall	80005c04 <vTareaADC+0x204>
80005abe:	f0 1f 00 53 	mcall	80005c08 <vTareaADC+0x208>
				//usart_write_line(&AVR32_USART0,"\r\n");
				xQueueSend(temperaturaQueue,&sensorTemperatura,0);
80005ac2:	0e 99       	mov	r9,r7
80005ac4:	0e 9a       	mov	r10,r7
80005ac6:	08 9b       	mov	r11,r4
80005ac8:	4b e8       	lddpc	r8,80005bc0 <vTareaADC+0x1c0>
80005aca:	70 0c       	ld.w	r12,r8[0x0]
80005acc:	f0 1f 00 50 	mcall	80005c0c <vTareaADC+0x20c>
				vTaskDelay(100);
80005ad0:	06 9c       	mov	r12,r3
80005ad2:	f0 1f 00 45 	mcall	80005be4 <vTareaADC+0x1e4>
				xQueueSend(temperaturaSDQueue,&sensorTemperatura,0);
80005ad6:	0e 99       	mov	r9,r7
80005ad8:	0e 9a       	mov	r10,r7
80005ada:	08 9b       	mov	r11,r4
80005adc:	4b c8       	lddpc	r8,80005bcc <vTareaADC+0x1cc>
80005ade:	70 0c       	ld.w	r12,r8[0x0]
80005ae0:	f0 1f 00 4b 	mcall	80005c0c <vTareaADC+0x20c>
80005ae4:	30 14       	mov	r4,1
80005ae6:	c6 08       	rjmp	80005ba6 <vTareaADC+0x1a6>
				temperatura=sensorTemperatura;
			}
			else if(sensorContador==1){
80005ae8:	58 14       	cp.w	r4,1
80005aea:	c2 e1       	brne	80005b46 <vTareaADC+0x146>
				gpio_set_gpio_pin(62);
80005aec:	00 9c       	mov	r12,r0
80005aee:	f0 1f 00 49 	mcall	80005c10 <vTareaADC+0x210>
				gpio_clr_gpio_pin(63);
80005af2:	33 fc       	mov	r12,63
80005af4:	f0 1f 00 3b 	mcall	80005be0 <vTareaADC+0x1e0>
				vTaskDelay(100);
80005af8:	06 9c       	mov	r12,r3
80005afa:	f0 1f 00 3b 	mcall	80005be4 <vTareaADC+0x1e4>
				//usart_write_line(&AVR32_USART0, pcTaskName);
				adc_start(&AVR32_ADC);
80005afe:	04 9c       	mov	r12,r2
80005b00:	f0 1f 00 3a 	mcall	80005be8 <vTareaADC+0x1e8>
				//adc_value_temp = adc_get_value(&AVR32_ADC,0);
				sensorgas = adc_get_value(&AVR32_ADC,0);
80005b04:	0e 9b       	mov	r11,r7
80005b06:	04 9c       	mov	r12,r2
80005b08:	f0 1f 00 39 	mcall	80005bec <vTareaADC+0x1ec>
80005b0c:	50 1c       	stdsp	sp[0x4],r12
				//gpio_clr_gpio_pin(21);
				sensorContador=2;
				usart_write_line(&AVR32_USART0,"    Gas:");
80005b0e:	4c 2b       	lddpc	r11,80005c14 <vTareaADC+0x214>
80005b10:	02 9c       	mov	r12,r1
80005b12:	f0 1f 00 39 	mcall	80005bf4 <vTareaADC+0x1f4>
				//usart_write_line(&AVR32_USART0,sensorgas);
				print_dbg_ulong(sensorgas);
80005b16:	40 1c       	lddsp	r12,sp[0x4]
80005b18:	f0 1f 00 3c 	mcall	80005c08 <vTareaADC+0x208>
				//usart_write_line(&AVR32_USART0,"\r\n");
				xQueueSend(gasQueue,&sensorgas,0);
80005b1c:	fa c4 ff fc 	sub	r4,sp,-4
80005b20:	0e 99       	mov	r9,r7
80005b22:	0e 9a       	mov	r10,r7
80005b24:	08 9b       	mov	r11,r4
80005b26:	4a 88       	lddpc	r8,80005bc4 <vTareaADC+0x1c4>
80005b28:	70 0c       	ld.w	r12,r8[0x0]
80005b2a:	f0 1f 00 39 	mcall	80005c0c <vTareaADC+0x20c>
				vTaskDelay(100);
80005b2e:	06 9c       	mov	r12,r3
80005b30:	f0 1f 00 2d 	mcall	80005be4 <vTareaADC+0x1e4>
				xQueueSend(gasSDQueue,&sensorgas,0);
80005b34:	0e 99       	mov	r9,r7
80005b36:	0e 9a       	mov	r10,r7
80005b38:	08 9b       	mov	r11,r4
80005b3a:	4a 68       	lddpc	r8,80005bd0 <vTareaADC+0x1d0>
80005b3c:	70 0c       	ld.w	r12,r8[0x0]
80005b3e:	f0 1f 00 34 	mcall	80005c0c <vTareaADC+0x20c>
80005b42:	30 24       	mov	r4,2
80005b44:	c3 18       	rjmp	80005ba6 <vTareaADC+0x1a6>
			}
			else if(sensorContador==2){
80005b46:	58 24       	cp.w	r4,2
80005b48:	c2 f1       	brne	80005ba6 <vTareaADC+0x1a6>
				gpio_clr_gpio_pin(62);
80005b4a:	00 9c       	mov	r12,r0
80005b4c:	f0 1f 00 25 	mcall	80005be0 <vTareaADC+0x1e0>
				gpio_set_gpio_pin(63);
80005b50:	33 fc       	mov	r12,63
80005b52:	f0 1f 00 30 	mcall	80005c10 <vTareaADC+0x210>
				vTaskDelay(100);
80005b56:	06 9c       	mov	r12,r3
80005b58:	f0 1f 00 23 	mcall	80005be4 <vTareaADC+0x1e4>
				//usart_write_line(&AVR32_USART0, pcTaskName);
				adc_start(&AVR32_ADC);
80005b5c:	04 9c       	mov	r12,r2
80005b5e:	f0 1f 00 23 	mcall	80005be8 <vTareaADC+0x1e8>
				//adc_value_temp = adc_get_value(&AVR32_ADC,0);
				sensorIluminosidad = adc_get_value(&AVR32_ADC,0);
80005b62:	0e 9b       	mov	r11,r7
80005b64:	04 9c       	mov	r12,r2
80005b66:	f0 1f 00 22 	mcall	80005bec <vTareaADC+0x1ec>
80005b6a:	50 0c       	stdsp	sp[0x0],r12
				//gpio_clr_gpio_pin(21);
				sensorContador=0;
				usart_write_line(&AVR32_USART0,"    Iluminosidad:");
80005b6c:	4a bb       	lddpc	r11,80005c18 <vTareaADC+0x218>
80005b6e:	02 9c       	mov	r12,r1
80005b70:	f0 1f 00 21 	mcall	80005bf4 <vTareaADC+0x1f4>
				//usart_write_line(&AVR32_USART0,sensorgas);
				print_dbg_ulong(sensorIluminosidad);
80005b74:	40 0c       	lddsp	r12,sp[0x0]
80005b76:	f0 1f 00 25 	mcall	80005c08 <vTareaADC+0x208>
				usart_write_line(&AVR32_USART0,"\r\n");
80005b7a:	4a 9b       	lddpc	r11,80005c1c <vTareaADC+0x21c>
80005b7c:	02 9c       	mov	r12,r1
80005b7e:	f0 1f 00 1e 	mcall	80005bf4 <vTareaADC+0x1f4>
				xQueueSend(iluminosidadQueue,&sensorIluminosidad,0);
80005b82:	0e 99       	mov	r9,r7
80005b84:	0e 9a       	mov	r10,r7
80005b86:	1a 9b       	mov	r11,sp
80005b88:	49 08       	lddpc	r8,80005bc8 <vTareaADC+0x1c8>
80005b8a:	70 0c       	ld.w	r12,r8[0x0]
80005b8c:	f0 1f 00 20 	mcall	80005c0c <vTareaADC+0x20c>
				vTaskDelay(100);
80005b90:	06 9c       	mov	r12,r3
80005b92:	f0 1f 00 15 	mcall	80005be4 <vTareaADC+0x1e4>
				xQueueSend(iluminosidadSDQueue,&sensorIluminosidad,0);
80005b96:	0e 99       	mov	r9,r7
80005b98:	0e 9a       	mov	r10,r7
80005b9a:	1a 9b       	mov	r11,sp
80005b9c:	48 e8       	lddpc	r8,80005bd4 <vTareaADC+0x1d4>
80005b9e:	70 0c       	ld.w	r12,r8[0x0]
80005ba0:	f0 1f 00 1b 	mcall	80005c0c <vTareaADC+0x20c>
80005ba4:	0e 94       	mov	r4,r7
			}
			xSemaphoreGive(xMutex);
80005ba6:	0e 99       	mov	r9,r7
80005ba8:	0e 9a       	mov	r10,r7
80005baa:	0e 9b       	mov	r11,r7
80005bac:	6c 0c       	ld.w	r12,r6[0x0]
80005bae:	f0 1f 00 18 	mcall	80005c0c <vTareaADC+0x20c>
		}
		vTaskDelay(1000);
80005bb2:	e0 6c 03 e8 	mov	r12,1000
80005bb6:	f0 1f 00 0c 	mcall	80005be4 <vTareaADC+0x1e4>
	}
80005bba:	c5 3b       	rjmp	80005a60 <vTareaADC+0x60>
80005bbc:	80 00       	ld.sh	r0,r0[0x0]
80005bbe:	63 bc       	ld.w	r12,r1[0x6c]
80005bc0:	00 00       	add	r0,r0
80005bc2:	0e 48       	or	r8,r7
80005bc4:	00 00       	add	r0,r0
80005bc6:	0a 3c       	cp.w	r12,r5
80005bc8:	00 00       	add	r0,r0
80005bca:	0e 2c       	rsub	r12,r7
80005bcc:	00 00       	add	r0,r0
80005bce:	0e 3c       	cp.w	r12,r7
80005bd0:	00 00       	add	r0,r0
80005bd2:	10 4c       	or	r12,r8
80005bd4:	00 00       	add	r0,r0
80005bd6:	0a 40       	or	r0,r5
80005bd8:	00 00       	add	r0,r0
80005bda:	0e 34       	cp.w	r4,r7
80005bdc:	80 00       	ld.sh	r0,r0[0x0]
80005bde:	60 a8       	ld.w	r8,r0[0x28]
80005be0:	80 00       	ld.sh	r0,r0[0x0]
80005be2:	41 4e       	lddsp	lr,sp[0x50]
80005be4:	80 00       	ld.sh	r0,r0[0x0]
80005be6:	6a 44       	ld.w	r4,r5[0x10]
80005be8:	80 00       	ld.sh	r0,r0[0x0]
80005bea:	3e e6       	mov	r6,-18
80005bec:	80 00       	ld.sh	r0,r0[0x0]
80005bee:	3f 08       	mov	r8,-16
80005bf0:	80 02       	ld.sh	r2,r0[0x0]
80005bf2:	27 e0       	sub	r0,126
80005bf4:	80 00       	ld.sh	r0,r0[0x0]
80005bf6:	49 c8       	lddpc	r8,80005c64 <vListInsert+0xe>
80005bf8:	80 00       	ld.sh	r0,r0[0x0]
80005bfa:	78 fa       	ld.w	r10,r12[0x3c]
80005bfc:	80 00       	ld.sh	r0,r0[0x0]
80005bfe:	76 b8       	ld.w	r8,r11[0x2c]
80005c00:	80 00       	ld.sh	r0,r0[0x0]
80005c02:	78 18       	ld.w	r8,r12[0x4]
80005c04:	80 00       	ld.sh	r0,r0[0x0]
80005c06:	79 6e       	ld.w	lr,r12[0x58]
80005c08:	80 00       	ld.sh	r0,r0[0x0]
80005c0a:	4b 38       	lddpc	r8,80005cd4 <pxPortInitialiseStack+0x24>
80005c0c:	80 00       	ld.sh	r0,r0[0x0]
80005c0e:	62 64       	ld.w	r4,r1[0x18]
80005c10:	80 00       	ld.sh	r0,r0[0x0]
80005c12:	41 32       	lddsp	r2,sp[0x4c]
80005c14:	80 02       	ld.sh	r2,r0[0x0]
80005c16:	27 f0       	sub	r0,127
80005c18:	80 02       	ld.sh	r2,r0[0x0]
80005c1a:	27 fc       	sub	r12,127
80005c1c:	80 02       	ld.sh	r2,r0[0x0]
80005c1e:	28 10       	sub	r0,-127

80005c20 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005c20:	f8 c8 ff f8 	sub	r8,r12,-8
80005c24:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80005c26:	3f f9       	mov	r9,-1
80005c28:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005c2a:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005c2c:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005c2e:	30 08       	mov	r8,0
80005c30:	99 08       	st.w	r12[0x0],r8
}
80005c32:	5e fc       	retal	r12

80005c34 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005c34:	30 08       	mov	r8,0
80005c36:	99 48       	st.w	r12[0x10],r8
}
80005c38:	5e fc       	retal	r12

80005c3a <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005c3a:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005c3c:	70 19       	ld.w	r9,r8[0x4]
80005c3e:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005c40:	78 19       	ld.w	r9,r12[0x4]
80005c42:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005c44:	70 19       	ld.w	r9,r8[0x4]
80005c46:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005c48:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005c4a:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005c4c:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005c4e:	78 08       	ld.w	r8,r12[0x0]
80005c50:	2f f8       	sub	r8,-1
80005c52:	99 08       	st.w	r12[0x0],r8
}
80005c54:	5e fc       	retal	r12

80005c56 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005c56:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005c58:	5b fa       	cp.w	r10,-1
80005c5a:	c0 31       	brne	80005c60 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005c5c:	78 48       	ld.w	r8,r12[0x10]
80005c5e:	c0 c8       	rjmp	80005c76 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005c60:	f8 c8 ff f8 	sub	r8,r12,-8
80005c64:	70 19       	ld.w	r9,r8[0x4]
80005c66:	72 09       	ld.w	r9,r9[0x0]
80005c68:	12 3a       	cp.w	r10,r9
80005c6a:	c0 63       	brcs	80005c76 <vListInsert+0x20>
80005c6c:	70 18       	ld.w	r8,r8[0x4]
80005c6e:	70 19       	ld.w	r9,r8[0x4]
80005c70:	72 09       	ld.w	r9,r9[0x0]
80005c72:	12 3a       	cp.w	r10,r9
80005c74:	cf c2       	brcc	80005c6c <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005c76:	70 19       	ld.w	r9,r8[0x4]
80005c78:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005c7a:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005c7c:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005c7e:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005c80:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005c82:	78 08       	ld.w	r8,r12[0x0]
80005c84:	2f f8       	sub	r8,-1
80005c86:	99 08       	st.w	r12[0x0],r8
}
80005c88:	5e fc       	retal	r12

80005c8a <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005c8a:	78 18       	ld.w	r8,r12[0x4]
80005c8c:	78 29       	ld.w	r9,r12[0x8]
80005c8e:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005c90:	78 28       	ld.w	r8,r12[0x8]
80005c92:	78 19       	ld.w	r9,r12[0x4]
80005c94:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005c96:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005c98:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005c9a:	18 39       	cp.w	r9,r12
80005c9c:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005ca0:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005ca4:	30 09       	mov	r9,0
80005ca6:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005ca8:	70 09       	ld.w	r9,r8[0x0]
80005caa:	20 19       	sub	r9,1
80005cac:	91 09       	st.w	r8[0x0],r9
}
80005cae:	5e fc       	retal	r12

80005cb0 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005cb0:	e0 68 08 08 	mov	r8,2056
80005cb4:	ea 18 08 08 	orh	r8,0x808
80005cb8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005cba:	e0 68 09 09 	mov	r8,2313
80005cbe:	ea 18 09 09 	orh	r8,0x909
80005cc2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005cc4:	e0 68 0a 0a 	mov	r8,2570
80005cc8:	ea 18 0a 0a 	orh	r8,0xa0a
80005ccc:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005cce:	e0 68 0b 0b 	mov	r8,2827
80005cd2:	ea 18 0b 0b 	orh	r8,0xb0b
80005cd6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005cd8:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005cda:	e0 68 be ef 	mov	r8,48879
80005cde:	ea 18 de ad 	orh	r8,0xdead
80005ce2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005ce4:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005ce6:	fc 18 00 40 	movh	r8,0x40
80005cea:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005cec:	e0 68 00 ff 	mov	r8,255
80005cf0:	ea 18 ff 00 	orh	r8,0xff00
80005cf4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005cf6:	e0 68 01 01 	mov	r8,257
80005cfa:	ea 18 01 01 	orh	r8,0x101
80005cfe:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005d00:	e0 68 02 02 	mov	r8,514
80005d04:	ea 18 02 02 	orh	r8,0x202
80005d08:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005d0a:	e0 68 03 03 	mov	r8,771
80005d0e:	ea 18 03 03 	orh	r8,0x303
80005d12:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005d14:	e0 68 04 04 	mov	r8,1028
80005d18:	ea 18 04 04 	orh	r8,0x404
80005d1c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005d1e:	e0 68 05 05 	mov	r8,1285
80005d22:	ea 18 05 05 	orh	r8,0x505
80005d26:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005d28:	e0 68 06 06 	mov	r8,1542
80005d2c:	ea 18 06 06 	orh	r8,0x606
80005d30:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005d32:	e0 68 07 07 	mov	r8,1799
80005d36:	ea 18 07 07 	orh	r8,0x707
80005d3a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005d3c:	30 08       	mov	r8,0
80005d3e:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005d40:	5e fc       	retal	r12
80005d42:	d7 03       	nop

80005d44 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005d44:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005d46:	48 38       	lddpc	r8,80005d50 <vPortEnterCritical+0xc>
80005d48:	70 09       	ld.w	r9,r8[0x0]
80005d4a:	2f f9       	sub	r9,-1
80005d4c:	91 09       	st.w	r8[0x0],r9
}
80005d4e:	5e fc       	retal	r12
80005d50:	00 00       	add	r0,r0
80005d52:	00 2c       	rsub	r12,r0

80005d54 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005d54:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005d56:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005d58:	30 0a       	mov	r10,0
80005d5a:	14 9b       	mov	r11,r10
80005d5c:	49 2c       	lddpc	r12,80005da4 <xPortStartScheduler+0x50>
80005d5e:	f0 1f 00 13 	mcall	80005da8 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);
80005d62:	e0 68 2e e0 	mov	r8,12000
80005d66:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005d6a:	30 08       	mov	r8,0
80005d6c:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005d70:	e0 68 07 68 	mov	r8,1896
80005d74:	ea 18 00 00 	orh	r8,0x0
80005d78:	70 00       	ld.w	r0,r8[0x0]
80005d7a:	60 0d       	ld.w	sp,r0[0x0]
80005d7c:	1b 00       	ld.w	r0,sp++
80005d7e:	e0 68 00 2c 	mov	r8,44
80005d82:	ea 18 00 00 	orh	r8,0x0
80005d86:	91 00       	st.w	r8[0x0],r0
80005d88:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005d8c:	2f ed       	sub	sp,-8
80005d8e:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005d92:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005d96:	e3 b0 00 00 	mtsr	0x0,r0
80005d9a:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005d9e:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80005da2:	d8 0a       	popm	pc,r12=0
80005da4:	80 00       	ld.sh	r0,r0[0x0]
80005da6:	5e 70       	retpl	r0
80005da8:	80 00       	ld.sh	r0,r0[0x0]
80005daa:	41 6c       	lddsp	r12,sp[0x58]

80005dac <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005dac:	20 6d       	sub	sp,24
80005dae:	eb cd 00 ff 	pushm	r0-r7
80005db2:	fa c7 ff c0 	sub	r7,sp,-64
80005db6:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005dba:	ef 40 ff e0 	st.w	r7[-32],r0
80005dbe:	ee f0 ff fc 	ld.w	r0,r7[-4]
80005dc2:	ef 40 ff e4 	st.w	r7[-28],r0
80005dc6:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005dca:	e0 68 00 2c 	mov	r8,44
80005dce:	ea 18 00 00 	orh	r8,0x0
80005dd2:	70 00       	ld.w	r0,r8[0x0]
80005dd4:	1a d0       	st.w	--sp,r0
80005dd6:	f0 1f 00 1a 	mcall	80005e3c <LABEL_RET_SCALL_260+0x14>
80005dda:	e0 68 07 68 	mov	r8,1896
80005dde:	ea 18 00 00 	orh	r8,0x0
80005de2:	70 00       	ld.w	r0,r8[0x0]
80005de4:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005de6:	f0 1f 00 17 	mcall	80005e40 <LABEL_RET_SCALL_260+0x18>
	portRESTORE_CONTEXT_SCALL();
80005dea:	e0 68 07 68 	mov	r8,1896
80005dee:	ea 18 00 00 	orh	r8,0x0
80005df2:	70 00       	ld.w	r0,r8[0x0]
80005df4:	60 0d       	ld.w	sp,r0[0x0]
80005df6:	1b 00       	ld.w	r0,sp++
80005df8:	e0 68 00 2c 	mov	r8,44
80005dfc:	ea 18 00 00 	orh	r8,0x0
80005e00:	91 00       	st.w	r8[0x0],r0
80005e02:	fa c7 ff d8 	sub	r7,sp,-40
80005e06:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005e0a:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005e0e:	e0 61 00 2c 	mov	r1,44
80005e12:	ea 11 00 00 	orh	r1,0x0
80005e16:	62 02       	ld.w	r2,r1[0x0]
80005e18:	58 02       	cp.w	r2,0
80005e1a:	c0 70       	breq	80005e28 <LABEL_RET_SCALL_260>
80005e1c:	e4 c2 00 01 	sub	r2,r2,1
80005e20:	83 02       	st.w	r1[0x0],r2
80005e22:	58 02       	cp.w	r2,0
80005e24:	c0 21       	brne	80005e28 <LABEL_RET_SCALL_260>
80005e26:	b1 c0       	cbr	r0,0x10

80005e28 <LABEL_RET_SCALL_260>:
80005e28:	ef 40 ff f8 	st.w	r7[-8],r0
80005e2c:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005e30:	ef 40 ff fc 	st.w	r7[-4],r0
80005e34:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005e38:	2f ad       	sub	sp,-24
80005e3a:	d6 13       	rets
80005e3c:	80 00       	ld.sh	r0,r0[0x0]
80005e3e:	5d 44       	*unknown*
80005e40:	80 00       	ld.sh	r0,r0[0x0]
80005e42:	64 60       	ld.w	r0,r2[0x18]

80005e44 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005e44:	e1 b8 00 43 	mfsr	r8,0x10c
80005e48:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005e4c:	5e fc       	retal	r12
80005e4e:	d7 03       	nop

80005e50 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005e50:	48 78       	lddpc	r8,80005e6c <vPortExitCritical+0x1c>
80005e52:	70 08       	ld.w	r8,r8[0x0]
80005e54:	58 08       	cp.w	r8,0
80005e56:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005e58:	48 58       	lddpc	r8,80005e6c <vPortExitCritical+0x1c>
80005e5a:	70 09       	ld.w	r9,r8[0x0]
80005e5c:	20 19       	sub	r9,1
80005e5e:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005e60:	70 08       	ld.w	r8,r8[0x0]
80005e62:	58 08       	cp.w	r8,0
80005e64:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005e66:	d5 03       	csrf	0x10
80005e68:	5e fc       	retal	r12
80005e6a:	00 00       	add	r0,r0
80005e6c:	00 00       	add	r0,r0
80005e6e:	00 2c       	rsub	r12,r0

80005e70 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005e70:	eb cd 00 ff 	pushm	r0-r7
80005e74:	e0 68 00 2c 	mov	r8,44
80005e78:	ea 18 00 00 	orh	r8,0x0
80005e7c:	70 00       	ld.w	r0,r8[0x0]
80005e7e:	1a d0       	st.w	--sp,r0
80005e80:	7a 90       	ld.w	r0,sp[0x24]
80005e82:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005e86:	58 10       	cp.w	r0,1
80005e88:	e0 8b 00 08 	brhi	80005e98 <LABEL_INT_SKIP_SAVE_CONTEXT_234>
80005e8c:	e0 68 07 68 	mov	r8,1896
80005e90:	ea 18 00 00 	orh	r8,0x0
80005e94:	70 00       	ld.w	r0,r8[0x0]
80005e96:	81 0d       	st.w	r0[0x0],sp

80005e98 <LABEL_INT_SKIP_SAVE_CONTEXT_234>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005e98:	f0 1f 00 12 	mcall	80005ee0 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005e9c:	f0 1f 00 12 	mcall	80005ee4 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x18>
		vTaskIncrementTick();
80005ea0:	f0 1f 00 12 	mcall	80005ee8 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x1c>
	portEXIT_CRITICAL();
80005ea4:	f0 1f 00 12 	mcall	80005eec <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005ea8:	7a 90       	ld.w	r0,sp[0x24]
80005eaa:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005eae:	58 10       	cp.w	r0,1
80005eb0:	e0 8b 00 0e 	brhi	80005ecc <LABEL_INT_SKIP_RESTORE_CONTEXT_251>
80005eb4:	f0 1f 00 0c 	mcall	80005ee4 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x18>
80005eb8:	f0 1f 00 0e 	mcall	80005ef0 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x24>
80005ebc:	f0 1f 00 0c 	mcall	80005eec <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x20>
80005ec0:	e0 68 07 68 	mov	r8,1896
80005ec4:	ea 18 00 00 	orh	r8,0x0
80005ec8:	70 00       	ld.w	r0,r8[0x0]
80005eca:	60 0d       	ld.w	sp,r0[0x0]

80005ecc <LABEL_INT_SKIP_RESTORE_CONTEXT_251>:
80005ecc:	1b 00       	ld.w	r0,sp++
80005ece:	e0 68 00 2c 	mov	r8,44
80005ed2:	ea 18 00 00 	orh	r8,0x0
80005ed6:	91 00       	st.w	r8[0x0],r0
80005ed8:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005edc:	d6 03       	rete
80005ede:	00 00       	add	r0,r0
80005ee0:	80 00       	ld.sh	r0,r0[0x0]
80005ee2:	5e 44       	retge	r4
80005ee4:	80 00       	ld.sh	r0,r0[0x0]
80005ee6:	5d 44       	*unknown*
80005ee8:	80 00       	ld.sh	r0,r0[0x0]
80005eea:	66 64       	ld.w	r4,r3[0x18]
80005eec:	80 00       	ld.sh	r0,r0[0x0]
80005eee:	5e 50       	retlt	r0
80005ef0:	80 00       	ld.sh	r0,r0[0x0]
80005ef2:	64 60       	ld.w	r0,r2[0x18]

80005ef4 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005ef4:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005ef6:	f0 1f 00 02 	mcall	80005efc <__malloc_lock+0x8>
}
80005efa:	d8 02       	popm	pc
80005efc:	80 00       	ld.sh	r0,r0[0x0]
80005efe:	64 50       	ld.w	r0,r2[0x14]

80005f00 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005f00:	d4 01       	pushm	lr
	xTaskResumeAll();
80005f02:	f0 1f 00 02 	mcall	80005f08 <__malloc_unlock+0x8>
}
80005f06:	d8 02       	popm	pc
80005f08:	80 00       	ld.sh	r0,r0[0x0]
80005f0a:	67 e8       	ld.w	r8,r3[0x78]

80005f0c <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005f0c:	d4 21       	pushm	r4-r7,lr
80005f0e:	16 95       	mov	r5,r11
80005f10:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80005f12:	58 0c       	cp.w	r12,0
80005f14:	c0 30       	breq	80005f1a <_read+0xe>
80005f16:	3f f7       	mov	r7,-1
80005f18:	c1 48       	rjmp	80005f40 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005f1a:	58 0a       	cp.w	r10,0
80005f1c:	e0 89 00 04 	brgt	80005f24 <_read+0x18>
80005f20:	30 07       	mov	r7,0
80005f22:	c0 f8       	rjmp	80005f40 <_read+0x34>
80005f24:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005f26:	48 84       	lddpc	r4,80005f44 <_read+0x38>
80005f28:	68 0c       	ld.w	r12,r4[0x0]
80005f2a:	f0 1f 00 08 	mcall	80005f48 <_read+0x3c>
    if (c < 0)
80005f2e:	c0 95       	brlt	80005f40 <_read+0x34>
      break;

    *ptr++ = c;
80005f30:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005f34:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005f36:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005f3a:	58 08       	cp.w	r8,0
80005f3c:	fe 99 ff f6 	brgt	80005f28 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80005f40:	0e 9c       	mov	r12,r7
80005f42:	d8 22       	popm	r4-r7,pc
80005f44:	00 00       	add	r0,r0
80005f46:	10 58       	eor	r8,r8
80005f48:	80 00       	ld.sh	r0,r0[0x0]
80005f4a:	49 9c       	lddpc	r12,80005fac <vPortFree+0x24>

80005f4c <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005f4c:	d4 21       	pushm	r4-r7,lr
80005f4e:	16 95       	mov	r5,r11
80005f50:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80005f52:	20 1c       	sub	r12,1
80005f54:	58 2c       	cp.w	r12,2
80005f56:	e0 8b 00 12 	brhi	80005f7a <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005f5a:	58 0a       	cp.w	r10,0
80005f5c:	c0 31       	brne	80005f62 <_write+0x16>
80005f5e:	30 07       	mov	r7,0
80005f60:	c0 e8       	rjmp	80005f7c <_write+0x30>
80005f62:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005f64:	48 74       	lddpc	r4,80005f80 <_write+0x34>
80005f66:	68 0c       	ld.w	r12,r4[0x0]
80005f68:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005f6c:	f0 1f 00 06 	mcall	80005f84 <_write+0x38>
80005f70:	c0 55       	brlt	80005f7a <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80005f72:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005f74:	0e 36       	cp.w	r6,r7
80005f76:	cf 81       	brne	80005f66 <_write+0x1a>
80005f78:	c0 28       	rjmp	80005f7c <_write+0x30>
80005f7a:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005f7c:	0e 9c       	mov	r12,r7
80005f7e:	d8 22       	popm	r4-r7,pc
80005f80:	00 00       	add	r0,r0
80005f82:	10 58       	eor	r8,r8
80005f84:	80 00       	ld.sh	r0,r0[0x0]
80005f86:	49 4c       	lddpc	r12,80005fd4 <pvPortMalloc+0x24>

80005f88 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005f88:	eb cd 40 80 	pushm	r7,lr
80005f8c:	18 97       	mov	r7,r12
	if( pv )
80005f8e:	58 0c       	cp.w	r12,0
80005f90:	c0 80       	breq	80005fa0 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80005f92:	f0 1f 00 05 	mcall	80005fa4 <vPortFree+0x1c>
		{
			free( pv );
80005f96:	0e 9c       	mov	r12,r7
80005f98:	f0 1f 00 04 	mcall	80005fa8 <vPortFree+0x20>
		}
		xTaskResumeAll();
80005f9c:	f0 1f 00 04 	mcall	80005fac <vPortFree+0x24>
80005fa0:	e3 cd 80 80 	ldm	sp++,r7,pc
80005fa4:	80 00       	ld.sh	r0,r0[0x0]
80005fa6:	64 50       	ld.w	r0,r2[0x14]
80005fa8:	80 00       	ld.sh	r0,r0[0x0]
80005faa:	7b ec       	ld.w	r12,sp[0x78]
80005fac:	80 00       	ld.sh	r0,r0[0x0]
80005fae:	67 e8       	ld.w	r8,r3[0x78]

80005fb0 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80005fb0:	eb cd 40 80 	pushm	r7,lr
80005fb4:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80005fb6:	f0 1f 00 06 	mcall	80005fcc <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80005fba:	0e 9c       	mov	r12,r7
80005fbc:	f0 1f 00 05 	mcall	80005fd0 <pvPortMalloc+0x20>
80005fc0:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80005fc2:	f0 1f 00 05 	mcall	80005fd4 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80005fc6:	0e 9c       	mov	r12,r7
80005fc8:	e3 cd 80 80 	ldm	sp++,r7,pc
80005fcc:	80 00       	ld.sh	r0,r0[0x0]
80005fce:	64 50       	ld.w	r0,r2[0x14]
80005fd0:	80 00       	ld.sh	r0,r0[0x0]
80005fd2:	7b fc       	ld.w	r12,sp[0x7c]
80005fd4:	80 00       	ld.sh	r0,r0[0x0]
80005fd6:	67 e8       	ld.w	r8,r3[0x78]

80005fd8 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005fd8:	d4 01       	pushm	lr
80005fda:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005fdc:	78 09       	ld.w	r9,r12[0x0]
80005fde:	58 09       	cp.w	r9,0
80005fe0:	c1 10       	breq	80006002 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80005fe2:	78 3a       	ld.w	r10,r12[0xc]
80005fe4:	79 09       	ld.w	r9,r12[0x40]
80005fe6:	f4 09 00 09 	add	r9,r10,r9
80005fea:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005fec:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80005fee:	14 39       	cp.w	r9,r10
80005ff0:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80005ff4:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005ff8:	79 0a       	ld.w	r10,r12[0x40]
80005ffa:	78 3b       	ld.w	r11,r12[0xc]
80005ffc:	10 9c       	mov	r12,r8
80005ffe:	f0 1f 00 02 	mcall	80006004 <prvCopyDataFromQueue+0x2c>
80006002:	d8 02       	popm	pc
80006004:	80 00       	ld.sh	r0,r0[0x0]
80006006:	80 38       	ld.sh	r8,r0[0x6]

80006008 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80006008:	eb cd 40 c0 	pushm	r6-r7,lr
8000600c:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
8000600e:	f0 1f 00 23 	mcall	80006098 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80006012:	6f 28       	ld.w	r8,r7[0x48]
80006014:	58 08       	cp.w	r8,0
80006016:	e0 8a 00 18 	brle	80006046 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000601a:	6e 98       	ld.w	r8,r7[0x24]
8000601c:	58 08       	cp.w	r8,0
8000601e:	c1 40       	breq	80006046 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006020:	ee c6 ff dc 	sub	r6,r7,-36
80006024:	c0 48       	rjmp	8000602c <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006026:	6e 98       	ld.w	r8,r7[0x24]
80006028:	58 08       	cp.w	r8,0
8000602a:	c0 e0       	breq	80006046 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000602c:	0c 9c       	mov	r12,r6
8000602e:	f0 1f 00 1c 	mcall	8000609c <prvUnlockQueue+0x94>
80006032:	c0 30       	breq	80006038 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80006034:	f0 1f 00 1b 	mcall	800060a0 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80006038:	6f 28       	ld.w	r8,r7[0x48]
8000603a:	20 18       	sub	r8,1
8000603c:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80006040:	58 08       	cp.w	r8,0
80006042:	fe 99 ff f2 	brgt	80006026 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80006046:	3f f8       	mov	r8,-1
80006048:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
8000604c:	f0 1f 00 16 	mcall	800060a4 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80006050:	f0 1f 00 12 	mcall	80006098 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80006054:	6f 18       	ld.w	r8,r7[0x44]
80006056:	58 08       	cp.w	r8,0
80006058:	e0 8a 00 18 	brle	80006088 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000605c:	6e 48       	ld.w	r8,r7[0x10]
8000605e:	58 08       	cp.w	r8,0
80006060:	c1 40       	breq	80006088 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80006062:	ee c6 ff f0 	sub	r6,r7,-16
80006066:	c0 48       	rjmp	8000606e <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006068:	6e 48       	ld.w	r8,r7[0x10]
8000606a:	58 08       	cp.w	r8,0
8000606c:	c0 e0       	breq	80006088 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000606e:	0c 9c       	mov	r12,r6
80006070:	f0 1f 00 0b 	mcall	8000609c <prvUnlockQueue+0x94>
80006074:	c0 30       	breq	8000607a <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80006076:	f0 1f 00 0b 	mcall	800060a0 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
8000607a:	6f 18       	ld.w	r8,r7[0x44]
8000607c:	20 18       	sub	r8,1
8000607e:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80006082:	58 08       	cp.w	r8,0
80006084:	fe 99 ff f2 	brgt	80006068 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80006088:	3f f8       	mov	r8,-1
8000608a:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
8000608e:	f0 1f 00 06 	mcall	800060a4 <prvUnlockQueue+0x9c>
}
80006092:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006096:	00 00       	add	r0,r0
80006098:	80 00       	ld.sh	r0,r0[0x0]
8000609a:	5d 44       	*unknown*
8000609c:	80 00       	ld.sh	r0,r0[0x0]
8000609e:	65 e8       	ld.w	r8,r2[0x78]
800060a0:	80 00       	ld.sh	r0,r0[0x0]
800060a2:	64 f4       	ld.w	r4,r2[0x3c]
800060a4:	80 00       	ld.sh	r0,r0[0x0]
800060a6:	5e 50       	retlt	r0

800060a8 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
800060a8:	d4 31       	pushm	r0-r7,lr
800060aa:	20 5d       	sub	sp,20
800060ac:	18 97       	mov	r7,r12
800060ae:	50 0b       	stdsp	sp[0x0],r11
800060b0:	50 2a       	stdsp	sp[0x8],r10
800060b2:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800060b4:	f8 c2 ff dc 	sub	r2,r12,-36
800060b8:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800060ba:	fa c4 ff f4 	sub	r4,sp,-12
800060be:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800060c0:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800060c2:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
800060c6:	f0 1f 00 3e 	mcall	800061bc <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800060ca:	6e e8       	ld.w	r8,r7[0x38]
800060cc:	58 08       	cp.w	r8,0
800060ce:	c2 a0       	breq	80006122 <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
800060d0:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
800060d2:	40 0b       	lddsp	r11,sp[0x0]
800060d4:	0e 9c       	mov	r12,r7
800060d6:	f0 1f 00 3b 	mcall	800061c0 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
800060da:	40 18       	lddsp	r8,sp[0x4]
800060dc:	58 08       	cp.w	r8,0
800060de:	c1 51       	brne	80006108 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
800060e0:	6e e8       	ld.w	r8,r7[0x38]
800060e2:	20 18       	sub	r8,1
800060e4:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800060e6:	6e 08       	ld.w	r8,r7[0x0]
800060e8:	58 08       	cp.w	r8,0
800060ea:	c0 41       	brne	800060f2 <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
800060ec:	f0 1f 00 36 	mcall	800061c4 <xQueueGenericReceive+0x11c>
800060f0:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800060f2:	6e 48       	ld.w	r8,r7[0x10]
800060f4:	58 08       	cp.w	r8,0
800060f6:	c1 20       	breq	8000611a <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
800060f8:	ee cc ff f0 	sub	r12,r7,-16
800060fc:	f0 1f 00 33 	mcall	800061c8 <xQueueGenericReceive+0x120>
80006100:	58 1c       	cp.w	r12,1
80006102:	c0 c1       	brne	8000611a <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80006104:	d7 33       	scall
80006106:	c0 a8       	rjmp	8000611a <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80006108:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000610a:	6e 98       	ld.w	r8,r7[0x24]
8000610c:	58 08       	cp.w	r8,0
8000610e:	c0 60       	breq	8000611a <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006110:	04 9c       	mov	r12,r2
80006112:	f0 1f 00 2e 	mcall	800061c8 <xQueueGenericReceive+0x120>
80006116:	c0 20       	breq	8000611a <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80006118:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
8000611a:	f0 1f 00 2d 	mcall	800061cc <xQueueGenericReceive+0x124>
8000611e:	30 1c       	mov	r12,1
				return pdPASS;
80006120:	c4 c8       	rjmp	800061b8 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80006122:	40 28       	lddsp	r8,sp[0x8]
80006124:	58 08       	cp.w	r8,0
80006126:	c0 51       	brne	80006130 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80006128:	f0 1f 00 29 	mcall	800061cc <xQueueGenericReceive+0x124>
8000612c:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
8000612e:	c4 58       	rjmp	800061b8 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80006130:	58 05       	cp.w	r5,0
80006132:	c0 51       	brne	8000613c <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006134:	08 9c       	mov	r12,r4
80006136:	f0 1f 00 27 	mcall	800061d0 <xQueueGenericReceive+0x128>
8000613a:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
8000613c:	f0 1f 00 24 	mcall	800061cc <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80006140:	f0 1f 00 25 	mcall	800061d4 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80006144:	f0 1f 00 1e 	mcall	800061bc <xQueueGenericReceive+0x114>
80006148:	6f 18       	ld.w	r8,r7[0x44]
8000614a:	5b f8       	cp.w	r8,-1
8000614c:	ef f1 0a 11 	st.weq	r7[0x44],r1
80006150:	6f 28       	ld.w	r8,r7[0x48]
80006152:	5b f8       	cp.w	r8,-1
80006154:	ef f1 0a 12 	st.weq	r7[0x48],r1
80006158:	f0 1f 00 1d 	mcall	800061cc <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000615c:	06 9b       	mov	r11,r3
8000615e:	08 9c       	mov	r12,r4
80006160:	f0 1f 00 1e 	mcall	800061d8 <xQueueGenericReceive+0x130>
80006164:	c2 41       	brne	800061ac <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80006166:	f0 1f 00 16 	mcall	800061bc <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
8000616a:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
8000616c:	f0 1f 00 18 	mcall	800061cc <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80006170:	58 06       	cp.w	r6,0
80006172:	c1 71       	brne	800061a0 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006174:	6e 08       	ld.w	r8,r7[0x0]
80006176:	58 08       	cp.w	r8,0
80006178:	c0 81       	brne	80006188 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
8000617a:	f0 1f 00 11 	mcall	800061bc <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
8000617e:	6e 1c       	ld.w	r12,r7[0x4]
80006180:	f0 1f 00 17 	mcall	800061dc <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80006184:	f0 1f 00 12 	mcall	800061cc <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80006188:	40 2b       	lddsp	r11,sp[0x8]
8000618a:	04 9c       	mov	r12,r2
8000618c:	f0 1f 00 15 	mcall	800061e0 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80006190:	0e 9c       	mov	r12,r7
80006192:	f0 1f 00 15 	mcall	800061e4 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80006196:	f0 1f 00 15 	mcall	800061e8 <xQueueGenericReceive+0x140>
8000619a:	c9 61       	brne	800060c6 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
8000619c:	d7 33       	scall
8000619e:	c9 4b       	rjmp	800060c6 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800061a0:	0e 9c       	mov	r12,r7
800061a2:	f0 1f 00 11 	mcall	800061e4 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
800061a6:	f0 1f 00 11 	mcall	800061e8 <xQueueGenericReceive+0x140>
800061aa:	c8 eb       	rjmp	800060c6 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
800061ac:	0e 9c       	mov	r12,r7
800061ae:	f0 1f 00 0e 	mcall	800061e4 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
800061b2:	f0 1f 00 0e 	mcall	800061e8 <xQueueGenericReceive+0x140>
800061b6:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
800061b8:	2f bd       	sub	sp,-20
800061ba:	d8 32       	popm	r0-r7,pc
800061bc:	80 00       	ld.sh	r0,r0[0x0]
800061be:	5d 44       	*unknown*
800061c0:	80 00       	ld.sh	r0,r0[0x0]
800061c2:	5f d8       	srvc	r8
800061c4:	80 00       	ld.sh	r0,r0[0x0]
800061c6:	65 00       	ld.w	r0,r2[0x40]
800061c8:	80 00       	ld.sh	r0,r0[0x0]
800061ca:	65 e8       	ld.w	r8,r2[0x78]
800061cc:	80 00       	ld.sh	r0,r0[0x0]
800061ce:	5e 50       	retlt	r0
800061d0:	80 00       	ld.sh	r0,r0[0x0]
800061d2:	64 dc       	ld.w	r12,r2[0x34]
800061d4:	80 00       	ld.sh	r0,r0[0x0]
800061d6:	64 50       	ld.w	r0,r2[0x14]
800061d8:	80 00       	ld.sh	r0,r0[0x0]
800061da:	67 78       	ld.w	r8,r3[0x5c]
800061dc:	80 00       	ld.sh	r0,r0[0x0]
800061de:	65 64       	ld.w	r4,r2[0x58]
800061e0:	80 00       	ld.sh	r0,r0[0x0]
800061e2:	6a 8c       	ld.w	r12,r5[0x20]
800061e4:	80 00       	ld.sh	r0,r0[0x0]
800061e6:	60 08       	ld.w	r8,r0[0x0]
800061e8:	80 00       	ld.sh	r0,r0[0x0]
800061ea:	67 e8       	ld.w	r8,r3[0x78]

800061ec <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
800061ec:	eb cd 40 80 	pushm	r7,lr
800061f0:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
800061f2:	79 08       	ld.w	r8,r12[0x40]
800061f4:	58 08       	cp.w	r8,0
800061f6:	c0 a1       	brne	8000620a <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800061f8:	78 08       	ld.w	r8,r12[0x0]
800061fa:	58 08       	cp.w	r8,0
800061fc:	c2 b1       	brne	80006252 <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
800061fe:	78 1c       	ld.w	r12,r12[0x4]
80006200:	f0 1f 00 17 	mcall	8000625c <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80006204:	30 08       	mov	r8,0
80006206:	8f 18       	st.w	r7[0x4],r8
80006208:	c2 58       	rjmp	80006252 <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
8000620a:	58 0a       	cp.w	r10,0
8000620c:	c1 01       	brne	8000622c <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
8000620e:	10 9a       	mov	r10,r8
80006210:	78 2c       	ld.w	r12,r12[0x8]
80006212:	f0 1f 00 14 	mcall	80006260 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80006216:	6e 29       	ld.w	r9,r7[0x8]
80006218:	6f 08       	ld.w	r8,r7[0x40]
8000621a:	f2 08 00 08 	add	r8,r9,r8
8000621e:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80006220:	6e 19       	ld.w	r9,r7[0x4]
80006222:	12 38       	cp.w	r8,r9
80006224:	c1 73       	brcs	80006252 <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80006226:	6e 08       	ld.w	r8,r7[0x0]
80006228:	8f 28       	st.w	r7[0x8],r8
8000622a:	c1 48       	rjmp	80006252 <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
8000622c:	10 9a       	mov	r10,r8
8000622e:	78 3c       	ld.w	r12,r12[0xc]
80006230:	f0 1f 00 0c 	mcall	80006260 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80006234:	6f 08       	ld.w	r8,r7[0x40]
80006236:	6e 39       	ld.w	r9,r7[0xc]
80006238:	f2 08 01 08 	sub	r8,r9,r8
8000623c:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
8000623e:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80006240:	12 38       	cp.w	r8,r9
80006242:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80006246:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
8000624a:	f3 d8 e3 19 	subcs	r9,r9,r8
8000624e:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80006252:	6e e8       	ld.w	r8,r7[0x38]
80006254:	2f f8       	sub	r8,-1
80006256:	8f e8       	st.w	r7[0x38],r8
}
80006258:	e3 cd 80 80 	ldm	sp++,r7,pc
8000625c:	80 00       	ld.sh	r0,r0[0x0]
8000625e:	65 0c       	ld.w	r12,r2[0x40]
80006260:	80 00       	ld.sh	r0,r0[0x0]
80006262:	80 38       	ld.sh	r8,r0[0x6]

80006264 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80006264:	d4 31       	pushm	r0-r7,lr
80006266:	20 5d       	sub	sp,20
80006268:	18 97       	mov	r7,r12
8000626a:	50 0b       	stdsp	sp[0x0],r11
8000626c:	50 2a       	stdsp	sp[0x8],r10
8000626e:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80006270:	f8 c0 ff f0 	sub	r0,r12,-16
80006274:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006276:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
8000627a:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000627c:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80006280:	f0 1f 00 2f 	mcall	8000633c <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006284:	6e e9       	ld.w	r9,r7[0x38]
80006286:	6e f8       	ld.w	r8,r7[0x3c]
80006288:	10 39       	cp.w	r9,r8
8000628a:	c1 42       	brcc	800062b2 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
8000628c:	40 1a       	lddsp	r10,sp[0x4]
8000628e:	40 0b       	lddsp	r11,sp[0x0]
80006290:	0e 9c       	mov	r12,r7
80006292:	f0 1f 00 2c 	mcall	80006340 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006296:	6e 98       	ld.w	r8,r7[0x24]
80006298:	58 08       	cp.w	r8,0
8000629a:	c0 80       	breq	800062aa <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
8000629c:	ee cc ff dc 	sub	r12,r7,-36
800062a0:	f0 1f 00 29 	mcall	80006344 <xQueueGenericSend+0xe0>
800062a4:	58 1c       	cp.w	r12,1
800062a6:	c0 21       	brne	800062aa <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
800062a8:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
800062aa:	f0 1f 00 28 	mcall	80006348 <xQueueGenericSend+0xe4>
800062ae:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
800062b0:	c4 38       	rjmp	80006336 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800062b2:	40 28       	lddsp	r8,sp[0x8]
800062b4:	58 08       	cp.w	r8,0
800062b6:	c0 51       	brne	800062c0 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800062b8:	f0 1f 00 24 	mcall	80006348 <xQueueGenericSend+0xe4>
800062bc:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
800062be:	c3 c8       	rjmp	80006336 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
800062c0:	58 04       	cp.w	r4,0
800062c2:	c0 51       	brne	800062cc <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800062c4:	06 9c       	mov	r12,r3
800062c6:	f0 1f 00 22 	mcall	8000634c <xQueueGenericSend+0xe8>
800062ca:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800062cc:	f0 1f 00 1f 	mcall	80006348 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800062d0:	f0 1f 00 20 	mcall	80006350 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
800062d4:	f0 1f 00 1a 	mcall	8000633c <xQueueGenericSend+0xd8>
800062d8:	6f 18       	ld.w	r8,r7[0x44]
800062da:	5b f8       	cp.w	r8,-1
800062dc:	ef f1 0a 11 	st.weq	r7[0x44],r1
800062e0:	6f 28       	ld.w	r8,r7[0x48]
800062e2:	5b f8       	cp.w	r8,-1
800062e4:	ef f1 0a 12 	st.weq	r7[0x48],r1
800062e8:	f0 1f 00 18 	mcall	80006348 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800062ec:	04 9b       	mov	r11,r2
800062ee:	06 9c       	mov	r12,r3
800062f0:	f0 1f 00 19 	mcall	80006354 <xQueueGenericSend+0xf0>
800062f4:	c1 b1       	brne	8000632a <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800062f6:	f0 1f 00 12 	mcall	8000633c <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
800062fa:	6e e5       	ld.w	r5,r7[0x38]
800062fc:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
800062fe:	f0 1f 00 13 	mcall	80006348 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80006302:	0c 35       	cp.w	r5,r6
80006304:	c0 d1       	brne	8000631e <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80006306:	40 2b       	lddsp	r11,sp[0x8]
80006308:	00 9c       	mov	r12,r0
8000630a:	f0 1f 00 14 	mcall	80006358 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
8000630e:	0e 9c       	mov	r12,r7
80006310:	f0 1f 00 13 	mcall	8000635c <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80006314:	f0 1f 00 13 	mcall	80006360 <xQueueGenericSend+0xfc>
80006318:	cb 41       	brne	80006280 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
8000631a:	d7 33       	scall
8000631c:	cb 2b       	rjmp	80006280 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000631e:	0e 9c       	mov	r12,r7
80006320:	f0 1f 00 0f 	mcall	8000635c <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80006324:	f0 1f 00 0f 	mcall	80006360 <xQueueGenericSend+0xfc>
80006328:	ca cb       	rjmp	80006280 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
8000632a:	0e 9c       	mov	r12,r7
8000632c:	f0 1f 00 0c 	mcall	8000635c <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80006330:	f0 1f 00 0c 	mcall	80006360 <xQueueGenericSend+0xfc>
80006334:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80006336:	2f bd       	sub	sp,-20
80006338:	d8 32       	popm	r0-r7,pc
8000633a:	00 00       	add	r0,r0
8000633c:	80 00       	ld.sh	r0,r0[0x0]
8000633e:	5d 44       	*unknown*
80006340:	80 00       	ld.sh	r0,r0[0x0]
80006342:	61 ec       	ld.w	r12,r0[0x78]
80006344:	80 00       	ld.sh	r0,r0[0x0]
80006346:	65 e8       	ld.w	r8,r2[0x78]
80006348:	80 00       	ld.sh	r0,r0[0x0]
8000634a:	5e 50       	retlt	r0
8000634c:	80 00       	ld.sh	r0,r0[0x0]
8000634e:	64 dc       	ld.w	r12,r2[0x34]
80006350:	80 00       	ld.sh	r0,r0[0x0]
80006352:	64 50       	ld.w	r0,r2[0x14]
80006354:	80 00       	ld.sh	r0,r0[0x0]
80006356:	67 78       	ld.w	r8,r3[0x5c]
80006358:	80 00       	ld.sh	r0,r0[0x0]
8000635a:	6a 8c       	ld.w	r12,r5[0x20]
8000635c:	80 00       	ld.sh	r0,r0[0x0]
8000635e:	60 08       	ld.w	r8,r0[0x0]
80006360:	80 00       	ld.sh	r0,r0[0x0]
80006362:	67 e8       	ld.w	r8,r3[0x78]

80006364 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
80006364:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80006368:	34 cc       	mov	r12,76
8000636a:	f0 1f 00 12 	mcall	800063b0 <xQueueCreateMutex+0x4c>
8000636e:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
80006370:	c1 d0       	breq	800063aa <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
80006372:	30 06       	mov	r6,0
80006374:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
80006376:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
80006378:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
8000637a:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
8000637c:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
8000637e:	30 18       	mov	r8,1
80006380:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
80006382:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
80006386:	3f f8       	mov	r8,-1
80006388:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
8000638c:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80006390:	2f 0c       	sub	r12,-16
80006392:	f0 1f 00 09 	mcall	800063b4 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80006396:	ee cc ff dc 	sub	r12,r7,-36
8000639a:	f0 1f 00 07 	mcall	800063b4 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
8000639e:	0c 99       	mov	r9,r6
800063a0:	0c 9a       	mov	r10,r6
800063a2:	0c 9b       	mov	r11,r6
800063a4:	0e 9c       	mov	r12,r7
800063a6:	f0 1f 00 05 	mcall	800063b8 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
800063aa:	0e 9c       	mov	r12,r7
800063ac:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800063b0:	80 00       	ld.sh	r0,r0[0x0]
800063b2:	5f b0       	srhi	r0
800063b4:	80 00       	ld.sh	r0,r0[0x0]
800063b6:	5c 20       	cpc	r0
800063b8:	80 00       	ld.sh	r0,r0[0x0]
800063ba:	62 64       	ld.w	r4,r1[0x18]

800063bc <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
800063bc:	d4 21       	pushm	r4-r7,lr
800063be:	18 97       	mov	r7,r12
800063c0:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
800063c2:	58 0c       	cp.w	r12,0
800063c4:	c2 f0       	breq	80006422 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800063c6:	34 cc       	mov	r12,76
800063c8:	f0 1f 00 17 	mcall	80006424 <xQueueCreate+0x68>
800063cc:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
800063ce:	c2 a0       	breq	80006422 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
800063d0:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
800063d4:	e8 cc ff ff 	sub	r12,r4,-1
800063d8:	f0 1f 00 13 	mcall	80006424 <xQueueCreate+0x68>
800063dc:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
800063de:	c1 e0       	breq	8000641a <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
800063e0:	f8 04 00 04 	add	r4,r12,r4
800063e4:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800063e6:	30 08       	mov	r8,0
800063e8:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
800063ea:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
800063ec:	ee c8 00 01 	sub	r8,r7,1
800063f0:	ad 38       	mul	r8,r6
800063f2:	10 0c       	add	r12,r8
800063f4:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
800063f6:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
800063f8:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
800063fc:	3f f8       	mov	r8,-1
800063fe:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80006402:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80006406:	ea cc ff f0 	sub	r12,r5,-16
8000640a:	f0 1f 00 08 	mcall	80006428 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000640e:	ea cc ff dc 	sub	r12,r5,-36
80006412:	f0 1f 00 06 	mcall	80006428 <xQueueCreate+0x6c>
80006416:	0a 9c       	mov	r12,r5
80006418:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
8000641a:	0a 9c       	mov	r12,r5
8000641c:	f0 1f 00 04 	mcall	8000642c <xQueueCreate+0x70>
80006420:	d8 2a       	popm	r4-r7,pc,r12=0
80006422:	d8 2a       	popm	r4-r7,pc,r12=0
80006424:	80 00       	ld.sh	r0,r0[0x0]
80006426:	5f b0       	srhi	r0
80006428:	80 00       	ld.sh	r0,r0[0x0]
8000642a:	5c 20       	cpc	r0
8000642c:	80 00       	ld.sh	r0,r0[0x0]
8000642e:	5f 88       	srls	r8

80006430 <xTaskIsTaskSuspended>:
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
80006430:	78 59       	ld.w	r9,r12[0x14]
80006432:	48 68       	lddpc	r8,80006448 <xTaskIsTaskSuspended+0x18>
80006434:	10 39       	cp.w	r9,r8
80006436:	c0 81       	brne	80006446 <xTaskIsTaskSuspended+0x16>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
80006438:	78 a8       	ld.w	r8,r12[0x28]
8000643a:	48 59       	lddpc	r9,8000644c <xTaskIsTaskSuspended+0x1c>
8000643c:	12 38       	cp.w	r8,r9
8000643e:	c0 40       	breq	80006446 <xTaskIsTaskSuspended+0x16>
80006440:	58 08       	cp.w	r8,0
80006442:	5f 0c       	sreq	r12
80006444:	5e fc       	retal	r12
80006446:	5e fd       	retal	0
80006448:	00 00       	add	r0,r0
8000644a:	07 bc       	ld.ub	r12,r3[0x3]
8000644c:	00 00       	add	r0,r0
8000644e:	07 6c       	ld.uh	r12,--r3

80006450 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80006450:	48 38       	lddpc	r8,8000645c <vTaskSuspendAll+0xc>
80006452:	70 09       	ld.w	r9,r8[0x0]
80006454:	2f f9       	sub	r9,-1
80006456:	91 09       	st.w	r8[0x0],r9
}
80006458:	5e fc       	retal	r12
8000645a:	00 00       	add	r0,r0
8000645c:	00 00       	add	r0,r0
8000645e:	07 98       	ld.ub	r8,r3[0x1]

80006460 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80006460:	49 a8       	lddpc	r8,800064c8 <vTaskSwitchContext+0x68>
80006462:	70 08       	ld.w	r8,r8[0x0]
80006464:	58 08       	cp.w	r8,0
80006466:	c0 b1       	brne	8000647c <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006468:	49 98       	lddpc	r8,800064cc <vTaskSwitchContext+0x6c>
8000646a:	70 08       	ld.w	r8,r8[0x0]
8000646c:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006470:	49 89       	lddpc	r9,800064d0 <vTaskSwitchContext+0x70>
80006472:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80006476:	58 08       	cp.w	r8,0
80006478:	c0 60       	breq	80006484 <vTaskSwitchContext+0x24>
8000647a:	c1 18       	rjmp	8000649c <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
8000647c:	30 19       	mov	r9,1
8000647e:	49 68       	lddpc	r8,800064d4 <vTaskSwitchContext+0x74>
80006480:	91 09       	st.w	r8[0x0],r9
80006482:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006484:	49 28       	lddpc	r8,800064cc <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006486:	49 3a       	lddpc	r10,800064d0 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006488:	70 09       	ld.w	r9,r8[0x0]
8000648a:	20 19       	sub	r9,1
8000648c:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000648e:	70 09       	ld.w	r9,r8[0x0]
80006490:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006494:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80006498:	58 09       	cp.w	r9,0
8000649a:	cf 70       	breq	80006488 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
8000649c:	48 c8       	lddpc	r8,800064cc <vTaskSwitchContext+0x6c>
8000649e:	70 08       	ld.w	r8,r8[0x0]
800064a0:	f0 08 00 28 	add	r8,r8,r8<<0x2
800064a4:	48 b9       	lddpc	r9,800064d0 <vTaskSwitchContext+0x70>
800064a6:	f2 08 00 28 	add	r8,r9,r8<<0x2
800064aa:	70 19       	ld.w	r9,r8[0x4]
800064ac:	72 19       	ld.w	r9,r9[0x4]
800064ae:	91 19       	st.w	r8[0x4],r9
800064b0:	f0 ca ff f8 	sub	r10,r8,-8
800064b4:	14 39       	cp.w	r9,r10
800064b6:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
800064ba:	f1 f9 0a 01 	st.weq	r8[0x4],r9
800064be:	70 18       	ld.w	r8,r8[0x4]
800064c0:	70 39       	ld.w	r9,r8[0xc]
800064c2:	48 68       	lddpc	r8,800064d8 <vTaskSwitchContext+0x78>
800064c4:	91 09       	st.w	r8[0x0],r9
800064c6:	5e fc       	retal	r12
800064c8:	00 00       	add	r0,r0
800064ca:	07 98       	ld.ub	r8,r3[0x1]
800064cc:	00 00       	add	r0,r0
800064ce:	07 d0       	ld.ub	r0,r3[0x5]
800064d0:	00 00       	add	r0,r0
800064d2:	06 b4       	st.h	r3++,r4
800064d4:	00 00       	add	r0,r0
800064d6:	07 b8       	ld.ub	r8,r3[0x3]
800064d8:	00 00       	add	r0,r0
800064da:	07 68       	ld.uh	r8,--r3

800064dc <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
800064dc:	48 48       	lddpc	r8,800064ec <vTaskSetTimeOutState+0x10>
800064de:	70 08       	ld.w	r8,r8[0x0]
800064e0:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
800064e2:	48 48       	lddpc	r8,800064f0 <vTaskSetTimeOutState+0x14>
800064e4:	70 08       	ld.w	r8,r8[0x0]
800064e6:	99 18       	st.w	r12[0x4],r8
}
800064e8:	5e fc       	retal	r12
800064ea:	00 00       	add	r0,r0
800064ec:	00 00       	add	r0,r0
800064ee:	06 ac       	st.w	r3++,r12
800064f0:	00 00       	add	r0,r0
800064f2:	07 94       	ld.ub	r4,r3[0x1]

800064f4 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
800064f4:	30 19       	mov	r9,1
800064f6:	48 28       	lddpc	r8,800064fc <vTaskMissedYield+0x8>
800064f8:	91 09       	st.w	r8[0x0],r9
}
800064fa:	5e fc       	retal	r12
800064fc:	00 00       	add	r0,r0
800064fe:	07 b8       	ld.ub	r8,r3[0x3]

80006500 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80006500:	48 28       	lddpc	r8,80006508 <xTaskGetCurrentTaskHandle+0x8>
80006502:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80006504:	5e fc       	retal	r12
80006506:	00 00       	add	r0,r0
80006508:	00 00       	add	r0,r0
8000650a:	07 68       	ld.uh	r8,--r3

8000650c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
8000650c:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80006510:	58 0c       	cp.w	r12,0
80006512:	c1 f0       	breq	80006550 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80006514:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80006516:	78 b9       	ld.w	r9,r12[0x2c]
80006518:	79 18       	ld.w	r8,r12[0x44]
8000651a:	10 39       	cp.w	r9,r8
8000651c:	c1 a0       	breq	80006550 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
8000651e:	f8 c6 ff fc 	sub	r6,r12,-4
80006522:	0c 9c       	mov	r12,r6
80006524:	f0 1f 00 0c 	mcall	80006554 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80006528:	6f 1c       	ld.w	r12,r7[0x44]
8000652a:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
8000652c:	f8 08 11 08 	rsub	r8,r12,8
80006530:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80006532:	48 a8       	lddpc	r8,80006558 <vTaskPriorityDisinherit+0x4c>
80006534:	70 08       	ld.w	r8,r8[0x0]
80006536:	10 3c       	cp.w	r12,r8
80006538:	e0 88 00 04 	brls	80006540 <vTaskPriorityDisinherit+0x34>
8000653c:	48 78       	lddpc	r8,80006558 <vTaskPriorityDisinherit+0x4c>
8000653e:	91 0c       	st.w	r8[0x0],r12
80006540:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006544:	0c 9b       	mov	r11,r6
80006546:	48 68       	lddpc	r8,8000655c <vTaskPriorityDisinherit+0x50>
80006548:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000654c:	f0 1f 00 05 	mcall	80006560 <vTaskPriorityDisinherit+0x54>
80006550:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006554:	80 00       	ld.sh	r0,r0[0x0]
80006556:	5c 8a       	casts.h	r10
80006558:	00 00       	add	r0,r0
8000655a:	07 d0       	ld.ub	r0,r3[0x5]
8000655c:	00 00       	add	r0,r0
8000655e:	06 b4       	st.h	r3++,r4
80006560:	80 00       	ld.sh	r0,r0[0x0]
80006562:	5c 3a       	neg	r10

80006564 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80006564:	eb cd 40 c0 	pushm	r6-r7,lr
80006568:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
8000656a:	49 b8       	lddpc	r8,800065d4 <vTaskPriorityInherit+0x70>
8000656c:	70 08       	ld.w	r8,r8[0x0]
8000656e:	78 b9       	ld.w	r9,r12[0x2c]
80006570:	70 b8       	ld.w	r8,r8[0x2c]
80006572:	10 39       	cp.w	r9,r8
80006574:	c2 d2       	brcc	800065ce <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80006576:	49 88       	lddpc	r8,800065d4 <vTaskPriorityInherit+0x70>
80006578:	70 08       	ld.w	r8,r8[0x0]
8000657a:	70 b8       	ld.w	r8,r8[0x2c]
8000657c:	f0 08 11 08 	rsub	r8,r8,8
80006580:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80006582:	f2 09 00 28 	add	r8,r9,r9<<0x2
80006586:	49 59       	lddpc	r9,800065d8 <vTaskPriorityInherit+0x74>
80006588:	f2 08 00 28 	add	r8,r9,r8<<0x2
8000658c:	78 59       	ld.w	r9,r12[0x14]
8000658e:	10 39       	cp.w	r9,r8
80006590:	c1 b1       	brne	800065c6 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80006592:	f8 c6 ff fc 	sub	r6,r12,-4
80006596:	0c 9c       	mov	r12,r6
80006598:	f0 1f 00 11 	mcall	800065dc <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
8000659c:	48 e8       	lddpc	r8,800065d4 <vTaskPriorityInherit+0x70>
8000659e:	70 08       	ld.w	r8,r8[0x0]
800065a0:	70 bc       	ld.w	r12,r8[0x2c]
800065a2:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800065a4:	48 f8       	lddpc	r8,800065e0 <vTaskPriorityInherit+0x7c>
800065a6:	70 08       	ld.w	r8,r8[0x0]
800065a8:	10 3c       	cp.w	r12,r8
800065aa:	e0 88 00 04 	brls	800065b2 <vTaskPriorityInherit+0x4e>
800065ae:	48 d8       	lddpc	r8,800065e0 <vTaskPriorityInherit+0x7c>
800065b0:	91 0c       	st.w	r8[0x0],r12
800065b2:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800065b6:	0c 9b       	mov	r11,r6
800065b8:	48 88       	lddpc	r8,800065d8 <vTaskPriorityInherit+0x74>
800065ba:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800065be:	f0 1f 00 0a 	mcall	800065e4 <vTaskPriorityInherit+0x80>
800065c2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800065c6:	48 48       	lddpc	r8,800065d4 <vTaskPriorityInherit+0x70>
800065c8:	70 08       	ld.w	r8,r8[0x0]
800065ca:	70 b8       	ld.w	r8,r8[0x2c]
800065cc:	99 b8       	st.w	r12[0x2c],r8
800065ce:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800065d2:	00 00       	add	r0,r0
800065d4:	00 00       	add	r0,r0
800065d6:	07 68       	ld.uh	r8,--r3
800065d8:	00 00       	add	r0,r0
800065da:	06 b4       	st.h	r3++,r4
800065dc:	80 00       	ld.sh	r0,r0[0x0]
800065de:	5c 8a       	casts.h	r10
800065e0:	00 00       	add	r0,r0
800065e2:	07 d0       	ld.ub	r0,r3[0x5]
800065e4:	80 00       	ld.sh	r0,r0[0x0]
800065e6:	5c 3a       	neg	r10

800065e8 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
800065e8:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
800065ec:	78 38       	ld.w	r8,r12[0xc]
800065ee:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
800065f0:	ee c6 ff e8 	sub	r6,r7,-24
800065f4:	0c 9c       	mov	r12,r6
800065f6:	f0 1f 00 15 	mcall	80006648 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800065fa:	49 58       	lddpc	r8,8000664c <xTaskRemoveFromEventList+0x64>
800065fc:	70 08       	ld.w	r8,r8[0x0]
800065fe:	58 08       	cp.w	r8,0
80006600:	c1 71       	brne	8000662e <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80006602:	ee c6 ff fc 	sub	r6,r7,-4
80006606:	0c 9c       	mov	r12,r6
80006608:	f0 1f 00 10 	mcall	80006648 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
8000660c:	6e bc       	ld.w	r12,r7[0x2c]
8000660e:	49 18       	lddpc	r8,80006650 <xTaskRemoveFromEventList+0x68>
80006610:	70 08       	ld.w	r8,r8[0x0]
80006612:	10 3c       	cp.w	r12,r8
80006614:	e0 88 00 04 	brls	8000661c <xTaskRemoveFromEventList+0x34>
80006618:	48 e8       	lddpc	r8,80006650 <xTaskRemoveFromEventList+0x68>
8000661a:	91 0c       	st.w	r8[0x0],r12
8000661c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006620:	0c 9b       	mov	r11,r6
80006622:	48 d8       	lddpc	r8,80006654 <xTaskRemoveFromEventList+0x6c>
80006624:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006628:	f0 1f 00 0c 	mcall	80006658 <xTaskRemoveFromEventList+0x70>
8000662c:	c0 58       	rjmp	80006636 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
8000662e:	0c 9b       	mov	r11,r6
80006630:	48 bc       	lddpc	r12,8000665c <xTaskRemoveFromEventList+0x74>
80006632:	f0 1f 00 0a 	mcall	80006658 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006636:	48 b8       	lddpc	r8,80006660 <xTaskRemoveFromEventList+0x78>
80006638:	70 08       	ld.w	r8,r8[0x0]
8000663a:	6e b9       	ld.w	r9,r7[0x2c]
8000663c:	70 b8       	ld.w	r8,r8[0x2c]
8000663e:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80006640:	5f 2c       	srhs	r12
80006642:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006646:	00 00       	add	r0,r0
80006648:	80 00       	ld.sh	r0,r0[0x0]
8000664a:	5c 8a       	casts.h	r10
8000664c:	00 00       	add	r0,r0
8000664e:	07 98       	ld.ub	r8,r3[0x1]
80006650:	00 00       	add	r0,r0
80006652:	07 d0       	ld.ub	r0,r3[0x5]
80006654:	00 00       	add	r0,r0
80006656:	06 b4       	st.h	r3++,r4
80006658:	80 00       	ld.sh	r0,r0[0x0]
8000665a:	5c 3a       	neg	r10
8000665c:	00 00       	add	r0,r0
8000665e:	07 6c       	ld.uh	r12,--r3
80006660:	00 00       	add	r0,r0
80006662:	07 68       	ld.uh	r8,--r3

80006664 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80006664:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006668:	4b 98       	lddpc	r8,8000674c <vTaskIncrementTick+0xe8>
8000666a:	70 08       	ld.w	r8,r8[0x0]
8000666c:	58 08       	cp.w	r8,0
8000666e:	c6 91       	brne	80006740 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80006670:	4b 88       	lddpc	r8,80006750 <vTaskIncrementTick+0xec>
80006672:	70 09       	ld.w	r9,r8[0x0]
80006674:	2f f9       	sub	r9,-1
80006676:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80006678:	70 08       	ld.w	r8,r8[0x0]
8000667a:	58 08       	cp.w	r8,0
8000667c:	c1 a1       	brne	800066b0 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
8000667e:	4b 68       	lddpc	r8,80006754 <vTaskIncrementTick+0xf0>
80006680:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80006682:	4b 69       	lddpc	r9,80006758 <vTaskIncrementTick+0xf4>
80006684:	72 0b       	ld.w	r11,r9[0x0]
80006686:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80006688:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
8000668a:	4b 59       	lddpc	r9,8000675c <vTaskIncrementTick+0xf8>
8000668c:	72 0a       	ld.w	r10,r9[0x0]
8000668e:	2f fa       	sub	r10,-1
80006690:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80006692:	70 08       	ld.w	r8,r8[0x0]
80006694:	70 08       	ld.w	r8,r8[0x0]
80006696:	58 08       	cp.w	r8,0
80006698:	c0 51       	brne	800066a2 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
8000669a:	3f f9       	mov	r9,-1
8000669c:	4b 18       	lddpc	r8,80006760 <vTaskIncrementTick+0xfc>
8000669e:	91 09       	st.w	r8[0x0],r9
800066a0:	c0 88       	rjmp	800066b0 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800066a2:	4a d8       	lddpc	r8,80006754 <vTaskIncrementTick+0xf0>
800066a4:	70 08       	ld.w	r8,r8[0x0]
800066a6:	70 38       	ld.w	r8,r8[0xc]
800066a8:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800066aa:	70 19       	ld.w	r9,r8[0x4]
800066ac:	4a d8       	lddpc	r8,80006760 <vTaskIncrementTick+0xfc>
800066ae:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800066b0:	4a 88       	lddpc	r8,80006750 <vTaskIncrementTick+0xec>
800066b2:	70 09       	ld.w	r9,r8[0x0]
800066b4:	4a b8       	lddpc	r8,80006760 <vTaskIncrementTick+0xfc>
800066b6:	70 08       	ld.w	r8,r8[0x0]
800066b8:	10 39       	cp.w	r9,r8
800066ba:	c4 73       	brcs	80006748 <vTaskIncrementTick+0xe4>
800066bc:	4a 68       	lddpc	r8,80006754 <vTaskIncrementTick+0xf0>
800066be:	70 08       	ld.w	r8,r8[0x0]
800066c0:	70 08       	ld.w	r8,r8[0x0]
800066c2:	58 08       	cp.w	r8,0
800066c4:	c0 c0       	breq	800066dc <vTaskIncrementTick+0x78>
800066c6:	4a 48       	lddpc	r8,80006754 <vTaskIncrementTick+0xf0>
800066c8:	70 08       	ld.w	r8,r8[0x0]
800066ca:	70 38       	ld.w	r8,r8[0xc]
800066cc:	70 37       	ld.w	r7,r8[0xc]
800066ce:	6e 18       	ld.w	r8,r7[0x4]
800066d0:	4a 09       	lddpc	r9,80006750 <vTaskIncrementTick+0xec>
800066d2:	72 09       	ld.w	r9,r9[0x0]
800066d4:	12 38       	cp.w	r8,r9
800066d6:	e0 88 00 14 	brls	800066fe <vTaskIncrementTick+0x9a>
800066da:	c0 e8       	rjmp	800066f6 <vTaskIncrementTick+0x92>
800066dc:	3f f9       	mov	r9,-1
800066de:	4a 18       	lddpc	r8,80006760 <vTaskIncrementTick+0xfc>
800066e0:	91 09       	st.w	r8[0x0],r9
800066e2:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800066e6:	6a 08       	ld.w	r8,r5[0x0]
800066e8:	70 38       	ld.w	r8,r8[0xc]
800066ea:	70 37       	ld.w	r7,r8[0xc]
800066ec:	6e 18       	ld.w	r8,r7[0x4]
800066ee:	64 09       	ld.w	r9,r2[0x0]
800066f0:	12 38       	cp.w	r8,r9
800066f2:	e0 88 00 0a 	brls	80006706 <vTaskIncrementTick+0xa2>
800066f6:	49 b9       	lddpc	r9,80006760 <vTaskIncrementTick+0xfc>
800066f8:	93 08       	st.w	r9[0x0],r8
800066fa:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800066fe:	49 a4       	lddpc	r4,80006764 <vTaskIncrementTick+0x100>
80006700:	49 a3       	lddpc	r3,80006768 <vTaskIncrementTick+0x104>
80006702:	49 55       	lddpc	r5,80006754 <vTaskIncrementTick+0xf0>
80006704:	49 32       	lddpc	r2,80006750 <vTaskIncrementTick+0xec>
80006706:	ee c6 ff fc 	sub	r6,r7,-4
8000670a:	0c 9c       	mov	r12,r6
8000670c:	f0 1f 00 18 	mcall	8000676c <vTaskIncrementTick+0x108>
80006710:	6e a8       	ld.w	r8,r7[0x28]
80006712:	58 08       	cp.w	r8,0
80006714:	c0 50       	breq	8000671e <vTaskIncrementTick+0xba>
80006716:	ee cc ff e8 	sub	r12,r7,-24
8000671a:	f0 1f 00 15 	mcall	8000676c <vTaskIncrementTick+0x108>
8000671e:	6e bc       	ld.w	r12,r7[0x2c]
80006720:	68 08       	ld.w	r8,r4[0x0]
80006722:	10 3c       	cp.w	r12,r8
80006724:	e9 fc ba 00 	st.whi	r4[0x0],r12
80006728:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000672c:	0c 9b       	mov	r11,r6
8000672e:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80006732:	f0 1f 00 10 	mcall	80006770 <vTaskIncrementTick+0x10c>
80006736:	6a 08       	ld.w	r8,r5[0x0]
80006738:	70 08       	ld.w	r8,r8[0x0]
8000673a:	58 08       	cp.w	r8,0
8000673c:	cd 51       	brne	800066e6 <vTaskIncrementTick+0x82>
8000673e:	cc fb       	rjmp	800066dc <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80006740:	48 d8       	lddpc	r8,80006774 <vTaskIncrementTick+0x110>
80006742:	70 09       	ld.w	r9,r8[0x0]
80006744:	2f f9       	sub	r9,-1
80006746:	91 09       	st.w	r8[0x0],r9
80006748:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000674c:	00 00       	add	r0,r0
8000674e:	07 98       	ld.ub	r8,r3[0x1]
80006750:	00 00       	add	r0,r0
80006752:	07 94       	ld.ub	r4,r3[0x1]
80006754:	00 00       	add	r0,r0
80006756:	06 a0       	st.w	r3++,r0
80006758:	00 00       	add	r0,r0
8000675a:	06 b0       	st.h	r3++,r0
8000675c:	00 00       	add	r0,r0
8000675e:	06 ac       	st.w	r3++,r12
80006760:	00 00       	add	r0,r0
80006762:	00 30       	cp.w	r0,r0
80006764:	00 00       	add	r0,r0
80006766:	07 d0       	ld.ub	r0,r3[0x5]
80006768:	00 00       	add	r0,r0
8000676a:	06 b4       	st.h	r3++,r4
8000676c:	80 00       	ld.sh	r0,r0[0x0]
8000676e:	5c 8a       	casts.h	r10
80006770:	80 00       	ld.sh	r0,r0[0x0]
80006772:	5c 3a       	neg	r10
80006774:	00 00       	add	r0,r0
80006776:	06 98       	mov	r8,r3

80006778 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80006778:	eb cd 40 c0 	pushm	r6-r7,lr
8000677c:	18 97       	mov	r7,r12
8000677e:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80006780:	f0 1f 00 15 	mcall	800067d4 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80006784:	6c 08       	ld.w	r8,r6[0x0]
80006786:	5b f8       	cp.w	r8,-1
80006788:	c0 31       	brne	8000678e <xTaskCheckForTimeOut+0x16>
8000678a:	30 07       	mov	r7,0
8000678c:	c1 f8       	rjmp	800067ca <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
8000678e:	49 39       	lddpc	r9,800067d8 <xTaskCheckForTimeOut+0x60>
80006790:	72 09       	ld.w	r9,r9[0x0]
80006792:	6e 0a       	ld.w	r10,r7[0x0]
80006794:	12 3a       	cp.w	r10,r9
80006796:	c0 70       	breq	800067a4 <xTaskCheckForTimeOut+0x2c>
80006798:	49 19       	lddpc	r9,800067dc <xTaskCheckForTimeOut+0x64>
8000679a:	72 09       	ld.w	r9,r9[0x0]
8000679c:	6e 1a       	ld.w	r10,r7[0x4]
8000679e:	12 3a       	cp.w	r10,r9
800067a0:	e0 88 00 14 	brls	800067c8 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800067a4:	48 e9       	lddpc	r9,800067dc <xTaskCheckForTimeOut+0x64>
800067a6:	72 0a       	ld.w	r10,r9[0x0]
800067a8:	6e 19       	ld.w	r9,r7[0x4]
800067aa:	12 1a       	sub	r10,r9
800067ac:	14 38       	cp.w	r8,r10
800067ae:	e0 88 00 0d 	brls	800067c8 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
800067b2:	48 ba       	lddpc	r10,800067dc <xTaskCheckForTimeOut+0x64>
800067b4:	74 0a       	ld.w	r10,r10[0x0]
800067b6:	14 19       	sub	r9,r10
800067b8:	f2 08 00 08 	add	r8,r9,r8
800067bc:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
800067be:	0e 9c       	mov	r12,r7
800067c0:	f0 1f 00 08 	mcall	800067e0 <xTaskCheckForTimeOut+0x68>
800067c4:	30 07       	mov	r7,0
800067c6:	c0 28       	rjmp	800067ca <xTaskCheckForTimeOut+0x52>
800067c8:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
800067ca:	f0 1f 00 07 	mcall	800067e4 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
800067ce:	0e 9c       	mov	r12,r7
800067d0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800067d4:	80 00       	ld.sh	r0,r0[0x0]
800067d6:	5d 44       	*unknown*
800067d8:	00 00       	add	r0,r0
800067da:	06 ac       	st.w	r3++,r12
800067dc:	00 00       	add	r0,r0
800067de:	07 94       	ld.ub	r4,r3[0x1]
800067e0:	80 00       	ld.sh	r0,r0[0x0]
800067e2:	64 dc       	ld.w	r12,r2[0x34]
800067e4:	80 00       	ld.sh	r0,r0[0x0]
800067e6:	5e 50       	retlt	r0

800067e8 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
800067e8:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
800067ec:	f0 1f 00 2c 	mcall	8000689c <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
800067f0:	4a c8       	lddpc	r8,800068a0 <xTaskResumeAll+0xb8>
800067f2:	70 09       	ld.w	r9,r8[0x0]
800067f4:	20 19       	sub	r9,1
800067f6:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800067f8:	70 08       	ld.w	r8,r8[0x0]
800067fa:	58 08       	cp.w	r8,0
800067fc:	c4 91       	brne	8000688e <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
800067fe:	4a a8       	lddpc	r8,800068a4 <xTaskResumeAll+0xbc>
80006800:	70 08       	ld.w	r8,r8[0x0]
80006802:	58 08       	cp.w	r8,0
80006804:	c4 50       	breq	8000688e <xTaskResumeAll+0xa6>
80006806:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006808:	4a 85       	lddpc	r5,800068a8 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
8000680a:	4a 93       	lddpc	r3,800068ac <xTaskResumeAll+0xc4>
8000680c:	4a 92       	lddpc	r2,800068b0 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000680e:	4a a1       	lddpc	r1,800068b4 <xTaskResumeAll+0xcc>
80006810:	c1 e8       	rjmp	8000684c <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80006812:	6a 38       	ld.w	r8,r5[0xc]
80006814:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80006816:	ee cc ff e8 	sub	r12,r7,-24
8000681a:	f0 1f 00 28 	mcall	800068b8 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
8000681e:	ee c6 ff fc 	sub	r6,r7,-4
80006822:	0c 9c       	mov	r12,r6
80006824:	f0 1f 00 25 	mcall	800068b8 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80006828:	6e bc       	ld.w	r12,r7[0x2c]
8000682a:	66 08       	ld.w	r8,r3[0x0]
8000682c:	10 3c       	cp.w	r12,r8
8000682e:	e7 fc ba 00 	st.whi	r3[0x0],r12
80006832:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006836:	0c 9b       	mov	r11,r6
80006838:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
8000683c:	f0 1f 00 20 	mcall	800068bc <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006840:	62 08       	ld.w	r8,r1[0x0]
80006842:	6e b9       	ld.w	r9,r7[0x2c]
80006844:	70 b8       	ld.w	r8,r8[0x2c]
80006846:	10 39       	cp.w	r9,r8
80006848:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
8000684c:	6a 08       	ld.w	r8,r5[0x0]
8000684e:	58 08       	cp.w	r8,0
80006850:	ce 11       	brne	80006812 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006852:	49 c8       	lddpc	r8,800068c0 <xTaskResumeAll+0xd8>
80006854:	70 08       	ld.w	r8,r8[0x0]
80006856:	58 08       	cp.w	r8,0
80006858:	c0 f0       	breq	80006876 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000685a:	49 a8       	lddpc	r8,800068c0 <xTaskResumeAll+0xd8>
8000685c:	70 08       	ld.w	r8,r8[0x0]
8000685e:	58 08       	cp.w	r8,0
80006860:	c1 10       	breq	80006882 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80006862:	49 87       	lddpc	r7,800068c0 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80006864:	f0 1f 00 18 	mcall	800068c4 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80006868:	6e 08       	ld.w	r8,r7[0x0]
8000686a:	20 18       	sub	r8,1
8000686c:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000686e:	6e 08       	ld.w	r8,r7[0x0]
80006870:	58 08       	cp.w	r8,0
80006872:	cf 91       	brne	80006864 <xTaskResumeAll+0x7c>
80006874:	c0 78       	rjmp	80006882 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80006876:	58 14       	cp.w	r4,1
80006878:	c0 50       	breq	80006882 <xTaskResumeAll+0x9a>
8000687a:	49 48       	lddpc	r8,800068c8 <xTaskResumeAll+0xe0>
8000687c:	70 08       	ld.w	r8,r8[0x0]
8000687e:	58 18       	cp.w	r8,1
80006880:	c0 71       	brne	8000688e <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80006882:	30 09       	mov	r9,0
80006884:	49 18       	lddpc	r8,800068c8 <xTaskResumeAll+0xe0>
80006886:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80006888:	d7 33       	scall
8000688a:	30 17       	mov	r7,1
8000688c:	c0 28       	rjmp	80006890 <xTaskResumeAll+0xa8>
8000688e:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80006890:	f0 1f 00 0f 	mcall	800068cc <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80006894:	0e 9c       	mov	r12,r7
80006896:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000689a:	00 00       	add	r0,r0
8000689c:	80 00       	ld.sh	r0,r0[0x0]
8000689e:	5d 44       	*unknown*
800068a0:	00 00       	add	r0,r0
800068a2:	07 98       	ld.ub	r8,r3[0x1]
800068a4:	00 00       	add	r0,r0
800068a6:	07 b4       	ld.ub	r4,r3[0x3]
800068a8:	00 00       	add	r0,r0
800068aa:	07 6c       	ld.uh	r12,--r3
800068ac:	00 00       	add	r0,r0
800068ae:	07 d0       	ld.ub	r0,r3[0x5]
800068b0:	00 00       	add	r0,r0
800068b2:	06 b4       	st.h	r3++,r4
800068b4:	00 00       	add	r0,r0
800068b6:	07 68       	ld.uh	r8,--r3
800068b8:	80 00       	ld.sh	r0,r0[0x0]
800068ba:	5c 8a       	casts.h	r10
800068bc:	80 00       	ld.sh	r0,r0[0x0]
800068be:	5c 3a       	neg	r10
800068c0:	00 00       	add	r0,r0
800068c2:	06 98       	mov	r8,r3
800068c4:	80 00       	ld.sh	r0,r0[0x0]
800068c6:	66 64       	ld.w	r4,r3[0x18]
800068c8:	00 00       	add	r0,r0
800068ca:	07 b8       	ld.ub	r8,r3[0x3]
800068cc:	80 00       	ld.sh	r0,r0[0x0]
800068ce:	5e 50       	retlt	r0

800068d0 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
800068d0:	eb cd 40 c0 	pushm	r6-r7,lr
800068d4:	18 97       	mov	r7,r12
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
800068d6:	58 0c       	cp.w	r12,0
800068d8:	c2 a0       	breq	8000692c <vTaskResume+0x5c>
800068da:	49 68       	lddpc	r8,80006930 <vTaskResume+0x60>
800068dc:	70 08       	ld.w	r8,r8[0x0]
800068de:	10 3c       	cp.w	r12,r8
800068e0:	c2 60       	breq	8000692c <vTaskResume+0x5c>
		{
			taskENTER_CRITICAL();
800068e2:	f0 1f 00 15 	mcall	80006934 <vTaskResume+0x64>
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
800068e6:	0e 9c       	mov	r12,r7
800068e8:	f0 1f 00 14 	mcall	80006938 <vTaskResume+0x68>
800068ec:	58 1c       	cp.w	r12,1
800068ee:	c1 d1       	brne	80006928 <vTaskResume+0x58>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
800068f0:	ee c6 ff fc 	sub	r6,r7,-4
800068f4:	0c 9c       	mov	r12,r6
800068f6:	f0 1f 00 12 	mcall	8000693c <vTaskResume+0x6c>
					prvAddTaskToReadyQueue( pxTCB );
800068fa:	6e bc       	ld.w	r12,r7[0x2c]
800068fc:	49 18       	lddpc	r8,80006940 <vTaskResume+0x70>
800068fe:	70 08       	ld.w	r8,r8[0x0]
80006900:	10 3c       	cp.w	r12,r8
80006902:	e0 88 00 04 	brls	8000690a <vTaskResume+0x3a>
80006906:	48 f8       	lddpc	r8,80006940 <vTaskResume+0x70>
80006908:	91 0c       	st.w	r8[0x0],r12
8000690a:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000690e:	0c 9b       	mov	r11,r6
80006910:	48 d8       	lddpc	r8,80006944 <vTaskResume+0x74>
80006912:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006916:	f0 1f 00 0d 	mcall	80006948 <vTaskResume+0x78>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000691a:	48 68       	lddpc	r8,80006930 <vTaskResume+0x60>
8000691c:	70 08       	ld.w	r8,r8[0x0]
8000691e:	6e b9       	ld.w	r9,r7[0x2c]
80006920:	70 b8       	ld.w	r8,r8[0x2c]
80006922:	10 39       	cp.w	r9,r8
80006924:	c0 23       	brcs	80006928 <vTaskResume+0x58>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
80006926:	d7 33       	scall
					}
				}
			}
			taskEXIT_CRITICAL();
80006928:	f0 1f 00 09 	mcall	8000694c <vTaskResume+0x7c>
8000692c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006930:	00 00       	add	r0,r0
80006932:	07 68       	ld.uh	r8,--r3
80006934:	80 00       	ld.sh	r0,r0[0x0]
80006936:	5d 44       	*unknown*
80006938:	80 00       	ld.sh	r0,r0[0x0]
8000693a:	64 30       	ld.w	r0,r2[0xc]
8000693c:	80 00       	ld.sh	r0,r0[0x0]
8000693e:	5c 8a       	casts.h	r10
80006940:	00 00       	add	r0,r0
80006942:	07 d0       	ld.ub	r0,r3[0x5]
80006944:	00 00       	add	r0,r0
80006946:	06 b4       	st.h	r3++,r4
80006948:	80 00       	ld.sh	r0,r0[0x0]
8000694a:	5c 3a       	neg	r10
8000694c:	80 00       	ld.sh	r0,r0[0x0]
8000694e:	5e 50       	retlt	r0

80006950 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
80006950:	eb cd 40 e0 	pushm	r5-r7,lr
80006954:	18 97       	mov	r7,r12
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
80006956:	f0 1f 00 1c 	mcall	800069c4 <vTaskSuspend+0x74>
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
8000695a:	49 c8       	lddpc	r8,800069c8 <vTaskSuspend+0x78>
8000695c:	70 08       	ld.w	r8,r8[0x0]
8000695e:	10 37       	cp.w	r7,r8
80006960:	c0 31       	brne	80006966 <vTaskSuspend+0x16>
80006962:	30 07       	mov	r7,0
80006964:	c0 38       	rjmp	8000696a <vTaskSuspend+0x1a>
			{
				pxTaskToSuspend = NULL;
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
80006966:	58 07       	cp.w	r7,0
80006968:	c0 41       	brne	80006970 <vTaskSuspend+0x20>
8000696a:	49 88       	lddpc	r8,800069c8 <vTaskSuspend+0x78>
8000696c:	70 06       	ld.w	r6,r8[0x0]
8000696e:	c0 28       	rjmp	80006972 <vTaskSuspend+0x22>
80006970:	0e 96       	mov	r6,r7

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			vListRemove( &( pxTCB->xGenericListItem ) );
80006972:	ec c5 ff fc 	sub	r5,r6,-4
80006976:	0a 9c       	mov	r12,r5
80006978:	f0 1f 00 15 	mcall	800069cc <vTaskSuspend+0x7c>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer )
8000697c:	6c a8       	ld.w	r8,r6[0x28]
8000697e:	58 08       	cp.w	r8,0
80006980:	c0 50       	breq	8000698a <vTaskSuspend+0x3a>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
80006982:	ec cc ff e8 	sub	r12,r6,-24
80006986:	f0 1f 00 12 	mcall	800069cc <vTaskSuspend+0x7c>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
8000698a:	0a 9b       	mov	r11,r5
8000698c:	49 1c       	lddpc	r12,800069d0 <vTaskSuspend+0x80>
8000698e:	f0 1f 00 12 	mcall	800069d4 <vTaskSuspend+0x84>
		}
		taskEXIT_CRITICAL();
80006992:	f0 1f 00 12 	mcall	800069d8 <vTaskSuspend+0x88>

		if( ( void * ) pxTaskToSuspend == NULL )
80006996:	58 07       	cp.w	r7,0
80006998:	c1 31       	brne	800069be <vTaskSuspend+0x6e>
		{
			if( xSchedulerRunning != pdFALSE )
8000699a:	49 18       	lddpc	r8,800069dc <vTaskSuspend+0x8c>
8000699c:	70 08       	ld.w	r8,r8[0x0]
8000699e:	58 08       	cp.w	r8,0
800069a0:	c0 40       	breq	800069a8 <vTaskSuspend+0x58>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
800069a2:	d7 33       	scall
800069a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1U )
800069a8:	48 e8       	lddpc	r8,800069e0 <vTaskSuspend+0x90>
800069aa:	70 08       	ld.w	r8,r8[0x0]
800069ac:	58 18       	cp.w	r8,1
800069ae:	c0 61       	brne	800069ba <vTaskSuspend+0x6a>
				{
					/* No other tasks are defined, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
800069b0:	30 09       	mov	r9,0
800069b2:	48 68       	lddpc	r8,800069c8 <vTaskSuspend+0x78>
800069b4:	91 09       	st.w	r8[0x0],r9
800069b6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				}
				else
				{
					vTaskSwitchContext();
800069ba:	f0 1f 00 0b 	mcall	800069e4 <vTaskSuspend+0x94>
800069be:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800069c2:	00 00       	add	r0,r0
800069c4:	80 00       	ld.sh	r0,r0[0x0]
800069c6:	5d 44       	*unknown*
800069c8:	00 00       	add	r0,r0
800069ca:	07 68       	ld.uh	r8,--r3
800069cc:	80 00       	ld.sh	r0,r0[0x0]
800069ce:	5c 8a       	casts.h	r10
800069d0:	00 00       	add	r0,r0
800069d2:	07 bc       	ld.ub	r12,r3[0x3]
800069d4:	80 00       	ld.sh	r0,r0[0x0]
800069d6:	5c 3a       	neg	r10
800069d8:	80 00       	ld.sh	r0,r0[0x0]
800069da:	5e 50       	retlt	r0
800069dc:	00 00       	add	r0,r0
800069de:	06 a4       	st.w	r3++,r4
800069e0:	00 00       	add	r0,r0
800069e2:	07 b4       	ld.ub	r4,r3[0x3]
800069e4:	80 00       	ld.sh	r0,r0[0x0]
800069e6:	64 60       	ld.w	r0,r2[0x18]

800069e8 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
800069e8:	eb cd 40 80 	pushm	r7,lr
800069ec:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
800069ee:	49 08       	lddpc	r8,80006a2c <prvAddCurrentTaskToDelayedList+0x44>
800069f0:	70 08       	ld.w	r8,r8[0x0]
800069f2:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
800069f4:	48 f8       	lddpc	r8,80006a30 <prvAddCurrentTaskToDelayedList+0x48>
800069f6:	70 08       	ld.w	r8,r8[0x0]
800069f8:	10 3c       	cp.w	r12,r8
800069fa:	c0 a2       	brcc	80006a0e <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800069fc:	48 c8       	lddpc	r8,80006a2c <prvAddCurrentTaskToDelayedList+0x44>
800069fe:	70 0b       	ld.w	r11,r8[0x0]
80006a00:	48 d8       	lddpc	r8,80006a34 <prvAddCurrentTaskToDelayedList+0x4c>
80006a02:	70 0c       	ld.w	r12,r8[0x0]
80006a04:	2f cb       	sub	r11,-4
80006a06:	f0 1f 00 0d 	mcall	80006a38 <prvAddCurrentTaskToDelayedList+0x50>
80006a0a:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006a0e:	48 88       	lddpc	r8,80006a2c <prvAddCurrentTaskToDelayedList+0x44>
80006a10:	70 0b       	ld.w	r11,r8[0x0]
80006a12:	48 b8       	lddpc	r8,80006a3c <prvAddCurrentTaskToDelayedList+0x54>
80006a14:	70 0c       	ld.w	r12,r8[0x0]
80006a16:	2f cb       	sub	r11,-4
80006a18:	f0 1f 00 08 	mcall	80006a38 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80006a1c:	48 98       	lddpc	r8,80006a40 <prvAddCurrentTaskToDelayedList+0x58>
80006a1e:	70 08       	ld.w	r8,r8[0x0]
80006a20:	10 37       	cp.w	r7,r8
80006a22:	c0 32       	brcc	80006a28 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80006a24:	48 78       	lddpc	r8,80006a40 <prvAddCurrentTaskToDelayedList+0x58>
80006a26:	91 07       	st.w	r8[0x0],r7
80006a28:	e3 cd 80 80 	ldm	sp++,r7,pc
80006a2c:	00 00       	add	r0,r0
80006a2e:	07 68       	ld.uh	r8,--r3
80006a30:	00 00       	add	r0,r0
80006a32:	07 94       	ld.ub	r4,r3[0x1]
80006a34:	00 00       	add	r0,r0
80006a36:	06 b0       	st.h	r3++,r0
80006a38:	80 00       	ld.sh	r0,r0[0x0]
80006a3a:	5c 56       	castu.b	r6
80006a3c:	00 00       	add	r0,r0
80006a3e:	06 a0       	st.w	r3++,r0
80006a40:	00 00       	add	r0,r0
80006a42:	00 30       	cp.w	r0,r0

80006a44 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80006a44:	eb cd 40 c0 	pushm	r6-r7,lr
80006a48:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80006a4a:	58 0c       	cp.w	r12,0
80006a4c:	c1 10       	breq	80006a6e <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
80006a4e:	f0 1f 00 0a 	mcall	80006a74 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
80006a52:	48 a8       	lddpc	r8,80006a78 <vTaskDelay+0x34>
80006a54:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006a56:	48 a8       	lddpc	r8,80006a7c <vTaskDelay+0x38>
80006a58:	70 0c       	ld.w	r12,r8[0x0]
80006a5a:	2f cc       	sub	r12,-4
80006a5c:	f0 1f 00 09 	mcall	80006a80 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006a60:	ee 06 00 0c 	add	r12,r7,r6
80006a64:	f0 1f 00 08 	mcall	80006a84 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
80006a68:	f0 1f 00 08 	mcall	80006a88 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006a6c:	c0 21       	brne	80006a70 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
80006a6e:	d7 33       	scall
80006a70:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006a74:	80 00       	ld.sh	r0,r0[0x0]
80006a76:	64 50       	ld.w	r0,r2[0x14]
80006a78:	00 00       	add	r0,r0
80006a7a:	07 94       	ld.ub	r4,r3[0x1]
80006a7c:	00 00       	add	r0,r0
80006a7e:	07 68       	ld.uh	r8,--r3
80006a80:	80 00       	ld.sh	r0,r0[0x0]
80006a82:	5c 8a       	casts.h	r10
80006a84:	80 00       	ld.sh	r0,r0[0x0]
80006a86:	69 e8       	ld.w	r8,r4[0x78]
80006a88:	80 00       	ld.sh	r0,r0[0x0]
80006a8a:	67 e8       	ld.w	r8,r3[0x78]

80006a8c <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80006a8c:	eb cd 40 c0 	pushm	r6-r7,lr
80006a90:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80006a92:	48 e7       	lddpc	r7,80006ac8 <vTaskPlaceOnEventList+0x3c>
80006a94:	6e 0b       	ld.w	r11,r7[0x0]
80006a96:	2e 8b       	sub	r11,-24
80006a98:	f0 1f 00 0d 	mcall	80006acc <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006a9c:	6e 0c       	ld.w	r12,r7[0x0]
80006a9e:	2f cc       	sub	r12,-4
80006aa0:	f0 1f 00 0c 	mcall	80006ad0 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006aa4:	5b f6       	cp.w	r6,-1
80006aa6:	c0 81       	brne	80006ab6 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006aa8:	6e 0b       	ld.w	r11,r7[0x0]
80006aaa:	2f cb       	sub	r11,-4
80006aac:	48 ac       	lddpc	r12,80006ad4 <vTaskPlaceOnEventList+0x48>
80006aae:	f0 1f 00 0b 	mcall	80006ad8 <vTaskPlaceOnEventList+0x4c>
80006ab2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80006ab6:	48 a8       	lddpc	r8,80006adc <vTaskPlaceOnEventList+0x50>
80006ab8:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80006aba:	ec 0c 00 0c 	add	r12,r6,r12
80006abe:	f0 1f 00 09 	mcall	80006ae0 <vTaskPlaceOnEventList+0x54>
80006ac2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006ac6:	00 00       	add	r0,r0
80006ac8:	00 00       	add	r0,r0
80006aca:	07 68       	ld.uh	r8,--r3
80006acc:	80 00       	ld.sh	r0,r0[0x0]
80006ace:	5c 56       	castu.b	r6
80006ad0:	80 00       	ld.sh	r0,r0[0x0]
80006ad2:	5c 8a       	casts.h	r10
80006ad4:	00 00       	add	r0,r0
80006ad6:	07 bc       	ld.ub	r12,r3[0x3]
80006ad8:	80 00       	ld.sh	r0,r0[0x0]
80006ada:	5c 3a       	neg	r10
80006adc:	00 00       	add	r0,r0
80006ade:	07 94       	ld.ub	r4,r3[0x1]
80006ae0:	80 00       	ld.sh	r0,r0[0x0]
80006ae2:	69 e8       	ld.w	r8,r4[0x78]

80006ae4 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80006ae4:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006ae8:	49 57       	lddpc	r7,80006b3c <prvIdleTask+0x58>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006aea:	49 64       	lddpc	r4,80006b40 <prvIdleTask+0x5c>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80006aec:	49 63       	lddpc	r3,80006b44 <prvIdleTask+0x60>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006aee:	49 75       	lddpc	r5,80006b48 <prvIdleTask+0x64>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006af0:	6e 08       	ld.w	r8,r7[0x0]
80006af2:	58 08       	cp.w	r8,0
80006af4:	c1 e0       	breq	80006b30 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80006af6:	f0 1f 00 16 	mcall	80006b4c <prvIdleTask+0x68>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006afa:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80006afc:	f0 1f 00 15 	mcall	80006b50 <prvIdleTask+0x6c>

			if( xListIsEmpty == pdFALSE )
80006b00:	58 06       	cp.w	r6,0
80006b02:	c1 70       	breq	80006b30 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80006b04:	f0 1f 00 14 	mcall	80006b54 <prvIdleTask+0x70>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80006b08:	68 38       	ld.w	r8,r4[0xc]
80006b0a:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80006b0c:	ec cc ff fc 	sub	r12,r6,-4
80006b10:	f0 1f 00 12 	mcall	80006b58 <prvIdleTask+0x74>
					--uxCurrentNumberOfTasks;
80006b14:	66 08       	ld.w	r8,r3[0x0]
80006b16:	20 18       	sub	r8,1
80006b18:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80006b1a:	6e 08       	ld.w	r8,r7[0x0]
80006b1c:	20 18       	sub	r8,1
80006b1e:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80006b20:	f0 1f 00 0f 	mcall	80006b5c <prvIdleTask+0x78>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006b24:	6c cc       	ld.w	r12,r6[0x30]
80006b26:	f0 1f 00 0f 	mcall	80006b60 <prvIdleTask+0x7c>
		vPortFree( pxTCB );
80006b2a:	0c 9c       	mov	r12,r6
80006b2c:	f0 1f 00 0d 	mcall	80006b60 <prvIdleTask+0x7c>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006b30:	6a 08       	ld.w	r8,r5[0x0]
80006b32:	58 18       	cp.w	r8,1
80006b34:	fe 98 ff de 	brls	80006af0 <prvIdleTask+0xc>
			{
				taskYIELD();
80006b38:	d7 33       	scall
80006b3a:	cd bb       	rjmp	80006af0 <prvIdleTask+0xc>
80006b3c:	00 00       	add	r0,r0
80006b3e:	06 a8       	st.w	r3++,r8
80006b40:	00 00       	add	r0,r0
80006b42:	07 54       	ld.sh	r4,--r3
80006b44:	00 00       	add	r0,r0
80006b46:	07 b4       	ld.ub	r4,r3[0x3]
80006b48:	00 00       	add	r0,r0
80006b4a:	06 b4       	st.h	r3++,r4
80006b4c:	80 00       	ld.sh	r0,r0[0x0]
80006b4e:	64 50       	ld.w	r0,r2[0x14]
80006b50:	80 00       	ld.sh	r0,r0[0x0]
80006b52:	67 e8       	ld.w	r8,r3[0x78]
80006b54:	80 00       	ld.sh	r0,r0[0x0]
80006b56:	5d 44       	*unknown*
80006b58:	80 00       	ld.sh	r0,r0[0x0]
80006b5a:	5c 8a       	casts.h	r10
80006b5c:	80 00       	ld.sh	r0,r0[0x0]
80006b5e:	5e 50       	retlt	r0
80006b60:	80 00       	ld.sh	r0,r0[0x0]
80006b62:	5f 88       	srls	r8

80006b64 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80006b64:	d4 31       	pushm	r0-r7,lr
80006b66:	20 1d       	sub	sp,4
80006b68:	fa c4 ff d8 	sub	r4,sp,-40
80006b6c:	50 0c       	stdsp	sp[0x0],r12
80006b6e:	16 91       	mov	r1,r11
80006b70:	14 97       	mov	r7,r10
80006b72:	12 90       	mov	r0,r9
80006b74:	10 93       	mov	r3,r8
80006b76:	68 02       	ld.w	r2,r4[0x0]
80006b78:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006b7a:	34 8c       	mov	r12,72
80006b7c:	f0 1f 00 5c 	mcall	80006cec <xTaskGenericCreate+0x188>
80006b80:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80006b82:	c0 31       	brne	80006b88 <xTaskGenericCreate+0x24>
80006b84:	3f fc       	mov	r12,-1
80006b86:	ca f8       	rjmp	80006ce4 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006b88:	58 06       	cp.w	r6,0
80006b8a:	e0 81 00 af 	brne	80006ce8 <xTaskGenericCreate+0x184>
80006b8e:	0e 9c       	mov	r12,r7
80006b90:	5c 7c       	castu.h	r12
80006b92:	a3 6c       	lsl	r12,0x2
80006b94:	f0 1f 00 56 	mcall	80006cec <xTaskGenericCreate+0x188>
80006b98:	18 96       	mov	r6,r12
80006b9a:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006b9c:	c0 61       	brne	80006ba8 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80006b9e:	0a 9c       	mov	r12,r5
80006ba0:	f0 1f 00 54 	mcall	80006cf0 <xTaskGenericCreate+0x18c>
80006ba4:	3f fc       	mov	r12,-1
80006ba6:	c9 f8       	rjmp	80006ce4 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006ba8:	5c 77       	castu.h	r7
80006baa:	ee 0a 15 02 	lsl	r10,r7,0x2
80006bae:	e0 6b 00 a5 	mov	r11,165
80006bb2:	0c 9c       	mov	r12,r6
80006bb4:	f0 1f 00 50 	mcall	80006cf4 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006bb8:	ee c6 00 01 	sub	r6,r7,1
80006bbc:	6a c8       	ld.w	r8,r5[0x30]
80006bbe:	f0 06 00 26 	add	r6,r8,r6<<0x2
80006bc2:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80006bc6:	31 0a       	mov	r10,16
80006bc8:	02 9b       	mov	r11,r1
80006bca:	ea cc ff cc 	sub	r12,r5,-52
80006bce:	f0 1f 00 4b 	mcall	80006cf8 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80006bd2:	30 08       	mov	r8,0
80006bd4:	eb 68 00 43 	st.b	r5[67],r8
80006bd8:	58 73       	cp.w	r3,7
80006bda:	e6 07 17 80 	movls	r7,r3
80006bde:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80006be2:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006be4:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006be8:	ea c4 ff fc 	sub	r4,r5,-4
80006bec:	08 9c       	mov	r12,r4
80006bee:	f0 1f 00 44 	mcall	80006cfc <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80006bf2:	ea cc ff e8 	sub	r12,r5,-24
80006bf6:	f0 1f 00 42 	mcall	80006cfc <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80006bfa:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006bfc:	ee 07 11 08 	rsub	r7,r7,8
80006c00:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006c02:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006c04:	00 9a       	mov	r10,r0
80006c06:	40 0b       	lddsp	r11,sp[0x0]
80006c08:	0c 9c       	mov	r12,r6
80006c0a:	f0 1f 00 3e 	mcall	80006d00 <xTaskGenericCreate+0x19c>
80006c0e:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006c10:	58 02       	cp.w	r2,0
80006c12:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80006c16:	f0 1f 00 3c 	mcall	80006d04 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006c1a:	4b c8       	lddpc	r8,80006d08 <xTaskGenericCreate+0x1a4>
80006c1c:	70 09       	ld.w	r9,r8[0x0]
80006c1e:	2f f9       	sub	r9,-1
80006c20:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80006c22:	4b b8       	lddpc	r8,80006d0c <xTaskGenericCreate+0x1a8>
80006c24:	70 08       	ld.w	r8,r8[0x0]
80006c26:	58 08       	cp.w	r8,0
80006c28:	c2 61       	brne	80006c74 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80006c2a:	4b 98       	lddpc	r8,80006d0c <xTaskGenericCreate+0x1a8>
80006c2c:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006c2e:	4b 78       	lddpc	r8,80006d08 <xTaskGenericCreate+0x1a4>
80006c30:	70 08       	ld.w	r8,r8[0x0]
80006c32:	58 18       	cp.w	r8,1
80006c34:	c2 b1       	brne	80006c8a <xTaskGenericCreate+0x126>
80006c36:	4b 77       	lddpc	r7,80006d10 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006c38:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006c3c:	0e 9c       	mov	r12,r7
80006c3e:	f0 1f 00 36 	mcall	80006d14 <xTaskGenericCreate+0x1b0>
80006c42:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006c44:	0c 37       	cp.w	r7,r6
80006c46:	cf b1       	brne	80006c3c <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006c48:	4b 47       	lddpc	r7,80006d18 <xTaskGenericCreate+0x1b4>
80006c4a:	0e 9c       	mov	r12,r7
80006c4c:	f0 1f 00 32 	mcall	80006d14 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006c50:	4b 36       	lddpc	r6,80006d1c <xTaskGenericCreate+0x1b8>
80006c52:	0c 9c       	mov	r12,r6
80006c54:	f0 1f 00 30 	mcall	80006d14 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006c58:	4b 2c       	lddpc	r12,80006d20 <xTaskGenericCreate+0x1bc>
80006c5a:	f0 1f 00 2f 	mcall	80006d14 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006c5e:	4b 2c       	lddpc	r12,80006d24 <xTaskGenericCreate+0x1c0>
80006c60:	f0 1f 00 2d 	mcall	80006d14 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006c64:	4b 1c       	lddpc	r12,80006d28 <xTaskGenericCreate+0x1c4>
80006c66:	f0 1f 00 2c 	mcall	80006d14 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006c6a:	4b 18       	lddpc	r8,80006d2c <xTaskGenericCreate+0x1c8>
80006c6c:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006c6e:	4b 18       	lddpc	r8,80006d30 <xTaskGenericCreate+0x1cc>
80006c70:	91 06       	st.w	r8[0x0],r6
80006c72:	c0 c8       	rjmp	80006c8a <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006c74:	4b 08       	lddpc	r8,80006d34 <xTaskGenericCreate+0x1d0>
80006c76:	70 08       	ld.w	r8,r8[0x0]
80006c78:	58 08       	cp.w	r8,0
80006c7a:	c0 81       	brne	80006c8a <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006c7c:	4a 48       	lddpc	r8,80006d0c <xTaskGenericCreate+0x1a8>
80006c7e:	70 08       	ld.w	r8,r8[0x0]
80006c80:	70 b8       	ld.w	r8,r8[0x2c]
80006c82:	10 33       	cp.w	r3,r8
80006c84:	c0 33       	brcs	80006c8a <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006c86:	4a 28       	lddpc	r8,80006d0c <xTaskGenericCreate+0x1a8>
80006c88:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006c8a:	6a b8       	ld.w	r8,r5[0x2c]
80006c8c:	4a b9       	lddpc	r9,80006d38 <xTaskGenericCreate+0x1d4>
80006c8e:	72 09       	ld.w	r9,r9[0x0]
80006c90:	12 38       	cp.w	r8,r9
80006c92:	e0 88 00 04 	brls	80006c9a <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006c96:	4a 99       	lddpc	r9,80006d38 <xTaskGenericCreate+0x1d4>
80006c98:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006c9a:	4a 98       	lddpc	r8,80006d3c <xTaskGenericCreate+0x1d8>
80006c9c:	70 09       	ld.w	r9,r8[0x0]
80006c9e:	2f f9       	sub	r9,-1
80006ca0:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80006ca2:	6a b8       	ld.w	r8,r5[0x2c]
80006ca4:	4a 79       	lddpc	r9,80006d40 <xTaskGenericCreate+0x1dc>
80006ca6:	72 09       	ld.w	r9,r9[0x0]
80006ca8:	12 38       	cp.w	r8,r9
80006caa:	e0 88 00 04 	brls	80006cb2 <xTaskGenericCreate+0x14e>
80006cae:	4a 59       	lddpc	r9,80006d40 <xTaskGenericCreate+0x1dc>
80006cb0:	93 08       	st.w	r9[0x0],r8
80006cb2:	6a bc       	ld.w	r12,r5[0x2c]
80006cb4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006cb8:	08 9b       	mov	r11,r4
80006cba:	49 68       	lddpc	r8,80006d10 <xTaskGenericCreate+0x1ac>
80006cbc:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006cc0:	f0 1f 00 21 	mcall	80006d44 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006cc4:	f0 1f 00 21 	mcall	80006d48 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006cc8:	49 b8       	lddpc	r8,80006d34 <xTaskGenericCreate+0x1d0>
80006cca:	70 08       	ld.w	r8,r8[0x0]
80006ccc:	58 08       	cp.w	r8,0
80006cce:	c0 a0       	breq	80006ce2 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006cd0:	48 f8       	lddpc	r8,80006d0c <xTaskGenericCreate+0x1a8>
80006cd2:	70 08       	ld.w	r8,r8[0x0]
80006cd4:	70 b8       	ld.w	r8,r8[0x2c]
80006cd6:	10 33       	cp.w	r3,r8
80006cd8:	e0 88 00 05 	brls	80006ce2 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006cdc:	d7 33       	scall
80006cde:	30 1c       	mov	r12,1
80006ce0:	c0 28       	rjmp	80006ce4 <xTaskGenericCreate+0x180>
80006ce2:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006ce4:	2f fd       	sub	sp,-4
80006ce6:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006ce8:	99 c6       	st.w	r12[0x30],r6
80006cea:	c5 fb       	rjmp	80006ba8 <xTaskGenericCreate+0x44>
80006cec:	80 00       	ld.sh	r0,r0[0x0]
80006cee:	5f b0       	srhi	r0
80006cf0:	80 00       	ld.sh	r0,r0[0x0]
80006cf2:	5f 88       	srls	r8
80006cf4:	80 00       	ld.sh	r0,r0[0x0]
80006cf6:	81 80       	st.w	r0[0x20],r0
80006cf8:	80 00       	ld.sh	r0,r0[0x0]
80006cfa:	84 ac       	ld.uh	r12,r2[0x4]
80006cfc:	80 00       	ld.sh	r0,r0[0x0]
80006cfe:	5c 34       	neg	r4
80006d00:	80 00       	ld.sh	r0,r0[0x0]
80006d02:	5c b0       	swap.b	r0
80006d04:	80 00       	ld.sh	r0,r0[0x0]
80006d06:	5d 44       	*unknown*
80006d08:	00 00       	add	r0,r0
80006d0a:	07 b4       	ld.ub	r4,r3[0x3]
80006d0c:	00 00       	add	r0,r0
80006d0e:	07 68       	ld.uh	r8,--r3
80006d10:	00 00       	add	r0,r0
80006d12:	06 b4       	st.h	r3++,r4
80006d14:	80 00       	ld.sh	r0,r0[0x0]
80006d16:	5c 20       	cpc	r0
80006d18:	00 00       	add	r0,r0
80006d1a:	07 80       	ld.ub	r0,r3[0x0]
80006d1c:	00 00       	add	r0,r0
80006d1e:	07 9c       	ld.ub	r12,r3[0x1]
80006d20:	00 00       	add	r0,r0
80006d22:	07 6c       	ld.uh	r12,--r3
80006d24:	00 00       	add	r0,r0
80006d26:	07 54       	ld.sh	r4,--r3
80006d28:	00 00       	add	r0,r0
80006d2a:	07 bc       	ld.ub	r12,r3[0x3]
80006d2c:	00 00       	add	r0,r0
80006d2e:	06 a0       	st.w	r3++,r0
80006d30:	00 00       	add	r0,r0
80006d32:	06 b0       	st.h	r3++,r0
80006d34:	00 00       	add	r0,r0
80006d36:	06 a4       	st.w	r3++,r4
80006d38:	00 00       	add	r0,r0
80006d3a:	06 9c       	mov	r12,r3
80006d3c:	00 00       	add	r0,r0
80006d3e:	07 b0       	ld.ub	r0,r3[0x3]
80006d40:	00 00       	add	r0,r0
80006d42:	07 d0       	ld.ub	r0,r3[0x5]
80006d44:	80 00       	ld.sh	r0,r0[0x0]
80006d46:	5c 3a       	neg	r10
80006d48:	80 00       	ld.sh	r0,r0[0x0]
80006d4a:	5e 50       	retlt	r0

80006d4c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006d4c:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006d4e:	30 09       	mov	r9,0
80006d50:	1a d9       	st.w	--sp,r9
80006d52:	1a d9       	st.w	--sp,r9
80006d54:	1a d9       	st.w	--sp,r9
80006d56:	12 98       	mov	r8,r9
80006d58:	e0 6a 01 00 	mov	r10,256
80006d5c:	48 9b       	lddpc	r11,80006d80 <vTaskStartScheduler+0x34>
80006d5e:	48 ac       	lddpc	r12,80006d84 <vTaskStartScheduler+0x38>
80006d60:	f0 1f 00 0a 	mcall	80006d88 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006d64:	2f dd       	sub	sp,-12
80006d66:	58 1c       	cp.w	r12,1
80006d68:	c0 a1       	brne	80006d7c <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006d6a:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006d6c:	30 19       	mov	r9,1
80006d6e:	48 88       	lddpc	r8,80006d8c <vTaskStartScheduler+0x40>
80006d70:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80006d72:	30 09       	mov	r9,0
80006d74:	48 78       	lddpc	r8,80006d90 <vTaskStartScheduler+0x44>
80006d76:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006d78:	f0 1f 00 07 	mcall	80006d94 <vTaskStartScheduler+0x48>
80006d7c:	d8 02       	popm	pc
80006d7e:	00 00       	add	r0,r0
80006d80:	80 02       	ld.sh	r2,r0[0x0]
80006d82:	f5 34 80 00 	ld.ub	r4,r10[-32768]
80006d86:	6a e4       	ld.w	r4,r5[0x38]
80006d88:	80 00       	ld.sh	r0,r0[0x0]
80006d8a:	6b 64       	ld.w	r4,r5[0x58]
80006d8c:	00 00       	add	r0,r0
80006d8e:	06 a4       	st.w	r3++,r4
80006d90:	00 00       	add	r0,r0
80006d92:	07 94       	ld.ub	r4,r3[0x1]
80006d94:	80 00       	ld.sh	r0,r0[0x0]
80006d96:	5d 54       	*unknown*

80006d98 <__avr32_f64_mul>:
80006d98:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
80006d9c:	e0 80 00 dc 	breq	80006f54 <__avr32_f64_mul_op1_zero>
80006da0:	d4 21       	pushm	r4-r7,lr
80006da2:	f7 e9 20 0e 	eor	lr,r11,r9
80006da6:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
80006daa:	30 15       	mov	r5,1
80006dac:	c4 30       	breq	80006e32 <__avr32_f64_mul_op1_subnormal>
80006dae:	ab 6b       	lsl	r11,0xa
80006db0:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
80006db4:	ab 6a       	lsl	r10,0xa
80006db6:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
80006dba:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
80006dbe:	c5 c0       	breq	80006e76 <__avr32_f64_mul_op2_subnormal>
80006dc0:	a1 78       	lsl	r8,0x1
80006dc2:	5c f9       	rol	r9
80006dc4:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
80006dc8:	e0 47 07 ff 	cp.w	r7,2047
80006dcc:	c7 70       	breq	80006eba <__avr32_f64_mul_op_nan_or_inf>
80006dce:	e0 46 07 ff 	cp.w	r6,2047
80006dd2:	c7 40       	breq	80006eba <__avr32_f64_mul_op_nan_or_inf>
80006dd4:	ee 06 00 0c 	add	r12,r7,r6
80006dd8:	e0 2c 03 fe 	sub	r12,1022
80006ddc:	f6 08 06 44 	mulu.d	r4,r11,r8
80006de0:	f4 09 07 44 	macu.d	r4,r10,r9
80006de4:	f4 08 06 46 	mulu.d	r6,r10,r8
80006de8:	f6 09 06 4a 	mulu.d	r10,r11,r9
80006dec:	08 07       	add	r7,r4
80006dee:	f4 05 00 4a 	adc	r10,r10,r5
80006df2:	5c 0b       	acr	r11
80006df4:	ed bb 00 14 	bld	r11,0x14
80006df8:	c0 50       	breq	80006e02 <__avr32_f64_mul+0x6a>
80006dfa:	a1 77       	lsl	r7,0x1
80006dfc:	5c fa       	rol	r10
80006dfe:	5c fb       	rol	r11
80006e00:	20 1c       	sub	r12,1
80006e02:	58 0c       	cp.w	r12,0
80006e04:	e0 8a 00 6f 	brle	80006ee2 <__avr32_f64_mul_res_subnormal>
80006e08:	e0 4c 07 ff 	cp.w	r12,2047
80006e0c:	e0 84 00 9c 	brge	80006f44 <__avr32_f64_mul_res_inf>
80006e10:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
80006e14:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
80006e18:	ef e6 12 17 	or	r7,r7,r6>>0x1
80006e1c:	ee 17 80 00 	eorh	r7,0x8000
80006e20:	f1 b7 04 20 	satu	r7,0x1
80006e24:	0e 0a       	add	r10,r7
80006e26:	5c 0b       	acr	r11
80006e28:	ed be 00 1f 	bld	lr,0x1f
80006e2c:	ef bb 00 1f 	bst	r11,0x1f
80006e30:	d8 22       	popm	r4-r7,pc

80006e32 <__avr32_f64_mul_op1_subnormal>:
80006e32:	e4 1b 00 0f 	andh	r11,0xf
80006e36:	f4 0c 12 00 	clz	r12,r10
80006e3a:	f6 06 12 00 	clz	r6,r11
80006e3e:	f7 bc 03 e1 	sublo	r12,-31
80006e42:	f8 06 17 30 	movlo	r6,r12
80006e46:	f7 b6 02 01 	subhs	r6,1
80006e4a:	e0 46 00 20 	cp.w	r6,32
80006e4e:	c0 d4       	brge	80006e68 <__avr32_f64_mul_op1_subnormal+0x36>
80006e50:	ec 0c 11 20 	rsub	r12,r6,32
80006e54:	f6 06 09 4b 	lsl	r11,r11,r6
80006e58:	f4 0c 0a 4c 	lsr	r12,r10,r12
80006e5c:	18 4b       	or	r11,r12
80006e5e:	f4 06 09 4a 	lsl	r10,r10,r6
80006e62:	20 b6       	sub	r6,11
80006e64:	0c 17       	sub	r7,r6
80006e66:	ca ab       	rjmp	80006dba <__avr32_f64_mul+0x22>
80006e68:	f4 06 09 4b 	lsl	r11,r10,r6
80006e6c:	c6 40       	breq	80006f34 <__avr32_f64_mul_res_zero>
80006e6e:	30 0a       	mov	r10,0
80006e70:	20 b6       	sub	r6,11
80006e72:	0c 17       	sub	r7,r6
80006e74:	ca 3b       	rjmp	80006dba <__avr32_f64_mul+0x22>

80006e76 <__avr32_f64_mul_op2_subnormal>:
80006e76:	e4 19 00 0f 	andh	r9,0xf
80006e7a:	f0 0c 12 00 	clz	r12,r8
80006e7e:	f2 05 12 00 	clz	r5,r9
80006e82:	f7 bc 03 ea 	sublo	r12,-22
80006e86:	f8 05 17 30 	movlo	r5,r12
80006e8a:	f7 b5 02 0a 	subhs	r5,10
80006e8e:	e0 45 00 20 	cp.w	r5,32
80006e92:	c0 d4       	brge	80006eac <__avr32_f64_mul_op2_subnormal+0x36>
80006e94:	ea 0c 11 20 	rsub	r12,r5,32
80006e98:	f2 05 09 49 	lsl	r9,r9,r5
80006e9c:	f0 0c 0a 4c 	lsr	r12,r8,r12
80006ea0:	18 49       	or	r9,r12
80006ea2:	f0 05 09 48 	lsl	r8,r8,r5
80006ea6:	20 25       	sub	r5,2
80006ea8:	0a 16       	sub	r6,r5
80006eaa:	c8 fb       	rjmp	80006dc8 <__avr32_f64_mul+0x30>
80006eac:	f0 05 09 49 	lsl	r9,r8,r5
80006eb0:	c4 20       	breq	80006f34 <__avr32_f64_mul_res_zero>
80006eb2:	30 08       	mov	r8,0
80006eb4:	20 25       	sub	r5,2
80006eb6:	0a 16       	sub	r6,r5
80006eb8:	c8 8b       	rjmp	80006dc8 <__avr32_f64_mul+0x30>

80006eba <__avr32_f64_mul_op_nan_or_inf>:
80006eba:	e4 19 00 0f 	andh	r9,0xf
80006ebe:	e4 1b 00 0f 	andh	r11,0xf
80006ec2:	14 4b       	or	r11,r10
80006ec4:	10 49       	or	r9,r8
80006ec6:	e0 47 07 ff 	cp.w	r7,2047
80006eca:	c0 91       	brne	80006edc <__avr32_f64_mul_op1_not_naninf>
80006ecc:	58 0b       	cp.w	r11,0
80006ece:	c3 81       	brne	80006f3e <__avr32_f64_mul_res_nan>
80006ed0:	e0 46 07 ff 	cp.w	r6,2047
80006ed4:	c3 81       	brne	80006f44 <__avr32_f64_mul_res_inf>
80006ed6:	58 09       	cp.w	r9,0
80006ed8:	c3 60       	breq	80006f44 <__avr32_f64_mul_res_inf>
80006eda:	c3 28       	rjmp	80006f3e <__avr32_f64_mul_res_nan>

80006edc <__avr32_f64_mul_op1_not_naninf>:
80006edc:	58 09       	cp.w	r9,0
80006ede:	c3 30       	breq	80006f44 <__avr32_f64_mul_res_inf>
80006ee0:	c2 f8       	rjmp	80006f3e <__avr32_f64_mul_res_nan>

80006ee2 <__avr32_f64_mul_res_subnormal>:
80006ee2:	5c 3c       	neg	r12
80006ee4:	2f fc       	sub	r12,-1
80006ee6:	f1 bc 04 c0 	satu	r12,0x6
80006eea:	e0 4c 00 20 	cp.w	r12,32
80006eee:	c1 14       	brge	80006f10 <__avr32_f64_mul_res_subnormal+0x2e>
80006ef0:	f8 08 11 20 	rsub	r8,r12,32
80006ef4:	0e 46       	or	r6,r7
80006ef6:	ee 0c 0a 47 	lsr	r7,r7,r12
80006efa:	f4 08 09 49 	lsl	r9,r10,r8
80006efe:	12 47       	or	r7,r9
80006f00:	f4 0c 0a 4a 	lsr	r10,r10,r12
80006f04:	f6 08 09 49 	lsl	r9,r11,r8
80006f08:	12 4a       	or	r10,r9
80006f0a:	f6 0c 0a 4b 	lsr	r11,r11,r12
80006f0e:	c8 3b       	rjmp	80006e14 <__avr32_f64_mul+0x7c>
80006f10:	f8 08 11 20 	rsub	r8,r12,32
80006f14:	f9 b9 00 00 	moveq	r9,0
80006f18:	c0 30       	breq	80006f1e <__avr32_f64_mul_res_subnormal+0x3c>
80006f1a:	f6 08 09 49 	lsl	r9,r11,r8
80006f1e:	0e 46       	or	r6,r7
80006f20:	ed ea 10 16 	or	r6,r6,r10<<0x1
80006f24:	f4 0c 0a 4a 	lsr	r10,r10,r12
80006f28:	f3 ea 10 07 	or	r7,r9,r10
80006f2c:	f6 0c 0a 4a 	lsr	r10,r11,r12
80006f30:	30 0b       	mov	r11,0
80006f32:	c7 1b       	rjmp	80006e14 <__avr32_f64_mul+0x7c>

80006f34 <__avr32_f64_mul_res_zero>:
80006f34:	1c 9b       	mov	r11,lr
80006f36:	e6 1b 80 00 	andh	r11,0x8000,COH
80006f3a:	30 0a       	mov	r10,0
80006f3c:	d8 22       	popm	r4-r7,pc

80006f3e <__avr32_f64_mul_res_nan>:
80006f3e:	3f fb       	mov	r11,-1
80006f40:	3f fa       	mov	r10,-1
80006f42:	d8 22       	popm	r4-r7,pc

80006f44 <__avr32_f64_mul_res_inf>:
80006f44:	f0 6b 00 00 	mov	r11,-1048576
80006f48:	ed be 00 1f 	bld	lr,0x1f
80006f4c:	ef bb 00 1f 	bst	r11,0x1f
80006f50:	30 0a       	mov	r10,0
80006f52:	d8 22       	popm	r4-r7,pc

80006f54 <__avr32_f64_mul_op1_zero>:
80006f54:	f7 e9 20 0b 	eor	r11,r11,r9
80006f58:	e6 1b 80 00 	andh	r11,0x8000,COH
80006f5c:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
80006f60:	e0 4c 07 ff 	cp.w	r12,2047
80006f64:	5e 1c       	retne	r12
80006f66:	3f fa       	mov	r10,-1
80006f68:	3f fb       	mov	r11,-1
80006f6a:	5e fc       	retal	r12

80006f6c <__avr32_f64_sub_from_add>:
80006f6c:	ee 19 80 00 	eorh	r9,0x8000

80006f70 <__avr32_f64_sub>:
80006f70:	f7 e9 20 0c 	eor	r12,r11,r9
80006f74:	e0 86 00 ca 	brmi	80007108 <__avr32_f64_add_from_sub>
80006f78:	eb cd 40 e0 	pushm	r5-r7,lr
80006f7c:	16 9c       	mov	r12,r11
80006f7e:	e6 1c 80 00 	andh	r12,0x8000,COH
80006f82:	bf db       	cbr	r11,0x1f
80006f84:	bf d9       	cbr	r9,0x1f
80006f86:	10 3a       	cp.w	r10,r8
80006f88:	f2 0b 13 00 	cpc	r11,r9
80006f8c:	c0 92       	brcc	80006f9e <__avr32_f64_sub+0x2e>
80006f8e:	16 97       	mov	r7,r11
80006f90:	12 9b       	mov	r11,r9
80006f92:	0e 99       	mov	r9,r7
80006f94:	14 97       	mov	r7,r10
80006f96:	10 9a       	mov	r10,r8
80006f98:	0e 98       	mov	r8,r7
80006f9a:	ee 1c 80 00 	eorh	r12,0x8000
80006f9e:	f6 07 16 14 	lsr	r7,r11,0x14
80006fa2:	ab 7b       	lsl	r11,0xb
80006fa4:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
80006fa8:	ab 7a       	lsl	r10,0xb
80006faa:	bf bb       	sbr	r11,0x1f
80006fac:	f2 06 16 14 	lsr	r6,r9,0x14
80006fb0:	c4 40       	breq	80007038 <__avr32_f64_sub_opL_subnormal>
80006fb2:	ab 79       	lsl	r9,0xb
80006fb4:	f3 e8 13 59 	or	r9,r9,r8>>0x15
80006fb8:	ab 78       	lsl	r8,0xb
80006fba:	bf b9       	sbr	r9,0x1f

80006fbc <__avr32_f64_sub_opL_subnormal_done>:
80006fbc:	e0 47 07 ff 	cp.w	r7,2047
80006fc0:	c4 f0       	breq	8000705e <__avr32_f64_sub_opH_nan_or_inf>
80006fc2:	0e 26       	rsub	r6,r7
80006fc4:	c1 20       	breq	80006fe8 <__avr32_f64_sub_shift_done>
80006fc6:	ec 05 11 20 	rsub	r5,r6,32
80006fca:	e0 46 00 20 	cp.w	r6,32
80006fce:	c7 c2       	brcc	800070c6 <__avr32_f64_sub_longshift>
80006fd0:	f0 05 09 4e 	lsl	lr,r8,r5
80006fd4:	f2 05 09 45 	lsl	r5,r9,r5
80006fd8:	f0 06 0a 48 	lsr	r8,r8,r6
80006fdc:	f2 06 0a 49 	lsr	r9,r9,r6
80006fe0:	0a 48       	or	r8,r5
80006fe2:	58 0e       	cp.w	lr,0
80006fe4:	5f 1e       	srne	lr
80006fe6:	1c 48       	or	r8,lr

80006fe8 <__avr32_f64_sub_shift_done>:
80006fe8:	10 1a       	sub	r10,r8
80006fea:	f6 09 01 4b 	sbc	r11,r11,r9
80006fee:	f6 06 12 00 	clz	r6,r11
80006ff2:	c0 e0       	breq	8000700e <__avr32_f64_sub_longnormalize_done>
80006ff4:	c7 83       	brcs	800070e4 <__avr32_f64_sub_longnormalize>
80006ff6:	ec 0e 11 20 	rsub	lr,r6,32
80006ffa:	f6 06 09 4b 	lsl	r11,r11,r6
80006ffe:	f4 0e 0a 4e 	lsr	lr,r10,lr
80007002:	1c 4b       	or	r11,lr
80007004:	f4 06 09 4a 	lsl	r10,r10,r6
80007008:	0c 17       	sub	r7,r6
8000700a:	e0 8a 00 39 	brle	8000707c <__avr32_f64_sub_subnormal_result>

8000700e <__avr32_f64_sub_longnormalize_done>:
8000700e:	f4 09 15 15 	lsl	r9,r10,0x15
80007012:	ab 9a       	lsr	r10,0xb
80007014:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
80007018:	ab 9b       	lsr	r11,0xb
8000701a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000701e:	18 4b       	or	r11,r12

80007020 <__avr32_f64_sub_round>:
80007020:	fc 17 80 00 	movh	r7,0x8000
80007024:	ed ba 00 00 	bld	r10,0x0
80007028:	f7 b7 01 ff 	subne	r7,-1
8000702c:	0e 39       	cp.w	r9,r7
8000702e:	5f 29       	srhs	r9
80007030:	12 0a       	add	r10,r9
80007032:	5c 0b       	acr	r11
80007034:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80007038 <__avr32_f64_sub_opL_subnormal>:
80007038:	ab 79       	lsl	r9,0xb
8000703a:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000703e:	ab 78       	lsl	r8,0xb
80007040:	f3 e8 10 0e 	or	lr,r9,r8
80007044:	f9 b6 01 01 	movne	r6,1
80007048:	ee 0e 11 00 	rsub	lr,r7,0
8000704c:	f9 b7 00 01 	moveq	r7,1
80007050:	ef bb 00 1f 	bst	r11,0x1f
80007054:	f7 ea 10 0e 	or	lr,r11,r10
80007058:	f9 b7 00 00 	moveq	r7,0
8000705c:	cb 0b       	rjmp	80006fbc <__avr32_f64_sub_opL_subnormal_done>

8000705e <__avr32_f64_sub_opH_nan_or_inf>:
8000705e:	bf db       	cbr	r11,0x1f
80007060:	f7 ea 10 0e 	or	lr,r11,r10
80007064:	c0 81       	brne	80007074 <__avr32_f64_sub_return_nan>
80007066:	e0 46 07 ff 	cp.w	r6,2047
8000706a:	c0 50       	breq	80007074 <__avr32_f64_sub_return_nan>
8000706c:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
80007070:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80007074 <__avr32_f64_sub_return_nan>:
80007074:	3f fa       	mov	r10,-1
80007076:	3f fb       	mov	r11,-1
80007078:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000707c <__avr32_f64_sub_subnormal_result>:
8000707c:	5c 37       	neg	r7
8000707e:	2f f7       	sub	r7,-1
80007080:	f1 b7 04 c0 	satu	r7,0x6
80007084:	e0 47 00 20 	cp.w	r7,32
80007088:	c1 14       	brge	800070aa <__avr32_f64_sub_subnormal_result+0x2e>
8000708a:	ee 08 11 20 	rsub	r8,r7,32
8000708e:	f4 08 09 49 	lsl	r9,r10,r8
80007092:	5f 16       	srne	r6
80007094:	f4 07 0a 4a 	lsr	r10,r10,r7
80007098:	0c 4a       	or	r10,r6
8000709a:	f6 08 09 49 	lsl	r9,r11,r8
8000709e:	f5 e9 10 0a 	or	r10,r10,r9
800070a2:	f4 07 0a 4b 	lsr	r11,r10,r7
800070a6:	30 07       	mov	r7,0
800070a8:	cb 3b       	rjmp	8000700e <__avr32_f64_sub_longnormalize_done>
800070aa:	ee 08 11 40 	rsub	r8,r7,64
800070ae:	f6 08 09 49 	lsl	r9,r11,r8
800070b2:	14 49       	or	r9,r10
800070b4:	5f 16       	srne	r6
800070b6:	f6 07 0a 4a 	lsr	r10,r11,r7
800070ba:	0c 4a       	or	r10,r6
800070bc:	30 0b       	mov	r11,0
800070be:	30 07       	mov	r7,0
800070c0:	ca 7b       	rjmp	8000700e <__avr32_f64_sub_longnormalize_done>
800070c2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

800070c6 <__avr32_f64_sub_longshift>:
800070c6:	f1 b6 04 c0 	satu	r6,0x6
800070ca:	f0 0e 17 00 	moveq	lr,r8
800070ce:	c0 40       	breq	800070d6 <__avr32_f64_sub_longshift+0x10>
800070d0:	f2 05 09 4e 	lsl	lr,r9,r5
800070d4:	10 4e       	or	lr,r8
800070d6:	f2 06 0a 48 	lsr	r8,r9,r6
800070da:	30 09       	mov	r9,0
800070dc:	58 0e       	cp.w	lr,0
800070de:	5f 1e       	srne	lr
800070e0:	1c 48       	or	r8,lr
800070e2:	c8 3b       	rjmp	80006fe8 <__avr32_f64_sub_shift_done>

800070e4 <__avr32_f64_sub_longnormalize>:
800070e4:	f4 06 12 00 	clz	r6,r10
800070e8:	f9 b7 03 00 	movlo	r7,0
800070ec:	f9 b6 03 00 	movlo	r6,0
800070f0:	f9 bc 03 00 	movlo	r12,0
800070f4:	f7 b6 02 e0 	subhs	r6,-32
800070f8:	f4 06 09 4b 	lsl	r11,r10,r6
800070fc:	30 0a       	mov	r10,0
800070fe:	0c 17       	sub	r7,r6
80007100:	fe 9a ff be 	brle	8000707c <__avr32_f64_sub_subnormal_result>
80007104:	c8 5b       	rjmp	8000700e <__avr32_f64_sub_longnormalize_done>
80007106:	d7 03       	nop

80007108 <__avr32_f64_add_from_sub>:
80007108:	ee 19 80 00 	eorh	r9,0x8000

8000710c <__avr32_f64_add>:
8000710c:	f7 e9 20 0c 	eor	r12,r11,r9
80007110:	fe 96 ff 2e 	brmi	80006f6c <__avr32_f64_sub_from_add>
80007114:	eb cd 40 e0 	pushm	r5-r7,lr
80007118:	16 9c       	mov	r12,r11
8000711a:	e6 1c 80 00 	andh	r12,0x8000,COH
8000711e:	bf db       	cbr	r11,0x1f
80007120:	bf d9       	cbr	r9,0x1f
80007122:	12 3b       	cp.w	r11,r9
80007124:	c0 72       	brcc	80007132 <__avr32_f64_add+0x26>
80007126:	16 97       	mov	r7,r11
80007128:	12 9b       	mov	r11,r9
8000712a:	0e 99       	mov	r9,r7
8000712c:	14 97       	mov	r7,r10
8000712e:	10 9a       	mov	r10,r8
80007130:	0e 98       	mov	r8,r7
80007132:	30 0e       	mov	lr,0
80007134:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
80007138:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000713c:	b5 ab       	sbr	r11,0x14
8000713e:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
80007142:	c6 20       	breq	80007206 <__avr32_f64_add_op2_subnormal>
80007144:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
80007148:	b5 a9       	sbr	r9,0x14
8000714a:	e0 47 07 ff 	cp.w	r7,2047
8000714e:	c2 80       	breq	8000719e <__avr32_f64_add_opH_nan_or_inf>
80007150:	0e 26       	rsub	r6,r7
80007152:	c1 20       	breq	80007176 <__avr32_f64_add_shift_done>
80007154:	e0 46 00 36 	cp.w	r6,54
80007158:	c1 52       	brcc	80007182 <__avr32_f64_add_res_of_done>
8000715a:	ec 05 11 20 	rsub	r5,r6,32
8000715e:	e0 46 00 20 	cp.w	r6,32
80007162:	c3 52       	brcc	800071cc <__avr32_f64_add_longshift>
80007164:	f0 05 09 4e 	lsl	lr,r8,r5
80007168:	f2 05 09 45 	lsl	r5,r9,r5
8000716c:	f0 06 0a 48 	lsr	r8,r8,r6
80007170:	f2 06 0a 49 	lsr	r9,r9,r6
80007174:	0a 48       	or	r8,r5

80007176 <__avr32_f64_add_shift_done>:
80007176:	10 0a       	add	r10,r8
80007178:	f6 09 00 4b 	adc	r11,r11,r9
8000717c:	ed bb 00 15 	bld	r11,0x15
80007180:	c3 40       	breq	800071e8 <__avr32_f64_add_res_of>

80007182 <__avr32_f64_add_res_of_done>:
80007182:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
80007186:	18 4b       	or	r11,r12

80007188 <__avr32_f64_add_round>:
80007188:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000718c:	18 4e       	or	lr,r12
8000718e:	ee 1e 80 00 	eorh	lr,0x8000
80007192:	f1 be 04 20 	satu	lr,0x1
80007196:	1c 0a       	add	r10,lr
80007198:	5c 0b       	acr	r11
8000719a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000719e <__avr32_f64_add_opH_nan_or_inf>:
8000719e:	b5 cb       	cbr	r11,0x14
800071a0:	f7 ea 10 0e 	or	lr,r11,r10
800071a4:	c1 01       	brne	800071c4 <__avr32_f64_add_return_nan>
800071a6:	e0 46 07 ff 	cp.w	r6,2047
800071aa:	c0 30       	breq	800071b0 <__avr32_f64_add_opL_nan_or_inf>
800071ac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

800071b0 <__avr32_f64_add_opL_nan_or_inf>:
800071b0:	b5 c9       	cbr	r9,0x14
800071b2:	f3 e8 10 0e 	or	lr,r9,r8
800071b6:	c0 71       	brne	800071c4 <__avr32_f64_add_return_nan>
800071b8:	30 0a       	mov	r10,0
800071ba:	fc 1b 7f f0 	movh	r11,0x7ff0
800071be:	18 4b       	or	r11,r12
800071c0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

800071c4 <__avr32_f64_add_return_nan>:
800071c4:	3f fa       	mov	r10,-1
800071c6:	3f fb       	mov	r11,-1
800071c8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

800071cc <__avr32_f64_add_longshift>:
800071cc:	f1 b6 04 c0 	satu	r6,0x6
800071d0:	f0 0e 17 00 	moveq	lr,r8
800071d4:	c0 60       	breq	800071e0 <__avr32_f64_add_longshift+0x14>
800071d6:	f2 05 09 4e 	lsl	lr,r9,r5
800071da:	58 08       	cp.w	r8,0
800071dc:	5f 18       	srne	r8
800071de:	10 4e       	or	lr,r8
800071e0:	f2 06 0a 48 	lsr	r8,r9,r6
800071e4:	30 09       	mov	r9,0
800071e6:	cc 8b       	rjmp	80007176 <__avr32_f64_add_shift_done>

800071e8 <__avr32_f64_add_res_of>:
800071e8:	fd ee 10 1e 	or	lr,lr,lr<<0x1
800071ec:	a1 9b       	lsr	r11,0x1
800071ee:	5d 0a       	ror	r10
800071f0:	5d 0e       	ror	lr
800071f2:	2f f7       	sub	r7,-1
800071f4:	e0 47 07 ff 	cp.w	r7,2047
800071f8:	f9 ba 00 00 	moveq	r10,0
800071fc:	f9 bb 00 00 	moveq	r11,0
80007200:	f9 be 00 00 	moveq	lr,0
80007204:	cb fb       	rjmp	80007182 <__avr32_f64_add_res_of_done>

80007206 <__avr32_f64_add_op2_subnormal>:
80007206:	30 16       	mov	r6,1
80007208:	58 07       	cp.w	r7,0
8000720a:	ca 01       	brne	8000714a <__avr32_f64_add+0x3e>
8000720c:	b5 cb       	cbr	r11,0x14
8000720e:	10 0a       	add	r10,r8
80007210:	f6 09 00 4b 	adc	r11,r11,r9
80007214:	18 4b       	or	r11,r12
80007216:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000721a:	d7 03       	nop

8000721c <__avr32_u32_to_f64>:
8000721c:	f8 cb 00 00 	sub	r11,r12,0
80007220:	30 0c       	mov	r12,0
80007222:	c0 38       	rjmp	80007228 <__avr32_s32_to_f64+0x4>

80007224 <__avr32_s32_to_f64>:
80007224:	18 9b       	mov	r11,r12
80007226:	5c 4b       	abs	r11
80007228:	30 0a       	mov	r10,0
8000722a:	5e 0b       	reteq	r11
8000722c:	d4 01       	pushm	lr
8000722e:	e0 69 04 1e 	mov	r9,1054
80007232:	f6 08 12 00 	clz	r8,r11
80007236:	c1 70       	breq	80007264 <__avr32_s32_to_f64+0x40>
80007238:	c0 c3       	brcs	80007250 <__avr32_s32_to_f64+0x2c>
8000723a:	f0 0e 11 20 	rsub	lr,r8,32
8000723e:	f6 08 09 4b 	lsl	r11,r11,r8
80007242:	f4 0e 0a 4e 	lsr	lr,r10,lr
80007246:	1c 4b       	or	r11,lr
80007248:	f4 08 09 4a 	lsl	r10,r10,r8
8000724c:	10 19       	sub	r9,r8
8000724e:	c0 b8       	rjmp	80007264 <__avr32_s32_to_f64+0x40>
80007250:	f4 08 12 00 	clz	r8,r10
80007254:	f9 b8 03 00 	movlo	r8,0
80007258:	f7 b8 02 e0 	subhs	r8,-32
8000725c:	f4 08 09 4b 	lsl	r11,r10,r8
80007260:	30 0a       	mov	r10,0
80007262:	10 19       	sub	r9,r8
80007264:	58 09       	cp.w	r9,0
80007266:	e0 89 00 30 	brgt	800072c6 <__avr32_s32_to_f64+0xa2>
8000726a:	5c 39       	neg	r9
8000726c:	2f f9       	sub	r9,-1
8000726e:	e0 49 00 36 	cp.w	r9,54
80007272:	c0 43       	brcs	8000727a <__avr32_s32_to_f64+0x56>
80007274:	30 0b       	mov	r11,0
80007276:	30 0a       	mov	r10,0
80007278:	c2 68       	rjmp	800072c4 <__avr32_s32_to_f64+0xa0>
8000727a:	2f 69       	sub	r9,-10
8000727c:	f2 08 11 20 	rsub	r8,r9,32
80007280:	e0 49 00 20 	cp.w	r9,32
80007284:	c0 b2       	brcc	8000729a <__avr32_s32_to_f64+0x76>
80007286:	f4 08 09 4e 	lsl	lr,r10,r8
8000728a:	f6 08 09 48 	lsl	r8,r11,r8
8000728e:	f4 09 0a 4a 	lsr	r10,r10,r9
80007292:	f6 09 0a 4b 	lsr	r11,r11,r9
80007296:	10 4b       	or	r11,r8
80007298:	c0 88       	rjmp	800072a8 <__avr32_s32_to_f64+0x84>
8000729a:	f6 08 09 4e 	lsl	lr,r11,r8
8000729e:	14 4e       	or	lr,r10
800072a0:	16 9a       	mov	r10,r11
800072a2:	30 0b       	mov	r11,0
800072a4:	f4 09 0a 4a 	lsr	r10,r10,r9
800072a8:	ed ba 00 00 	bld	r10,0x0
800072ac:	c0 92       	brcc	800072be <__avr32_s32_to_f64+0x9a>
800072ae:	1c 7e       	tst	lr,lr
800072b0:	c0 41       	brne	800072b8 <__avr32_s32_to_f64+0x94>
800072b2:	ed ba 00 01 	bld	r10,0x1
800072b6:	c0 42       	brcc	800072be <__avr32_s32_to_f64+0x9a>
800072b8:	2f fa       	sub	r10,-1
800072ba:	f7 bb 02 ff 	subhs	r11,-1
800072be:	5c fc       	rol	r12
800072c0:	5d 0b       	ror	r11
800072c2:	5d 0a       	ror	r10
800072c4:	d8 02       	popm	pc
800072c6:	e0 68 03 ff 	mov	r8,1023
800072ca:	ed ba 00 0b 	bld	r10,0xb
800072ce:	f7 b8 00 ff 	subeq	r8,-1
800072d2:	10 0a       	add	r10,r8
800072d4:	5c 0b       	acr	r11
800072d6:	f7 b9 03 fe 	sublo	r9,-2
800072da:	e0 49 07 ff 	cp.w	r9,2047
800072de:	c0 55       	brlt	800072e8 <__avr32_s32_to_f64+0xc4>
800072e0:	30 0a       	mov	r10,0
800072e2:	fc 1b ff e0 	movh	r11,0xffe0
800072e6:	c0 c8       	rjmp	800072fe <__floatsidf_return_op1>
800072e8:	ed bb 00 1f 	bld	r11,0x1f
800072ec:	f7 b9 01 01 	subne	r9,1
800072f0:	ab 9a       	lsr	r10,0xb
800072f2:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
800072f6:	a1 7b       	lsl	r11,0x1
800072f8:	ab 9b       	lsr	r11,0xb
800072fa:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

800072fe <__floatsidf_return_op1>:
800072fe:	a1 7c       	lsl	r12,0x1
80007300:	5d 0b       	ror	r11
80007302:	d8 02       	popm	pc

80007304 <__avr32_f64_cmp_lt>:
80007304:	1a de       	st.w	--sp,lr
80007306:	1a d7       	st.w	--sp,r7
80007308:	a1 7b       	lsl	r11,0x1
8000730a:	5f 3c       	srlo	r12
8000730c:	a1 79       	lsl	r9,0x1
8000730e:	5f 37       	srlo	r7
80007310:	5c fc       	rol	r12
80007312:	fc 1e ff e0 	movh	lr,0xffe0
80007316:	58 0a       	cp.w	r10,0
80007318:	fc 0b 13 00 	cpc	r11,lr
8000731c:	e0 8b 00 1d 	brhi	80007356 <__avr32_f64_cmp_lt+0x52>
80007320:	58 08       	cp.w	r8,0
80007322:	fc 09 13 00 	cpc	r9,lr
80007326:	e0 8b 00 18 	brhi	80007356 <__avr32_f64_cmp_lt+0x52>
8000732a:	58 0b       	cp.w	r11,0
8000732c:	f5 ba 00 00 	subfeq	r10,0
80007330:	c1 50       	breq	8000735a <__avr32_f64_cmp_lt+0x56>
80007332:	1b 07       	ld.w	r7,sp++
80007334:	1b 0e       	ld.w	lr,sp++
80007336:	58 3c       	cp.w	r12,3
80007338:	c0 a0       	breq	8000734c <__avr32_f64_cmp_lt+0x48>
8000733a:	58 1c       	cp.w	r12,1
8000733c:	c0 33       	brcs	80007342 <__avr32_f64_cmp_lt+0x3e>
8000733e:	5e 0d       	reteq	0
80007340:	5e 1f       	retne	1
80007342:	10 3a       	cp.w	r10,r8
80007344:	f2 0b 13 00 	cpc	r11,r9
80007348:	5e 2d       	reths	0
8000734a:	5e 3f       	retlo	1
8000734c:	14 38       	cp.w	r8,r10
8000734e:	f6 09 13 00 	cpc	r9,r11
80007352:	5e 2d       	reths	0
80007354:	5e 3f       	retlo	1
80007356:	1b 07       	ld.w	r7,sp++
80007358:	d8 0a       	popm	pc,r12=0
8000735a:	58 17       	cp.w	r7,1
8000735c:	5f 1c       	srne	r12
8000735e:	58 09       	cp.w	r9,0
80007360:	f5 b8 00 00 	subfeq	r8,0
80007364:	1b 07       	ld.w	r7,sp++
80007366:	1b 0e       	ld.w	lr,sp++
80007368:	5e 0d       	reteq	0
8000736a:	5e fc       	retal	r12

8000736c <__avr32_f32_cmp_ge>:
8000736c:	f8 0a 15 01 	lsl	r10,r12,0x1
80007370:	f6 09 15 01 	lsl	r9,r11,0x1
80007374:	f5 ba 00 00 	subfeq	r10,0
80007378:	5e 0f       	reteq	1
8000737a:	fc 18 ff 00 	movh	r8,0xff00
8000737e:	10 3a       	cp.w	r10,r8
80007380:	5e bd       	rethi	0
80007382:	10 39       	cp.w	r9,r8
80007384:	5e bd       	rethi	0
80007386:	f7 ec 20 08 	eor	r8,r11,r12
8000738a:	ed bc 00 1f 	bld	r12,0x1f
8000738e:	5f 28       	srhs	r8
80007390:	5e 68       	retmi	r8
80007392:	c0 43       	brcs	8000739a <__avr32_f32_cmp_ge+0x2e>
80007394:	16 3c       	cp.w	r12,r11
80007396:	5e 2f       	reths	1
80007398:	5e 3d       	retlo	0
8000739a:	18 3b       	cp.w	r11,r12
8000739c:	5e 2f       	reths	1
8000739e:	5e 3d       	retlo	0

800073a0 <__avr32_f64_div>:
800073a0:	eb cd 40 ff 	pushm	r0-r7,lr
800073a4:	f7 e9 20 0e 	eor	lr,r11,r9
800073a8:	f6 07 16 14 	lsr	r7,r11,0x14
800073ac:	a9 7b       	lsl	r11,0x9
800073ae:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
800073b2:	a9 7a       	lsl	r10,0x9
800073b4:	bd bb       	sbr	r11,0x1d
800073b6:	e4 1b 3f ff 	andh	r11,0x3fff
800073ba:	ab d7       	cbr	r7,0xb
800073bc:	e0 80 00 cc 	breq	80007554 <__avr32_f64_div_round_subnormal+0x54>
800073c0:	e0 47 07 ff 	cp.w	r7,2047
800073c4:	e0 84 00 b5 	brge	8000752e <__avr32_f64_div_round_subnormal+0x2e>
800073c8:	f2 06 16 14 	lsr	r6,r9,0x14
800073cc:	a9 79       	lsl	r9,0x9
800073ce:	f3 e8 13 79 	or	r9,r9,r8>>0x17
800073d2:	a9 78       	lsl	r8,0x9
800073d4:	bd b9       	sbr	r9,0x1d
800073d6:	e4 19 3f ff 	andh	r9,0x3fff
800073da:	ab d6       	cbr	r6,0xb
800073dc:	e0 80 00 e2 	breq	800075a0 <__avr32_f64_div_round_subnormal+0xa0>
800073e0:	e0 46 07 ff 	cp.w	r6,2047
800073e4:	e0 84 00 b2 	brge	80007548 <__avr32_f64_div_round_subnormal+0x48>
800073e8:	0c 17       	sub	r7,r6
800073ea:	fe 37 fc 01 	sub	r7,-1023
800073ee:	fc 1c 80 00 	movh	r12,0x8000
800073f2:	f8 03 16 01 	lsr	r3,r12,0x1
800073f6:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
800073fa:	5c d4       	com	r4
800073fc:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
80007400:	e6 09 06 44 	mulu.d	r4,r3,r9
80007404:	f8 05 01 25 	sub	r5,r12,r5<<0x2
80007408:	e6 05 06 44 	mulu.d	r4,r3,r5
8000740c:	ea 03 15 02 	lsl	r3,r5,0x2
80007410:	e6 09 06 44 	mulu.d	r4,r3,r9
80007414:	f8 05 01 25 	sub	r5,r12,r5<<0x2
80007418:	e6 05 06 44 	mulu.d	r4,r3,r5
8000741c:	ea 03 15 02 	lsl	r3,r5,0x2
80007420:	e6 09 06 44 	mulu.d	r4,r3,r9
80007424:	f8 05 01 25 	sub	r5,r12,r5<<0x2
80007428:	e6 05 06 44 	mulu.d	r4,r3,r5
8000742c:	ea 03 15 02 	lsl	r3,r5,0x2
80007430:	e6 08 06 40 	mulu.d	r0,r3,r8
80007434:	e4 09 07 40 	macu.d	r0,r2,r9
80007438:	e6 09 06 44 	mulu.d	r4,r3,r9
8000743c:	02 04       	add	r4,r1
8000743e:	5c 05       	acr	r5
80007440:	a3 65       	lsl	r5,0x2
80007442:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
80007446:	a3 64       	lsl	r4,0x2
80007448:	5c 34       	neg	r4
8000744a:	f8 05 01 45 	sbc	r5,r12,r5
8000744e:	e6 04 06 40 	mulu.d	r0,r3,r4
80007452:	e4 05 07 40 	macu.d	r0,r2,r5
80007456:	e6 05 06 44 	mulu.d	r4,r3,r5
8000745a:	02 04       	add	r4,r1
8000745c:	5c 05       	acr	r5
8000745e:	ea 03 15 02 	lsl	r3,r5,0x2
80007462:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
80007466:	e8 02 15 02 	lsl	r2,r4,0x2
8000746a:	e6 08 06 40 	mulu.d	r0,r3,r8
8000746e:	e4 09 07 40 	macu.d	r0,r2,r9
80007472:	e6 09 06 44 	mulu.d	r4,r3,r9
80007476:	02 04       	add	r4,r1
80007478:	5c 05       	acr	r5
8000747a:	a3 65       	lsl	r5,0x2
8000747c:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
80007480:	a3 64       	lsl	r4,0x2
80007482:	5c 34       	neg	r4
80007484:	f8 05 01 45 	sbc	r5,r12,r5
80007488:	e6 04 06 40 	mulu.d	r0,r3,r4
8000748c:	e4 05 07 40 	macu.d	r0,r2,r5
80007490:	e6 05 06 44 	mulu.d	r4,r3,r5
80007494:	02 04       	add	r4,r1
80007496:	5c 05       	acr	r5
80007498:	ea 03 15 02 	lsl	r3,r5,0x2
8000749c:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
800074a0:	e8 02 15 02 	lsl	r2,r4,0x2
800074a4:	e6 0a 06 40 	mulu.d	r0,r3,r10
800074a8:	e4 0b 07 40 	macu.d	r0,r2,r11
800074ac:	e6 0b 06 42 	mulu.d	r2,r3,r11
800074b0:	02 02       	add	r2,r1
800074b2:	5c 03       	acr	r3
800074b4:	ed b3 00 1c 	bld	r3,0x1c
800074b8:	c0 90       	breq	800074ca <__avr32_f64_div+0x12a>
800074ba:	a1 72       	lsl	r2,0x1
800074bc:	5c f3       	rol	r3
800074be:	20 17       	sub	r7,1
800074c0:	a3 9a       	lsr	r10,0x3
800074c2:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
800074c6:	a3 9b       	lsr	r11,0x3
800074c8:	c0 58       	rjmp	800074d2 <__avr32_f64_div+0x132>
800074ca:	a5 8a       	lsr	r10,0x4
800074cc:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
800074d0:	a5 8b       	lsr	r11,0x4
800074d2:	58 07       	cp.w	r7,0
800074d4:	e0 8a 00 8b 	brle	800075ea <__avr32_f64_div_res_subnormal>
800074d8:	e0 12 ff 00 	andl	r2,0xff00
800074dc:	e8 12 00 80 	orl	r2,0x80
800074e0:	e6 08 06 40 	mulu.d	r0,r3,r8
800074e4:	e4 09 07 40 	macu.d	r0,r2,r9
800074e8:	e4 08 06 44 	mulu.d	r4,r2,r8
800074ec:	e6 09 06 48 	mulu.d	r8,r3,r9
800074f0:	00 05       	add	r5,r0
800074f2:	f0 01 00 48 	adc	r8,r8,r1
800074f6:	5c 09       	acr	r9
800074f8:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
800074fc:	58 04       	cp.w	r4,0
800074fe:	5c 25       	cpc	r5

80007500 <__avr32_f64_div_round_subnormal>:
80007500:	f4 08 13 00 	cpc	r8,r10
80007504:	f6 09 13 00 	cpc	r9,r11
80007508:	5f 36       	srlo	r6
8000750a:	f8 06 17 00 	moveq	r6,r12
8000750e:	e4 0a 16 08 	lsr	r10,r2,0x8
80007512:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
80007516:	e6 0b 16 08 	lsr	r11,r3,0x8
8000751a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000751e:	ed be 00 1f 	bld	lr,0x1f
80007522:	ef bb 00 1f 	bst	r11,0x1f
80007526:	0c 0a       	add	r10,r6
80007528:	5c 0b       	acr	r11
8000752a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000752e:	e4 1b 00 0f 	andh	r11,0xf
80007532:	14 4b       	or	r11,r10
80007534:	e0 81 00 a7 	brne	80007682 <__avr32_f64_div_res_subnormal+0x98>
80007538:	f2 06 16 14 	lsr	r6,r9,0x14
8000753c:	ab d6       	cbr	r6,0xb
8000753e:	e0 46 07 ff 	cp.w	r6,2047
80007542:	e0 81 00 a4 	brne	8000768a <__avr32_f64_div_res_subnormal+0xa0>
80007546:	c9 e8       	rjmp	80007682 <__avr32_f64_div_res_subnormal+0x98>
80007548:	e4 19 00 0f 	andh	r9,0xf
8000754c:	10 49       	or	r9,r8
8000754e:	e0 81 00 9a 	brne	80007682 <__avr32_f64_div_res_subnormal+0x98>
80007552:	c9 28       	rjmp	80007676 <__avr32_f64_div_res_subnormal+0x8c>
80007554:	a3 7b       	lsl	r11,0x3
80007556:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000755a:	a3 7a       	lsl	r10,0x3
8000755c:	f5 eb 10 04 	or	r4,r10,r11
80007560:	e0 80 00 a0 	breq	800076a0 <__avr32_f64_div_op1_zero>
80007564:	f6 04 12 00 	clz	r4,r11
80007568:	c1 70       	breq	80007596 <__avr32_f64_div_round_subnormal+0x96>
8000756a:	c0 c3       	brcs	80007582 <__avr32_f64_div_round_subnormal+0x82>
8000756c:	e8 05 11 20 	rsub	r5,r4,32
80007570:	f6 04 09 4b 	lsl	r11,r11,r4
80007574:	f4 05 0a 45 	lsr	r5,r10,r5
80007578:	0a 4b       	or	r11,r5
8000757a:	f4 04 09 4a 	lsl	r10,r10,r4
8000757e:	08 17       	sub	r7,r4
80007580:	c0 b8       	rjmp	80007596 <__avr32_f64_div_round_subnormal+0x96>
80007582:	f4 04 12 00 	clz	r4,r10
80007586:	f9 b4 03 00 	movlo	r4,0
8000758a:	f7 b4 02 e0 	subhs	r4,-32
8000758e:	f4 04 09 4b 	lsl	r11,r10,r4
80007592:	30 0a       	mov	r10,0
80007594:	08 17       	sub	r7,r4
80007596:	a3 8a       	lsr	r10,0x2
80007598:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000759c:	a3 8b       	lsr	r11,0x2
8000759e:	c1 1b       	rjmp	800073c0 <__avr32_f64_div+0x20>
800075a0:	a3 79       	lsl	r9,0x3
800075a2:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
800075a6:	a3 78       	lsl	r8,0x3
800075a8:	f3 e8 10 04 	or	r4,r9,r8
800075ac:	c6 f0       	breq	8000768a <__avr32_f64_div_res_subnormal+0xa0>
800075ae:	f2 04 12 00 	clz	r4,r9
800075b2:	c1 70       	breq	800075e0 <__avr32_f64_div_round_subnormal+0xe0>
800075b4:	c0 c3       	brcs	800075cc <__avr32_f64_div_round_subnormal+0xcc>
800075b6:	e8 05 11 20 	rsub	r5,r4,32
800075ba:	f2 04 09 49 	lsl	r9,r9,r4
800075be:	f0 05 0a 45 	lsr	r5,r8,r5
800075c2:	0a 49       	or	r9,r5
800075c4:	f0 04 09 48 	lsl	r8,r8,r4
800075c8:	08 16       	sub	r6,r4
800075ca:	c0 b8       	rjmp	800075e0 <__avr32_f64_div_round_subnormal+0xe0>
800075cc:	f0 04 12 00 	clz	r4,r8
800075d0:	f9 b4 03 00 	movlo	r4,0
800075d4:	f7 b4 02 e0 	subhs	r4,-32
800075d8:	f0 04 09 49 	lsl	r9,r8,r4
800075dc:	30 08       	mov	r8,0
800075de:	08 16       	sub	r6,r4
800075e0:	a3 88       	lsr	r8,0x2
800075e2:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
800075e6:	a3 89       	lsr	r9,0x2
800075e8:	cf ca       	rjmp	800073e0 <__avr32_f64_div+0x40>

800075ea <__avr32_f64_div_res_subnormal>:
800075ea:	5c 37       	neg	r7
800075ec:	2f f7       	sub	r7,-1
800075ee:	f1 b7 04 c0 	satu	r7,0x6
800075f2:	e0 47 00 20 	cp.w	r7,32
800075f6:	c1 54       	brge	80007620 <__avr32_f64_div_res_subnormal+0x36>
800075f8:	ee 06 11 20 	rsub	r6,r7,32
800075fc:	e4 07 0a 42 	lsr	r2,r2,r7
80007600:	e6 06 09 4c 	lsl	r12,r3,r6
80007604:	18 42       	or	r2,r12
80007606:	e6 07 0a 43 	lsr	r3,r3,r7
8000760a:	f4 06 09 41 	lsl	r1,r10,r6
8000760e:	f4 07 0a 4a 	lsr	r10,r10,r7
80007612:	f6 06 09 4c 	lsl	r12,r11,r6
80007616:	18 4a       	or	r10,r12
80007618:	f6 07 0a 4b 	lsr	r11,r11,r7
8000761c:	30 00       	mov	r0,0
8000761e:	c1 58       	rjmp	80007648 <__avr32_f64_div_res_subnormal+0x5e>
80007620:	ee 06 11 20 	rsub	r6,r7,32
80007624:	f9 b0 00 00 	moveq	r0,0
80007628:	f9 bc 00 00 	moveq	r12,0
8000762c:	c0 50       	breq	80007636 <__avr32_f64_div_res_subnormal+0x4c>
8000762e:	f4 06 09 40 	lsl	r0,r10,r6
80007632:	f6 06 09 4c 	lsl	r12,r11,r6
80007636:	e6 07 0a 42 	lsr	r2,r3,r7
8000763a:	30 03       	mov	r3,0
8000763c:	f4 07 0a 41 	lsr	r1,r10,r7
80007640:	18 41       	or	r1,r12
80007642:	f6 07 0a 4a 	lsr	r10,r11,r7
80007646:	30 0b       	mov	r11,0
80007648:	e0 12 ff 00 	andl	r2,0xff00
8000764c:	e8 12 00 80 	orl	r2,0x80
80007650:	e6 08 06 46 	mulu.d	r6,r3,r8
80007654:	e4 09 07 46 	macu.d	r6,r2,r9
80007658:	e4 08 06 44 	mulu.d	r4,r2,r8
8000765c:	e6 09 06 48 	mulu.d	r8,r3,r9
80007660:	0c 05       	add	r5,r6
80007662:	f0 07 00 48 	adc	r8,r8,r7
80007666:	5c 09       	acr	r9
80007668:	30 07       	mov	r7,0
8000766a:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000766e:	00 34       	cp.w	r4,r0
80007670:	e2 05 13 00 	cpc	r5,r1
80007674:	c4 6b       	rjmp	80007500 <__avr32_f64_div_round_subnormal>
80007676:	1c 9b       	mov	r11,lr
80007678:	e6 1b 80 00 	andh	r11,0x8000,COH
8000767c:	30 0a       	mov	r10,0
8000767e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
80007682:	3f fb       	mov	r11,-1
80007684:	30 0a       	mov	r10,0
80007686:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000768a:	f5 eb 10 04 	or	r4,r10,r11
8000768e:	c0 90       	breq	800076a0 <__avr32_f64_div_op1_zero>
80007690:	1c 9b       	mov	r11,lr
80007692:	e6 1b 80 00 	andh	r11,0x8000,COH
80007696:	ea 1b 7f f0 	orh	r11,0x7ff0
8000769a:	30 0a       	mov	r10,0
8000769c:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

800076a0 <__avr32_f64_div_op1_zero>:
800076a0:	f1 e9 10 15 	or	r5,r8,r9<<0x1
800076a4:	ce f0       	breq	80007682 <__avr32_f64_div_res_subnormal+0x98>
800076a6:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
800076aa:	e0 44 07 ff 	cp.w	r4,2047
800076ae:	ce 41       	brne	80007676 <__avr32_f64_div_res_subnormal+0x8c>
800076b0:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
800076b4:	ce 10       	breq	80007676 <__avr32_f64_div_res_subnormal+0x8c>
800076b6:	ce 6b       	rjmp	80007682 <__avr32_f64_div_res_subnormal+0x98>

800076b8 <__avr32_f32_div>:
800076b8:	f7 ec 20 08 	eor	r8,r11,r12
800076bc:	a1 7c       	lsl	r12,0x1
800076be:	a1 7b       	lsl	r11,0x1
800076c0:	c7 a0       	breq	800077b4 <__divsf_return_op1+0x16>
800076c2:	18 7c       	tst	r12,r12
800076c4:	f9 b9 00 00 	moveq	r9,0
800076c8:	c0 90       	breq	800076da <__avr32_f32_div+0x22>
800076ca:	f8 09 16 18 	lsr	r9,r12,0x18
800076ce:	c7 e0       	breq	800077ca <__divsf_return_op1+0x2c>
800076d0:	e0 49 00 ff 	cp.w	r9,255
800076d4:	c6 82       	brcc	800077a4 <__divsf_return_op1+0x6>
800076d6:	a7 7c       	lsl	r12,0x7
800076d8:	bf bc       	sbr	r12,0x1f
800076da:	f6 0a 16 18 	lsr	r10,r11,0x18
800076de:	c7 e0       	breq	800077da <__divsf_return_op1+0x3c>
800076e0:	e0 4a 00 ff 	cp.w	r10,255
800076e4:	c6 62       	brcc	800077b0 <__divsf_return_op1+0x12>
800076e6:	a7 7b       	lsl	r11,0x7
800076e8:	bf bb       	sbr	r11,0x1f
800076ea:	58 09       	cp.w	r9,0
800076ec:	f5 bc 00 00 	subfeq	r12,0
800076f0:	5e 0d       	reteq	0
800076f2:	1a d5       	st.w	--sp,r5
800076f4:	bb 27       	st.d	--sp,r6
800076f6:	14 19       	sub	r9,r10
800076f8:	28 19       	sub	r9,-127
800076fa:	fc 1a 80 00 	movh	r10,0x8000
800076fe:	a3 8c       	lsr	r12,0x2
80007700:	f6 05 16 02 	lsr	r5,r11,0x2
80007704:	f4 0b 16 01 	lsr	r11,r10,0x1
80007708:	ed d5 c3 62 	bfextu	r6,r5,0x1b,0x2
8000770c:	5c d6       	com	r6
8000770e:	f7 d6 d3 82 	bfins	r11,r6,0x1c,0x2
80007712:	f6 05 06 46 	mulu.d	r6,r11,r5
80007716:	f4 07 01 27 	sub	r7,r10,r7<<0x2
8000771a:	f6 07 06 46 	mulu.d	r6,r11,r7
8000771e:	ee 0b 15 02 	lsl	r11,r7,0x2
80007722:	f6 05 06 46 	mulu.d	r6,r11,r5
80007726:	f4 07 01 27 	sub	r7,r10,r7<<0x2
8000772a:	f6 07 06 46 	mulu.d	r6,r11,r7
8000772e:	ee 0b 15 02 	lsl	r11,r7,0x2
80007732:	f6 05 06 46 	mulu.d	r6,r11,r5
80007736:	f4 07 01 27 	sub	r7,r10,r7<<0x2
8000773a:	f6 07 06 46 	mulu.d	r6,r11,r7
8000773e:	ee 0b 15 02 	lsl	r11,r7,0x2
80007742:	f6 05 06 46 	mulu.d	r6,r11,r5
80007746:	f4 07 01 27 	sub	r7,r10,r7<<0x2
8000774a:	f6 07 06 46 	mulu.d	r6,r11,r7
8000774e:	ee 0b 15 02 	lsl	r11,r7,0x2
80007752:	f6 0c 06 46 	mulu.d	r6,r11,r12
80007756:	a5 8c       	lsr	r12,0x4
80007758:	ed b7 00 1c 	bld	r7,0x1c
8000775c:	c0 40       	breq	80007764 <__avr32_f32_div+0xac>
8000775e:	a1 77       	lsl	r7,0x1
80007760:	20 19       	sub	r9,1
80007762:	a1 7c       	lsl	r12,0x1
80007764:	58 09       	cp.w	r9,0
80007766:	e0 8a 00 42 	brle	800077ea <__avr32_f32_div_res_subnormal>
8000776a:	e0 17 ff e0 	andl	r7,0xffe0
8000776e:	e8 17 00 10 	orl	r7,0x10
80007772:	ea 07 06 4a 	mulu.d	r10,r5,r7
80007776:	eb d7 c0 a1 	bfextu	r5,r7,0x5,0x1
8000777a:	58 0a       	cp.w	r10,0

8000777c <__avr32_f32_div_round_subnormal>:
8000777c:	f8 0b 13 00 	cpc	r11,r12
80007780:	5f 3b       	srlo	r11
80007782:	ea 0b 17 00 	moveq	r11,r5
80007786:	ee 0c 16 05 	lsr	r12,r7,0x5
8000778a:	f9 d9 d2 e8 	bfins	r12,r9,0x17,0x8
8000778e:	bb 07       	ld.d	r6,sp++
80007790:	1b 05       	ld.w	r5,sp++
80007792:	ed b8 00 1f 	bld	r8,0x1f
80007796:	ef bc 00 1f 	bst	r12,0x1f
8000779a:	16 0c       	add	r12,r11
8000779c:	5e fc       	retal	r12

8000779e <__divsf_return_op1>:
8000779e:	a1 78       	lsl	r8,0x1
800077a0:	5d 0c       	ror	r12
800077a2:	5e fc       	retal	r12
800077a4:	5e 1e       	retne	-1
800077a6:	fc 19 ff 00 	movh	r9,0xff00
800077aa:	12 3b       	cp.w	r11,r9
800077ac:	cf 93       	brcs	8000779e <__divsf_return_op1>
800077ae:	5e fe       	retal	-1
800077b0:	5e 0d       	reteq	0
800077b2:	5e fe       	retal	-1
800077b4:	18 7c       	tst	r12,r12
800077b6:	5e 0e       	reteq	-1
800077b8:	f8 09 16 18 	lsr	r9,r12,0x18
800077bc:	c0 70       	breq	800077ca <__divsf_return_op1+0x2c>
800077be:	e0 49 00 ff 	cp.w	r9,255
800077c2:	cf 12       	brcc	800077a4 <__divsf_return_op1+0x6>
800077c4:	fc 1c ff 00 	movh	r12,0xff00
800077c8:	ce bb       	rjmp	8000779e <__divsf_return_op1>
800077ca:	a7 7c       	lsl	r12,0x7
800077cc:	f8 09 12 00 	clz	r9,r12
800077d0:	f8 09 09 4c 	lsl	r12,r12,r9
800077d4:	f2 09 11 01 	rsub	r9,r9,1
800077d8:	c8 1b       	rjmp	800076da <__avr32_f32_div+0x22>
800077da:	a7 7b       	lsl	r11,0x7
800077dc:	f6 0a 12 00 	clz	r10,r11
800077e0:	f6 0a 09 4b 	lsl	r11,r11,r10
800077e4:	f4 0a 11 01 	rsub	r10,r10,1
800077e8:	c8 5b       	rjmp	800076f2 <__avr32_f32_div+0x3a>

800077ea <__avr32_f32_div_res_subnormal>:
800077ea:	5c 39       	neg	r9
800077ec:	2f f9       	sub	r9,-1
800077ee:	f1 b9 04 a0 	satu	r9,0x5
800077f2:	f2 0a 11 20 	rsub	r10,r9,32
800077f6:	ee 09 0a 47 	lsr	r7,r7,r9
800077fa:	f8 0a 09 46 	lsl	r6,r12,r10
800077fe:	f8 09 0a 4c 	lsr	r12,r12,r9
80007802:	e0 17 ff e0 	andl	r7,0xffe0
80007806:	e8 17 00 10 	orl	r7,0x10
8000780a:	ea 07 06 4a 	mulu.d	r10,r5,r7
8000780e:	30 09       	mov	r9,0
80007810:	eb d7 c0 a1 	bfextu	r5,r7,0x5,0x1
80007814:	0c 3a       	cp.w	r10,r6
80007816:	cb 3b       	rjmp	8000777c <__avr32_f32_div_round_subnormal>

80007818 <__avr32_f32_mul>:
80007818:	18 98       	mov	r8,r12
8000781a:	16 5c       	eor	r12,r11
8000781c:	e6 1c 80 00 	andh	r12,0x8000,COH
80007820:	bf d8       	cbr	r8,0x1f
80007822:	c6 60       	breq	800078ee <__avr32_f32_mul_op1_zero>
80007824:	bf db       	cbr	r11,0x1f
80007826:	f0 0b 0c 4a 	max	r10,r8,r11
8000782a:	f0 0b 0d 49 	min	r9,r8,r11
8000782e:	f4 08 15 08 	lsl	r8,r10,0x8
80007832:	bf b8       	sbr	r8,0x1f
80007834:	b7 9a       	lsr	r10,0x17
80007836:	e0 4a 00 ff 	cp.w	r10,255
8000783a:	c3 d0       	breq	800078b4 <__avr32_f32_mul_op1_nan_or_inf>
8000783c:	f2 0b 15 08 	lsl	r11,r9,0x8
80007840:	bf bb       	sbr	r11,0x1f
80007842:	b7 99       	lsr	r9,0x17
80007844:	c2 40       	breq	8000788c <__avr32_f32_mul_op2_subnormal>
80007846:	14 09       	add	r9,r10
80007848:	f0 0b 06 4a 	mulu.d	r10,r8,r11
8000784c:	f6 08 15 01 	lsl	r8,r11,0x1
80007850:	f0 0b 17 20 	movhs	r11,r8
80007854:	f7 b9 02 01 	subhs	r9,1
80007858:	a9 8a       	lsr	r10,0x8
8000785a:	f5 db d3 08 	bfins	r10,r11,0x18,0x8
8000785e:	27 e9       	sub	r9,126
80007860:	e0 8a 00 39 	brle	800078d2 <__avr32_f32_mul_res_subnormal>
80007864:	e0 49 00 ff 	cp.w	r9,255
80007868:	c0 f4       	brge	80007886 <__avr32_f32_mul_round+0x14>
8000786a:	f9 eb 12 8c 	or	r12,r12,r11>>0x8
8000786e:	f9 d9 d2 e8 	bfins	r12,r9,0x17,0x8

80007872 <__avr32_f32_mul_round>:
80007872:	fc 18 80 00 	movh	r8,0x8000
80007876:	ed bc 00 00 	bld	r12,0x0
8000787a:	f7 b8 01 ff 	subne	r8,-1
8000787e:	10 3a       	cp.w	r10,r8
80007880:	f7 bc 02 ff 	subhs	r12,-1
80007884:	5e fc       	retal	r12
80007886:	ea 1c 7f 80 	orh	r12,0x7f80
8000788a:	5e fc       	retal	r12

8000788c <__avr32_f32_mul_op2_subnormal>:
8000788c:	bf db       	cbr	r11,0x1f
8000788e:	f6 09 12 00 	clz	r9,r11
80007892:	5e 3d       	retlo	0
80007894:	20 89       	sub	r9,8
80007896:	f6 09 09 4b 	lsl	r11,r11,r9
8000789a:	f2 09 11 01 	rsub	r9,r9,1
8000789e:	14 7a       	tst	r10,r10
800078a0:	cd 31       	brne	80007846 <__avr32_f32_mul+0x2e>
800078a2:	bf d8       	cbr	r8,0x1f
800078a4:	f6 0a 12 00 	clz	r10,r11
800078a8:	5e 3d       	retlo	0
800078aa:	f0 0a 09 48 	lsl	r8,r8,r10
800078ae:	f4 0a 11 01 	rsub	r10,r10,1
800078b2:	cc ab       	rjmp	80007846 <__avr32_f32_mul+0x2e>

800078b4 <__avr32_f32_mul_op1_nan_or_inf>:
800078b4:	f0 0b 15 01 	lsl	r11,r8,0x1
800078b8:	5e 1e       	retne	-1
800078ba:	12 79       	tst	r9,r9
800078bc:	5e 0e       	reteq	-1
800078be:	f9 da d2 e8 	bfins	r12,r10,0x17,0x8
800078c2:	f2 0b 16 17 	lsr	r11,r9,0x17
800078c6:	e0 4b 00 ff 	cp.w	r11,255
800078ca:	5e 1c       	retne	r12
800078cc:	a9 79       	lsl	r9,0x9
800078ce:	5e 0c       	reteq	r12
800078d0:	5e fe       	retal	-1

800078d2 <__avr32_f32_mul_res_subnormal>:
800078d2:	f2 09 11 09 	rsub	r9,r9,9
800078d6:	f2 08 11 20 	rsub	r8,r9,32
800078da:	5e 3d       	retlo	0
800078dc:	f6 09 0a 49 	lsr	r9,r11,r9
800078e0:	12 4c       	or	r12,r9
800078e2:	f6 08 09 4b 	lsl	r11,r11,r8
800078e6:	e4 1a 00 ff 	andh	r10,0xff
800078ea:	16 4a       	or	r10,r11
800078ec:	cc 3b       	rjmp	80007872 <__avr32_f32_mul_round>

800078ee <__avr32_f32_mul_op1_zero>:
800078ee:	f5 db c2 e8 	bfextu	r10,r11,0x17,0x8
800078f2:	e0 4a 00 ff 	cp.w	r10,255
800078f6:	5e 1c       	retne	r12
800078f8:	5e 0e       	reteq	-1

800078fa <__avr32_s32_to_f32>:
800078fa:	58 0c       	cp.w	r12,0
800078fc:	5e 0c       	reteq	r12
800078fe:	18 9b       	mov	r11,r12
80007900:	5c 4c       	abs	r12
80007902:	e0 6a 00 9e 	mov	r10,158
80007906:	f8 09 12 00 	clz	r9,r12
8000790a:	12 1a       	sub	r10,r9
8000790c:	f8 09 09 4c 	lsl	r12,r12,r9
80007910:	58 0a       	cp.w	r10,0
80007912:	e0 8a 00 15 	brle	8000793c <__avr32_s32_to_f32_subnormal>
80007916:	37 f9       	mov	r9,127
80007918:	ed bc 00 08 	bld	r12,0x8
8000791c:	f7 b9 00 ff 	subeq	r9,-1
80007920:	12 0c       	add	r12,r9
80007922:	f7 ba 03 fe 	sublo	r10,-2
80007926:	ed bc 00 1f 	bld	r12,0x1f
8000792a:	f7 ba 01 01 	subne	r10,1
8000792e:	f8 0c 16 07 	lsr	r12,r12,0x7
80007932:	f9 da d3 08 	bfins	r12,r10,0x18,0x8
80007936:	a1 7b       	lsl	r11,0x1
80007938:	5d 0c       	ror	r12
8000793a:	5e fc       	retal	r12

8000793c <__avr32_s32_to_f32_subnormal>:
8000793c:	f4 0a 11 01 	rsub	r10,r10,1
80007940:	59 9a       	cp.w	r10,25
80007942:	f9 bc 02 00 	movhs	r12,0
80007946:	c1 32       	brcc	8000796c <__avr32_s32_to_f32_subnormal+0x30>
80007948:	f4 09 11 20 	rsub	r9,r10,32
8000794c:	f8 09 09 49 	lsl	r9,r12,r9
80007950:	5f 19       	srne	r9
80007952:	f8 0a 0a 4c 	lsr	r12,r12,r10
80007956:	12 4c       	or	r12,r9
80007958:	37 f9       	mov	r9,127
8000795a:	ed bc 00 08 	bld	r12,0x8
8000795e:	f7 b9 00 ff 	subeq	r9,-1
80007962:	12 0c       	add	r12,r9
80007964:	f8 0c 16 07 	lsr	r12,r12,0x7
80007968:	a1 7b       	lsl	r11,0x1
8000796a:	5d 0c       	ror	r12
8000796c:	5e fc       	retal	r12

8000796e <__avr32_f32_to_u32>:
8000796e:	58 0c       	cp.w	r12,0
80007970:	5e 6d       	retmi	0
80007972:	f7 dc c2 e8 	bfextu	r11,r12,0x17,0x8
80007976:	27 fb       	sub	r11,127
80007978:	5e 3d       	retlo	0
8000797a:	f6 0b 11 1f 	rsub	r11,r11,31
8000797e:	a9 6c       	lsl	r12,0x8
80007980:	bf bc       	sbr	r12,0x1f
80007982:	f8 0b 0a 4c 	lsr	r12,r12,r11
80007986:	5e fc       	retal	r12

80007988 <__avr32_udiv64>:
80007988:	d4 31       	pushm	r0-r7,lr
8000798a:	1a 97       	mov	r7,sp
8000798c:	20 3d       	sub	sp,12
8000798e:	10 9c       	mov	r12,r8
80007990:	12 9e       	mov	lr,r9
80007992:	14 93       	mov	r3,r10
80007994:	58 09       	cp.w	r9,0
80007996:	e0 81 00 bd 	brne	80007b10 <__avr32_udiv64+0x188>
8000799a:	16 38       	cp.w	r8,r11
8000799c:	e0 88 00 40 	brls	80007a1c <__avr32_udiv64+0x94>
800079a0:	f0 08 12 00 	clz	r8,r8
800079a4:	c0 d0       	breq	800079be <__avr32_udiv64+0x36>
800079a6:	f6 08 09 4b 	lsl	r11,r11,r8
800079aa:	f0 09 11 20 	rsub	r9,r8,32
800079ae:	f8 08 09 4c 	lsl	r12,r12,r8
800079b2:	f4 09 0a 49 	lsr	r9,r10,r9
800079b6:	f4 08 09 43 	lsl	r3,r10,r8
800079ba:	f3 eb 10 0b 	or	r11,r9,r11
800079be:	f8 0e 16 10 	lsr	lr,r12,0x10
800079c2:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
800079c6:	f6 0e 0d 00 	divu	r0,r11,lr
800079ca:	e6 0b 16 10 	lsr	r11,r3,0x10
800079ce:	00 99       	mov	r9,r0
800079d0:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
800079d4:	e0 0a 02 48 	mul	r8,r0,r10
800079d8:	10 3b       	cp.w	r11,r8
800079da:	c0 a2       	brcc	800079ee <__avr32_udiv64+0x66>
800079dc:	20 19       	sub	r9,1
800079de:	18 0b       	add	r11,r12
800079e0:	18 3b       	cp.w	r11,r12
800079e2:	c0 63       	brcs	800079ee <__avr32_udiv64+0x66>
800079e4:	10 3b       	cp.w	r11,r8
800079e6:	f7 b9 03 01 	sublo	r9,1
800079ea:	f7 dc e3 0b 	addcs	r11,r11,r12
800079ee:	f6 08 01 01 	sub	r1,r11,r8
800079f2:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
800079f6:	e2 0e 0d 00 	divu	r0,r1,lr
800079fa:	e7 e1 11 03 	or	r3,r3,r1<<0x10
800079fe:	00 98       	mov	r8,r0
80007a00:	e0 0a 02 4a 	mul	r10,r0,r10
80007a04:	14 33       	cp.w	r3,r10
80007a06:	c0 82       	brcc	80007a16 <__avr32_udiv64+0x8e>
80007a08:	20 18       	sub	r8,1
80007a0a:	18 03       	add	r3,r12
80007a0c:	18 33       	cp.w	r3,r12
80007a0e:	c0 43       	brcs	80007a16 <__avr32_udiv64+0x8e>
80007a10:	14 33       	cp.w	r3,r10
80007a12:	f7 b8 03 01 	sublo	r8,1
80007a16:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80007a1a:	cd f8       	rjmp	80007bd8 <__avr32_udiv64+0x250>
80007a1c:	58 08       	cp.w	r8,0
80007a1e:	c0 51       	brne	80007a28 <__avr32_udiv64+0xa0>
80007a20:	30 19       	mov	r9,1
80007a22:	f2 08 0d 08 	divu	r8,r9,r8
80007a26:	10 9c       	mov	r12,r8
80007a28:	f8 06 12 00 	clz	r6,r12
80007a2c:	c0 41       	brne	80007a34 <__avr32_udiv64+0xac>
80007a2e:	18 1b       	sub	r11,r12
80007a30:	30 19       	mov	r9,1
80007a32:	c4 08       	rjmp	80007ab2 <__avr32_udiv64+0x12a>
80007a34:	ec 01 11 20 	rsub	r1,r6,32
80007a38:	f4 01 0a 49 	lsr	r9,r10,r1
80007a3c:	f8 06 09 4c 	lsl	r12,r12,r6
80007a40:	f6 06 09 48 	lsl	r8,r11,r6
80007a44:	f6 01 0a 41 	lsr	r1,r11,r1
80007a48:	f3 e8 10 08 	or	r8,r9,r8
80007a4c:	f8 03 16 10 	lsr	r3,r12,0x10
80007a50:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
80007a54:	e2 03 0d 00 	divu	r0,r1,r3
80007a58:	f0 0b 16 10 	lsr	r11,r8,0x10
80007a5c:	00 9e       	mov	lr,r0
80007a5e:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80007a62:	e0 05 02 49 	mul	r9,r0,r5
80007a66:	12 3b       	cp.w	r11,r9
80007a68:	c0 a2       	brcc	80007a7c <__avr32_udiv64+0xf4>
80007a6a:	20 1e       	sub	lr,1
80007a6c:	18 0b       	add	r11,r12
80007a6e:	18 3b       	cp.w	r11,r12
80007a70:	c0 63       	brcs	80007a7c <__avr32_udiv64+0xf4>
80007a72:	12 3b       	cp.w	r11,r9
80007a74:	f7 be 03 01 	sublo	lr,1
80007a78:	f7 dc e3 0b 	addcs	r11,r11,r12
80007a7c:	12 1b       	sub	r11,r9
80007a7e:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
80007a82:	f6 03 0d 02 	divu	r2,r11,r3
80007a86:	f1 e3 11 08 	or	r8,r8,r3<<0x10
80007a8a:	04 99       	mov	r9,r2
80007a8c:	e4 05 02 4b 	mul	r11,r2,r5
80007a90:	16 38       	cp.w	r8,r11
80007a92:	c0 a2       	brcc	80007aa6 <__avr32_udiv64+0x11e>
80007a94:	20 19       	sub	r9,1
80007a96:	18 08       	add	r8,r12
80007a98:	18 38       	cp.w	r8,r12
80007a9a:	c0 63       	brcs	80007aa6 <__avr32_udiv64+0x11e>
80007a9c:	16 38       	cp.w	r8,r11
80007a9e:	f7 b9 03 01 	sublo	r9,1
80007aa2:	f1 dc e3 08 	addcs	r8,r8,r12
80007aa6:	f4 06 09 43 	lsl	r3,r10,r6
80007aaa:	f0 0b 01 0b 	sub	r11,r8,r11
80007aae:	f3 ee 11 09 	or	r9,r9,lr<<0x10
80007ab2:	f8 06 16 10 	lsr	r6,r12,0x10
80007ab6:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
80007aba:	f6 06 0d 00 	divu	r0,r11,r6
80007abe:	e6 0b 16 10 	lsr	r11,r3,0x10
80007ac2:	00 9a       	mov	r10,r0
80007ac4:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80007ac8:	e0 0e 02 48 	mul	r8,r0,lr
80007acc:	10 3b       	cp.w	r11,r8
80007ace:	c0 a2       	brcc	80007ae2 <__avr32_udiv64+0x15a>
80007ad0:	20 1a       	sub	r10,1
80007ad2:	18 0b       	add	r11,r12
80007ad4:	18 3b       	cp.w	r11,r12
80007ad6:	c0 63       	brcs	80007ae2 <__avr32_udiv64+0x15a>
80007ad8:	10 3b       	cp.w	r11,r8
80007ada:	f7 ba 03 01 	sublo	r10,1
80007ade:	f7 dc e3 0b 	addcs	r11,r11,r12
80007ae2:	f6 08 01 01 	sub	r1,r11,r8
80007ae6:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
80007aea:	e2 06 0d 00 	divu	r0,r1,r6
80007aee:	e7 e1 11 03 	or	r3,r3,r1<<0x10
80007af2:	00 98       	mov	r8,r0
80007af4:	e0 0e 02 4b 	mul	r11,r0,lr
80007af8:	16 33       	cp.w	r3,r11
80007afa:	c0 82       	brcc	80007b0a <__avr32_udiv64+0x182>
80007afc:	20 18       	sub	r8,1
80007afe:	18 03       	add	r3,r12
80007b00:	18 33       	cp.w	r3,r12
80007b02:	c0 43       	brcs	80007b0a <__avr32_udiv64+0x182>
80007b04:	16 33       	cp.w	r3,r11
80007b06:	f7 b8 03 01 	sublo	r8,1
80007b0a:	f1 ea 11 08 	or	r8,r8,r10<<0x10
80007b0e:	c6 98       	rjmp	80007be0 <__avr32_udiv64+0x258>
80007b10:	16 39       	cp.w	r9,r11
80007b12:	e0 8b 00 65 	brhi	80007bdc <__avr32_udiv64+0x254>
80007b16:	f2 09 12 00 	clz	r9,r9
80007b1a:	c0 b1       	brne	80007b30 <__avr32_udiv64+0x1a8>
80007b1c:	10 3a       	cp.w	r10,r8
80007b1e:	5f 2a       	srhs	r10
80007b20:	1c 3b       	cp.w	r11,lr
80007b22:	5f b8       	srhi	r8
80007b24:	10 4a       	or	r10,r8
80007b26:	f2 0a 18 00 	cp.b	r10,r9
80007b2a:	c5 90       	breq	80007bdc <__avr32_udiv64+0x254>
80007b2c:	30 18       	mov	r8,1
80007b2e:	c5 98       	rjmp	80007be0 <__avr32_udiv64+0x258>
80007b30:	f0 09 09 46 	lsl	r6,r8,r9
80007b34:	f2 03 11 20 	rsub	r3,r9,32
80007b38:	fc 09 09 4e 	lsl	lr,lr,r9
80007b3c:	f0 03 0a 48 	lsr	r8,r8,r3
80007b40:	f6 09 09 4c 	lsl	r12,r11,r9
80007b44:	f4 03 0a 42 	lsr	r2,r10,r3
80007b48:	ef 46 ff f4 	st.w	r7[-12],r6
80007b4c:	f6 03 0a 43 	lsr	r3,r11,r3
80007b50:	18 42       	or	r2,r12
80007b52:	f1 ee 10 0c 	or	r12,r8,lr
80007b56:	f8 01 16 10 	lsr	r1,r12,0x10
80007b5a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
80007b5e:	e6 01 0d 04 	divu	r4,r3,r1
80007b62:	e4 03 16 10 	lsr	r3,r2,0x10
80007b66:	08 9e       	mov	lr,r4
80007b68:	e7 e5 11 03 	or	r3,r3,r5<<0x10
80007b6c:	e8 06 02 48 	mul	r8,r4,r6
80007b70:	10 33       	cp.w	r3,r8
80007b72:	c0 a2       	brcc	80007b86 <__avr32_udiv64+0x1fe>
80007b74:	20 1e       	sub	lr,1
80007b76:	18 03       	add	r3,r12
80007b78:	18 33       	cp.w	r3,r12
80007b7a:	c0 63       	brcs	80007b86 <__avr32_udiv64+0x1fe>
80007b7c:	10 33       	cp.w	r3,r8
80007b7e:	f7 be 03 01 	sublo	lr,1
80007b82:	e7 dc e3 03 	addcs	r3,r3,r12
80007b86:	10 13       	sub	r3,r8
80007b88:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
80007b8c:	e6 01 0d 00 	divu	r0,r3,r1
80007b90:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80007b94:	00 98       	mov	r8,r0
80007b96:	e0 06 02 46 	mul	r6,r0,r6
80007b9a:	0c 3b       	cp.w	r11,r6
80007b9c:	c0 a2       	brcc	80007bb0 <__avr32_udiv64+0x228>
80007b9e:	20 18       	sub	r8,1
80007ba0:	18 0b       	add	r11,r12
80007ba2:	18 3b       	cp.w	r11,r12
80007ba4:	c0 63       	brcs	80007bb0 <__avr32_udiv64+0x228>
80007ba6:	0c 3b       	cp.w	r11,r6
80007ba8:	f7 dc e3 0b 	addcs	r11,r11,r12
80007bac:	f7 b8 03 01 	sublo	r8,1
80007bb0:	f1 ee 11 08 	or	r8,r8,lr<<0x10
80007bb4:	ee f4 ff f4 	ld.w	r4,r7[-12]
80007bb8:	0c 1b       	sub	r11,r6
80007bba:	f0 04 06 42 	mulu.d	r2,r8,r4
80007bbe:	06 95       	mov	r5,r3
80007bc0:	16 35       	cp.w	r5,r11
80007bc2:	e0 8b 00 0a 	brhi	80007bd6 <__avr32_udiv64+0x24e>
80007bc6:	5f 0b       	sreq	r11
80007bc8:	f4 09 09 49 	lsl	r9,r10,r9
80007bcc:	12 32       	cp.w	r2,r9
80007bce:	5f b9       	srhi	r9
80007bd0:	f7 e9 00 09 	and	r9,r11,r9
80007bd4:	c0 60       	breq	80007be0 <__avr32_udiv64+0x258>
80007bd6:	20 18       	sub	r8,1
80007bd8:	30 09       	mov	r9,0
80007bda:	c0 38       	rjmp	80007be0 <__avr32_udiv64+0x258>
80007bdc:	30 09       	mov	r9,0
80007bde:	12 98       	mov	r8,r9
80007be0:	10 9a       	mov	r10,r8
80007be2:	12 93       	mov	r3,r9
80007be4:	10 92       	mov	r2,r8
80007be6:	12 9b       	mov	r11,r9
80007be8:	2f dd       	sub	sp,-12
80007bea:	d8 32       	popm	r0-r7,pc

80007bec <free>:
80007bec:	d4 01       	pushm	lr
80007bee:	e0 68 05 34 	mov	r8,1332
80007bf2:	18 9b       	mov	r11,r12
80007bf4:	70 0c       	ld.w	r12,r8[0x0]
80007bf6:	e0 a0 1e 73 	rcall	8000b8dc <_free_r>
80007bfa:	d8 02       	popm	pc

80007bfc <malloc>:
80007bfc:	d4 01       	pushm	lr
80007bfe:	e0 68 05 34 	mov	r8,1332
80007c02:	18 9b       	mov	r11,r12
80007c04:	70 0c       	ld.w	r12,r8[0x0]
80007c06:	c0 3c       	rcall	80007c0c <_malloc_r>
80007c08:	d8 02       	popm	pc
80007c0a:	d7 03       	nop

80007c0c <_malloc_r>:
80007c0c:	d4 31       	pushm	r0-r7,lr
80007c0e:	f6 c8 ff f5 	sub	r8,r11,-11
80007c12:	18 95       	mov	r5,r12
80007c14:	10 97       	mov	r7,r8
80007c16:	e0 17 ff f8 	andl	r7,0xfff8
80007c1a:	59 68       	cp.w	r8,22
80007c1c:	f9 b7 08 10 	movls	r7,16
80007c20:	16 37       	cp.w	r7,r11
80007c22:	5f 38       	srlo	r8
80007c24:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80007c28:	c0 50       	breq	80007c32 <_malloc_r+0x26>
80007c2a:	30 c8       	mov	r8,12
80007c2c:	99 38       	st.w	r12[0xc],r8
80007c2e:	e0 8f 01 f4 	bral	80008016 <_malloc_r+0x40a>
80007c32:	fe b0 f1 61 	rcall	80005ef4 <__malloc_lock>
80007c36:	e0 47 01 f7 	cp.w	r7,503
80007c3a:	e0 8b 00 1c 	brhi	80007c72 <_malloc_r+0x66>
80007c3e:	ee 03 16 03 	lsr	r3,r7,0x3
80007c42:	33 48       	mov	r8,52
80007c44:	f0 03 00 38 	add	r8,r8,r3<<0x3
80007c48:	70 36       	ld.w	r6,r8[0xc]
80007c4a:	10 36       	cp.w	r6,r8
80007c4c:	c0 61       	brne	80007c58 <_malloc_r+0x4c>
80007c4e:	ec c8 ff f8 	sub	r8,r6,-8
80007c52:	70 36       	ld.w	r6,r8[0xc]
80007c54:	10 36       	cp.w	r6,r8
80007c56:	c0 c0       	breq	80007c6e <_malloc_r+0x62>
80007c58:	6c 18       	ld.w	r8,r6[0x4]
80007c5a:	e0 18 ff fc 	andl	r8,0xfffc
80007c5e:	6c 3a       	ld.w	r10,r6[0xc]
80007c60:	ec 08 00 09 	add	r9,r6,r8
80007c64:	0a 9c       	mov	r12,r5
80007c66:	6c 28       	ld.w	r8,r6[0x8]
80007c68:	95 28       	st.w	r10[0x8],r8
80007c6a:	91 3a       	st.w	r8[0xc],r10
80007c6c:	c4 68       	rjmp	80007cf8 <_malloc_r+0xec>
80007c6e:	2f e3       	sub	r3,-2
80007c70:	c4 c8       	rjmp	80007d08 <_malloc_r+0xfc>
80007c72:	ee 03 16 09 	lsr	r3,r7,0x9
80007c76:	c0 41       	brne	80007c7e <_malloc_r+0x72>
80007c78:	ee 03 16 03 	lsr	r3,r7,0x3
80007c7c:	c2 68       	rjmp	80007cc8 <_malloc_r+0xbc>
80007c7e:	58 43       	cp.w	r3,4
80007c80:	e0 8b 00 06 	brhi	80007c8c <_malloc_r+0x80>
80007c84:	ee 03 16 06 	lsr	r3,r7,0x6
80007c88:	2c 83       	sub	r3,-56
80007c8a:	c1 f8       	rjmp	80007cc8 <_malloc_r+0xbc>
80007c8c:	59 43       	cp.w	r3,20
80007c8e:	e0 8b 00 04 	brhi	80007c96 <_malloc_r+0x8a>
80007c92:	2a 53       	sub	r3,-91
80007c94:	c1 a8       	rjmp	80007cc8 <_malloc_r+0xbc>
80007c96:	e0 43 00 54 	cp.w	r3,84
80007c9a:	e0 8b 00 06 	brhi	80007ca6 <_malloc_r+0x9a>
80007c9e:	ee 03 16 0c 	lsr	r3,r7,0xc
80007ca2:	29 23       	sub	r3,-110
80007ca4:	c1 28       	rjmp	80007cc8 <_malloc_r+0xbc>
80007ca6:	e0 43 01 54 	cp.w	r3,340
80007caa:	e0 8b 00 06 	brhi	80007cb6 <_malloc_r+0xaa>
80007cae:	ee 03 16 0f 	lsr	r3,r7,0xf
80007cb2:	28 93       	sub	r3,-119
80007cb4:	c0 a8       	rjmp	80007cc8 <_malloc_r+0xbc>
80007cb6:	e0 43 05 54 	cp.w	r3,1364
80007cba:	e0 88 00 04 	brls	80007cc2 <_malloc_r+0xb6>
80007cbe:	37 e3       	mov	r3,126
80007cc0:	c0 48       	rjmp	80007cc8 <_malloc_r+0xbc>
80007cc2:	ee 03 16 12 	lsr	r3,r7,0x12
80007cc6:	28 43       	sub	r3,-124
80007cc8:	33 4a       	mov	r10,52
80007cca:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80007cce:	74 36       	ld.w	r6,r10[0xc]
80007cd0:	c1 98       	rjmp	80007d02 <_malloc_r+0xf6>
80007cd2:	6c 19       	ld.w	r9,r6[0x4]
80007cd4:	e0 19 ff fc 	andl	r9,0xfffc
80007cd8:	f2 07 01 0b 	sub	r11,r9,r7
80007cdc:	58 fb       	cp.w	r11,15
80007cde:	e0 8a 00 04 	brle	80007ce6 <_malloc_r+0xda>
80007ce2:	20 13       	sub	r3,1
80007ce4:	c1 18       	rjmp	80007d06 <_malloc_r+0xfa>
80007ce6:	6c 38       	ld.w	r8,r6[0xc]
80007ce8:	58 0b       	cp.w	r11,0
80007cea:	c0 b5       	brlt	80007d00 <_malloc_r+0xf4>
80007cec:	6c 2a       	ld.w	r10,r6[0x8]
80007cee:	ec 09 00 09 	add	r9,r6,r9
80007cf2:	0a 9c       	mov	r12,r5
80007cf4:	91 2a       	st.w	r8[0x8],r10
80007cf6:	95 38       	st.w	r10[0xc],r8
80007cf8:	72 18       	ld.w	r8,r9[0x4]
80007cfa:	a1 a8       	sbr	r8,0x0
80007cfc:	93 18       	st.w	r9[0x4],r8
80007cfe:	cb 88       	rjmp	80007e6e <_malloc_r+0x262>
80007d00:	10 96       	mov	r6,r8
80007d02:	14 36       	cp.w	r6,r10
80007d04:	ce 71       	brne	80007cd2 <_malloc_r+0xc6>
80007d06:	2f f3       	sub	r3,-1
80007d08:	33 4a       	mov	r10,52
80007d0a:	f4 cc ff f8 	sub	r12,r10,-8
80007d0e:	78 26       	ld.w	r6,r12[0x8]
80007d10:	18 36       	cp.w	r6,r12
80007d12:	c6 a0       	breq	80007de6 <_malloc_r+0x1da>
80007d14:	6c 19       	ld.w	r9,r6[0x4]
80007d16:	e0 19 ff fc 	andl	r9,0xfffc
80007d1a:	f2 07 01 08 	sub	r8,r9,r7
80007d1e:	58 f8       	cp.w	r8,15
80007d20:	e0 89 00 8c 	brgt	80007e38 <_malloc_r+0x22c>
80007d24:	99 3c       	st.w	r12[0xc],r12
80007d26:	99 2c       	st.w	r12[0x8],r12
80007d28:	58 08       	cp.w	r8,0
80007d2a:	c0 55       	brlt	80007d34 <_malloc_r+0x128>
80007d2c:	ec 09 00 09 	add	r9,r6,r9
80007d30:	0a 9c       	mov	r12,r5
80007d32:	ce 3b       	rjmp	80007cf8 <_malloc_r+0xec>
80007d34:	e0 49 01 ff 	cp.w	r9,511
80007d38:	e0 8b 00 13 	brhi	80007d5e <_malloc_r+0x152>
80007d3c:	a3 99       	lsr	r9,0x3
80007d3e:	f4 09 00 38 	add	r8,r10,r9<<0x3
80007d42:	70 2b       	ld.w	r11,r8[0x8]
80007d44:	8d 38       	st.w	r6[0xc],r8
80007d46:	8d 2b       	st.w	r6[0x8],r11
80007d48:	97 36       	st.w	r11[0xc],r6
80007d4a:	91 26       	st.w	r8[0x8],r6
80007d4c:	a3 49       	asr	r9,0x2
80007d4e:	74 18       	ld.w	r8,r10[0x4]
80007d50:	30 1b       	mov	r11,1
80007d52:	f6 09 09 49 	lsl	r9,r11,r9
80007d56:	f1 e9 10 09 	or	r9,r8,r9
80007d5a:	95 19       	st.w	r10[0x4],r9
80007d5c:	c4 58       	rjmp	80007de6 <_malloc_r+0x1da>
80007d5e:	f2 0a 16 09 	lsr	r10,r9,0x9
80007d62:	58 4a       	cp.w	r10,4
80007d64:	e0 8b 00 06 	brhi	80007d70 <_malloc_r+0x164>
80007d68:	f2 0a 16 06 	lsr	r10,r9,0x6
80007d6c:	2c 8a       	sub	r10,-56
80007d6e:	c1 f8       	rjmp	80007dac <_malloc_r+0x1a0>
80007d70:	59 4a       	cp.w	r10,20
80007d72:	e0 8b 00 04 	brhi	80007d7a <_malloc_r+0x16e>
80007d76:	2a 5a       	sub	r10,-91
80007d78:	c1 a8       	rjmp	80007dac <_malloc_r+0x1a0>
80007d7a:	e0 4a 00 54 	cp.w	r10,84
80007d7e:	e0 8b 00 06 	brhi	80007d8a <_malloc_r+0x17e>
80007d82:	f2 0a 16 0c 	lsr	r10,r9,0xc
80007d86:	29 2a       	sub	r10,-110
80007d88:	c1 28       	rjmp	80007dac <_malloc_r+0x1a0>
80007d8a:	e0 4a 01 54 	cp.w	r10,340
80007d8e:	e0 8b 00 06 	brhi	80007d9a <_malloc_r+0x18e>
80007d92:	f2 0a 16 0f 	lsr	r10,r9,0xf
80007d96:	28 9a       	sub	r10,-119
80007d98:	c0 a8       	rjmp	80007dac <_malloc_r+0x1a0>
80007d9a:	e0 4a 05 54 	cp.w	r10,1364
80007d9e:	e0 88 00 04 	brls	80007da6 <_malloc_r+0x19a>
80007da2:	37 ea       	mov	r10,126
80007da4:	c0 48       	rjmp	80007dac <_malloc_r+0x1a0>
80007da6:	f2 0a 16 12 	lsr	r10,r9,0x12
80007daa:	28 4a       	sub	r10,-124
80007dac:	33 4b       	mov	r11,52
80007dae:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80007db2:	68 28       	ld.w	r8,r4[0x8]
80007db4:	08 38       	cp.w	r8,r4
80007db6:	c0 e1       	brne	80007dd2 <_malloc_r+0x1c6>
80007db8:	76 19       	ld.w	r9,r11[0x4]
80007dba:	a3 4a       	asr	r10,0x2
80007dbc:	30 1e       	mov	lr,1
80007dbe:	fc 0a 09 4a 	lsl	r10,lr,r10
80007dc2:	f3 ea 10 0a 	or	r10,r9,r10
80007dc6:	10 99       	mov	r9,r8
80007dc8:	97 1a       	st.w	r11[0x4],r10
80007dca:	c0 a8       	rjmp	80007dde <_malloc_r+0x1d2>
80007dcc:	70 28       	ld.w	r8,r8[0x8]
80007dce:	08 38       	cp.w	r8,r4
80007dd0:	c0 60       	breq	80007ddc <_malloc_r+0x1d0>
80007dd2:	70 1a       	ld.w	r10,r8[0x4]
80007dd4:	e0 1a ff fc 	andl	r10,0xfffc
80007dd8:	14 39       	cp.w	r9,r10
80007dda:	cf 93       	brcs	80007dcc <_malloc_r+0x1c0>
80007ddc:	70 39       	ld.w	r9,r8[0xc]
80007dde:	8d 39       	st.w	r6[0xc],r9
80007de0:	8d 28       	st.w	r6[0x8],r8
80007de2:	91 36       	st.w	r8[0xc],r6
80007de4:	93 26       	st.w	r9[0x8],r6
80007de6:	e6 08 14 02 	asr	r8,r3,0x2
80007dea:	30 1b       	mov	r11,1
80007dec:	33 44       	mov	r4,52
80007dee:	f6 08 09 4b 	lsl	r11,r11,r8
80007df2:	68 18       	ld.w	r8,r4[0x4]
80007df4:	10 3b       	cp.w	r11,r8
80007df6:	e0 8b 00 6b 	brhi	80007ecc <_malloc_r+0x2c0>
80007dfa:	f7 e8 00 09 	and	r9,r11,r8
80007dfe:	c0 b1       	brne	80007e14 <_malloc_r+0x208>
80007e00:	e0 13 ff fc 	andl	r3,0xfffc
80007e04:	a1 7b       	lsl	r11,0x1
80007e06:	2f c3       	sub	r3,-4
80007e08:	c0 38       	rjmp	80007e0e <_malloc_r+0x202>
80007e0a:	2f c3       	sub	r3,-4
80007e0c:	a1 7b       	lsl	r11,0x1
80007e0e:	f7 e8 00 09 	and	r9,r11,r8
80007e12:	cf c0       	breq	80007e0a <_malloc_r+0x1fe>
80007e14:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80007e18:	06 92       	mov	r2,r3
80007e1a:	1c 91       	mov	r1,lr
80007e1c:	62 36       	ld.w	r6,r1[0xc]
80007e1e:	c2 e8       	rjmp	80007e7a <_malloc_r+0x26e>
80007e20:	6c 1a       	ld.w	r10,r6[0x4]
80007e22:	e0 1a ff fc 	andl	r10,0xfffc
80007e26:	f4 07 01 08 	sub	r8,r10,r7
80007e2a:	58 f8       	cp.w	r8,15
80007e2c:	e0 8a 00 15 	brle	80007e56 <_malloc_r+0x24a>
80007e30:	6c 3a       	ld.w	r10,r6[0xc]
80007e32:	6c 29       	ld.w	r9,r6[0x8]
80007e34:	95 29       	st.w	r10[0x8],r9
80007e36:	93 3a       	st.w	r9[0xc],r10
80007e38:	0e 99       	mov	r9,r7
80007e3a:	ec 07 00 07 	add	r7,r6,r7
80007e3e:	a1 a9       	sbr	r9,0x0
80007e40:	99 37       	st.w	r12[0xc],r7
80007e42:	99 27       	st.w	r12[0x8],r7
80007e44:	8d 19       	st.w	r6[0x4],r9
80007e46:	ee 08 09 08 	st.w	r7[r8],r8
80007e4a:	8f 2c       	st.w	r7[0x8],r12
80007e4c:	8f 3c       	st.w	r7[0xc],r12
80007e4e:	a1 a8       	sbr	r8,0x0
80007e50:	0a 9c       	mov	r12,r5
80007e52:	8f 18       	st.w	r7[0x4],r8
80007e54:	c0 d8       	rjmp	80007e6e <_malloc_r+0x262>
80007e56:	6c 39       	ld.w	r9,r6[0xc]
80007e58:	58 08       	cp.w	r8,0
80007e5a:	c0 f5       	brlt	80007e78 <_malloc_r+0x26c>
80007e5c:	ec 0a 00 0a 	add	r10,r6,r10
80007e60:	74 18       	ld.w	r8,r10[0x4]
80007e62:	a1 a8       	sbr	r8,0x0
80007e64:	0a 9c       	mov	r12,r5
80007e66:	95 18       	st.w	r10[0x4],r8
80007e68:	6c 28       	ld.w	r8,r6[0x8]
80007e6a:	93 28       	st.w	r9[0x8],r8
80007e6c:	91 39       	st.w	r8[0xc],r9
80007e6e:	fe b0 f0 49 	rcall	80005f00 <__malloc_unlock>
80007e72:	ec cc ff f8 	sub	r12,r6,-8
80007e76:	d8 32       	popm	r0-r7,pc
80007e78:	12 96       	mov	r6,r9
80007e7a:	02 36       	cp.w	r6,r1
80007e7c:	cd 21       	brne	80007e20 <_malloc_r+0x214>
80007e7e:	2f f2       	sub	r2,-1
80007e80:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80007e84:	c0 30       	breq	80007e8a <_malloc_r+0x27e>
80007e86:	2f 81       	sub	r1,-8
80007e88:	cc ab       	rjmp	80007e1c <_malloc_r+0x210>
80007e8a:	1c 98       	mov	r8,lr
80007e8c:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80007e90:	c0 81       	brne	80007ea0 <_malloc_r+0x294>
80007e92:	68 19       	ld.w	r9,r4[0x4]
80007e94:	f6 08 11 ff 	rsub	r8,r11,-1
80007e98:	f3 e8 00 08 	and	r8,r9,r8
80007e9c:	89 18       	st.w	r4[0x4],r8
80007e9e:	c0 78       	rjmp	80007eac <_malloc_r+0x2a0>
80007ea0:	f0 c9 00 08 	sub	r9,r8,8
80007ea4:	20 13       	sub	r3,1
80007ea6:	70 08       	ld.w	r8,r8[0x0]
80007ea8:	12 38       	cp.w	r8,r9
80007eaa:	cf 10       	breq	80007e8c <_malloc_r+0x280>
80007eac:	a1 7b       	lsl	r11,0x1
80007eae:	68 18       	ld.w	r8,r4[0x4]
80007eb0:	10 3b       	cp.w	r11,r8
80007eb2:	e0 8b 00 0d 	brhi	80007ecc <_malloc_r+0x2c0>
80007eb6:	58 0b       	cp.w	r11,0
80007eb8:	c0 a0       	breq	80007ecc <_malloc_r+0x2c0>
80007eba:	04 93       	mov	r3,r2
80007ebc:	c0 38       	rjmp	80007ec2 <_malloc_r+0x2b6>
80007ebe:	2f c3       	sub	r3,-4
80007ec0:	a1 7b       	lsl	r11,0x1
80007ec2:	f7 e8 00 09 	and	r9,r11,r8
80007ec6:	ca 71       	brne	80007e14 <_malloc_r+0x208>
80007ec8:	cf bb       	rjmp	80007ebe <_malloc_r+0x2b2>
80007eca:	d7 03       	nop
80007ecc:	68 23       	ld.w	r3,r4[0x8]
80007ece:	66 12       	ld.w	r2,r3[0x4]
80007ed0:	e0 12 ff fc 	andl	r2,0xfffc
80007ed4:	0e 32       	cp.w	r2,r7
80007ed6:	5f 39       	srlo	r9
80007ed8:	e4 07 01 08 	sub	r8,r2,r7
80007edc:	58 f8       	cp.w	r8,15
80007ede:	5f aa       	srle	r10
80007ee0:	f5 e9 10 09 	or	r9,r10,r9
80007ee4:	e0 80 00 9a 	breq	80008018 <_malloc_r+0x40c>
80007ee8:	e0 68 07 dc 	mov	r8,2012
80007eec:	70 01       	ld.w	r1,r8[0x0]
80007eee:	e0 68 04 40 	mov	r8,1088
80007ef2:	2f 01       	sub	r1,-16
80007ef4:	70 08       	ld.w	r8,r8[0x0]
80007ef6:	0e 01       	add	r1,r7
80007ef8:	5b f8       	cp.w	r8,-1
80007efa:	c0 40       	breq	80007f02 <_malloc_r+0x2f6>
80007efc:	28 11       	sub	r1,-127
80007efe:	e0 11 ff 80 	andl	r1,0xff80
80007f02:	02 9b       	mov	r11,r1
80007f04:	0a 9c       	mov	r12,r5
80007f06:	e0 a0 02 a5 	rcall	80008450 <_sbrk_r>
80007f0a:	18 96       	mov	r6,r12
80007f0c:	5b fc       	cp.w	r12,-1
80007f0e:	c7 50       	breq	80007ff8 <_malloc_r+0x3ec>
80007f10:	e6 02 00 08 	add	r8,r3,r2
80007f14:	10 3c       	cp.w	r12,r8
80007f16:	c0 32       	brcc	80007f1c <_malloc_r+0x310>
80007f18:	08 33       	cp.w	r3,r4
80007f1a:	c6 f1       	brne	80007ff8 <_malloc_r+0x3ec>
80007f1c:	e0 6a 07 e0 	mov	r10,2016
80007f20:	74 09       	ld.w	r9,r10[0x0]
80007f22:	e2 09 00 09 	add	r9,r1,r9
80007f26:	95 09       	st.w	r10[0x0],r9
80007f28:	10 36       	cp.w	r6,r8
80007f2a:	c0 a1       	brne	80007f3e <_malloc_r+0x332>
80007f2c:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80007f30:	c0 71       	brne	80007f3e <_malloc_r+0x332>
80007f32:	e2 02 00 02 	add	r2,r1,r2
80007f36:	68 28       	ld.w	r8,r4[0x8]
80007f38:	a1 a2       	sbr	r2,0x0
80007f3a:	91 12       	st.w	r8[0x4],r2
80007f3c:	c4 f8       	rjmp	80007fda <_malloc_r+0x3ce>
80007f3e:	e0 6a 04 40 	mov	r10,1088
80007f42:	74 0b       	ld.w	r11,r10[0x0]
80007f44:	5b fb       	cp.w	r11,-1
80007f46:	c0 31       	brne	80007f4c <_malloc_r+0x340>
80007f48:	95 06       	st.w	r10[0x0],r6
80007f4a:	c0 78       	rjmp	80007f58 <_malloc_r+0x34c>
80007f4c:	ec 09 00 09 	add	r9,r6,r9
80007f50:	e0 6a 07 e0 	mov	r10,2016
80007f54:	10 19       	sub	r9,r8
80007f56:	95 09       	st.w	r10[0x0],r9
80007f58:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80007f5c:	f0 09 11 08 	rsub	r9,r8,8
80007f60:	58 08       	cp.w	r8,0
80007f62:	f2 08 17 10 	movne	r8,r9
80007f66:	ed d8 e1 06 	addne	r6,r6,r8
80007f6a:	28 08       	sub	r8,-128
80007f6c:	ec 01 00 01 	add	r1,r6,r1
80007f70:	0a 9c       	mov	r12,r5
80007f72:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80007f76:	f0 01 01 01 	sub	r1,r8,r1
80007f7a:	02 9b       	mov	r11,r1
80007f7c:	e0 a0 02 6a 	rcall	80008450 <_sbrk_r>
80007f80:	e0 68 07 e0 	mov	r8,2016
80007f84:	5b fc       	cp.w	r12,-1
80007f86:	ec 0c 17 00 	moveq	r12,r6
80007f8a:	f9 b1 00 00 	moveq	r1,0
80007f8e:	70 09       	ld.w	r9,r8[0x0]
80007f90:	0c 1c       	sub	r12,r6
80007f92:	89 26       	st.w	r4[0x8],r6
80007f94:	02 0c       	add	r12,r1
80007f96:	12 01       	add	r1,r9
80007f98:	a1 ac       	sbr	r12,0x0
80007f9a:	91 01       	st.w	r8[0x0],r1
80007f9c:	8d 1c       	st.w	r6[0x4],r12
80007f9e:	08 33       	cp.w	r3,r4
80007fa0:	c1 d0       	breq	80007fda <_malloc_r+0x3ce>
80007fa2:	58 f2       	cp.w	r2,15
80007fa4:	e0 8b 00 05 	brhi	80007fae <_malloc_r+0x3a2>
80007fa8:	30 18       	mov	r8,1
80007faa:	8d 18       	st.w	r6[0x4],r8
80007fac:	c2 68       	rjmp	80007ff8 <_malloc_r+0x3ec>
80007fae:	30 59       	mov	r9,5
80007fb0:	20 c2       	sub	r2,12
80007fb2:	e0 12 ff f8 	andl	r2,0xfff8
80007fb6:	e6 02 00 08 	add	r8,r3,r2
80007fba:	91 29       	st.w	r8[0x8],r9
80007fbc:	91 19       	st.w	r8[0x4],r9
80007fbe:	66 18       	ld.w	r8,r3[0x4]
80007fc0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007fc4:	e5 e8 10 08 	or	r8,r2,r8
80007fc8:	87 18       	st.w	r3[0x4],r8
80007fca:	58 f2       	cp.w	r2,15
80007fcc:	e0 88 00 07 	brls	80007fda <_malloc_r+0x3ce>
80007fd0:	e6 cb ff f8 	sub	r11,r3,-8
80007fd4:	0a 9c       	mov	r12,r5
80007fd6:	e0 a0 1c 83 	rcall	8000b8dc <_free_r>
80007fda:	e0 69 07 d8 	mov	r9,2008
80007fde:	72 0a       	ld.w	r10,r9[0x0]
80007fe0:	e0 68 07 e0 	mov	r8,2016
80007fe4:	70 08       	ld.w	r8,r8[0x0]
80007fe6:	14 38       	cp.w	r8,r10
80007fe8:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007fec:	e0 69 07 d4 	mov	r9,2004
80007ff0:	72 0a       	ld.w	r10,r9[0x0]
80007ff2:	14 38       	cp.w	r8,r10
80007ff4:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007ff8:	68 28       	ld.w	r8,r4[0x8]
80007ffa:	70 18       	ld.w	r8,r8[0x4]
80007ffc:	e0 18 ff fc 	andl	r8,0xfffc
80008000:	0e 38       	cp.w	r8,r7
80008002:	5f 39       	srlo	r9
80008004:	0e 18       	sub	r8,r7
80008006:	58 f8       	cp.w	r8,15
80008008:	5f aa       	srle	r10
8000800a:	f5 e9 10 09 	or	r9,r10,r9
8000800e:	c0 50       	breq	80008018 <_malloc_r+0x40c>
80008010:	0a 9c       	mov	r12,r5
80008012:	fe b0 ef 77 	rcall	80005f00 <__malloc_unlock>
80008016:	d8 3a       	popm	r0-r7,pc,r12=0
80008018:	68 26       	ld.w	r6,r4[0x8]
8000801a:	a1 a8       	sbr	r8,0x0
8000801c:	0e 99       	mov	r9,r7
8000801e:	a1 a9       	sbr	r9,0x0
80008020:	8d 19       	st.w	r6[0x4],r9
80008022:	ec 07 00 07 	add	r7,r6,r7
80008026:	0a 9c       	mov	r12,r5
80008028:	89 27       	st.w	r4[0x8],r7
8000802a:	8f 18       	st.w	r7[0x4],r8
8000802c:	fe b0 ef 6a 	rcall	80005f00 <__malloc_unlock>
80008030:	ec cc ff f8 	sub	r12,r6,-8
80008034:	d8 32       	popm	r0-r7,pc
80008036:	d7 03       	nop

80008038 <memcpy>:
80008038:	58 8a       	cp.w	r10,8
8000803a:	c2 f5       	brlt	80008098 <memcpy+0x60>
8000803c:	f9 eb 10 09 	or	r9,r12,r11
80008040:	e2 19 00 03 	andl	r9,0x3,COH
80008044:	e0 81 00 97 	brne	80008172 <memcpy+0x13a>
80008048:	e0 4a 00 20 	cp.w	r10,32
8000804c:	c3 b4       	brge	800080c2 <memcpy+0x8a>
8000804e:	f4 08 14 02 	asr	r8,r10,0x2
80008052:	f0 09 11 08 	rsub	r9,r8,8
80008056:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000805a:	76 69       	ld.w	r9,r11[0x18]
8000805c:	99 69       	st.w	r12[0x18],r9
8000805e:	76 59       	ld.w	r9,r11[0x14]
80008060:	99 59       	st.w	r12[0x14],r9
80008062:	76 49       	ld.w	r9,r11[0x10]
80008064:	99 49       	st.w	r12[0x10],r9
80008066:	76 39       	ld.w	r9,r11[0xc]
80008068:	99 39       	st.w	r12[0xc],r9
8000806a:	76 29       	ld.w	r9,r11[0x8]
8000806c:	99 29       	st.w	r12[0x8],r9
8000806e:	76 19       	ld.w	r9,r11[0x4]
80008070:	99 19       	st.w	r12[0x4],r9
80008072:	76 09       	ld.w	r9,r11[0x0]
80008074:	99 09       	st.w	r12[0x0],r9
80008076:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000807a:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000807e:	e0 1a 00 03 	andl	r10,0x3
80008082:	f4 0a 11 04 	rsub	r10,r10,4
80008086:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000808a:	17 a9       	ld.ub	r9,r11[0x2]
8000808c:	b0 a9       	st.b	r8[0x2],r9
8000808e:	17 99       	ld.ub	r9,r11[0x1]
80008090:	b0 99       	st.b	r8[0x1],r9
80008092:	17 89       	ld.ub	r9,r11[0x0]
80008094:	b0 89       	st.b	r8[0x0],r9
80008096:	5e fc       	retal	r12
80008098:	f4 0a 11 09 	rsub	r10,r10,9
8000809c:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800080a0:	17 f9       	ld.ub	r9,r11[0x7]
800080a2:	b8 f9       	st.b	r12[0x7],r9
800080a4:	17 e9       	ld.ub	r9,r11[0x6]
800080a6:	b8 e9       	st.b	r12[0x6],r9
800080a8:	17 d9       	ld.ub	r9,r11[0x5]
800080aa:	b8 d9       	st.b	r12[0x5],r9
800080ac:	17 c9       	ld.ub	r9,r11[0x4]
800080ae:	b8 c9       	st.b	r12[0x4],r9
800080b0:	17 b9       	ld.ub	r9,r11[0x3]
800080b2:	b8 b9       	st.b	r12[0x3],r9
800080b4:	17 a9       	ld.ub	r9,r11[0x2]
800080b6:	b8 a9       	st.b	r12[0x2],r9
800080b8:	17 99       	ld.ub	r9,r11[0x1]
800080ba:	b8 99       	st.b	r12[0x1],r9
800080bc:	17 89       	ld.ub	r9,r11[0x0]
800080be:	b8 89       	st.b	r12[0x0],r9
800080c0:	5e fc       	retal	r12
800080c2:	eb cd 40 c0 	pushm	r6-r7,lr
800080c6:	18 99       	mov	r9,r12
800080c8:	22 0a       	sub	r10,32
800080ca:	b7 07       	ld.d	r6,r11++
800080cc:	b3 26       	st.d	r9++,r6
800080ce:	b7 07       	ld.d	r6,r11++
800080d0:	b3 26       	st.d	r9++,r6
800080d2:	b7 07       	ld.d	r6,r11++
800080d4:	b3 26       	st.d	r9++,r6
800080d6:	b7 07       	ld.d	r6,r11++
800080d8:	b3 26       	st.d	r9++,r6
800080da:	22 0a       	sub	r10,32
800080dc:	cf 74       	brge	800080ca <memcpy+0x92>
800080de:	2f 0a       	sub	r10,-16
800080e0:	c0 65       	brlt	800080ec <memcpy+0xb4>
800080e2:	b7 07       	ld.d	r6,r11++
800080e4:	b3 26       	st.d	r9++,r6
800080e6:	b7 07       	ld.d	r6,r11++
800080e8:	b3 26       	st.d	r9++,r6
800080ea:	21 0a       	sub	r10,16
800080ec:	5c 3a       	neg	r10
800080ee:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
800080f2:	d7 03       	nop
800080f4:	d7 03       	nop
800080f6:	f7 36 00 0e 	ld.ub	r6,r11[14]
800080fa:	f3 66 00 0e 	st.b	r9[14],r6
800080fe:	f7 36 00 0d 	ld.ub	r6,r11[13]
80008102:	f3 66 00 0d 	st.b	r9[13],r6
80008106:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000810a:	f3 66 00 0c 	st.b	r9[12],r6
8000810e:	f7 36 00 0b 	ld.ub	r6,r11[11]
80008112:	f3 66 00 0b 	st.b	r9[11],r6
80008116:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000811a:	f3 66 00 0a 	st.b	r9[10],r6
8000811e:	f7 36 00 09 	ld.ub	r6,r11[9]
80008122:	f3 66 00 09 	st.b	r9[9],r6
80008126:	f7 36 00 08 	ld.ub	r6,r11[8]
8000812a:	f3 66 00 08 	st.b	r9[8],r6
8000812e:	f7 36 00 07 	ld.ub	r6,r11[7]
80008132:	f3 66 00 07 	st.b	r9[7],r6
80008136:	f7 36 00 06 	ld.ub	r6,r11[6]
8000813a:	f3 66 00 06 	st.b	r9[6],r6
8000813e:	f7 36 00 05 	ld.ub	r6,r11[5]
80008142:	f3 66 00 05 	st.b	r9[5],r6
80008146:	f7 36 00 04 	ld.ub	r6,r11[4]
8000814a:	f3 66 00 04 	st.b	r9[4],r6
8000814e:	f7 36 00 03 	ld.ub	r6,r11[3]
80008152:	f3 66 00 03 	st.b	r9[3],r6
80008156:	f7 36 00 02 	ld.ub	r6,r11[2]
8000815a:	f3 66 00 02 	st.b	r9[2],r6
8000815e:	f7 36 00 01 	ld.ub	r6,r11[1]
80008162:	f3 66 00 01 	st.b	r9[1],r6
80008166:	f7 36 00 00 	ld.ub	r6,r11[0]
8000816a:	f3 66 00 00 	st.b	r9[0],r6
8000816e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80008172:	20 1a       	sub	r10,1
80008174:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80008178:	f8 0a 0b 09 	st.b	r12[r10],r9
8000817c:	cf b1       	brne	80008172 <memcpy+0x13a>
8000817e:	5e fc       	retal	r12

80008180 <memset>:
80008180:	18 98       	mov	r8,r12
80008182:	c0 38       	rjmp	80008188 <memset+0x8>
80008184:	10 cb       	st.b	r8++,r11
80008186:	20 1a       	sub	r10,1
80008188:	58 0a       	cp.w	r10,0
8000818a:	cf d1       	brne	80008184 <memset+0x4>
8000818c:	5e fc       	retal	r12
8000818e:	d7 03       	nop

80008190 <_realloc_r>:
80008190:	d4 31       	pushm	r0-r7,lr
80008192:	20 1d       	sub	sp,4
80008194:	16 94       	mov	r4,r11
80008196:	18 92       	mov	r2,r12
80008198:	14 9b       	mov	r11,r10
8000819a:	58 04       	cp.w	r4,0
8000819c:	c0 51       	brne	800081a6 <_realloc_r+0x16>
8000819e:	fe b0 fd 37 	rcall	80007c0c <_malloc_r>
800081a2:	18 95       	mov	r5,r12
800081a4:	c5 39       	rjmp	8000844a <_realloc_r+0x2ba>
800081a6:	50 0a       	stdsp	sp[0x0],r10
800081a8:	fe b0 ee a6 	rcall	80005ef4 <__malloc_lock>
800081ac:	40 0b       	lddsp	r11,sp[0x0]
800081ae:	f6 c8 ff f5 	sub	r8,r11,-11
800081b2:	e8 c1 00 08 	sub	r1,r4,8
800081b6:	10 96       	mov	r6,r8
800081b8:	62 1c       	ld.w	r12,r1[0x4]
800081ba:	e0 16 ff f8 	andl	r6,0xfff8
800081be:	59 68       	cp.w	r8,22
800081c0:	f9 b6 08 10 	movls	r6,16
800081c4:	16 36       	cp.w	r6,r11
800081c6:	5f 38       	srlo	r8
800081c8:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
800081cc:	c0 50       	breq	800081d6 <_realloc_r+0x46>
800081ce:	30 c8       	mov	r8,12
800081d0:	30 05       	mov	r5,0
800081d2:	85 38       	st.w	r2[0xc],r8
800081d4:	c3 b9       	rjmp	8000844a <_realloc_r+0x2ba>
800081d6:	18 90       	mov	r0,r12
800081d8:	e0 10 ff fc 	andl	r0,0xfffc
800081dc:	0c 30       	cp.w	r0,r6
800081de:	e0 84 01 0b 	brge	800083f4 <_realloc_r+0x264>
800081e2:	33 48       	mov	r8,52
800081e4:	e2 00 00 09 	add	r9,r1,r0
800081e8:	70 25       	ld.w	r5,r8[0x8]
800081ea:	0a 39       	cp.w	r9,r5
800081ec:	c0 90       	breq	800081fe <_realloc_r+0x6e>
800081ee:	72 1a       	ld.w	r10,r9[0x4]
800081f0:	a1 ca       	cbr	r10,0x0
800081f2:	f2 0a 00 0a 	add	r10,r9,r10
800081f6:	74 1a       	ld.w	r10,r10[0x4]
800081f8:	ed ba 00 00 	bld	r10,0x0
800081fc:	c2 20       	breq	80008240 <_realloc_r+0xb0>
800081fe:	72 1a       	ld.w	r10,r9[0x4]
80008200:	e0 1a ff fc 	andl	r10,0xfffc
80008204:	f4 00 00 03 	add	r3,r10,r0
80008208:	0a 39       	cp.w	r9,r5
8000820a:	c1 31       	brne	80008230 <_realloc_r+0xa0>
8000820c:	ec c7 ff f0 	sub	r7,r6,-16
80008210:	0e 33       	cp.w	r3,r7
80008212:	c1 95       	brlt	80008244 <_realloc_r+0xb4>
80008214:	e2 06 00 09 	add	r9,r1,r6
80008218:	0c 13       	sub	r3,r6
8000821a:	a1 a3       	sbr	r3,0x0
8000821c:	93 13       	st.w	r9[0x4],r3
8000821e:	91 29       	st.w	r8[0x8],r9
80008220:	04 9c       	mov	r12,r2
80008222:	62 18       	ld.w	r8,r1[0x4]
80008224:	08 95       	mov	r5,r4
80008226:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000822a:	10 46       	or	r6,r8
8000822c:	83 16       	st.w	r1[0x4],r6
8000822e:	c0 c9       	rjmp	80008446 <_realloc_r+0x2b6>
80008230:	0c 33       	cp.w	r3,r6
80008232:	c0 95       	brlt	80008244 <_realloc_r+0xb4>
80008234:	72 28       	ld.w	r8,r9[0x8]
80008236:	02 97       	mov	r7,r1
80008238:	72 39       	ld.w	r9,r9[0xc]
8000823a:	93 28       	st.w	r9[0x8],r8
8000823c:	91 39       	st.w	r8[0xc],r9
8000823e:	cd d8       	rjmp	800083f8 <_realloc_r+0x268>
80008240:	30 0a       	mov	r10,0
80008242:	14 99       	mov	r9,r10
80008244:	ed bc 00 00 	bld	r12,0x0
80008248:	e0 80 00 96 	breq	80008374 <_realloc_r+0x1e4>
8000824c:	62 07       	ld.w	r7,r1[0x0]
8000824e:	e2 07 01 07 	sub	r7,r1,r7
80008252:	6e 1c       	ld.w	r12,r7[0x4]
80008254:	e0 1c ff fc 	andl	r12,0xfffc
80008258:	58 09       	cp.w	r9,0
8000825a:	c5 70       	breq	80008308 <_realloc_r+0x178>
8000825c:	f8 00 00 03 	add	r3,r12,r0
80008260:	0a 39       	cp.w	r9,r5
80008262:	c4 81       	brne	800082f2 <_realloc_r+0x162>
80008264:	14 03       	add	r3,r10
80008266:	ec c9 ff f0 	sub	r9,r6,-16
8000826a:	12 33       	cp.w	r3,r9
8000826c:	c4 e5       	brlt	80008308 <_realloc_r+0x178>
8000826e:	6e 3a       	ld.w	r10,r7[0xc]
80008270:	6e 29       	ld.w	r9,r7[0x8]
80008272:	95 29       	st.w	r10[0x8],r9
80008274:	93 3a       	st.w	r9[0xc],r10
80008276:	ee c5 ff f8 	sub	r5,r7,-8
8000827a:	e0 ca 00 04 	sub	r10,r0,4
8000827e:	e0 4a 00 24 	cp.w	r10,36
80008282:	e0 8b 00 25 	brhi	800082cc <_realloc_r+0x13c>
80008286:	0a 99       	mov	r9,r5
80008288:	59 3a       	cp.w	r10,19
8000828a:	e0 88 00 1a 	brls	800082be <_realloc_r+0x12e>
8000828e:	09 09       	ld.w	r9,r4++
80008290:	8b 09       	st.w	r5[0x0],r9
80008292:	09 09       	ld.w	r9,r4++
80008294:	8f 39       	st.w	r7[0xc],r9
80008296:	ee c9 ff f0 	sub	r9,r7,-16
8000829a:	59 ba       	cp.w	r10,27
8000829c:	e0 88 00 11 	brls	800082be <_realloc_r+0x12e>
800082a0:	09 0b       	ld.w	r11,r4++
800082a2:	93 0b       	st.w	r9[0x0],r11
800082a4:	09 09       	ld.w	r9,r4++
800082a6:	8f 59       	st.w	r7[0x14],r9
800082a8:	ee c9 ff e8 	sub	r9,r7,-24
800082ac:	e0 4a 00 24 	cp.w	r10,36
800082b0:	c0 71       	brne	800082be <_realloc_r+0x12e>
800082b2:	09 0a       	ld.w	r10,r4++
800082b4:	93 0a       	st.w	r9[0x0],r10
800082b6:	ee c9 ff e0 	sub	r9,r7,-32
800082ba:	09 0a       	ld.w	r10,r4++
800082bc:	8f 7a       	st.w	r7[0x1c],r10
800082be:	09 0a       	ld.w	r10,r4++
800082c0:	12 aa       	st.w	r9++,r10
800082c2:	68 0a       	ld.w	r10,r4[0x0]
800082c4:	93 0a       	st.w	r9[0x0],r10
800082c6:	68 1a       	ld.w	r10,r4[0x4]
800082c8:	93 1a       	st.w	r9[0x4],r10
800082ca:	c0 78       	rjmp	800082d8 <_realloc_r+0x148>
800082cc:	50 08       	stdsp	sp[0x0],r8
800082ce:	08 9b       	mov	r11,r4
800082d0:	0a 9c       	mov	r12,r5
800082d2:	e0 a0 1d a6 	rcall	8000be1e <memmove>
800082d6:	40 08       	lddsp	r8,sp[0x0]
800082d8:	ee 06 00 09 	add	r9,r7,r6
800082dc:	0c 13       	sub	r3,r6
800082de:	a1 a3       	sbr	r3,0x0
800082e0:	93 13       	st.w	r9[0x4],r3
800082e2:	91 29       	st.w	r8[0x8],r9
800082e4:	04 9c       	mov	r12,r2
800082e6:	6e 18       	ld.w	r8,r7[0x4]
800082e8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800082ec:	10 46       	or	r6,r8
800082ee:	8f 16       	st.w	r7[0x4],r6
800082f0:	ca b8       	rjmp	80008446 <_realloc_r+0x2b6>
800082f2:	14 03       	add	r3,r10
800082f4:	0c 33       	cp.w	r3,r6
800082f6:	c0 95       	brlt	80008308 <_realloc_r+0x178>
800082f8:	72 28       	ld.w	r8,r9[0x8]
800082fa:	72 39       	ld.w	r9,r9[0xc]
800082fc:	93 28       	st.w	r9[0x8],r8
800082fe:	91 39       	st.w	r8[0xc],r9
80008300:	6e 28       	ld.w	r8,r7[0x8]
80008302:	6e 39       	ld.w	r9,r7[0xc]
80008304:	c0 88       	rjmp	80008314 <_realloc_r+0x184>
80008306:	d7 03       	nop
80008308:	f8 00 00 03 	add	r3,r12,r0
8000830c:	0c 33       	cp.w	r3,r6
8000830e:	c3 35       	brlt	80008374 <_realloc_r+0x1e4>
80008310:	6e 39       	ld.w	r9,r7[0xc]
80008312:	6e 28       	ld.w	r8,r7[0x8]
80008314:	93 28       	st.w	r9[0x8],r8
80008316:	91 39       	st.w	r8[0xc],r9
80008318:	e0 ca 00 04 	sub	r10,r0,4
8000831c:	ee cc ff f8 	sub	r12,r7,-8
80008320:	e0 4a 00 24 	cp.w	r10,36
80008324:	e0 8b 00 24 	brhi	8000836c <_realloc_r+0x1dc>
80008328:	59 3a       	cp.w	r10,19
8000832a:	e0 88 00 1a 	brls	8000835e <_realloc_r+0x1ce>
8000832e:	09 08       	ld.w	r8,r4++
80008330:	99 08       	st.w	r12[0x0],r8
80008332:	09 08       	ld.w	r8,r4++
80008334:	8f 38       	st.w	r7[0xc],r8
80008336:	ee cc ff f0 	sub	r12,r7,-16
8000833a:	59 ba       	cp.w	r10,27
8000833c:	e0 88 00 11 	brls	8000835e <_realloc_r+0x1ce>
80008340:	09 08       	ld.w	r8,r4++
80008342:	99 08       	st.w	r12[0x0],r8
80008344:	09 08       	ld.w	r8,r4++
80008346:	8f 58       	st.w	r7[0x14],r8
80008348:	ee cc ff e8 	sub	r12,r7,-24
8000834c:	e0 4a 00 24 	cp.w	r10,36
80008350:	c0 71       	brne	8000835e <_realloc_r+0x1ce>
80008352:	09 08       	ld.w	r8,r4++
80008354:	99 08       	st.w	r12[0x0],r8
80008356:	ee cc ff e0 	sub	r12,r7,-32
8000835a:	09 08       	ld.w	r8,r4++
8000835c:	8f 78       	st.w	r7[0x1c],r8
8000835e:	09 08       	ld.w	r8,r4++
80008360:	18 a8       	st.w	r12++,r8
80008362:	68 08       	ld.w	r8,r4[0x0]
80008364:	99 08       	st.w	r12[0x0],r8
80008366:	68 18       	ld.w	r8,r4[0x4]
80008368:	99 18       	st.w	r12[0x4],r8
8000836a:	c4 78       	rjmp	800083f8 <_realloc_r+0x268>
8000836c:	08 9b       	mov	r11,r4
8000836e:	e0 a0 1d 58 	rcall	8000be1e <memmove>
80008372:	c4 38       	rjmp	800083f8 <_realloc_r+0x268>
80008374:	04 9c       	mov	r12,r2
80008376:	fe b0 fc 4b 	rcall	80007c0c <_malloc_r>
8000837a:	18 95       	mov	r5,r12
8000837c:	c3 a0       	breq	800083f0 <_realloc_r+0x260>
8000837e:	62 18       	ld.w	r8,r1[0x4]
80008380:	f8 c9 00 08 	sub	r9,r12,8
80008384:	a1 c8       	cbr	r8,0x0
80008386:	e2 08 00 08 	add	r8,r1,r8
8000838a:	10 39       	cp.w	r9,r8
8000838c:	c0 71       	brne	8000839a <_realloc_r+0x20a>
8000838e:	72 13       	ld.w	r3,r9[0x4]
80008390:	02 97       	mov	r7,r1
80008392:	e0 13 ff fc 	andl	r3,0xfffc
80008396:	00 03       	add	r3,r0
80008398:	c3 08       	rjmp	800083f8 <_realloc_r+0x268>
8000839a:	e0 ca 00 04 	sub	r10,r0,4
8000839e:	e0 4a 00 24 	cp.w	r10,36
800083a2:	e0 8b 00 20 	brhi	800083e2 <_realloc_r+0x252>
800083a6:	08 99       	mov	r9,r4
800083a8:	18 98       	mov	r8,r12
800083aa:	59 3a       	cp.w	r10,19
800083ac:	e0 88 00 14 	brls	800083d4 <_realloc_r+0x244>
800083b0:	13 0b       	ld.w	r11,r9++
800083b2:	10 ab       	st.w	r8++,r11
800083b4:	13 0b       	ld.w	r11,r9++
800083b6:	10 ab       	st.w	r8++,r11
800083b8:	59 ba       	cp.w	r10,27
800083ba:	e0 88 00 0d 	brls	800083d4 <_realloc_r+0x244>
800083be:	13 0b       	ld.w	r11,r9++
800083c0:	10 ab       	st.w	r8++,r11
800083c2:	13 0b       	ld.w	r11,r9++
800083c4:	10 ab       	st.w	r8++,r11
800083c6:	e0 4a 00 24 	cp.w	r10,36
800083ca:	c0 51       	brne	800083d4 <_realloc_r+0x244>
800083cc:	13 0a       	ld.w	r10,r9++
800083ce:	10 aa       	st.w	r8++,r10
800083d0:	13 0a       	ld.w	r10,r9++
800083d2:	10 aa       	st.w	r8++,r10
800083d4:	13 0a       	ld.w	r10,r9++
800083d6:	10 aa       	st.w	r8++,r10
800083d8:	72 0a       	ld.w	r10,r9[0x0]
800083da:	91 0a       	st.w	r8[0x0],r10
800083dc:	72 19       	ld.w	r9,r9[0x4]
800083de:	91 19       	st.w	r8[0x4],r9
800083e0:	c0 48       	rjmp	800083e8 <_realloc_r+0x258>
800083e2:	08 9b       	mov	r11,r4
800083e4:	e0 a0 1d 1d 	rcall	8000be1e <memmove>
800083e8:	08 9b       	mov	r11,r4
800083ea:	04 9c       	mov	r12,r2
800083ec:	e0 a0 1a 78 	rcall	8000b8dc <_free_r>
800083f0:	04 9c       	mov	r12,r2
800083f2:	c2 a8       	rjmp	80008446 <_realloc_r+0x2b6>
800083f4:	00 93       	mov	r3,r0
800083f6:	02 97       	mov	r7,r1
800083f8:	e6 06 01 09 	sub	r9,r3,r6
800083fc:	6e 18       	ld.w	r8,r7[0x4]
800083fe:	58 f9       	cp.w	r9,15
80008400:	e0 88 00 16 	brls	8000842c <_realloc_r+0x29c>
80008404:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008408:	ed e8 10 08 	or	r8,r6,r8
8000840c:	8f 18       	st.w	r7[0x4],r8
8000840e:	12 98       	mov	r8,r9
80008410:	a1 a8       	sbr	r8,0x0
80008412:	ee 06 00 0b 	add	r11,r7,r6
80008416:	f6 09 00 09 	add	r9,r11,r9
8000841a:	97 18       	st.w	r11[0x4],r8
8000841c:	72 18       	ld.w	r8,r9[0x4]
8000841e:	a1 a8       	sbr	r8,0x0
80008420:	2f 8b       	sub	r11,-8
80008422:	93 18       	st.w	r9[0x4],r8
80008424:	04 9c       	mov	r12,r2
80008426:	e0 a0 1a 5b 	rcall	8000b8dc <_free_r>
8000842a:	c0 b8       	rjmp	80008440 <_realloc_r+0x2b0>
8000842c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008430:	e7 e8 10 08 	or	r8,r3,r8
80008434:	8f 18       	st.w	r7[0x4],r8
80008436:	ee 03 00 03 	add	r3,r7,r3
8000843a:	66 18       	ld.w	r8,r3[0x4]
8000843c:	a1 a8       	sbr	r8,0x0
8000843e:	87 18       	st.w	r3[0x4],r8
80008440:	04 9c       	mov	r12,r2
80008442:	ee c5 ff f8 	sub	r5,r7,-8
80008446:	fe b0 ed 5d 	rcall	80005f00 <__malloc_unlock>
8000844a:	0a 9c       	mov	r12,r5
8000844c:	2f fd       	sub	sp,-4
8000844e:	d8 32       	popm	r0-r7,pc

80008450 <_sbrk_r>:
80008450:	d4 21       	pushm	r4-r7,lr
80008452:	30 08       	mov	r8,0
80008454:	18 97       	mov	r7,r12
80008456:	e0 66 10 5c 	mov	r6,4188
8000845a:	16 9c       	mov	r12,r11
8000845c:	8d 08       	st.w	r6[0x0],r8
8000845e:	c8 5c       	rcall	80008568 <_sbrk>
80008460:	5b fc       	cp.w	r12,-1
80008462:	c0 51       	brne	8000846c <_sbrk_r+0x1c>
80008464:	6c 08       	ld.w	r8,r6[0x0]
80008466:	58 08       	cp.w	r8,0
80008468:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000846c:	d8 22       	popm	r4-r7,pc
8000846e:	d7 03       	nop

80008470 <sprintf>:
80008470:	d4 01       	pushm	lr
80008472:	21 7d       	sub	sp,92
80008474:	e0 68 ff ff 	mov	r8,65535
80008478:	ea 18 7f ff 	orh	r8,0x7fff
8000847c:	50 58       	stdsp	sp[0x14],r8
8000847e:	50 28       	stdsp	sp[0x8],r8
80008480:	e0 68 02 08 	mov	r8,520
80008484:	ba 68       	st.h	sp[0xc],r8
80008486:	3f f8       	mov	r8,-1
80008488:	ba 78       	st.h	sp[0xe],r8
8000848a:	e0 68 05 34 	mov	r8,1332
8000848e:	50 4c       	stdsp	sp[0x10],r12
80008490:	16 9a       	mov	r10,r11
80008492:	50 0c       	stdsp	sp[0x0],r12
80008494:	fa c9 ff a0 	sub	r9,sp,-96
80008498:	70 0c       	ld.w	r12,r8[0x0]
8000849a:	1a 9b       	mov	r11,sp
8000849c:	e0 a0 02 20 	rcall	800088dc <_vfprintf_r>
800084a0:	30 09       	mov	r9,0
800084a2:	40 08       	lddsp	r8,sp[0x0]
800084a4:	b0 89       	st.b	r8[0x0],r9
800084a6:	2e 9d       	sub	sp,-92
800084a8:	d8 02       	popm	pc
800084aa:	d7 03       	nop

800084ac <strncpy>:
800084ac:	30 08       	mov	r8,0
800084ae:	10 3a       	cp.w	r10,r8
800084b0:	5e 0c       	reteq	r12
800084b2:	f6 08 07 09 	ld.ub	r9,r11[r8]
800084b6:	f8 08 0b 09 	st.b	r12[r8],r9
800084ba:	2f f8       	sub	r8,-1
800084bc:	58 09       	cp.w	r9,0
800084be:	cf 81       	brne	800084ae <strncpy+0x2>
800084c0:	10 3a       	cp.w	r10,r8
800084c2:	5e 0c       	reteq	r12
800084c4:	f8 08 0b 09 	st.b	r12[r8],r9
800084c8:	2f f8       	sub	r8,-1
800084ca:	cf bb       	rjmp	800084c0 <strncpy+0x14>

800084cc <_close>:
800084cc:	30 28       	mov	r8,2
800084ce:	d6 73       	breakpoint
800084d0:	3f fc       	mov	r12,-1
800084d2:	35 8b       	mov	r11,88
800084d4:	58 0c       	cp.w	r12,0
800084d6:	5e 4c       	retge	r12
800084d8:	e0 6a 10 5c 	mov	r10,4188
800084dc:	95 0b       	st.w	r10[0x0],r11
800084de:	5e fc       	retal	r12

800084e0 <_lseek>:
800084e0:	30 58       	mov	r8,5
800084e2:	d6 73       	breakpoint
800084e4:	3f fc       	mov	r12,-1
800084e6:	35 8b       	mov	r11,88
800084e8:	58 0c       	cp.w	r12,0
800084ea:	5e 4c       	retge	r12
800084ec:	e0 6a 10 5c 	mov	r10,4188
800084f0:	95 0b       	st.w	r10[0x0],r11
800084f2:	5e fc       	retal	r12

800084f4 <isatty>:
800084f4:	30 b8       	mov	r8,11
800084f6:	d6 73       	breakpoint
800084f8:	3f fc       	mov	r12,-1
800084fa:	35 8b       	mov	r11,88
800084fc:	58 0c       	cp.w	r12,0
800084fe:	5e 4c       	retge	r12
80008500:	e0 6a 10 5c 	mov	r10,4188
80008504:	95 0b       	st.w	r10[0x0],r11
80008506:	5e fc       	retal	r12

80008508 <_fstat_host>:
80008508:	30 98       	mov	r8,9
8000850a:	d6 73       	breakpoint
8000850c:	3f fc       	mov	r12,-1
8000850e:	35 8b       	mov	r11,88
80008510:	58 0c       	cp.w	r12,0
80008512:	5e 4c       	retge	r12
80008514:	e0 6a 10 5c 	mov	r10,4188
80008518:	95 0b       	st.w	r10[0x0],r11
8000851a:	5e fc       	retal	r12

8000851c <_fstat>:
8000851c:	d4 21       	pushm	r4-r7,lr
8000851e:	21 0d       	sub	sp,64
80008520:	16 97       	mov	r7,r11
80008522:	1a 9b       	mov	r11,sp
80008524:	cf 2f       	rcall	80008508 <_fstat_host>
80008526:	c0 34       	brge	8000852c <_fstat+0x10>
80008528:	3f fc       	mov	r12,-1
8000852a:	c1 c8       	rjmp	80008562 <_fstat+0x46>
8000852c:	40 08       	lddsp	r8,sp[0x0]
8000852e:	ae 08       	st.h	r7[0x0],r8
80008530:	40 18       	lddsp	r8,sp[0x4]
80008532:	ae 18       	st.h	r7[0x2],r8
80008534:	40 28       	lddsp	r8,sp[0x8]
80008536:	8f 18       	st.w	r7[0x4],r8
80008538:	40 38       	lddsp	r8,sp[0xc]
8000853a:	ae 48       	st.h	r7[0x8],r8
8000853c:	40 48       	lddsp	r8,sp[0x10]
8000853e:	ae 58       	st.h	r7[0xa],r8
80008540:	40 58       	lddsp	r8,sp[0x14]
80008542:	ae 68       	st.h	r7[0xc],r8
80008544:	40 68       	lddsp	r8,sp[0x18]
80008546:	ae 78       	st.h	r7[0xe],r8
80008548:	40 88       	lddsp	r8,sp[0x20]
8000854a:	8f 48       	st.w	r7[0x10],r8
8000854c:	40 a8       	lddsp	r8,sp[0x28]
8000854e:	8f b8       	st.w	r7[0x2c],r8
80008550:	40 c8       	lddsp	r8,sp[0x30]
80008552:	8f c8       	st.w	r7[0x30],r8
80008554:	40 d8       	lddsp	r8,sp[0x34]
80008556:	8f 58       	st.w	r7[0x14],r8
80008558:	40 e8       	lddsp	r8,sp[0x38]
8000855a:	30 0c       	mov	r12,0
8000855c:	8f 78       	st.w	r7[0x1c],r8
8000855e:	40 f8       	lddsp	r8,sp[0x3c]
80008560:	8f 98       	st.w	r7[0x24],r8
80008562:	2f 0d       	sub	sp,-64
80008564:	d8 22       	popm	r4-r7,pc
80008566:	d7 03       	nop

80008568 <_sbrk>:
80008568:	d4 01       	pushm	lr
8000856a:	e0 68 08 08 	mov	r8,2056
8000856e:	70 09       	ld.w	r9,r8[0x0]
80008570:	58 09       	cp.w	r9,0
80008572:	c0 41       	brne	8000857a <_sbrk+0x12>
80008574:	e0 69 10 60 	mov	r9,4192
80008578:	91 09       	st.w	r8[0x0],r9
8000857a:	e0 69 08 08 	mov	r9,2056
8000857e:	e0 6a f0 00 	mov	r10,61440
80008582:	72 08       	ld.w	r8,r9[0x0]
80008584:	f0 0c 00 0c 	add	r12,r8,r12
80008588:	14 3c       	cp.w	r12,r10
8000858a:	e0 8b 00 04 	brhi	80008592 <_sbrk+0x2a>
8000858e:	93 0c       	st.w	r9[0x0],r12
80008590:	c0 68       	rjmp	8000859c <_sbrk+0x34>
80008592:	e0 a0 18 2b 	rcall	8000b5e8 <__errno>
80008596:	30 c8       	mov	r8,12
80008598:	99 08       	st.w	r12[0x0],r8
8000859a:	3f f8       	mov	r8,-1
8000859c:	10 9c       	mov	r12,r8
8000859e:	d8 02       	popm	pc

800085a0 <get_arg>:
800085a0:	d4 31       	pushm	r0-r7,lr
800085a2:	20 8d       	sub	sp,32
800085a4:	fa c4 ff bc 	sub	r4,sp,-68
800085a8:	50 4b       	stdsp	sp[0x10],r11
800085aa:	68 2e       	ld.w	lr,r4[0x8]
800085ac:	50 58       	stdsp	sp[0x14],r8
800085ae:	12 96       	mov	r6,r9
800085b0:	7c 0b       	ld.w	r11,lr[0x0]
800085b2:	70 05       	ld.w	r5,r8[0x0]
800085b4:	50 6e       	stdsp	sp[0x18],lr
800085b6:	58 0b       	cp.w	r11,0
800085b8:	f4 0b 17 00 	moveq	r11,r10
800085bc:	68 03       	ld.w	r3,r4[0x0]
800085be:	68 11       	ld.w	r1,r4[0x4]
800085c0:	40 49       	lddsp	r9,sp[0x10]
800085c2:	30 08       	mov	r8,0
800085c4:	c2 e9       	rjmp	80008820 <get_arg+0x280>
800085c6:	2f fb       	sub	r11,-1
800085c8:	32 5c       	mov	r12,37
800085ca:	17 8a       	ld.ub	r10,r11[0x0]
800085cc:	f8 0a 18 00 	cp.b	r10,r12
800085d0:	5f 1e       	srne	lr
800085d2:	f0 0a 18 00 	cp.b	r10,r8
800085d6:	5f 1c       	srne	r12
800085d8:	fd ec 00 0c 	and	r12,lr,r12
800085dc:	f0 0c 18 00 	cp.b	r12,r8
800085e0:	cf 31       	brne	800085c6 <get_arg+0x26>
800085e2:	58 0a       	cp.w	r10,0
800085e4:	e0 80 01 2b 	breq	8000883a <get_arg+0x29a>
800085e8:	30 0c       	mov	r12,0
800085ea:	3f fa       	mov	r10,-1
800085ec:	18 90       	mov	r0,r12
800085ee:	50 3a       	stdsp	sp[0xc],r10
800085f0:	18 94       	mov	r4,r12
800085f2:	18 92       	mov	r2,r12
800085f4:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
800085f8:	16 97       	mov	r7,r11
800085fa:	50 7c       	stdsp	sp[0x1c],r12
800085fc:	4c ec       	lddpc	r12,80008734 <get_arg+0x194>
800085fe:	0f 3a       	ld.ub	r10,r7++
80008600:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80008604:	40 7c       	lddsp	r12,sp[0x1c]
80008606:	1c 0c       	add	r12,lr
80008608:	4c ce       	lddpc	lr,80008738 <get_arg+0x198>
8000860a:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
8000860e:	20 1e       	sub	lr,1
80008610:	50 0e       	stdsp	sp[0x0],lr
80008612:	4c be       	lddpc	lr,8000873c <get_arg+0x19c>
80008614:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80008618:	50 7c       	stdsp	sp[0x1c],r12
8000861a:	40 0c       	lddsp	r12,sp[0x0]
8000861c:	58 7c       	cp.w	r12,7
8000861e:	e0 8b 00 fa 	brhi	80008812 <get_arg+0x272>
80008622:	4c 8e       	lddpc	lr,80008740 <get_arg+0x1a0>
80008624:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80008628:	36 8b       	mov	r11,104
8000862a:	f6 0a 18 00 	cp.b	r10,r11
8000862e:	e0 80 00 f2 	breq	80008812 <get_arg+0x272>
80008632:	37 1b       	mov	r11,113
80008634:	f6 0a 18 00 	cp.b	r10,r11
80008638:	c0 70       	breq	80008646 <get_arg+0xa6>
8000863a:	34 cb       	mov	r11,76
8000863c:	f6 0a 18 00 	cp.b	r10,r11
80008640:	c0 51       	brne	8000864a <get_arg+0xaa>
80008642:	a3 b4       	sbr	r4,0x3
80008644:	ce 78       	rjmp	80008812 <get_arg+0x272>
80008646:	a5 b4       	sbr	r4,0x5
80008648:	ce 58       	rjmp	80008812 <get_arg+0x272>
8000864a:	08 9a       	mov	r10,r4
8000864c:	0e 9b       	mov	r11,r7
8000864e:	a5 aa       	sbr	r10,0x4
80008650:	17 3c       	ld.ub	r12,r11++
80008652:	a5 b4       	sbr	r4,0x5
80008654:	36 ce       	mov	lr,108
80008656:	fc 0c 18 00 	cp.b	r12,lr
8000865a:	e0 80 00 dd 	breq	80008814 <get_arg+0x274>
8000865e:	14 94       	mov	r4,r10
80008660:	cd 98       	rjmp	80008812 <get_arg+0x272>
80008662:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80008666:	36 7c       	mov	r12,103
80008668:	f8 0a 18 00 	cp.b	r10,r12
8000866c:	e0 8b 00 27 	brhi	800086ba <get_arg+0x11a>
80008670:	36 5b       	mov	r11,101
80008672:	f6 0a 18 00 	cp.b	r10,r11
80008676:	c4 82       	brcc	80008706 <get_arg+0x166>
80008678:	34 fb       	mov	r11,79
8000867a:	f6 0a 18 00 	cp.b	r10,r11
8000867e:	c4 80       	breq	8000870e <get_arg+0x16e>
80008680:	e0 8b 00 0c 	brhi	80008698 <get_arg+0xf8>
80008684:	34 5b       	mov	r11,69
80008686:	f6 0a 18 00 	cp.b	r10,r11
8000868a:	c3 e0       	breq	80008706 <get_arg+0x166>
8000868c:	34 7b       	mov	r11,71
8000868e:	f6 0a 18 00 	cp.b	r10,r11
80008692:	c3 a0       	breq	80008706 <get_arg+0x166>
80008694:	34 4b       	mov	r11,68
80008696:	c0 88       	rjmp	800086a6 <get_arg+0x106>
80008698:	35 8b       	mov	r11,88
8000869a:	f6 0a 18 00 	cp.b	r10,r11
8000869e:	c2 c0       	breq	800086f6 <get_arg+0x156>
800086a0:	e0 8b 00 07 	brhi	800086ae <get_arg+0x10e>
800086a4:	35 5b       	mov	r11,85
800086a6:	f6 0a 18 00 	cp.b	r10,r11
800086aa:	c3 51       	brne	80008714 <get_arg+0x174>
800086ac:	c3 18       	rjmp	8000870e <get_arg+0x16e>
800086ae:	36 3b       	mov	r11,99
800086b0:	f6 0a 18 00 	cp.b	r10,r11
800086b4:	c2 f0       	breq	80008712 <get_arg+0x172>
800086b6:	36 4b       	mov	r11,100
800086b8:	c0 e8       	rjmp	800086d4 <get_arg+0x134>
800086ba:	37 0b       	mov	r11,112
800086bc:	f6 0a 18 00 	cp.b	r10,r11
800086c0:	c2 50       	breq	8000870a <get_arg+0x16a>
800086c2:	e0 8b 00 0d 	brhi	800086dc <get_arg+0x13c>
800086c6:	36 eb       	mov	r11,110
800086c8:	f6 0a 18 00 	cp.b	r10,r11
800086cc:	c1 f0       	breq	8000870a <get_arg+0x16a>
800086ce:	e0 8b 00 14 	brhi	800086f6 <get_arg+0x156>
800086d2:	36 9b       	mov	r11,105
800086d4:	f6 0a 18 00 	cp.b	r10,r11
800086d8:	c1 e1       	brne	80008714 <get_arg+0x174>
800086da:	c0 e8       	rjmp	800086f6 <get_arg+0x156>
800086dc:	37 5b       	mov	r11,117
800086de:	f6 0a 18 00 	cp.b	r10,r11
800086e2:	c0 a0       	breq	800086f6 <get_arg+0x156>
800086e4:	37 8b       	mov	r11,120
800086e6:	f6 0a 18 00 	cp.b	r10,r11
800086ea:	c0 60       	breq	800086f6 <get_arg+0x156>
800086ec:	37 3b       	mov	r11,115
800086ee:	f6 0a 18 00 	cp.b	r10,r11
800086f2:	c1 11       	brne	80008714 <get_arg+0x174>
800086f4:	c0 b8       	rjmp	8000870a <get_arg+0x16a>
800086f6:	ed b4 00 04 	bld	r4,0x4
800086fa:	c0 a0       	breq	8000870e <get_arg+0x16e>
800086fc:	ed b4 00 05 	bld	r4,0x5
80008700:	c0 91       	brne	80008712 <get_arg+0x172>
80008702:	30 20       	mov	r0,2
80008704:	c0 88       	rjmp	80008714 <get_arg+0x174>
80008706:	30 40       	mov	r0,4
80008708:	c0 68       	rjmp	80008714 <get_arg+0x174>
8000870a:	30 30       	mov	r0,3
8000870c:	c0 48       	rjmp	80008714 <get_arg+0x174>
8000870e:	30 10       	mov	r0,1
80008710:	c0 28       	rjmp	80008714 <get_arg+0x174>
80008712:	30 00       	mov	r0,0
80008714:	40 3b       	lddsp	r11,sp[0xc]
80008716:	5b fb       	cp.w	r11,-1
80008718:	c0 40       	breq	80008720 <get_arg+0x180>
8000871a:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
8000871e:	c7 a8       	rjmp	80008812 <get_arg+0x272>
80008720:	58 60       	cp.w	r0,6
80008722:	e0 8b 00 78 	brhi	80008812 <get_arg+0x272>
80008726:	6c 0a       	ld.w	r10,r6[0x0]
80008728:	ea cc ff ff 	sub	r12,r5,-1
8000872c:	48 6e       	lddpc	lr,80008744 <get_arg+0x1a4>
8000872e:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80008732:	d7 03       	nop
80008734:	80 02       	ld.sh	r2,r0[0x0]
80008736:	f8 10 80 02 	mems	8,0x1
8000873a:	f7 48 80 02 	st.w	r11[-32766],r8
8000873e:	f6 dc 80 02 	satsub.w	r12,r11,-32766
80008742:	f5 3c 80 02 	ld.ub	r12,r10[-32766]
80008746:	f5 5c f4 cb 	st.h	r10[-2869],r12
8000874a:	ff f8 8d 0b 	st.hls	pc[0x216],r8
8000874e:	f4 ea 00 00 	ld.d	r10,r10[0]
80008752:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80008756:	c0 f8       	rjmp	80008774 <get_arg+0x1d4>
80008758:	f4 cb ff fc 	sub	r11,r10,-4
8000875c:	8d 0b       	st.w	r6[0x0],r11
8000875e:	74 0a       	ld.w	r10,r10[0x0]
80008760:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80008764:	c0 88       	rjmp	80008774 <get_arg+0x1d4>
80008766:	f4 cb ff f8 	sub	r11,r10,-8
8000876a:	8d 0b       	st.w	r6[0x0],r11
8000876c:	f4 ea 00 00 	ld.d	r10,r10[0]
80008770:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80008774:	0e 9b       	mov	r11,r7
80008776:	18 95       	mov	r5,r12
80008778:	c4 e8       	rjmp	80008814 <get_arg+0x274>
8000877a:	62 0a       	ld.w	r10,r1[0x0]
8000877c:	5b fa       	cp.w	r10,-1
8000877e:	c0 b1       	brne	80008794 <get_arg+0x1f4>
80008780:	50 19       	stdsp	sp[0x4],r9
80008782:	50 28       	stdsp	sp[0x8],r8
80008784:	e0 6a 00 80 	mov	r10,128
80008788:	30 0b       	mov	r11,0
8000878a:	02 9c       	mov	r12,r1
8000878c:	fe b0 fc fa 	rcall	80008180 <memset>
80008790:	40 28       	lddsp	r8,sp[0x8]
80008792:	40 19       	lddsp	r9,sp[0x4]
80008794:	e4 cc 00 01 	sub	r12,r2,1
80008798:	0e 9b       	mov	r11,r7
8000879a:	50 3c       	stdsp	sp[0xc],r12
8000879c:	f2 0c 0c 49 	max	r9,r9,r12
800087a0:	c3 a8       	rjmp	80008814 <get_arg+0x274>
800087a2:	62 0a       	ld.w	r10,r1[0x0]
800087a4:	5b fa       	cp.w	r10,-1
800087a6:	c0 b1       	brne	800087bc <get_arg+0x21c>
800087a8:	50 19       	stdsp	sp[0x4],r9
800087aa:	50 28       	stdsp	sp[0x8],r8
800087ac:	e0 6a 00 80 	mov	r10,128
800087b0:	30 0b       	mov	r11,0
800087b2:	02 9c       	mov	r12,r1
800087b4:	fe b0 fc e6 	rcall	80008180 <memset>
800087b8:	40 28       	lddsp	r8,sp[0x8]
800087ba:	40 19       	lddsp	r9,sp[0x4]
800087bc:	20 12       	sub	r2,1
800087be:	30 0a       	mov	r10,0
800087c0:	0e 9b       	mov	r11,r7
800087c2:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
800087c6:	f2 02 0c 49 	max	r9,r9,r2
800087ca:	c2 58       	rjmp	80008814 <get_arg+0x274>
800087cc:	16 97       	mov	r7,r11
800087ce:	6c 0a       	ld.w	r10,r6[0x0]
800087d0:	f4 cb ff fc 	sub	r11,r10,-4
800087d4:	8d 0b       	st.w	r6[0x0],r11
800087d6:	74 0a       	ld.w	r10,r10[0x0]
800087d8:	0e 9b       	mov	r11,r7
800087da:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
800087de:	2f f5       	sub	r5,-1
800087e0:	c1 a8       	rjmp	80008814 <get_arg+0x274>
800087e2:	f4 c2 00 30 	sub	r2,r10,48
800087e6:	c0 68       	rjmp	800087f2 <get_arg+0x252>
800087e8:	e4 02 00 22 	add	r2,r2,r2<<0x2
800087ec:	2f f7       	sub	r7,-1
800087ee:	f4 02 00 12 	add	r2,r10,r2<<0x1
800087f2:	0f 8a       	ld.ub	r10,r7[0x0]
800087f4:	58 0a       	cp.w	r10,0
800087f6:	c0 e0       	breq	80008812 <get_arg+0x272>
800087f8:	23 0a       	sub	r10,48
800087fa:	58 9a       	cp.w	r10,9
800087fc:	fe 98 ff f6 	brls	800087e8 <get_arg+0x248>
80008800:	c0 98       	rjmp	80008812 <get_arg+0x272>
80008802:	2f f7       	sub	r7,-1
80008804:	0f 8a       	ld.ub	r10,r7[0x0]
80008806:	58 0a       	cp.w	r10,0
80008808:	c0 50       	breq	80008812 <get_arg+0x272>
8000880a:	23 0a       	sub	r10,48
8000880c:	58 9a       	cp.w	r10,9
8000880e:	fe 98 ff fa 	brls	80008802 <get_arg+0x262>
80008812:	0e 9b       	mov	r11,r7
80008814:	40 7c       	lddsp	r12,sp[0x1c]
80008816:	30 ba       	mov	r10,11
80008818:	f4 0c 18 00 	cp.b	r12,r10
8000881c:	fe 91 fe ec 	brne	800085f4 <get_arg+0x54>
80008820:	40 42       	lddsp	r2,sp[0x10]
80008822:	17 8c       	ld.ub	r12,r11[0x0]
80008824:	0a 32       	cp.w	r2,r5
80008826:	5f 4a       	srge	r10
80008828:	f0 0c 18 00 	cp.b	r12,r8
8000882c:	5f 1c       	srne	r12
8000882e:	f9 ea 00 0a 	and	r10,r12,r10
80008832:	f0 0a 18 00 	cp.b	r10,r8
80008836:	fe 91 fe c9 	brne	800085c8 <get_arg+0x28>
8000883a:	30 08       	mov	r8,0
8000883c:	40 4e       	lddsp	lr,sp[0x10]
8000883e:	17 8a       	ld.ub	r10,r11[0x0]
80008840:	e2 05 00 21 	add	r1,r1,r5<<0x2
80008844:	f0 0a 18 00 	cp.b	r10,r8
80008848:	fc 09 17 10 	movne	r9,lr
8000884c:	e6 05 00 38 	add	r8,r3,r5<<0x3
80008850:	06 9e       	mov	lr,r3
80008852:	c2 a8       	rjmp	800088a6 <get_arg+0x306>
80008854:	62 0a       	ld.w	r10,r1[0x0]
80008856:	58 3a       	cp.w	r10,3
80008858:	c1 e0       	breq	80008894 <get_arg+0x2f4>
8000885a:	e0 89 00 07 	brgt	80008868 <get_arg+0x2c8>
8000885e:	58 1a       	cp.w	r10,1
80008860:	c1 a0       	breq	80008894 <get_arg+0x2f4>
80008862:	58 2a       	cp.w	r10,2
80008864:	c1 81       	brne	80008894 <get_arg+0x2f4>
80008866:	c0 58       	rjmp	80008870 <get_arg+0x2d0>
80008868:	58 5a       	cp.w	r10,5
8000886a:	c0 c0       	breq	80008882 <get_arg+0x2e2>
8000886c:	c0 b5       	brlt	80008882 <get_arg+0x2e2>
8000886e:	c1 38       	rjmp	80008894 <get_arg+0x2f4>
80008870:	6c 0a       	ld.w	r10,r6[0x0]
80008872:	f4 cc ff f8 	sub	r12,r10,-8
80008876:	8d 0c       	st.w	r6[0x0],r12
80008878:	f4 e2 00 00 	ld.d	r2,r10[0]
8000887c:	f0 e3 00 00 	st.d	r8[0],r2
80008880:	c1 08       	rjmp	800088a0 <get_arg+0x300>
80008882:	6c 0a       	ld.w	r10,r6[0x0]
80008884:	f4 cc ff f8 	sub	r12,r10,-8
80008888:	8d 0c       	st.w	r6[0x0],r12
8000888a:	f4 e2 00 00 	ld.d	r2,r10[0]
8000888e:	f0 e3 00 00 	st.d	r8[0],r2
80008892:	c0 78       	rjmp	800088a0 <get_arg+0x300>
80008894:	6c 0a       	ld.w	r10,r6[0x0]
80008896:	f4 cc ff fc 	sub	r12,r10,-4
8000889a:	8d 0c       	st.w	r6[0x0],r12
8000889c:	74 0a       	ld.w	r10,r10[0x0]
8000889e:	91 0a       	st.w	r8[0x0],r10
800088a0:	2f f5       	sub	r5,-1
800088a2:	2f 88       	sub	r8,-8
800088a4:	2f c1       	sub	r1,-4
800088a6:	12 35       	cp.w	r5,r9
800088a8:	fe 9a ff d6 	brle	80008854 <get_arg+0x2b4>
800088ac:	1c 93       	mov	r3,lr
800088ae:	40 52       	lddsp	r2,sp[0x14]
800088b0:	40 6e       	lddsp	lr,sp[0x18]
800088b2:	85 05       	st.w	r2[0x0],r5
800088b4:	9d 0b       	st.w	lr[0x0],r11
800088b6:	40 4b       	lddsp	r11,sp[0x10]
800088b8:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
800088bc:	2f 8d       	sub	sp,-32
800088be:	d8 32       	popm	r0-r7,pc

800088c0 <__sprint_r>:
800088c0:	d4 21       	pushm	r4-r7,lr
800088c2:	14 97       	mov	r7,r10
800088c4:	74 28       	ld.w	r8,r10[0x8]
800088c6:	58 08       	cp.w	r8,0
800088c8:	c0 41       	brne	800088d0 <__sprint_r+0x10>
800088ca:	95 18       	st.w	r10[0x4],r8
800088cc:	10 9c       	mov	r12,r8
800088ce:	d8 22       	popm	r4-r7,pc
800088d0:	e0 a0 18 ca 	rcall	8000ba64 <__sfvwrite_r>
800088d4:	30 08       	mov	r8,0
800088d6:	8f 18       	st.w	r7[0x4],r8
800088d8:	8f 28       	st.w	r7[0x8],r8
800088da:	d8 22       	popm	r4-r7,pc

800088dc <_vfprintf_r>:
800088dc:	d4 31       	pushm	r0-r7,lr
800088de:	fa cd 06 bc 	sub	sp,sp,1724
800088e2:	51 09       	stdsp	sp[0x40],r9
800088e4:	16 91       	mov	r1,r11
800088e6:	14 97       	mov	r7,r10
800088e8:	18 95       	mov	r5,r12
800088ea:	e0 a0 1a 2d 	rcall	8000bd44 <_localeconv_r>
800088ee:	78 0c       	ld.w	r12,r12[0x0]
800088f0:	50 cc       	stdsp	sp[0x30],r12
800088f2:	58 05       	cp.w	r5,0
800088f4:	c0 70       	breq	80008902 <_vfprintf_r+0x26>
800088f6:	6a 68       	ld.w	r8,r5[0x18]
800088f8:	58 08       	cp.w	r8,0
800088fa:	c0 41       	brne	80008902 <_vfprintf_r+0x26>
800088fc:	0a 9c       	mov	r12,r5
800088fe:	e0 a0 17 57 	rcall	8000b7ac <__sinit>
80008902:	4d 08       	lddpc	r8,80008a40 <_vfprintf_r+0x164>
80008904:	10 31       	cp.w	r1,r8
80008906:	c0 31       	brne	8000890c <_vfprintf_r+0x30>
80008908:	6a 01       	ld.w	r1,r5[0x0]
8000890a:	c0 a8       	rjmp	8000891e <_vfprintf_r+0x42>
8000890c:	4c e8       	lddpc	r8,80008a44 <_vfprintf_r+0x168>
8000890e:	10 31       	cp.w	r1,r8
80008910:	c0 31       	brne	80008916 <_vfprintf_r+0x3a>
80008912:	6a 11       	ld.w	r1,r5[0x4]
80008914:	c0 58       	rjmp	8000891e <_vfprintf_r+0x42>
80008916:	4c d8       	lddpc	r8,80008a48 <_vfprintf_r+0x16c>
80008918:	10 31       	cp.w	r1,r8
8000891a:	eb f1 00 02 	ld.weq	r1,r5[0x8]
8000891e:	82 68       	ld.sh	r8,r1[0xc]
80008920:	ed b8 00 03 	bld	r8,0x3
80008924:	c0 41       	brne	8000892c <_vfprintf_r+0x50>
80008926:	62 48       	ld.w	r8,r1[0x10]
80008928:	58 08       	cp.w	r8,0
8000892a:	c0 71       	brne	80008938 <_vfprintf_r+0x5c>
8000892c:	02 9b       	mov	r11,r1
8000892e:	0a 9c       	mov	r12,r5
80008930:	e0 a0 0f 6c 	rcall	8000a808 <__swsetup_r>
80008934:	e0 81 0f 63 	brne	8000a7fa <_vfprintf_r+0x1f1e>
80008938:	82 68       	ld.sh	r8,r1[0xc]
8000893a:	10 99       	mov	r9,r8
8000893c:	e2 19 00 1a 	andl	r9,0x1a,COH
80008940:	58 a9       	cp.w	r9,10
80008942:	c3 c1       	brne	800089ba <_vfprintf_r+0xde>
80008944:	82 79       	ld.sh	r9,r1[0xe]
80008946:	30 0a       	mov	r10,0
80008948:	f4 09 19 00 	cp.h	r9,r10
8000894c:	c3 75       	brlt	800089ba <_vfprintf_r+0xde>
8000894e:	a1 d8       	cbr	r8,0x1
80008950:	fb 58 05 d0 	st.h	sp[1488],r8
80008954:	62 88       	ld.w	r8,r1[0x20]
80008956:	fb 48 05 e4 	st.w	sp[1508],r8
8000895a:	62 a8       	ld.w	r8,r1[0x28]
8000895c:	fb 48 05 ec 	st.w	sp[1516],r8
80008960:	fa c8 ff bc 	sub	r8,sp,-68
80008964:	fb 48 05 d4 	st.w	sp[1492],r8
80008968:	fb 48 05 c4 	st.w	sp[1476],r8
8000896c:	e0 68 04 00 	mov	r8,1024
80008970:	fb 48 05 d8 	st.w	sp[1496],r8
80008974:	fb 48 05 cc 	st.w	sp[1484],r8
80008978:	30 08       	mov	r8,0
8000897a:	fb 59 05 d2 	st.h	sp[1490],r9
8000897e:	0e 9a       	mov	r10,r7
80008980:	41 09       	lddsp	r9,sp[0x40]
80008982:	fa c7 fa 3c 	sub	r7,sp,-1476
80008986:	fb 48 05 dc 	st.w	sp[1500],r8
8000898a:	0a 9c       	mov	r12,r5
8000898c:	0e 9b       	mov	r11,r7
8000898e:	ca 7f       	rcall	800088dc <_vfprintf_r>
80008990:	50 bc       	stdsp	sp[0x2c],r12
80008992:	c0 95       	brlt	800089a4 <_vfprintf_r+0xc8>
80008994:	0e 9b       	mov	r11,r7
80008996:	0a 9c       	mov	r12,r5
80008998:	e0 a0 16 2e 	rcall	8000b5f4 <_fflush_r>
8000899c:	40 be       	lddsp	lr,sp[0x2c]
8000899e:	f9 be 01 ff 	movne	lr,-1
800089a2:	50 be       	stdsp	sp[0x2c],lr
800089a4:	fb 08 05 d0 	ld.sh	r8,sp[1488]
800089a8:	ed b8 00 06 	bld	r8,0x6
800089ac:	e0 81 0f 29 	brne	8000a7fe <_vfprintf_r+0x1f22>
800089b0:	82 68       	ld.sh	r8,r1[0xc]
800089b2:	a7 a8       	sbr	r8,0x6
800089b4:	a2 68       	st.h	r1[0xc],r8
800089b6:	e0 8f 0f 24 	bral	8000a7fe <_vfprintf_r+0x1f22>
800089ba:	30 08       	mov	r8,0
800089bc:	fb 48 06 b4 	st.w	sp[1716],r8
800089c0:	fb 48 06 90 	st.w	sp[1680],r8
800089c4:	fb 48 06 8c 	st.w	sp[1676],r8
800089c8:	fb 48 06 b0 	st.w	sp[1712],r8
800089cc:	30 08       	mov	r8,0
800089ce:	30 09       	mov	r9,0
800089d0:	50 a7       	stdsp	sp[0x28],r7
800089d2:	50 78       	stdsp	sp[0x1c],r8
800089d4:	fa c3 f9 e0 	sub	r3,sp,-1568
800089d8:	3f f8       	mov	r8,-1
800089da:	50 59       	stdsp	sp[0x14],r9
800089dc:	fb 43 06 88 	st.w	sp[1672],r3
800089e0:	fb 48 05 44 	st.w	sp[1348],r8
800089e4:	12 9c       	mov	r12,r9
800089e6:	50 69       	stdsp	sp[0x18],r9
800089e8:	50 d9       	stdsp	sp[0x34],r9
800089ea:	50 e9       	stdsp	sp[0x38],r9
800089ec:	50 b9       	stdsp	sp[0x2c],r9
800089ee:	12 97       	mov	r7,r9
800089f0:	0a 94       	mov	r4,r5
800089f2:	40 a2       	lddsp	r2,sp[0x28]
800089f4:	32 5a       	mov	r10,37
800089f6:	30 08       	mov	r8,0
800089f8:	c0 28       	rjmp	800089fc <_vfprintf_r+0x120>
800089fa:	2f f2       	sub	r2,-1
800089fc:	05 89       	ld.ub	r9,r2[0x0]
800089fe:	f0 09 18 00 	cp.b	r9,r8
80008a02:	5f 1b       	srne	r11
80008a04:	f4 09 18 00 	cp.b	r9,r10
80008a08:	5f 19       	srne	r9
80008a0a:	f3 eb 00 0b 	and	r11,r9,r11
80008a0e:	f0 0b 18 00 	cp.b	r11,r8
80008a12:	cf 41       	brne	800089fa <_vfprintf_r+0x11e>
80008a14:	40 ab       	lddsp	r11,sp[0x28]
80008a16:	e4 0b 01 06 	sub	r6,r2,r11
80008a1a:	c2 50       	breq	80008a64 <_vfprintf_r+0x188>
80008a1c:	fa f8 06 90 	ld.w	r8,sp[1680]
80008a20:	0c 08       	add	r8,r6
80008a22:	87 0b       	st.w	r3[0x0],r11
80008a24:	fb 48 06 90 	st.w	sp[1680],r8
80008a28:	87 16       	st.w	r3[0x4],r6
80008a2a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008a2e:	2f f8       	sub	r8,-1
80008a30:	fb 48 06 8c 	st.w	sp[1676],r8
80008a34:	58 78       	cp.w	r8,7
80008a36:	e0 89 00 0b 	brgt	80008a4c <_vfprintf_r+0x170>
80008a3a:	2f 83       	sub	r3,-8
80008a3c:	c1 18       	rjmp	80008a5e <_vfprintf_r+0x182>
80008a3e:	d7 03       	nop
80008a40:	80 02       	ld.sh	r2,r0[0x0]
80008a42:	f9 20 80 02 	ld.sb	r0,r12[-32766]
80008a46:	f9 40 80 02 	st.w	r12[-32766],r0
80008a4a:	f9 60 fa ca 	st.b	r12[-1334],r0
80008a4e:	f9 78 02 9b 	stcond	r12[667],r8
80008a52:	08 9c       	mov	r12,r4
80008a54:	c3 6f       	rcall	800088c0 <__sprint_r>
80008a56:	e0 81 0e ce 	brne	8000a7f2 <_vfprintf_r+0x1f16>
80008a5a:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a5e:	40 ba       	lddsp	r10,sp[0x2c]
80008a60:	0c 0a       	add	r10,r6
80008a62:	50 ba       	stdsp	sp[0x2c],r10
80008a64:	05 89       	ld.ub	r9,r2[0x0]
80008a66:	30 08       	mov	r8,0
80008a68:	f0 09 18 00 	cp.b	r9,r8
80008a6c:	e0 80 0e b2 	breq	8000a7d0 <_vfprintf_r+0x1ef4>
80008a70:	30 09       	mov	r9,0
80008a72:	fb 68 06 bb 	st.b	sp[1723],r8
80008a76:	0e 96       	mov	r6,r7
80008a78:	e4 c8 ff ff 	sub	r8,r2,-1
80008a7c:	3f fe       	mov	lr,-1
80008a7e:	50 93       	stdsp	sp[0x24],r3
80008a80:	50 41       	stdsp	sp[0x10],r1
80008a82:	0e 93       	mov	r3,r7
80008a84:	04 91       	mov	r1,r2
80008a86:	50 89       	stdsp	sp[0x20],r9
80008a88:	50 a8       	stdsp	sp[0x28],r8
80008a8a:	50 2e       	stdsp	sp[0x8],lr
80008a8c:	50 39       	stdsp	sp[0xc],r9
80008a8e:	12 95       	mov	r5,r9
80008a90:	12 90       	mov	r0,r9
80008a92:	10 97       	mov	r7,r8
80008a94:	08 92       	mov	r2,r4
80008a96:	c0 78       	rjmp	80008aa4 <_vfprintf_r+0x1c8>
80008a98:	3f fc       	mov	r12,-1
80008a9a:	08 97       	mov	r7,r4
80008a9c:	50 2c       	stdsp	sp[0x8],r12
80008a9e:	c0 38       	rjmp	80008aa4 <_vfprintf_r+0x1c8>
80008aa0:	30 0b       	mov	r11,0
80008aa2:	50 3b       	stdsp	sp[0xc],r11
80008aa4:	0f 38       	ld.ub	r8,r7++
80008aa6:	c0 28       	rjmp	80008aaa <_vfprintf_r+0x1ce>
80008aa8:	12 90       	mov	r0,r9
80008aaa:	f0 c9 00 20 	sub	r9,r8,32
80008aae:	e0 49 00 58 	cp.w	r9,88
80008ab2:	e0 8b 0a 36 	brhi	80009f1e <_vfprintf_r+0x1642>
80008ab6:	4d 9a       	lddpc	r10,80008c18 <_vfprintf_r+0x33c>
80008ab8:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80008abc:	50 a7       	stdsp	sp[0x28],r7
80008abe:	50 80       	stdsp	sp[0x20],r0
80008ac0:	0c 97       	mov	r7,r6
80008ac2:	04 94       	mov	r4,r2
80008ac4:	06 96       	mov	r6,r3
80008ac6:	02 92       	mov	r2,r1
80008ac8:	4d 59       	lddpc	r9,80008c1c <_vfprintf_r+0x340>
80008aca:	40 93       	lddsp	r3,sp[0x24]
80008acc:	10 90       	mov	r0,r8
80008ace:	40 41       	lddsp	r1,sp[0x10]
80008ad0:	50 d9       	stdsp	sp[0x34],r9
80008ad2:	e0 8f 08 95 	bral	80009bfc <_vfprintf_r+0x1320>
80008ad6:	30 08       	mov	r8,0
80008ad8:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80008adc:	f0 09 18 00 	cp.b	r9,r8
80008ae0:	ce 21       	brne	80008aa4 <_vfprintf_r+0x1c8>
80008ae2:	32 08       	mov	r8,32
80008ae4:	c6 e8       	rjmp	80008bc0 <_vfprintf_r+0x2e4>
80008ae6:	a1 a5       	sbr	r5,0x0
80008ae8:	cd eb       	rjmp	80008aa4 <_vfprintf_r+0x1c8>
80008aea:	0f 89       	ld.ub	r9,r7[0x0]
80008aec:	f2 c8 00 30 	sub	r8,r9,48
80008af0:	58 98       	cp.w	r8,9
80008af2:	e0 8b 00 1d 	brhi	80008b2c <_vfprintf_r+0x250>
80008af6:	ee c8 ff ff 	sub	r8,r7,-1
80008afa:	30 0b       	mov	r11,0
80008afc:	23 09       	sub	r9,48
80008afe:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80008b02:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80008b06:	11 39       	ld.ub	r9,r8++
80008b08:	f2 ca 00 30 	sub	r10,r9,48
80008b0c:	58 9a       	cp.w	r10,9
80008b0e:	fe 98 ff f7 	brls	80008afc <_vfprintf_r+0x220>
80008b12:	e0 49 00 24 	cp.w	r9,36
80008b16:	cc 51       	brne	80008aa0 <_vfprintf_r+0x1c4>
80008b18:	e0 4b 00 20 	cp.w	r11,32
80008b1c:	e0 89 0e 6a 	brgt	8000a7f0 <_vfprintf_r+0x1f14>
80008b20:	20 1b       	sub	r11,1
80008b22:	fa f9 06 b4 	ld.w	r9,sp[1716]
80008b26:	12 3b       	cp.w	r11,r9
80008b28:	c0 95       	brlt	80008b3a <_vfprintf_r+0x25e>
80008b2a:	c1 08       	rjmp	80008b4a <_vfprintf_r+0x26e>
80008b2c:	fa f9 06 b4 	ld.w	r9,sp[1716]
80008b30:	ec ca ff ff 	sub	r10,r6,-1
80008b34:	12 36       	cp.w	r6,r9
80008b36:	c1 f5       	brlt	80008b74 <_vfprintf_r+0x298>
80008b38:	c2 68       	rjmp	80008b84 <_vfprintf_r+0x2a8>
80008b3a:	fa ce f9 44 	sub	lr,sp,-1724
80008b3e:	10 97       	mov	r7,r8
80008b40:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80008b44:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80008b48:	c3 58       	rjmp	80008bb2 <_vfprintf_r+0x2d6>
80008b4a:	10 97       	mov	r7,r8
80008b4c:	fa c8 f9 50 	sub	r8,sp,-1712
80008b50:	1a d8       	st.w	--sp,r8
80008b52:	fa c8 fa b8 	sub	r8,sp,-1352
80008b56:	1a d8       	st.w	--sp,r8
80008b58:	fa c8 fb b4 	sub	r8,sp,-1100
80008b5c:	02 9a       	mov	r10,r1
80008b5e:	1a d8       	st.w	--sp,r8
80008b60:	04 9c       	mov	r12,r2
80008b62:	fa c8 f9 40 	sub	r8,sp,-1728
80008b66:	fa c9 ff b4 	sub	r9,sp,-76
80008b6a:	fe b0 fd 1b 	rcall	800085a0 <get_arg>
80008b6e:	2f dd       	sub	sp,-12
80008b70:	78 00       	ld.w	r0,r12[0x0]
80008b72:	c2 08       	rjmp	80008bb2 <_vfprintf_r+0x2d6>
80008b74:	fa cc f9 44 	sub	r12,sp,-1724
80008b78:	14 96       	mov	r6,r10
80008b7a:	f8 03 00 38 	add	r8,r12,r3<<0x3
80008b7e:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80008b82:	c1 88       	rjmp	80008bb2 <_vfprintf_r+0x2d6>
80008b84:	41 08       	lddsp	r8,sp[0x40]
80008b86:	59 f9       	cp.w	r9,31
80008b88:	e0 89 00 11 	brgt	80008baa <_vfprintf_r+0x2ce>
80008b8c:	f0 cb ff fc 	sub	r11,r8,-4
80008b90:	51 0b       	stdsp	sp[0x40],r11
80008b92:	70 00       	ld.w	r0,r8[0x0]
80008b94:	fa cb f9 44 	sub	r11,sp,-1724
80008b98:	f6 09 00 38 	add	r8,r11,r9<<0x3
80008b9c:	f1 40 fd 88 	st.w	r8[-632],r0
80008ba0:	2f f9       	sub	r9,-1
80008ba2:	14 96       	mov	r6,r10
80008ba4:	fb 49 06 b4 	st.w	sp[1716],r9
80008ba8:	c0 58       	rjmp	80008bb2 <_vfprintf_r+0x2d6>
80008baa:	70 00       	ld.w	r0,r8[0x0]
80008bac:	14 96       	mov	r6,r10
80008bae:	2f c8       	sub	r8,-4
80008bb0:	51 08       	stdsp	sp[0x40],r8
80008bb2:	58 00       	cp.w	r0,0
80008bb4:	fe 94 ff 78 	brge	80008aa4 <_vfprintf_r+0x1c8>
80008bb8:	5c 30       	neg	r0
80008bba:	a3 a5       	sbr	r5,0x2
80008bbc:	c7 4b       	rjmp	80008aa4 <_vfprintf_r+0x1c8>
80008bbe:	32 b8       	mov	r8,43
80008bc0:	fb 68 06 bb 	st.b	sp[1723],r8
80008bc4:	c7 0b       	rjmp	80008aa4 <_vfprintf_r+0x1c8>
80008bc6:	0f 38       	ld.ub	r8,r7++
80008bc8:	e0 48 00 2a 	cp.w	r8,42
80008bcc:	c0 30       	breq	80008bd2 <_vfprintf_r+0x2f6>
80008bce:	30 09       	mov	r9,0
80008bd0:	c7 d8       	rjmp	80008cca <_vfprintf_r+0x3ee>
80008bd2:	0f 88       	ld.ub	r8,r7[0x0]
80008bd4:	f0 c9 00 30 	sub	r9,r8,48
80008bd8:	58 99       	cp.w	r9,9
80008bda:	e0 8b 00 23 	brhi	80008c20 <_vfprintf_r+0x344>
80008bde:	ee c4 ff ff 	sub	r4,r7,-1
80008be2:	30 0b       	mov	r11,0
80008be4:	23 08       	sub	r8,48
80008be6:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80008bea:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80008bee:	09 38       	ld.ub	r8,r4++
80008bf0:	f0 c9 00 30 	sub	r9,r8,48
80008bf4:	58 99       	cp.w	r9,9
80008bf6:	fe 98 ff f7 	brls	80008be4 <_vfprintf_r+0x308>
80008bfa:	e0 48 00 24 	cp.w	r8,36
80008bfe:	fe 91 ff 51 	brne	80008aa0 <_vfprintf_r+0x1c4>
80008c02:	e0 4b 00 20 	cp.w	r11,32
80008c06:	e0 89 0d f5 	brgt	8000a7f0 <_vfprintf_r+0x1f14>
80008c0a:	20 1b       	sub	r11,1
80008c0c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c10:	10 3b       	cp.w	r11,r8
80008c12:	c0 e5       	brlt	80008c2e <_vfprintf_r+0x352>
80008c14:	c1 58       	rjmp	80008c3e <_vfprintf_r+0x362>
80008c16:	d7 03       	nop
80008c18:	80 02       	ld.sh	r2,r0[0x0]
80008c1a:	f5 78 80 02 	stcond	r10[-32766],r8
80008c1e:	f7 b4       	*unknown*
80008c20:	fa fa 06 b4 	ld.w	r10,sp[1716]
80008c24:	ec c9 ff ff 	sub	r9,r6,-1
80008c28:	14 36       	cp.w	r6,r10
80008c2a:	c1 f5       	brlt	80008c68 <_vfprintf_r+0x38c>
80008c2c:	c2 88       	rjmp	80008c7c <_vfprintf_r+0x3a0>
80008c2e:	fa ca f9 44 	sub	r10,sp,-1724
80008c32:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80008c36:	f6 fb fd 88 	ld.w	r11,r11[-632]
80008c3a:	50 2b       	stdsp	sp[0x8],r11
80008c3c:	c3 c8       	rjmp	80008cb4 <_vfprintf_r+0x3d8>
80008c3e:	fa c8 f9 50 	sub	r8,sp,-1712
80008c42:	1a d8       	st.w	--sp,r8
80008c44:	fa c8 fa b8 	sub	r8,sp,-1352
80008c48:	1a d8       	st.w	--sp,r8
80008c4a:	fa c8 fb b4 	sub	r8,sp,-1100
80008c4e:	02 9a       	mov	r10,r1
80008c50:	1a d8       	st.w	--sp,r8
80008c52:	04 9c       	mov	r12,r2
80008c54:	fa c8 f9 40 	sub	r8,sp,-1728
80008c58:	fa c9 ff b4 	sub	r9,sp,-76
80008c5c:	fe b0 fc a2 	rcall	800085a0 <get_arg>
80008c60:	2f dd       	sub	sp,-12
80008c62:	78 0c       	ld.w	r12,r12[0x0]
80008c64:	50 2c       	stdsp	sp[0x8],r12
80008c66:	c2 78       	rjmp	80008cb4 <_vfprintf_r+0x3d8>
80008c68:	12 96       	mov	r6,r9
80008c6a:	0e 94       	mov	r4,r7
80008c6c:	fa c9 f9 44 	sub	r9,sp,-1724
80008c70:	f2 03 00 38 	add	r8,r9,r3<<0x3
80008c74:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80008c78:	50 28       	stdsp	sp[0x8],r8
80008c7a:	c1 d8       	rjmp	80008cb4 <_vfprintf_r+0x3d8>
80008c7c:	41 08       	lddsp	r8,sp[0x40]
80008c7e:	59 fa       	cp.w	r10,31
80008c80:	e0 89 00 14 	brgt	80008ca8 <_vfprintf_r+0x3cc>
80008c84:	f0 cb ff fc 	sub	r11,r8,-4
80008c88:	70 08       	ld.w	r8,r8[0x0]
80008c8a:	51 0b       	stdsp	sp[0x40],r11
80008c8c:	50 28       	stdsp	sp[0x8],r8
80008c8e:	fa c6 f9 44 	sub	r6,sp,-1724
80008c92:	40 2e       	lddsp	lr,sp[0x8]
80008c94:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80008c98:	f1 4e fd 88 	st.w	r8[-632],lr
80008c9c:	2f fa       	sub	r10,-1
80008c9e:	0e 94       	mov	r4,r7
80008ca0:	fb 4a 06 b4 	st.w	sp[1716],r10
80008ca4:	12 96       	mov	r6,r9
80008ca6:	c0 78       	rjmp	80008cb4 <_vfprintf_r+0x3d8>
80008ca8:	70 0c       	ld.w	r12,r8[0x0]
80008caa:	0e 94       	mov	r4,r7
80008cac:	2f c8       	sub	r8,-4
80008cae:	50 2c       	stdsp	sp[0x8],r12
80008cb0:	12 96       	mov	r6,r9
80008cb2:	51 08       	stdsp	sp[0x40],r8
80008cb4:	40 2b       	lddsp	r11,sp[0x8]
80008cb6:	58 0b       	cp.w	r11,0
80008cb8:	fe 95 fe f0 	brlt	80008a98 <_vfprintf_r+0x1bc>
80008cbc:	08 97       	mov	r7,r4
80008cbe:	cf 3a       	rjmp	80008aa4 <_vfprintf_r+0x1c8>
80008cc0:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008cc4:	0f 38       	ld.ub	r8,r7++
80008cc6:	f4 09 00 19 	add	r9,r10,r9<<0x1
80008cca:	f0 ca 00 30 	sub	r10,r8,48
80008cce:	58 9a       	cp.w	r10,9
80008cd0:	fe 98 ff f8 	brls	80008cc0 <_vfprintf_r+0x3e4>
80008cd4:	3f fa       	mov	r10,-1
80008cd6:	f2 0a 0c 49 	max	r9,r9,r10
80008cda:	50 29       	stdsp	sp[0x8],r9
80008cdc:	ce 7a       	rjmp	80008aaa <_vfprintf_r+0x1ce>
80008cde:	a7 b5       	sbr	r5,0x7
80008ce0:	ce 2a       	rjmp	80008aa4 <_vfprintf_r+0x1c8>
80008ce2:	30 09       	mov	r9,0
80008ce4:	23 08       	sub	r8,48
80008ce6:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008cea:	f0 09 00 19 	add	r9,r8,r9<<0x1
80008cee:	0f 38       	ld.ub	r8,r7++
80008cf0:	f0 ca 00 30 	sub	r10,r8,48
80008cf4:	58 9a       	cp.w	r10,9
80008cf6:	fe 98 ff f7 	brls	80008ce4 <_vfprintf_r+0x408>
80008cfa:	e0 48 00 24 	cp.w	r8,36
80008cfe:	fe 91 fe d5 	brne	80008aa8 <_vfprintf_r+0x1cc>
80008d02:	e0 49 00 20 	cp.w	r9,32
80008d06:	e0 89 0d 75 	brgt	8000a7f0 <_vfprintf_r+0x1f14>
80008d0a:	f2 c3 00 01 	sub	r3,r9,1
80008d0e:	30 19       	mov	r9,1
80008d10:	50 39       	stdsp	sp[0xc],r9
80008d12:	cc 9a       	rjmp	80008aa4 <_vfprintf_r+0x1c8>
80008d14:	a3 b5       	sbr	r5,0x3
80008d16:	cc 7a       	rjmp	80008aa4 <_vfprintf_r+0x1c8>
80008d18:	a7 a5       	sbr	r5,0x6
80008d1a:	cc 5a       	rjmp	80008aa4 <_vfprintf_r+0x1c8>
80008d1c:	0a 98       	mov	r8,r5
80008d1e:	a5 b5       	sbr	r5,0x5
80008d20:	a5 a8       	sbr	r8,0x4
80008d22:	0f 89       	ld.ub	r9,r7[0x0]
80008d24:	36 ce       	mov	lr,108
80008d26:	fc 09 18 00 	cp.b	r9,lr
80008d2a:	f7 b7 00 ff 	subeq	r7,-1
80008d2e:	f0 05 17 10 	movne	r5,r8
80008d32:	cb 9a       	rjmp	80008aa4 <_vfprintf_r+0x1c8>
80008d34:	a5 b5       	sbr	r5,0x5
80008d36:	cb 7a       	rjmp	80008aa4 <_vfprintf_r+0x1c8>
80008d38:	50 a7       	stdsp	sp[0x28],r7
80008d3a:	50 80       	stdsp	sp[0x20],r0
80008d3c:	0c 97       	mov	r7,r6
80008d3e:	10 90       	mov	r0,r8
80008d40:	06 96       	mov	r6,r3
80008d42:	04 94       	mov	r4,r2
80008d44:	40 93       	lddsp	r3,sp[0x24]
80008d46:	02 92       	mov	r2,r1
80008d48:	0e 99       	mov	r9,r7
80008d4a:	40 41       	lddsp	r1,sp[0x10]
80008d4c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d50:	40 3c       	lddsp	r12,sp[0xc]
80008d52:	58 0c       	cp.w	r12,0
80008d54:	c1 d0       	breq	80008d8e <_vfprintf_r+0x4b2>
80008d56:	10 36       	cp.w	r6,r8
80008d58:	c0 64       	brge	80008d64 <_vfprintf_r+0x488>
80008d5a:	fa cb f9 44 	sub	r11,sp,-1724
80008d5e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d62:	c1 d8       	rjmp	80008d9c <_vfprintf_r+0x4c0>
80008d64:	fa c8 f9 50 	sub	r8,sp,-1712
80008d68:	1a d8       	st.w	--sp,r8
80008d6a:	fa c8 fa b8 	sub	r8,sp,-1352
80008d6e:	1a d8       	st.w	--sp,r8
80008d70:	fa c8 fb b4 	sub	r8,sp,-1100
80008d74:	1a d8       	st.w	--sp,r8
80008d76:	fa c8 f9 40 	sub	r8,sp,-1728
80008d7a:	fa c9 ff b4 	sub	r9,sp,-76
80008d7e:	04 9a       	mov	r10,r2
80008d80:	0c 9b       	mov	r11,r6
80008d82:	08 9c       	mov	r12,r4
80008d84:	fe b0 fc 0e 	rcall	800085a0 <get_arg>
80008d88:	2f dd       	sub	sp,-12
80008d8a:	19 b8       	ld.ub	r8,r12[0x3]
80008d8c:	c2 28       	rjmp	80008dd0 <_vfprintf_r+0x4f4>
80008d8e:	2f f7       	sub	r7,-1
80008d90:	10 39       	cp.w	r9,r8
80008d92:	c0 84       	brge	80008da2 <_vfprintf_r+0x4c6>
80008d94:	fa ca f9 44 	sub	r10,sp,-1724
80008d98:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008d9c:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80008da0:	c1 88       	rjmp	80008dd0 <_vfprintf_r+0x4f4>
80008da2:	41 09       	lddsp	r9,sp[0x40]
80008da4:	59 f8       	cp.w	r8,31
80008da6:	e0 89 00 12 	brgt	80008dca <_vfprintf_r+0x4ee>
80008daa:	f2 ca ff fc 	sub	r10,r9,-4
80008dae:	51 0a       	stdsp	sp[0x40],r10
80008db0:	72 09       	ld.w	r9,r9[0x0]
80008db2:	fa c6 f9 44 	sub	r6,sp,-1724
80008db6:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008dba:	2f f8       	sub	r8,-1
80008dbc:	f5 49 fd 88 	st.w	r10[-632],r9
80008dc0:	fb 48 06 b4 	st.w	sp[1716],r8
80008dc4:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80008dc8:	c0 48       	rjmp	80008dd0 <_vfprintf_r+0x4f4>
80008dca:	13 b8       	ld.ub	r8,r9[0x3]
80008dcc:	2f c9       	sub	r9,-4
80008dce:	51 09       	stdsp	sp[0x40],r9
80008dd0:	fb 68 06 60 	st.b	sp[1632],r8
80008dd4:	30 0e       	mov	lr,0
80008dd6:	30 08       	mov	r8,0
80008dd8:	30 12       	mov	r2,1
80008dda:	fb 68 06 bb 	st.b	sp[1723],r8
80008dde:	50 2e       	stdsp	sp[0x8],lr
80008de0:	e0 8f 08 b1 	bral	80009f42 <_vfprintf_r+0x1666>
80008de4:	50 a7       	stdsp	sp[0x28],r7
80008de6:	50 80       	stdsp	sp[0x20],r0
80008de8:	0c 97       	mov	r7,r6
80008dea:	04 94       	mov	r4,r2
80008dec:	06 96       	mov	r6,r3
80008dee:	02 92       	mov	r2,r1
80008df0:	40 93       	lddsp	r3,sp[0x24]
80008df2:	10 90       	mov	r0,r8
80008df4:	40 41       	lddsp	r1,sp[0x10]
80008df6:	a5 a5       	sbr	r5,0x4
80008df8:	c0 a8       	rjmp	80008e0c <_vfprintf_r+0x530>
80008dfa:	50 a7       	stdsp	sp[0x28],r7
80008dfc:	50 80       	stdsp	sp[0x20],r0
80008dfe:	0c 97       	mov	r7,r6
80008e00:	04 94       	mov	r4,r2
80008e02:	06 96       	mov	r6,r3
80008e04:	02 92       	mov	r2,r1
80008e06:	40 93       	lddsp	r3,sp[0x24]
80008e08:	10 90       	mov	r0,r8
80008e0a:	40 41       	lddsp	r1,sp[0x10]
80008e0c:	ed b5 00 05 	bld	r5,0x5
80008e10:	c5 11       	brne	80008eb2 <_vfprintf_r+0x5d6>
80008e12:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e16:	40 3c       	lddsp	r12,sp[0xc]
80008e18:	58 0c       	cp.w	r12,0
80008e1a:	c1 e0       	breq	80008e56 <_vfprintf_r+0x57a>
80008e1c:	10 36       	cp.w	r6,r8
80008e1e:	c0 64       	brge	80008e2a <_vfprintf_r+0x54e>
80008e20:	fa cb f9 44 	sub	r11,sp,-1724
80008e24:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e28:	c2 08       	rjmp	80008e68 <_vfprintf_r+0x58c>
80008e2a:	fa c8 f9 50 	sub	r8,sp,-1712
80008e2e:	1a d8       	st.w	--sp,r8
80008e30:	fa c8 fa b8 	sub	r8,sp,-1352
80008e34:	0c 9b       	mov	r11,r6
80008e36:	1a d8       	st.w	--sp,r8
80008e38:	fa c8 fb b4 	sub	r8,sp,-1100
80008e3c:	1a d8       	st.w	--sp,r8
80008e3e:	fa c9 ff b4 	sub	r9,sp,-76
80008e42:	fa c8 f9 40 	sub	r8,sp,-1728
80008e46:	04 9a       	mov	r10,r2
80008e48:	08 9c       	mov	r12,r4
80008e4a:	fe b0 fb ab 	rcall	800085a0 <get_arg>
80008e4e:	2f dd       	sub	sp,-12
80008e50:	78 1b       	ld.w	r11,r12[0x4]
80008e52:	78 09       	ld.w	r9,r12[0x0]
80008e54:	c2 b8       	rjmp	80008eaa <_vfprintf_r+0x5ce>
80008e56:	ee ca ff ff 	sub	r10,r7,-1
80008e5a:	10 37       	cp.w	r7,r8
80008e5c:	c0 b4       	brge	80008e72 <_vfprintf_r+0x596>
80008e5e:	fa c9 f9 44 	sub	r9,sp,-1724
80008e62:	14 97       	mov	r7,r10
80008e64:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008e68:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008e6c:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008e70:	c1 d8       	rjmp	80008eaa <_vfprintf_r+0x5ce>
80008e72:	41 09       	lddsp	r9,sp[0x40]
80008e74:	59 f8       	cp.w	r8,31
80008e76:	e0 89 00 14 	brgt	80008e9e <_vfprintf_r+0x5c2>
80008e7a:	f2 cb ff f8 	sub	r11,r9,-8
80008e7e:	51 0b       	stdsp	sp[0x40],r11
80008e80:	fa c6 f9 44 	sub	r6,sp,-1724
80008e84:	72 1b       	ld.w	r11,r9[0x4]
80008e86:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80008e8a:	72 09       	ld.w	r9,r9[0x0]
80008e8c:	f9 4b fd 8c 	st.w	r12[-628],r11
80008e90:	f9 49 fd 88 	st.w	r12[-632],r9
80008e94:	2f f8       	sub	r8,-1
80008e96:	14 97       	mov	r7,r10
80008e98:	fb 48 06 b4 	st.w	sp[1716],r8
80008e9c:	c0 78       	rjmp	80008eaa <_vfprintf_r+0x5ce>
80008e9e:	f2 c8 ff f8 	sub	r8,r9,-8
80008ea2:	72 1b       	ld.w	r11,r9[0x4]
80008ea4:	14 97       	mov	r7,r10
80008ea6:	51 08       	stdsp	sp[0x40],r8
80008ea8:	72 09       	ld.w	r9,r9[0x0]
80008eaa:	16 98       	mov	r8,r11
80008eac:	fa e9 00 00 	st.d	sp[0],r8
80008eb0:	ca e8       	rjmp	8000900c <_vfprintf_r+0x730>
80008eb2:	ed b5 00 04 	bld	r5,0x4
80008eb6:	c1 71       	brne	80008ee4 <_vfprintf_r+0x608>
80008eb8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ebc:	40 3e       	lddsp	lr,sp[0xc]
80008ebe:	58 0e       	cp.w	lr,0
80008ec0:	c0 80       	breq	80008ed0 <_vfprintf_r+0x5f4>
80008ec2:	10 36       	cp.w	r6,r8
80008ec4:	c6 94       	brge	80008f96 <_vfprintf_r+0x6ba>
80008ec6:	fa cc f9 44 	sub	r12,sp,-1724
80008eca:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008ece:	c8 28       	rjmp	80008fd2 <_vfprintf_r+0x6f6>
80008ed0:	ee ca ff ff 	sub	r10,r7,-1
80008ed4:	10 37       	cp.w	r7,r8
80008ed6:	e0 84 00 81 	brge	80008fd8 <_vfprintf_r+0x6fc>
80008eda:	fa cb f9 44 	sub	r11,sp,-1724
80008ede:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008ee2:	c7 78       	rjmp	80008fd0 <_vfprintf_r+0x6f4>
80008ee4:	ed b5 00 06 	bld	r5,0x6
80008ee8:	c4 b1       	brne	80008f7e <_vfprintf_r+0x6a2>
80008eea:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008eee:	40 3c       	lddsp	r12,sp[0xc]
80008ef0:	58 0c       	cp.w	r12,0
80008ef2:	c1 d0       	breq	80008f2c <_vfprintf_r+0x650>
80008ef4:	10 36       	cp.w	r6,r8
80008ef6:	c0 64       	brge	80008f02 <_vfprintf_r+0x626>
80008ef8:	fa cb f9 44 	sub	r11,sp,-1724
80008efc:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f00:	c1 f8       	rjmp	80008f3e <_vfprintf_r+0x662>
80008f02:	fa c8 f9 50 	sub	r8,sp,-1712
80008f06:	1a d8       	st.w	--sp,r8
80008f08:	fa c8 fa b8 	sub	r8,sp,-1352
80008f0c:	1a d8       	st.w	--sp,r8
80008f0e:	fa c8 fb b4 	sub	r8,sp,-1100
80008f12:	1a d8       	st.w	--sp,r8
80008f14:	fa c8 f9 40 	sub	r8,sp,-1728
80008f18:	fa c9 ff b4 	sub	r9,sp,-76
80008f1c:	04 9a       	mov	r10,r2
80008f1e:	0c 9b       	mov	r11,r6
80008f20:	08 9c       	mov	r12,r4
80008f22:	fe b0 fb 3f 	rcall	800085a0 <get_arg>
80008f26:	2f dd       	sub	sp,-12
80008f28:	98 18       	ld.sh	r8,r12[0x2]
80008f2a:	c2 68       	rjmp	80008f76 <_vfprintf_r+0x69a>
80008f2c:	ee ca ff ff 	sub	r10,r7,-1
80008f30:	10 37       	cp.w	r7,r8
80008f32:	c0 94       	brge	80008f44 <_vfprintf_r+0x668>
80008f34:	fa c9 f9 44 	sub	r9,sp,-1724
80008f38:	14 97       	mov	r7,r10
80008f3a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008f3e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008f42:	c1 a8       	rjmp	80008f76 <_vfprintf_r+0x69a>
80008f44:	41 09       	lddsp	r9,sp[0x40]
80008f46:	59 f8       	cp.w	r8,31
80008f48:	e0 89 00 13 	brgt	80008f6e <_vfprintf_r+0x692>
80008f4c:	f2 cb ff fc 	sub	r11,r9,-4
80008f50:	51 0b       	stdsp	sp[0x40],r11
80008f52:	72 09       	ld.w	r9,r9[0x0]
80008f54:	fa c6 f9 44 	sub	r6,sp,-1724
80008f58:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008f5c:	2f f8       	sub	r8,-1
80008f5e:	f7 49 fd 88 	st.w	r11[-632],r9
80008f62:	fb 48 06 b4 	st.w	sp[1716],r8
80008f66:	14 97       	mov	r7,r10
80008f68:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008f6c:	c0 58       	rjmp	80008f76 <_vfprintf_r+0x69a>
80008f6e:	92 18       	ld.sh	r8,r9[0x2]
80008f70:	14 97       	mov	r7,r10
80008f72:	2f c9       	sub	r9,-4
80008f74:	51 09       	stdsp	sp[0x40],r9
80008f76:	50 18       	stdsp	sp[0x4],r8
80008f78:	bf 58       	asr	r8,0x1f
80008f7a:	50 08       	stdsp	sp[0x0],r8
80008f7c:	c4 88       	rjmp	8000900c <_vfprintf_r+0x730>
80008f7e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f82:	40 3c       	lddsp	r12,sp[0xc]
80008f84:	58 0c       	cp.w	r12,0
80008f86:	c1 d0       	breq	80008fc0 <_vfprintf_r+0x6e4>
80008f88:	10 36       	cp.w	r6,r8
80008f8a:	c0 64       	brge	80008f96 <_vfprintf_r+0x6ba>
80008f8c:	fa cb f9 44 	sub	r11,sp,-1724
80008f90:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f94:	c1 f8       	rjmp	80008fd2 <_vfprintf_r+0x6f6>
80008f96:	fa c8 f9 50 	sub	r8,sp,-1712
80008f9a:	1a d8       	st.w	--sp,r8
80008f9c:	fa c8 fa b8 	sub	r8,sp,-1352
80008fa0:	0c 9b       	mov	r11,r6
80008fa2:	1a d8       	st.w	--sp,r8
80008fa4:	fa c8 fb b4 	sub	r8,sp,-1100
80008fa8:	04 9a       	mov	r10,r2
80008faa:	1a d8       	st.w	--sp,r8
80008fac:	08 9c       	mov	r12,r4
80008fae:	fa c8 f9 40 	sub	r8,sp,-1728
80008fb2:	fa c9 ff b4 	sub	r9,sp,-76
80008fb6:	fe b0 fa f5 	rcall	800085a0 <get_arg>
80008fba:	2f dd       	sub	sp,-12
80008fbc:	78 0b       	ld.w	r11,r12[0x0]
80008fbe:	c2 48       	rjmp	80009006 <_vfprintf_r+0x72a>
80008fc0:	ee ca ff ff 	sub	r10,r7,-1
80008fc4:	10 37       	cp.w	r7,r8
80008fc6:	c0 94       	brge	80008fd8 <_vfprintf_r+0x6fc>
80008fc8:	fa c9 f9 44 	sub	r9,sp,-1724
80008fcc:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008fd0:	14 97       	mov	r7,r10
80008fd2:	ec fb fd 88 	ld.w	r11,r6[-632]
80008fd6:	c1 88       	rjmp	80009006 <_vfprintf_r+0x72a>
80008fd8:	41 09       	lddsp	r9,sp[0x40]
80008fda:	59 f8       	cp.w	r8,31
80008fdc:	e0 89 00 11 	brgt	80008ffe <_vfprintf_r+0x722>
80008fe0:	f2 cb ff fc 	sub	r11,r9,-4
80008fe4:	51 0b       	stdsp	sp[0x40],r11
80008fe6:	fa c6 f9 44 	sub	r6,sp,-1724
80008fea:	72 0b       	ld.w	r11,r9[0x0]
80008fec:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008ff0:	f3 4b fd 88 	st.w	r9[-632],r11
80008ff4:	2f f8       	sub	r8,-1
80008ff6:	14 97       	mov	r7,r10
80008ff8:	fb 48 06 b4 	st.w	sp[1716],r8
80008ffc:	c0 58       	rjmp	80009006 <_vfprintf_r+0x72a>
80008ffe:	72 0b       	ld.w	r11,r9[0x0]
80009000:	14 97       	mov	r7,r10
80009002:	2f c9       	sub	r9,-4
80009004:	51 09       	stdsp	sp[0x40],r9
80009006:	50 1b       	stdsp	sp[0x4],r11
80009008:	bf 5b       	asr	r11,0x1f
8000900a:	50 0b       	stdsp	sp[0x0],r11
8000900c:	fa ea 00 00 	ld.d	r10,sp[0]
80009010:	58 0a       	cp.w	r10,0
80009012:	5c 2b       	cpc	r11
80009014:	c0 e4       	brge	80009030 <_vfprintf_r+0x754>
80009016:	30 08       	mov	r8,0
80009018:	fa ea 00 00 	ld.d	r10,sp[0]
8000901c:	30 09       	mov	r9,0
8000901e:	f0 0a 01 0a 	sub	r10,r8,r10
80009022:	f2 0b 01 4b 	sbc	r11,r9,r11
80009026:	32 d8       	mov	r8,45
80009028:	fa eb 00 00 	st.d	sp[0],r10
8000902c:	fb 68 06 bb 	st.b	sp[1723],r8
80009030:	30 18       	mov	r8,1
80009032:	e0 8f 06 fe 	bral	80009e2e <_vfprintf_r+0x1552>
80009036:	50 a7       	stdsp	sp[0x28],r7
80009038:	50 80       	stdsp	sp[0x20],r0
8000903a:	0c 97       	mov	r7,r6
8000903c:	04 94       	mov	r4,r2
8000903e:	06 96       	mov	r6,r3
80009040:	02 92       	mov	r2,r1
80009042:	40 93       	lddsp	r3,sp[0x24]
80009044:	10 90       	mov	r0,r8
80009046:	40 41       	lddsp	r1,sp[0x10]
80009048:	0e 99       	mov	r9,r7
8000904a:	ed b5 00 03 	bld	r5,0x3
8000904e:	c4 11       	brne	800090d0 <_vfprintf_r+0x7f4>
80009050:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009054:	40 3a       	lddsp	r10,sp[0xc]
80009056:	58 0a       	cp.w	r10,0
80009058:	c1 90       	breq	8000908a <_vfprintf_r+0x7ae>
8000905a:	10 36       	cp.w	r6,r8
8000905c:	c6 45       	brlt	80009124 <_vfprintf_r+0x848>
8000905e:	fa c8 f9 50 	sub	r8,sp,-1712
80009062:	1a d8       	st.w	--sp,r8
80009064:	fa c8 fa b8 	sub	r8,sp,-1352
80009068:	1a d8       	st.w	--sp,r8
8000906a:	fa c8 fb b4 	sub	r8,sp,-1100
8000906e:	0c 9b       	mov	r11,r6
80009070:	1a d8       	st.w	--sp,r8
80009072:	04 9a       	mov	r10,r2
80009074:	fa c8 f9 40 	sub	r8,sp,-1728
80009078:	fa c9 ff b4 	sub	r9,sp,-76
8000907c:	08 9c       	mov	r12,r4
8000907e:	fe b0 fa 91 	rcall	800085a0 <get_arg>
80009082:	2f dd       	sub	sp,-12
80009084:	78 16       	ld.w	r6,r12[0x4]
80009086:	50 76       	stdsp	sp[0x1c],r6
80009088:	c4 88       	rjmp	80009118 <_vfprintf_r+0x83c>
8000908a:	2f f7       	sub	r7,-1
8000908c:	10 39       	cp.w	r9,r8
8000908e:	c0 c4       	brge	800090a6 <_vfprintf_r+0x7ca>
80009090:	fa ce f9 44 	sub	lr,sp,-1724
80009094:	fc 06 00 36 	add	r6,lr,r6<<0x3
80009098:	ec fc fd 8c 	ld.w	r12,r6[-628]
8000909c:	50 7c       	stdsp	sp[0x1c],r12
8000909e:	ec f6 fd 88 	ld.w	r6,r6[-632]
800090a2:	50 56       	stdsp	sp[0x14],r6
800090a4:	c6 68       	rjmp	80009170 <_vfprintf_r+0x894>
800090a6:	41 09       	lddsp	r9,sp[0x40]
800090a8:	59 f8       	cp.w	r8,31
800090aa:	e0 89 00 10 	brgt	800090ca <_vfprintf_r+0x7ee>
800090ae:	f2 ca ff f8 	sub	r10,r9,-8
800090b2:	72 1b       	ld.w	r11,r9[0x4]
800090b4:	51 0a       	stdsp	sp[0x40],r10
800090b6:	72 09       	ld.w	r9,r9[0x0]
800090b8:	fa ca f9 44 	sub	r10,sp,-1724
800090bc:	50 7b       	stdsp	sp[0x1c],r11
800090be:	50 59       	stdsp	sp[0x14],r9
800090c0:	f4 08 00 39 	add	r9,r10,r8<<0x3
800090c4:	40 5b       	lddsp	r11,sp[0x14]
800090c6:	40 7a       	lddsp	r10,sp[0x1c]
800090c8:	c4 78       	rjmp	80009156 <_vfprintf_r+0x87a>
800090ca:	72 18       	ld.w	r8,r9[0x4]
800090cc:	50 78       	stdsp	sp[0x1c],r8
800090ce:	c4 c8       	rjmp	80009166 <_vfprintf_r+0x88a>
800090d0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800090d4:	40 3e       	lddsp	lr,sp[0xc]
800090d6:	58 0e       	cp.w	lr,0
800090d8:	c2 30       	breq	8000911e <_vfprintf_r+0x842>
800090da:	10 36       	cp.w	r6,r8
800090dc:	c0 94       	brge	800090ee <_vfprintf_r+0x812>
800090de:	fa cc f9 44 	sub	r12,sp,-1724
800090e2:	f8 06 00 36 	add	r6,r12,r6<<0x3
800090e6:	ec fb fd 8c 	ld.w	r11,r6[-628]
800090ea:	50 7b       	stdsp	sp[0x1c],r11
800090ec:	cd 9b       	rjmp	8000909e <_vfprintf_r+0x7c2>
800090ee:	fa c8 f9 50 	sub	r8,sp,-1712
800090f2:	1a d8       	st.w	--sp,r8
800090f4:	fa c8 fa b8 	sub	r8,sp,-1352
800090f8:	04 9a       	mov	r10,r2
800090fa:	1a d8       	st.w	--sp,r8
800090fc:	fa c8 fb b4 	sub	r8,sp,-1100
80009100:	0c 9b       	mov	r11,r6
80009102:	1a d8       	st.w	--sp,r8
80009104:	08 9c       	mov	r12,r4
80009106:	fa c8 f9 40 	sub	r8,sp,-1728
8000910a:	fa c9 ff b4 	sub	r9,sp,-76
8000910e:	fe b0 fa 49 	rcall	800085a0 <get_arg>
80009112:	2f dd       	sub	sp,-12
80009114:	78 1a       	ld.w	r10,r12[0x4]
80009116:	50 7a       	stdsp	sp[0x1c],r10
80009118:	78 0c       	ld.w	r12,r12[0x0]
8000911a:	50 5c       	stdsp	sp[0x14],r12
8000911c:	c2 a8       	rjmp	80009170 <_vfprintf_r+0x894>
8000911e:	2f f7       	sub	r7,-1
80009120:	10 39       	cp.w	r9,r8
80009122:	c0 94       	brge	80009134 <_vfprintf_r+0x858>
80009124:	fa c9 f9 44 	sub	r9,sp,-1724
80009128:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000912c:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80009130:	50 78       	stdsp	sp[0x1c],r8
80009132:	cb 6b       	rjmp	8000909e <_vfprintf_r+0x7c2>
80009134:	41 09       	lddsp	r9,sp[0x40]
80009136:	59 f8       	cp.w	r8,31
80009138:	e0 89 00 15 	brgt	80009162 <_vfprintf_r+0x886>
8000913c:	f2 ca ff f8 	sub	r10,r9,-8
80009140:	72 16       	ld.w	r6,r9[0x4]
80009142:	72 09       	ld.w	r9,r9[0x0]
80009144:	51 0a       	stdsp	sp[0x40],r10
80009146:	50 59       	stdsp	sp[0x14],r9
80009148:	fa ce f9 44 	sub	lr,sp,-1724
8000914c:	50 76       	stdsp	sp[0x1c],r6
8000914e:	fc 08 00 39 	add	r9,lr,r8<<0x3
80009152:	40 5b       	lddsp	r11,sp[0x14]
80009154:	0c 9a       	mov	r10,r6
80009156:	f2 eb fd 88 	st.d	r9[-632],r10
8000915a:	2f f8       	sub	r8,-1
8000915c:	fb 48 06 b4 	st.w	sp[1716],r8
80009160:	c0 88       	rjmp	80009170 <_vfprintf_r+0x894>
80009162:	72 1c       	ld.w	r12,r9[0x4]
80009164:	50 7c       	stdsp	sp[0x1c],r12
80009166:	f2 c8 ff f8 	sub	r8,r9,-8
8000916a:	51 08       	stdsp	sp[0x40],r8
8000916c:	72 09       	ld.w	r9,r9[0x0]
8000916e:	50 59       	stdsp	sp[0x14],r9
80009170:	40 5b       	lddsp	r11,sp[0x14]
80009172:	40 7a       	lddsp	r10,sp[0x1c]
80009174:	e0 a0 19 60 	rcall	8000c434 <__isinfd>
80009178:	18 96       	mov	r6,r12
8000917a:	c1 50       	breq	800091a4 <_vfprintf_r+0x8c8>
8000917c:	30 08       	mov	r8,0
8000917e:	30 09       	mov	r9,0
80009180:	40 5b       	lddsp	r11,sp[0x14]
80009182:	40 7a       	lddsp	r10,sp[0x1c]
80009184:	fe b0 f0 c0 	rcall	80007304 <__avr32_f64_cmp_lt>
80009188:	c0 40       	breq	80009190 <_vfprintf_r+0x8b4>
8000918a:	32 d8       	mov	r8,45
8000918c:	fb 68 06 bb 	st.b	sp[1723],r8
80009190:	4d 18       	lddpc	r8,800092d4 <_vfprintf_r+0x9f8>
80009192:	4d 26       	lddpc	r6,800092d8 <_vfprintf_r+0x9fc>
80009194:	a7 d5       	cbr	r5,0x7
80009196:	e0 40 00 47 	cp.w	r0,71
8000919a:	f0 06 17 a0 	movle	r6,r8
8000919e:	30 32       	mov	r2,3
800091a0:	e0 8f 06 d4 	bral	80009f48 <_vfprintf_r+0x166c>
800091a4:	40 5b       	lddsp	r11,sp[0x14]
800091a6:	40 7a       	lddsp	r10,sp[0x1c]
800091a8:	e0 a0 19 5b 	rcall	8000c45e <__isnand>
800091ac:	c0 c0       	breq	800091c4 <_vfprintf_r+0x8e8>
800091ae:	50 26       	stdsp	sp[0x8],r6
800091b0:	4c b8       	lddpc	r8,800092dc <_vfprintf_r+0xa00>
800091b2:	4c c6       	lddpc	r6,800092e0 <_vfprintf_r+0xa04>
800091b4:	a7 d5       	cbr	r5,0x7
800091b6:	e0 40 00 47 	cp.w	r0,71
800091ba:	f0 06 17 a0 	movle	r6,r8
800091be:	30 32       	mov	r2,3
800091c0:	e0 8f 06 ca 	bral	80009f54 <_vfprintf_r+0x1678>
800091c4:	40 2a       	lddsp	r10,sp[0x8]
800091c6:	5b fa       	cp.w	r10,-1
800091c8:	c0 41       	brne	800091d0 <_vfprintf_r+0x8f4>
800091ca:	30 69       	mov	r9,6
800091cc:	50 29       	stdsp	sp[0x8],r9
800091ce:	c1 18       	rjmp	800091f0 <_vfprintf_r+0x914>
800091d0:	e0 40 00 47 	cp.w	r0,71
800091d4:	5f 09       	sreq	r9
800091d6:	e0 40 00 67 	cp.w	r0,103
800091da:	5f 08       	sreq	r8
800091dc:	f3 e8 10 08 	or	r8,r9,r8
800091e0:	f8 08 18 00 	cp.b	r8,r12
800091e4:	c0 60       	breq	800091f0 <_vfprintf_r+0x914>
800091e6:	40 28       	lddsp	r8,sp[0x8]
800091e8:	58 08       	cp.w	r8,0
800091ea:	f9 b8 00 01 	moveq	r8,1
800091ee:	50 28       	stdsp	sp[0x8],r8
800091f0:	40 78       	lddsp	r8,sp[0x1c]
800091f2:	40 59       	lddsp	r9,sp[0x14]
800091f4:	fa e9 06 94 	st.d	sp[1684],r8
800091f8:	a9 a5       	sbr	r5,0x8
800091fa:	fa f8 06 94 	ld.w	r8,sp[1684]
800091fe:	58 08       	cp.w	r8,0
80009200:	c0 65       	brlt	8000920c <_vfprintf_r+0x930>
80009202:	40 5e       	lddsp	lr,sp[0x14]
80009204:	30 0c       	mov	r12,0
80009206:	50 6e       	stdsp	sp[0x18],lr
80009208:	50 9c       	stdsp	sp[0x24],r12
8000920a:	c0 78       	rjmp	80009218 <_vfprintf_r+0x93c>
8000920c:	40 5b       	lddsp	r11,sp[0x14]
8000920e:	32 da       	mov	r10,45
80009210:	ee 1b 80 00 	eorh	r11,0x8000
80009214:	50 9a       	stdsp	sp[0x24],r10
80009216:	50 6b       	stdsp	sp[0x18],r11
80009218:	e0 40 00 46 	cp.w	r0,70
8000921c:	5f 09       	sreq	r9
8000921e:	e0 40 00 66 	cp.w	r0,102
80009222:	5f 08       	sreq	r8
80009224:	f3 e8 10 08 	or	r8,r9,r8
80009228:	50 48       	stdsp	sp[0x10],r8
8000922a:	c0 40       	breq	80009232 <_vfprintf_r+0x956>
8000922c:	40 22       	lddsp	r2,sp[0x8]
8000922e:	30 39       	mov	r9,3
80009230:	c1 08       	rjmp	80009250 <_vfprintf_r+0x974>
80009232:	e0 40 00 45 	cp.w	r0,69
80009236:	5f 09       	sreq	r9
80009238:	e0 40 00 65 	cp.w	r0,101
8000923c:	5f 08       	sreq	r8
8000923e:	40 22       	lddsp	r2,sp[0x8]
80009240:	10 49       	or	r9,r8
80009242:	2f f2       	sub	r2,-1
80009244:	40 46       	lddsp	r6,sp[0x10]
80009246:	ec 09 18 00 	cp.b	r9,r6
8000924a:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000924e:	30 29       	mov	r9,2
80009250:	fa c8 f9 5c 	sub	r8,sp,-1700
80009254:	1a d8       	st.w	--sp,r8
80009256:	fa c8 f9 54 	sub	r8,sp,-1708
8000925a:	1a d8       	st.w	--sp,r8
8000925c:	fa c8 f9 4c 	sub	r8,sp,-1716
80009260:	08 9c       	mov	r12,r4
80009262:	1a d8       	st.w	--sp,r8
80009264:	04 98       	mov	r8,r2
80009266:	40 9b       	lddsp	r11,sp[0x24]
80009268:	40 aa       	lddsp	r10,sp[0x28]
8000926a:	e0 a0 0b cf 	rcall	8000aa08 <_dtoa_r>
8000926e:	e0 40 00 47 	cp.w	r0,71
80009272:	5f 19       	srne	r9
80009274:	e0 40 00 67 	cp.w	r0,103
80009278:	5f 18       	srne	r8
8000927a:	18 96       	mov	r6,r12
8000927c:	2f dd       	sub	sp,-12
8000927e:	f3 e8 00 08 	and	r8,r9,r8
80009282:	c0 41       	brne	8000928a <_vfprintf_r+0x9ae>
80009284:	ed b5 00 00 	bld	r5,0x0
80009288:	c3 81       	brne	800092f8 <_vfprintf_r+0xa1c>
8000928a:	ec 02 00 0e 	add	lr,r6,r2
8000928e:	50 3e       	stdsp	sp[0xc],lr
80009290:	40 4c       	lddsp	r12,sp[0x10]
80009292:	58 0c       	cp.w	r12,0
80009294:	c1 50       	breq	800092be <_vfprintf_r+0x9e2>
80009296:	0d 89       	ld.ub	r9,r6[0x0]
80009298:	33 08       	mov	r8,48
8000929a:	f0 09 18 00 	cp.b	r9,r8
8000929e:	c0 b1       	brne	800092b4 <_vfprintf_r+0x9d8>
800092a0:	30 08       	mov	r8,0
800092a2:	30 09       	mov	r9,0
800092a4:	40 6b       	lddsp	r11,sp[0x18]
800092a6:	40 7a       	lddsp	r10,sp[0x1c]
800092a8:	e0 a0 1a 33 	rcall	8000c70e <__avr32_f64_cmp_eq>
800092ac:	fb b2 00 01 	rsubeq	r2,1
800092b0:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
800092b4:	40 3b       	lddsp	r11,sp[0xc]
800092b6:	fa f8 06 ac 	ld.w	r8,sp[1708]
800092ba:	10 0b       	add	r11,r8
800092bc:	50 3b       	stdsp	sp[0xc],r11
800092be:	40 6b       	lddsp	r11,sp[0x18]
800092c0:	30 08       	mov	r8,0
800092c2:	30 09       	mov	r9,0
800092c4:	40 7a       	lddsp	r10,sp[0x1c]
800092c6:	e0 a0 1a 24 	rcall	8000c70e <__avr32_f64_cmp_eq>
800092ca:	c1 10       	breq	800092ec <_vfprintf_r+0xa10>
800092cc:	40 3a       	lddsp	r10,sp[0xc]
800092ce:	fb 4a 06 a4 	st.w	sp[1700],r10
800092d2:	c0 d8       	rjmp	800092ec <_vfprintf_r+0xa10>
800092d4:	80 02       	ld.sh	r2,r0[0x0]
800092d6:	f7 c8       	*unknown*
800092d8:	80 02       	ld.sh	r2,r0[0x0]
800092da:	f7 cc       	*unknown*
800092dc:	80 02       	ld.sh	r2,r0[0x0]
800092de:	f7 d0 80 02 	ldswp.w	r0,r11[8]
800092e2:	f7 d4 10 c9 	ldins.h	r4:t,r11[402]
800092e6:	fb 48 06 a4 	st.w	sp[1700],r8
800092ea:	c0 28       	rjmp	800092ee <_vfprintf_r+0xa12>
800092ec:	33 09       	mov	r9,48
800092ee:	fa f8 06 a4 	ld.w	r8,sp[1700]
800092f2:	40 3e       	lddsp	lr,sp[0xc]
800092f4:	1c 38       	cp.w	r8,lr
800092f6:	cf 73       	brcs	800092e4 <_vfprintf_r+0xa08>
800092f8:	e0 40 00 47 	cp.w	r0,71
800092fc:	5f 09       	sreq	r9
800092fe:	e0 40 00 67 	cp.w	r0,103
80009302:	5f 08       	sreq	r8
80009304:	f3 e8 10 08 	or	r8,r9,r8
80009308:	fa f9 06 a4 	ld.w	r9,sp[1700]
8000930c:	0c 19       	sub	r9,r6
8000930e:	50 69       	stdsp	sp[0x18],r9
80009310:	58 08       	cp.w	r8,0
80009312:	c0 b0       	breq	80009328 <_vfprintf_r+0xa4c>
80009314:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009318:	5b d8       	cp.w	r8,-3
8000931a:	c0 55       	brlt	80009324 <_vfprintf_r+0xa48>
8000931c:	40 2c       	lddsp	r12,sp[0x8]
8000931e:	18 38       	cp.w	r8,r12
80009320:	e0 8a 00 6a 	brle	800093f4 <_vfprintf_r+0xb18>
80009324:	20 20       	sub	r0,2
80009326:	c0 58       	rjmp	80009330 <_vfprintf_r+0xa54>
80009328:	e0 40 00 65 	cp.w	r0,101
8000932c:	e0 89 00 46 	brgt	800093b8 <_vfprintf_r+0xadc>
80009330:	fa fb 06 ac 	ld.w	r11,sp[1708]
80009334:	fb 60 06 9c 	st.b	sp[1692],r0
80009338:	20 1b       	sub	r11,1
8000933a:	fb 4b 06 ac 	st.w	sp[1708],r11
8000933e:	c0 47       	brpl	80009346 <_vfprintf_r+0xa6a>
80009340:	5c 3b       	neg	r11
80009342:	32 d8       	mov	r8,45
80009344:	c0 28       	rjmp	80009348 <_vfprintf_r+0xa6c>
80009346:	32 b8       	mov	r8,43
80009348:	fb 68 06 9d 	st.b	sp[1693],r8
8000934c:	58 9b       	cp.w	r11,9
8000934e:	e0 8a 00 1d 	brle	80009388 <_vfprintf_r+0xaac>
80009352:	fa c9 fa 35 	sub	r9,sp,-1483
80009356:	30 aa       	mov	r10,10
80009358:	12 98       	mov	r8,r9
8000935a:	0e 9c       	mov	r12,r7
8000935c:	0c 92       	mov	r2,r6
8000935e:	f6 0a 0c 06 	divs	r6,r11,r10
80009362:	0e 9b       	mov	r11,r7
80009364:	2d 0b       	sub	r11,-48
80009366:	10 fb       	st.b	--r8,r11
80009368:	0c 9b       	mov	r11,r6
8000936a:	58 96       	cp.w	r6,9
8000936c:	fe 99 ff f9 	brgt	8000935e <_vfprintf_r+0xa82>
80009370:	2d 0b       	sub	r11,-48
80009372:	18 97       	mov	r7,r12
80009374:	04 96       	mov	r6,r2
80009376:	10 fb       	st.b	--r8,r11
80009378:	fa ca f9 62 	sub	r10,sp,-1694
8000937c:	c0 38       	rjmp	80009382 <_vfprintf_r+0xaa6>
8000937e:	11 3b       	ld.ub	r11,r8++
80009380:	14 cb       	st.b	r10++,r11
80009382:	12 38       	cp.w	r8,r9
80009384:	cf d3       	brcs	8000937e <_vfprintf_r+0xaa2>
80009386:	c0 98       	rjmp	80009398 <_vfprintf_r+0xabc>
80009388:	2d 0b       	sub	r11,-48
8000938a:	33 08       	mov	r8,48
8000938c:	fb 6b 06 9f 	st.b	sp[1695],r11
80009390:	fb 68 06 9e 	st.b	sp[1694],r8
80009394:	fa ca f9 60 	sub	r10,sp,-1696
80009398:	fa c8 f9 64 	sub	r8,sp,-1692
8000939c:	f4 08 01 08 	sub	r8,r10,r8
800093a0:	50 e8       	stdsp	sp[0x38],r8
800093a2:	10 92       	mov	r2,r8
800093a4:	40 6b       	lddsp	r11,sp[0x18]
800093a6:	16 02       	add	r2,r11
800093a8:	58 1b       	cp.w	r11,1
800093aa:	e0 89 00 05 	brgt	800093b4 <_vfprintf_r+0xad8>
800093ae:	ed b5 00 00 	bld	r5,0x0
800093b2:	c3 51       	brne	8000941c <_vfprintf_r+0xb40>
800093b4:	2f f2       	sub	r2,-1
800093b6:	c3 38       	rjmp	8000941c <_vfprintf_r+0xb40>
800093b8:	e0 40 00 66 	cp.w	r0,102
800093bc:	c1 c1       	brne	800093f4 <_vfprintf_r+0xb18>
800093be:	fa f2 06 ac 	ld.w	r2,sp[1708]
800093c2:	58 02       	cp.w	r2,0
800093c4:	e0 8a 00 0c 	brle	800093dc <_vfprintf_r+0xb00>
800093c8:	40 2a       	lddsp	r10,sp[0x8]
800093ca:	58 0a       	cp.w	r10,0
800093cc:	c0 41       	brne	800093d4 <_vfprintf_r+0xaf8>
800093ce:	ed b5 00 00 	bld	r5,0x0
800093d2:	c2 51       	brne	8000941c <_vfprintf_r+0xb40>
800093d4:	2f f2       	sub	r2,-1
800093d6:	40 29       	lddsp	r9,sp[0x8]
800093d8:	12 02       	add	r2,r9
800093da:	c0 b8       	rjmp	800093f0 <_vfprintf_r+0xb14>
800093dc:	40 28       	lddsp	r8,sp[0x8]
800093de:	58 08       	cp.w	r8,0
800093e0:	c0 61       	brne	800093ec <_vfprintf_r+0xb10>
800093e2:	ed b5 00 00 	bld	r5,0x0
800093e6:	c0 30       	breq	800093ec <_vfprintf_r+0xb10>
800093e8:	30 12       	mov	r2,1
800093ea:	c1 98       	rjmp	8000941c <_vfprintf_r+0xb40>
800093ec:	40 22       	lddsp	r2,sp[0x8]
800093ee:	2f e2       	sub	r2,-2
800093f0:	36 60       	mov	r0,102
800093f2:	c1 58       	rjmp	8000941c <_vfprintf_r+0xb40>
800093f4:	fa f2 06 ac 	ld.w	r2,sp[1708]
800093f8:	40 6e       	lddsp	lr,sp[0x18]
800093fa:	1c 32       	cp.w	r2,lr
800093fc:	c0 65       	brlt	80009408 <_vfprintf_r+0xb2c>
800093fe:	ed b5 00 00 	bld	r5,0x0
80009402:	f7 b2 00 ff 	subeq	r2,-1
80009406:	c0 a8       	rjmp	8000941a <_vfprintf_r+0xb3e>
80009408:	e4 08 11 02 	rsub	r8,r2,2
8000940c:	40 6c       	lddsp	r12,sp[0x18]
8000940e:	58 02       	cp.w	r2,0
80009410:	f0 02 17 a0 	movle	r2,r8
80009414:	f9 b2 09 01 	movgt	r2,1
80009418:	18 02       	add	r2,r12
8000941a:	36 70       	mov	r0,103
8000941c:	40 9b       	lddsp	r11,sp[0x24]
8000941e:	58 0b       	cp.w	r11,0
80009420:	e0 80 05 94 	breq	80009f48 <_vfprintf_r+0x166c>
80009424:	32 d8       	mov	r8,45
80009426:	fb 68 06 bb 	st.b	sp[1723],r8
8000942a:	e0 8f 05 93 	bral	80009f50 <_vfprintf_r+0x1674>
8000942e:	50 a7       	stdsp	sp[0x28],r7
80009430:	04 94       	mov	r4,r2
80009432:	0c 97       	mov	r7,r6
80009434:	02 92       	mov	r2,r1
80009436:	06 96       	mov	r6,r3
80009438:	40 41       	lddsp	r1,sp[0x10]
8000943a:	40 93       	lddsp	r3,sp[0x24]
8000943c:	0e 99       	mov	r9,r7
8000943e:	ed b5 00 05 	bld	r5,0x5
80009442:	c4 81       	brne	800094d2 <_vfprintf_r+0xbf6>
80009444:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009448:	40 3e       	lddsp	lr,sp[0xc]
8000944a:	58 0e       	cp.w	lr,0
8000944c:	c1 d0       	breq	80009486 <_vfprintf_r+0xbaa>
8000944e:	10 36       	cp.w	r6,r8
80009450:	c0 64       	brge	8000945c <_vfprintf_r+0xb80>
80009452:	fa cc f9 44 	sub	r12,sp,-1724
80009456:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000945a:	c1 d8       	rjmp	80009494 <_vfprintf_r+0xbb8>
8000945c:	fa c8 f9 50 	sub	r8,sp,-1712
80009460:	1a d8       	st.w	--sp,r8
80009462:	fa c8 fa b8 	sub	r8,sp,-1352
80009466:	04 9a       	mov	r10,r2
80009468:	1a d8       	st.w	--sp,r8
8000946a:	fa c8 fb b4 	sub	r8,sp,-1100
8000946e:	0c 9b       	mov	r11,r6
80009470:	1a d8       	st.w	--sp,r8
80009472:	08 9c       	mov	r12,r4
80009474:	fa c8 f9 40 	sub	r8,sp,-1728
80009478:	fa c9 ff b4 	sub	r9,sp,-76
8000947c:	fe b0 f8 92 	rcall	800085a0 <get_arg>
80009480:	2f dd       	sub	sp,-12
80009482:	78 0a       	ld.w	r10,r12[0x0]
80009484:	c2 08       	rjmp	800094c4 <_vfprintf_r+0xbe8>
80009486:	2f f7       	sub	r7,-1
80009488:	10 39       	cp.w	r9,r8
8000948a:	c0 84       	brge	8000949a <_vfprintf_r+0xbbe>
8000948c:	fa cb f9 44 	sub	r11,sp,-1724
80009490:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009494:	ec fa fd 88 	ld.w	r10,r6[-632]
80009498:	c1 68       	rjmp	800094c4 <_vfprintf_r+0xbe8>
8000949a:	41 09       	lddsp	r9,sp[0x40]
8000949c:	59 f8       	cp.w	r8,31
8000949e:	e0 89 00 10 	brgt	800094be <_vfprintf_r+0xbe2>
800094a2:	f2 ca ff fc 	sub	r10,r9,-4
800094a6:	51 0a       	stdsp	sp[0x40],r10
800094a8:	fa c6 f9 44 	sub	r6,sp,-1724
800094ac:	72 0a       	ld.w	r10,r9[0x0]
800094ae:	ec 08 00 39 	add	r9,r6,r8<<0x3
800094b2:	f3 4a fd 88 	st.w	r9[-632],r10
800094b6:	2f f8       	sub	r8,-1
800094b8:	fb 48 06 b4 	st.w	sp[1716],r8
800094bc:	c0 48       	rjmp	800094c4 <_vfprintf_r+0xbe8>
800094be:	72 0a       	ld.w	r10,r9[0x0]
800094c0:	2f c9       	sub	r9,-4
800094c2:	51 09       	stdsp	sp[0x40],r9
800094c4:	40 be       	lddsp	lr,sp[0x2c]
800094c6:	1c 98       	mov	r8,lr
800094c8:	95 1e       	st.w	r10[0x4],lr
800094ca:	bf 58       	asr	r8,0x1f
800094cc:	95 08       	st.w	r10[0x0],r8
800094ce:	fe 9f fa 92 	bral	800089f2 <_vfprintf_r+0x116>
800094d2:	ed b5 00 04 	bld	r5,0x4
800094d6:	c4 80       	breq	80009566 <_vfprintf_r+0xc8a>
800094d8:	e2 15 00 40 	andl	r5,0x40,COH
800094dc:	c4 50       	breq	80009566 <_vfprintf_r+0xc8a>
800094de:	fa f8 06 b4 	ld.w	r8,sp[1716]
800094e2:	40 3c       	lddsp	r12,sp[0xc]
800094e4:	58 0c       	cp.w	r12,0
800094e6:	c1 d0       	breq	80009520 <_vfprintf_r+0xc44>
800094e8:	10 36       	cp.w	r6,r8
800094ea:	c0 64       	brge	800094f6 <_vfprintf_r+0xc1a>
800094ec:	fa cb f9 44 	sub	r11,sp,-1724
800094f0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800094f4:	c1 d8       	rjmp	8000952e <_vfprintf_r+0xc52>
800094f6:	fa c8 f9 50 	sub	r8,sp,-1712
800094fa:	1a d8       	st.w	--sp,r8
800094fc:	fa c8 fa b8 	sub	r8,sp,-1352
80009500:	04 9a       	mov	r10,r2
80009502:	1a d8       	st.w	--sp,r8
80009504:	fa c8 fb b4 	sub	r8,sp,-1100
80009508:	0c 9b       	mov	r11,r6
8000950a:	1a d8       	st.w	--sp,r8
8000950c:	08 9c       	mov	r12,r4
8000950e:	fa c8 f9 40 	sub	r8,sp,-1728
80009512:	fa c9 ff b4 	sub	r9,sp,-76
80009516:	fe b0 f8 45 	rcall	800085a0 <get_arg>
8000951a:	2f dd       	sub	sp,-12
8000951c:	78 0a       	ld.w	r10,r12[0x0]
8000951e:	c2 08       	rjmp	8000955e <_vfprintf_r+0xc82>
80009520:	2f f7       	sub	r7,-1
80009522:	10 39       	cp.w	r9,r8
80009524:	c0 84       	brge	80009534 <_vfprintf_r+0xc58>
80009526:	fa ca f9 44 	sub	r10,sp,-1724
8000952a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000952e:	ec fa fd 88 	ld.w	r10,r6[-632]
80009532:	c1 68       	rjmp	8000955e <_vfprintf_r+0xc82>
80009534:	41 09       	lddsp	r9,sp[0x40]
80009536:	59 f8       	cp.w	r8,31
80009538:	e0 89 00 10 	brgt	80009558 <_vfprintf_r+0xc7c>
8000953c:	f2 ca ff fc 	sub	r10,r9,-4
80009540:	51 0a       	stdsp	sp[0x40],r10
80009542:	fa c6 f9 44 	sub	r6,sp,-1724
80009546:	72 0a       	ld.w	r10,r9[0x0]
80009548:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000954c:	f3 4a fd 88 	st.w	r9[-632],r10
80009550:	2f f8       	sub	r8,-1
80009552:	fb 48 06 b4 	st.w	sp[1716],r8
80009556:	c0 48       	rjmp	8000955e <_vfprintf_r+0xc82>
80009558:	72 0a       	ld.w	r10,r9[0x0]
8000955a:	2f c9       	sub	r9,-4
8000955c:	51 09       	stdsp	sp[0x40],r9
8000955e:	40 be       	lddsp	lr,sp[0x2c]
80009560:	b4 0e       	st.h	r10[0x0],lr
80009562:	fe 9f fa 48 	bral	800089f2 <_vfprintf_r+0x116>
80009566:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000956a:	40 3c       	lddsp	r12,sp[0xc]
8000956c:	58 0c       	cp.w	r12,0
8000956e:	c1 d0       	breq	800095a8 <_vfprintf_r+0xccc>
80009570:	10 36       	cp.w	r6,r8
80009572:	c0 64       	brge	8000957e <_vfprintf_r+0xca2>
80009574:	fa cb f9 44 	sub	r11,sp,-1724
80009578:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000957c:	c1 d8       	rjmp	800095b6 <_vfprintf_r+0xcda>
8000957e:	fa c8 f9 50 	sub	r8,sp,-1712
80009582:	1a d8       	st.w	--sp,r8
80009584:	fa c8 fa b8 	sub	r8,sp,-1352
80009588:	04 9a       	mov	r10,r2
8000958a:	1a d8       	st.w	--sp,r8
8000958c:	fa c8 fb b4 	sub	r8,sp,-1100
80009590:	0c 9b       	mov	r11,r6
80009592:	1a d8       	st.w	--sp,r8
80009594:	08 9c       	mov	r12,r4
80009596:	fa c8 f9 40 	sub	r8,sp,-1728
8000959a:	fa c9 ff b4 	sub	r9,sp,-76
8000959e:	fe b0 f8 01 	rcall	800085a0 <get_arg>
800095a2:	2f dd       	sub	sp,-12
800095a4:	78 0a       	ld.w	r10,r12[0x0]
800095a6:	c2 08       	rjmp	800095e6 <_vfprintf_r+0xd0a>
800095a8:	2f f7       	sub	r7,-1
800095aa:	10 39       	cp.w	r9,r8
800095ac:	c0 84       	brge	800095bc <_vfprintf_r+0xce0>
800095ae:	fa ca f9 44 	sub	r10,sp,-1724
800095b2:	f4 06 00 36 	add	r6,r10,r6<<0x3
800095b6:	ec fa fd 88 	ld.w	r10,r6[-632]
800095ba:	c1 68       	rjmp	800095e6 <_vfprintf_r+0xd0a>
800095bc:	41 09       	lddsp	r9,sp[0x40]
800095be:	59 f8       	cp.w	r8,31
800095c0:	e0 89 00 10 	brgt	800095e0 <_vfprintf_r+0xd04>
800095c4:	f2 ca ff fc 	sub	r10,r9,-4
800095c8:	51 0a       	stdsp	sp[0x40],r10
800095ca:	fa c6 f9 44 	sub	r6,sp,-1724
800095ce:	72 0a       	ld.w	r10,r9[0x0]
800095d0:	ec 08 00 39 	add	r9,r6,r8<<0x3
800095d4:	f3 4a fd 88 	st.w	r9[-632],r10
800095d8:	2f f8       	sub	r8,-1
800095da:	fb 48 06 b4 	st.w	sp[1716],r8
800095de:	c0 48       	rjmp	800095e6 <_vfprintf_r+0xd0a>
800095e0:	72 0a       	ld.w	r10,r9[0x0]
800095e2:	2f c9       	sub	r9,-4
800095e4:	51 09       	stdsp	sp[0x40],r9
800095e6:	40 be       	lddsp	lr,sp[0x2c]
800095e8:	95 0e       	st.w	r10[0x0],lr
800095ea:	fe 9f fa 04 	bral	800089f2 <_vfprintf_r+0x116>
800095ee:	50 a7       	stdsp	sp[0x28],r7
800095f0:	50 80       	stdsp	sp[0x20],r0
800095f2:	0c 97       	mov	r7,r6
800095f4:	04 94       	mov	r4,r2
800095f6:	06 96       	mov	r6,r3
800095f8:	02 92       	mov	r2,r1
800095fa:	40 93       	lddsp	r3,sp[0x24]
800095fc:	10 90       	mov	r0,r8
800095fe:	40 41       	lddsp	r1,sp[0x10]
80009600:	a5 a5       	sbr	r5,0x4
80009602:	c0 a8       	rjmp	80009616 <_vfprintf_r+0xd3a>
80009604:	50 a7       	stdsp	sp[0x28],r7
80009606:	50 80       	stdsp	sp[0x20],r0
80009608:	0c 97       	mov	r7,r6
8000960a:	04 94       	mov	r4,r2
8000960c:	06 96       	mov	r6,r3
8000960e:	02 92       	mov	r2,r1
80009610:	40 93       	lddsp	r3,sp[0x24]
80009612:	10 90       	mov	r0,r8
80009614:	40 41       	lddsp	r1,sp[0x10]
80009616:	ed b5 00 05 	bld	r5,0x5
8000961a:	c5 d1       	brne	800096d4 <_vfprintf_r+0xdf8>
8000961c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009620:	40 3c       	lddsp	r12,sp[0xc]
80009622:	58 0c       	cp.w	r12,0
80009624:	c2 60       	breq	80009670 <_vfprintf_r+0xd94>
80009626:	10 36       	cp.w	r6,r8
80009628:	c0 a4       	brge	8000963c <_vfprintf_r+0xd60>
8000962a:	fa cb f9 44 	sub	r11,sp,-1724
8000962e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009632:	ec e8 fd 88 	ld.d	r8,r6[-632]
80009636:	fa e9 00 00 	st.d	sp[0],r8
8000963a:	c1 88       	rjmp	8000966a <_vfprintf_r+0xd8e>
8000963c:	fa c8 f9 50 	sub	r8,sp,-1712
80009640:	1a d8       	st.w	--sp,r8
80009642:	fa c8 fa b8 	sub	r8,sp,-1352
80009646:	04 9a       	mov	r10,r2
80009648:	1a d8       	st.w	--sp,r8
8000964a:	0c 9b       	mov	r11,r6
8000964c:	fa c8 fb b4 	sub	r8,sp,-1100
80009650:	08 9c       	mov	r12,r4
80009652:	1a d8       	st.w	--sp,r8
80009654:	fa c8 f9 40 	sub	r8,sp,-1728
80009658:	fa c9 ff b4 	sub	r9,sp,-76
8000965c:	fe b0 f7 a2 	rcall	800085a0 <get_arg>
80009660:	2f dd       	sub	sp,-12
80009662:	f8 ea 00 00 	ld.d	r10,r12[0]
80009666:	fa eb 00 00 	st.d	sp[0],r10
8000966a:	30 08       	mov	r8,0
8000966c:	e0 8f 03 de 	bral	80009e28 <_vfprintf_r+0x154c>
80009670:	ee ca ff ff 	sub	r10,r7,-1
80009674:	10 37       	cp.w	r7,r8
80009676:	c0 b4       	brge	8000968c <_vfprintf_r+0xdb0>
80009678:	fa c9 f9 44 	sub	r9,sp,-1724
8000967c:	14 97       	mov	r7,r10
8000967e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009682:	ec ea fd 88 	ld.d	r10,r6[-632]
80009686:	fa eb 00 00 	st.d	sp[0],r10
8000968a:	c1 88       	rjmp	800096ba <_vfprintf_r+0xdde>
8000968c:	41 09       	lddsp	r9,sp[0x40]
8000968e:	59 f8       	cp.w	r8,31
80009690:	e0 89 00 18 	brgt	800096c0 <_vfprintf_r+0xde4>
80009694:	f2 e6 00 00 	ld.d	r6,r9[0]
80009698:	f2 cb ff f8 	sub	r11,r9,-8
8000969c:	fa e7 00 00 	st.d	sp[0],r6
800096a0:	51 0b       	stdsp	sp[0x40],r11
800096a2:	fa c6 f9 44 	sub	r6,sp,-1724
800096a6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800096aa:	fa e6 00 00 	ld.d	r6,sp[0]
800096ae:	f2 e7 fd 88 	st.d	r9[-632],r6
800096b2:	2f f8       	sub	r8,-1
800096b4:	14 97       	mov	r7,r10
800096b6:	fb 48 06 b4 	st.w	sp[1716],r8
800096ba:	40 38       	lddsp	r8,sp[0xc]
800096bc:	e0 8f 03 b6 	bral	80009e28 <_vfprintf_r+0x154c>
800096c0:	f2 e6 00 00 	ld.d	r6,r9[0]
800096c4:	40 38       	lddsp	r8,sp[0xc]
800096c6:	fa e7 00 00 	st.d	sp[0],r6
800096ca:	2f 89       	sub	r9,-8
800096cc:	14 97       	mov	r7,r10
800096ce:	51 09       	stdsp	sp[0x40],r9
800096d0:	e0 8f 03 ac 	bral	80009e28 <_vfprintf_r+0x154c>
800096d4:	ed b5 00 04 	bld	r5,0x4
800096d8:	c1 61       	brne	80009704 <_vfprintf_r+0xe28>
800096da:	fa f8 06 b4 	ld.w	r8,sp[1716]
800096de:	40 3e       	lddsp	lr,sp[0xc]
800096e0:	58 0e       	cp.w	lr,0
800096e2:	c0 80       	breq	800096f2 <_vfprintf_r+0xe16>
800096e4:	10 36       	cp.w	r6,r8
800096e6:	c6 74       	brge	800097b4 <_vfprintf_r+0xed8>
800096e8:	fa cc f9 44 	sub	r12,sp,-1724
800096ec:	f8 06 00 36 	add	r6,r12,r6<<0x3
800096f0:	c8 08       	rjmp	800097f0 <_vfprintf_r+0xf14>
800096f2:	ee ca ff ff 	sub	r10,r7,-1
800096f6:	10 37       	cp.w	r7,r8
800096f8:	c7 f4       	brge	800097f6 <_vfprintf_r+0xf1a>
800096fa:	fa cb f9 44 	sub	r11,sp,-1724
800096fe:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009702:	c7 68       	rjmp	800097ee <_vfprintf_r+0xf12>
80009704:	ed b5 00 06 	bld	r5,0x6
80009708:	c4 a1       	brne	8000979c <_vfprintf_r+0xec0>
8000970a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000970e:	40 3c       	lddsp	r12,sp[0xc]
80009710:	58 0c       	cp.w	r12,0
80009712:	c1 d0       	breq	8000974c <_vfprintf_r+0xe70>
80009714:	10 36       	cp.w	r6,r8
80009716:	c0 64       	brge	80009722 <_vfprintf_r+0xe46>
80009718:	fa cb f9 44 	sub	r11,sp,-1724
8000971c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009720:	c1 f8       	rjmp	8000975e <_vfprintf_r+0xe82>
80009722:	fa c8 f9 50 	sub	r8,sp,-1712
80009726:	1a d8       	st.w	--sp,r8
80009728:	fa c8 fa b8 	sub	r8,sp,-1352
8000972c:	1a d8       	st.w	--sp,r8
8000972e:	fa c8 fb b4 	sub	r8,sp,-1100
80009732:	1a d8       	st.w	--sp,r8
80009734:	fa c8 f9 40 	sub	r8,sp,-1728
80009738:	fa c9 ff b4 	sub	r9,sp,-76
8000973c:	04 9a       	mov	r10,r2
8000973e:	0c 9b       	mov	r11,r6
80009740:	08 9c       	mov	r12,r4
80009742:	fe b0 f7 2f 	rcall	800085a0 <get_arg>
80009746:	2f dd       	sub	sp,-12
80009748:	98 18       	ld.sh	r8,r12[0x2]
8000974a:	c2 68       	rjmp	80009796 <_vfprintf_r+0xeba>
8000974c:	ee ca ff ff 	sub	r10,r7,-1
80009750:	10 37       	cp.w	r7,r8
80009752:	c0 94       	brge	80009764 <_vfprintf_r+0xe88>
80009754:	fa c9 f9 44 	sub	r9,sp,-1724
80009758:	14 97       	mov	r7,r10
8000975a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000975e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009762:	c1 a8       	rjmp	80009796 <_vfprintf_r+0xeba>
80009764:	41 09       	lddsp	r9,sp[0x40]
80009766:	59 f8       	cp.w	r8,31
80009768:	e0 89 00 13 	brgt	8000978e <_vfprintf_r+0xeb2>
8000976c:	f2 cb ff fc 	sub	r11,r9,-4
80009770:	51 0b       	stdsp	sp[0x40],r11
80009772:	72 09       	ld.w	r9,r9[0x0]
80009774:	fa c6 f9 44 	sub	r6,sp,-1724
80009778:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000977c:	2f f8       	sub	r8,-1
8000977e:	f7 49 fd 88 	st.w	r11[-632],r9
80009782:	fb 48 06 b4 	st.w	sp[1716],r8
80009786:	14 97       	mov	r7,r10
80009788:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000978c:	c0 58       	rjmp	80009796 <_vfprintf_r+0xeba>
8000978e:	92 18       	ld.sh	r8,r9[0x2]
80009790:	14 97       	mov	r7,r10
80009792:	2f c9       	sub	r9,-4
80009794:	51 09       	stdsp	sp[0x40],r9
80009796:	5c 78       	castu.h	r8
80009798:	50 18       	stdsp	sp[0x4],r8
8000979a:	c4 68       	rjmp	80009826 <_vfprintf_r+0xf4a>
8000979c:	fa f8 06 b4 	ld.w	r8,sp[1716]
800097a0:	40 3c       	lddsp	r12,sp[0xc]
800097a2:	58 0c       	cp.w	r12,0
800097a4:	c1 d0       	breq	800097de <_vfprintf_r+0xf02>
800097a6:	10 36       	cp.w	r6,r8
800097a8:	c0 64       	brge	800097b4 <_vfprintf_r+0xed8>
800097aa:	fa cb f9 44 	sub	r11,sp,-1724
800097ae:	f6 06 00 36 	add	r6,r11,r6<<0x3
800097b2:	c1 f8       	rjmp	800097f0 <_vfprintf_r+0xf14>
800097b4:	fa c8 f9 50 	sub	r8,sp,-1712
800097b8:	1a d8       	st.w	--sp,r8
800097ba:	fa c8 fa b8 	sub	r8,sp,-1352
800097be:	0c 9b       	mov	r11,r6
800097c0:	1a d8       	st.w	--sp,r8
800097c2:	fa c8 fb b4 	sub	r8,sp,-1100
800097c6:	04 9a       	mov	r10,r2
800097c8:	1a d8       	st.w	--sp,r8
800097ca:	08 9c       	mov	r12,r4
800097cc:	fa c8 f9 40 	sub	r8,sp,-1728
800097d0:	fa c9 ff b4 	sub	r9,sp,-76
800097d4:	fe b0 f6 e6 	rcall	800085a0 <get_arg>
800097d8:	2f dd       	sub	sp,-12
800097da:	78 0b       	ld.w	r11,r12[0x0]
800097dc:	c2 48       	rjmp	80009824 <_vfprintf_r+0xf48>
800097de:	ee ca ff ff 	sub	r10,r7,-1
800097e2:	10 37       	cp.w	r7,r8
800097e4:	c0 94       	brge	800097f6 <_vfprintf_r+0xf1a>
800097e6:	fa c9 f9 44 	sub	r9,sp,-1724
800097ea:	f2 06 00 36 	add	r6,r9,r6<<0x3
800097ee:	14 97       	mov	r7,r10
800097f0:	ec fb fd 88 	ld.w	r11,r6[-632]
800097f4:	c1 88       	rjmp	80009824 <_vfprintf_r+0xf48>
800097f6:	41 09       	lddsp	r9,sp[0x40]
800097f8:	59 f8       	cp.w	r8,31
800097fa:	e0 89 00 11 	brgt	8000981c <_vfprintf_r+0xf40>
800097fe:	f2 cb ff fc 	sub	r11,r9,-4
80009802:	51 0b       	stdsp	sp[0x40],r11
80009804:	fa c6 f9 44 	sub	r6,sp,-1724
80009808:	72 0b       	ld.w	r11,r9[0x0]
8000980a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000980e:	f3 4b fd 88 	st.w	r9[-632],r11
80009812:	2f f8       	sub	r8,-1
80009814:	14 97       	mov	r7,r10
80009816:	fb 48 06 b4 	st.w	sp[1716],r8
8000981a:	c0 58       	rjmp	80009824 <_vfprintf_r+0xf48>
8000981c:	72 0b       	ld.w	r11,r9[0x0]
8000981e:	14 97       	mov	r7,r10
80009820:	2f c9       	sub	r9,-4
80009822:	51 09       	stdsp	sp[0x40],r9
80009824:	50 1b       	stdsp	sp[0x4],r11
80009826:	30 0e       	mov	lr,0
80009828:	50 0e       	stdsp	sp[0x0],lr
8000982a:	1c 98       	mov	r8,lr
8000982c:	e0 8f 02 fe 	bral	80009e28 <_vfprintf_r+0x154c>
80009830:	50 a7       	stdsp	sp[0x28],r7
80009832:	50 80       	stdsp	sp[0x20],r0
80009834:	0c 97       	mov	r7,r6
80009836:	04 94       	mov	r4,r2
80009838:	06 96       	mov	r6,r3
8000983a:	02 92       	mov	r2,r1
8000983c:	40 93       	lddsp	r3,sp[0x24]
8000983e:	40 41       	lddsp	r1,sp[0x10]
80009840:	0e 99       	mov	r9,r7
80009842:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009846:	40 3c       	lddsp	r12,sp[0xc]
80009848:	58 0c       	cp.w	r12,0
8000984a:	c1 d0       	breq	80009884 <_vfprintf_r+0xfa8>
8000984c:	10 36       	cp.w	r6,r8
8000984e:	c0 64       	brge	8000985a <_vfprintf_r+0xf7e>
80009850:	fa cb f9 44 	sub	r11,sp,-1724
80009854:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009858:	c1 d8       	rjmp	80009892 <_vfprintf_r+0xfb6>
8000985a:	fa c8 f9 50 	sub	r8,sp,-1712
8000985e:	1a d8       	st.w	--sp,r8
80009860:	fa c8 fa b8 	sub	r8,sp,-1352
80009864:	1a d8       	st.w	--sp,r8
80009866:	fa c8 fb b4 	sub	r8,sp,-1100
8000986a:	1a d8       	st.w	--sp,r8
8000986c:	fa c9 ff b4 	sub	r9,sp,-76
80009870:	fa c8 f9 40 	sub	r8,sp,-1728
80009874:	04 9a       	mov	r10,r2
80009876:	0c 9b       	mov	r11,r6
80009878:	08 9c       	mov	r12,r4
8000987a:	fe b0 f6 93 	rcall	800085a0 <get_arg>
8000987e:	2f dd       	sub	sp,-12
80009880:	78 09       	ld.w	r9,r12[0x0]
80009882:	c2 18       	rjmp	800098c4 <_vfprintf_r+0xfe8>
80009884:	2f f7       	sub	r7,-1
80009886:	10 39       	cp.w	r9,r8
80009888:	c0 84       	brge	80009898 <_vfprintf_r+0xfbc>
8000988a:	fa ca f9 44 	sub	r10,sp,-1724
8000988e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009892:	ec f9 fd 88 	ld.w	r9,r6[-632]
80009896:	c1 78       	rjmp	800098c4 <_vfprintf_r+0xfe8>
80009898:	41 09       	lddsp	r9,sp[0x40]
8000989a:	59 f8       	cp.w	r8,31
8000989c:	e0 89 00 10 	brgt	800098bc <_vfprintf_r+0xfe0>
800098a0:	f2 ca ff fc 	sub	r10,r9,-4
800098a4:	51 0a       	stdsp	sp[0x40],r10
800098a6:	fa c6 f9 44 	sub	r6,sp,-1724
800098aa:	72 09       	ld.w	r9,r9[0x0]
800098ac:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800098b0:	f5 49 fd 88 	st.w	r10[-632],r9
800098b4:	2f f8       	sub	r8,-1
800098b6:	fb 48 06 b4 	st.w	sp[1716],r8
800098ba:	c0 58       	rjmp	800098c4 <_vfprintf_r+0xfe8>
800098bc:	f2 c8 ff fc 	sub	r8,r9,-4
800098c0:	51 08       	stdsp	sp[0x40],r8
800098c2:	72 09       	ld.w	r9,r9[0x0]
800098c4:	33 08       	mov	r8,48
800098c6:	fb 68 06 b8 	st.b	sp[1720],r8
800098ca:	37 88       	mov	r8,120
800098cc:	30 0e       	mov	lr,0
800098ce:	fb 68 06 b9 	st.b	sp[1721],r8
800098d2:	4c ac       	lddpc	r12,800099f8 <_vfprintf_r+0x111c>
800098d4:	50 19       	stdsp	sp[0x4],r9
800098d6:	a1 b5       	sbr	r5,0x1
800098d8:	50 0e       	stdsp	sp[0x0],lr
800098da:	50 dc       	stdsp	sp[0x34],r12
800098dc:	30 28       	mov	r8,2
800098de:	37 80       	mov	r0,120
800098e0:	e0 8f 02 a4 	bral	80009e28 <_vfprintf_r+0x154c>
800098e4:	50 a7       	stdsp	sp[0x28],r7
800098e6:	50 80       	stdsp	sp[0x20],r0
800098e8:	10 90       	mov	r0,r8
800098ea:	30 08       	mov	r8,0
800098ec:	fb 68 06 bb 	st.b	sp[1723],r8
800098f0:	0c 97       	mov	r7,r6
800098f2:	04 94       	mov	r4,r2
800098f4:	06 96       	mov	r6,r3
800098f6:	02 92       	mov	r2,r1
800098f8:	40 93       	lddsp	r3,sp[0x24]
800098fa:	40 41       	lddsp	r1,sp[0x10]
800098fc:	0e 99       	mov	r9,r7
800098fe:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009902:	40 3b       	lddsp	r11,sp[0xc]
80009904:	58 0b       	cp.w	r11,0
80009906:	c1 d0       	breq	80009940 <_vfprintf_r+0x1064>
80009908:	10 36       	cp.w	r6,r8
8000990a:	c0 64       	brge	80009916 <_vfprintf_r+0x103a>
8000990c:	fa ca f9 44 	sub	r10,sp,-1724
80009910:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009914:	c1 d8       	rjmp	8000994e <_vfprintf_r+0x1072>
80009916:	fa c8 f9 50 	sub	r8,sp,-1712
8000991a:	1a d8       	st.w	--sp,r8
8000991c:	fa c8 fa b8 	sub	r8,sp,-1352
80009920:	1a d8       	st.w	--sp,r8
80009922:	fa c8 fb b4 	sub	r8,sp,-1100
80009926:	0c 9b       	mov	r11,r6
80009928:	1a d8       	st.w	--sp,r8
8000992a:	04 9a       	mov	r10,r2
8000992c:	fa c8 f9 40 	sub	r8,sp,-1728
80009930:	fa c9 ff b4 	sub	r9,sp,-76
80009934:	08 9c       	mov	r12,r4
80009936:	fe b0 f6 35 	rcall	800085a0 <get_arg>
8000993a:	2f dd       	sub	sp,-12
8000993c:	78 06       	ld.w	r6,r12[0x0]
8000993e:	c2 08       	rjmp	8000997e <_vfprintf_r+0x10a2>
80009940:	2f f7       	sub	r7,-1
80009942:	10 39       	cp.w	r9,r8
80009944:	c0 84       	brge	80009954 <_vfprintf_r+0x1078>
80009946:	fa c9 f9 44 	sub	r9,sp,-1724
8000994a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000994e:	ec f6 fd 88 	ld.w	r6,r6[-632]
80009952:	c1 68       	rjmp	8000997e <_vfprintf_r+0x10a2>
80009954:	41 09       	lddsp	r9,sp[0x40]
80009956:	59 f8       	cp.w	r8,31
80009958:	e0 89 00 10 	brgt	80009978 <_vfprintf_r+0x109c>
8000995c:	f2 ca ff fc 	sub	r10,r9,-4
80009960:	51 0a       	stdsp	sp[0x40],r10
80009962:	72 06       	ld.w	r6,r9[0x0]
80009964:	fa ce f9 44 	sub	lr,sp,-1724
80009968:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000996c:	f3 46 fd 88 	st.w	r9[-632],r6
80009970:	2f f8       	sub	r8,-1
80009972:	fb 48 06 b4 	st.w	sp[1716],r8
80009976:	c0 48       	rjmp	8000997e <_vfprintf_r+0x10a2>
80009978:	72 06       	ld.w	r6,r9[0x0]
8000997a:	2f c9       	sub	r9,-4
8000997c:	51 09       	stdsp	sp[0x40],r9
8000997e:	40 2c       	lddsp	r12,sp[0x8]
80009980:	58 0c       	cp.w	r12,0
80009982:	c1 05       	brlt	800099a2 <_vfprintf_r+0x10c6>
80009984:	18 9a       	mov	r10,r12
80009986:	30 0b       	mov	r11,0
80009988:	0c 9c       	mov	r12,r6
8000998a:	e0 a0 12 3f 	rcall	8000be08 <memchr>
8000998e:	e0 80 02 e0 	breq	80009f4e <_vfprintf_r+0x1672>
80009992:	f8 06 01 02 	sub	r2,r12,r6
80009996:	40 2b       	lddsp	r11,sp[0x8]
80009998:	16 32       	cp.w	r2,r11
8000999a:	e0 89 02 da 	brgt	80009f4e <_vfprintf_r+0x1672>
8000999e:	e0 8f 02 d5 	bral	80009f48 <_vfprintf_r+0x166c>
800099a2:	30 0a       	mov	r10,0
800099a4:	0c 9c       	mov	r12,r6
800099a6:	50 2a       	stdsp	sp[0x8],r10
800099a8:	e0 a0 15 a2 	rcall	8000c4ec <strlen>
800099ac:	18 92       	mov	r2,r12
800099ae:	e0 8f 02 d3 	bral	80009f54 <_vfprintf_r+0x1678>
800099b2:	50 a7       	stdsp	sp[0x28],r7
800099b4:	50 80       	stdsp	sp[0x20],r0
800099b6:	0c 97       	mov	r7,r6
800099b8:	04 94       	mov	r4,r2
800099ba:	06 96       	mov	r6,r3
800099bc:	02 92       	mov	r2,r1
800099be:	40 93       	lddsp	r3,sp[0x24]
800099c0:	10 90       	mov	r0,r8
800099c2:	40 41       	lddsp	r1,sp[0x10]
800099c4:	a5 a5       	sbr	r5,0x4
800099c6:	c0 a8       	rjmp	800099da <_vfprintf_r+0x10fe>
800099c8:	50 a7       	stdsp	sp[0x28],r7
800099ca:	50 80       	stdsp	sp[0x20],r0
800099cc:	0c 97       	mov	r7,r6
800099ce:	04 94       	mov	r4,r2
800099d0:	06 96       	mov	r6,r3
800099d2:	02 92       	mov	r2,r1
800099d4:	40 93       	lddsp	r3,sp[0x24]
800099d6:	10 90       	mov	r0,r8
800099d8:	40 41       	lddsp	r1,sp[0x10]
800099da:	ed b5 00 05 	bld	r5,0x5
800099de:	c5 71       	brne	80009a8c <_vfprintf_r+0x11b0>
800099e0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800099e4:	40 39       	lddsp	r9,sp[0xc]
800099e6:	58 09       	cp.w	r9,0
800099e8:	c2 20       	breq	80009a2c <_vfprintf_r+0x1150>
800099ea:	10 36       	cp.w	r6,r8
800099ec:	c0 84       	brge	800099fc <_vfprintf_r+0x1120>
800099ee:	fa c8 f9 44 	sub	r8,sp,-1724
800099f2:	f0 06 00 36 	add	r6,r8,r6<<0x3
800099f6:	c2 48       	rjmp	80009a3e <_vfprintf_r+0x1162>
800099f8:	80 02       	ld.sh	r2,r0[0x0]
800099fa:	f7 d8       	*unknown*
800099fc:	fa c8 f9 50 	sub	r8,sp,-1712
80009a00:	1a d8       	st.w	--sp,r8
80009a02:	fa c8 fa b8 	sub	r8,sp,-1352
80009a06:	1a d8       	st.w	--sp,r8
80009a08:	fa c8 fb b4 	sub	r8,sp,-1100
80009a0c:	1a d8       	st.w	--sp,r8
80009a0e:	fa c8 f9 40 	sub	r8,sp,-1728
80009a12:	fa c9 ff b4 	sub	r9,sp,-76
80009a16:	04 9a       	mov	r10,r2
80009a18:	0c 9b       	mov	r11,r6
80009a1a:	08 9c       	mov	r12,r4
80009a1c:	fe b0 f5 c2 	rcall	800085a0 <get_arg>
80009a20:	2f dd       	sub	sp,-12
80009a22:	f8 e8 00 00 	ld.d	r8,r12[0]
80009a26:	fa e9 00 00 	st.d	sp[0],r8
80009a2a:	c2 e8       	rjmp	80009a86 <_vfprintf_r+0x11aa>
80009a2c:	ee ca ff ff 	sub	r10,r7,-1
80009a30:	10 37       	cp.w	r7,r8
80009a32:	c0 b4       	brge	80009a48 <_vfprintf_r+0x116c>
80009a34:	fa c8 f9 44 	sub	r8,sp,-1724
80009a38:	14 97       	mov	r7,r10
80009a3a:	f0 06 00 36 	add	r6,r8,r6<<0x3
80009a3e:	ec ea fd 88 	ld.d	r10,r6[-632]
80009a42:	fa eb 00 00 	st.d	sp[0],r10
80009a46:	c2 08       	rjmp	80009a86 <_vfprintf_r+0x11aa>
80009a48:	41 09       	lddsp	r9,sp[0x40]
80009a4a:	59 f8       	cp.w	r8,31
80009a4c:	e0 89 00 16 	brgt	80009a78 <_vfprintf_r+0x119c>
80009a50:	f2 e6 00 00 	ld.d	r6,r9[0]
80009a54:	f2 cb ff f8 	sub	r11,r9,-8
80009a58:	fa e7 00 00 	st.d	sp[0],r6
80009a5c:	51 0b       	stdsp	sp[0x40],r11
80009a5e:	fa c6 f9 44 	sub	r6,sp,-1724
80009a62:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009a66:	fa e6 00 00 	ld.d	r6,sp[0]
80009a6a:	f2 e7 fd 88 	st.d	r9[-632],r6
80009a6e:	2f f8       	sub	r8,-1
80009a70:	14 97       	mov	r7,r10
80009a72:	fb 48 06 b4 	st.w	sp[1716],r8
80009a76:	c0 88       	rjmp	80009a86 <_vfprintf_r+0x11aa>
80009a78:	f2 e6 00 00 	ld.d	r6,r9[0]
80009a7c:	2f 89       	sub	r9,-8
80009a7e:	fa e7 00 00 	st.d	sp[0],r6
80009a82:	51 09       	stdsp	sp[0x40],r9
80009a84:	14 97       	mov	r7,r10
80009a86:	30 18       	mov	r8,1
80009a88:	e0 8f 01 d0 	bral	80009e28 <_vfprintf_r+0x154c>
80009a8c:	ed b5 00 04 	bld	r5,0x4
80009a90:	c1 61       	brne	80009abc <_vfprintf_r+0x11e0>
80009a92:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009a96:	40 3e       	lddsp	lr,sp[0xc]
80009a98:	58 0e       	cp.w	lr,0
80009a9a:	c0 80       	breq	80009aaa <_vfprintf_r+0x11ce>
80009a9c:	10 36       	cp.w	r6,r8
80009a9e:	c6 74       	brge	80009b6c <_vfprintf_r+0x1290>
80009aa0:	fa cc f9 44 	sub	r12,sp,-1724
80009aa4:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009aa8:	c8 08       	rjmp	80009ba8 <_vfprintf_r+0x12cc>
80009aaa:	ee ca ff ff 	sub	r10,r7,-1
80009aae:	10 37       	cp.w	r7,r8
80009ab0:	c7 f4       	brge	80009bae <_vfprintf_r+0x12d2>
80009ab2:	fa cb f9 44 	sub	r11,sp,-1724
80009ab6:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009aba:	c7 68       	rjmp	80009ba6 <_vfprintf_r+0x12ca>
80009abc:	ed b5 00 06 	bld	r5,0x6
80009ac0:	c4 a1       	brne	80009b54 <_vfprintf_r+0x1278>
80009ac2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009ac6:	40 3c       	lddsp	r12,sp[0xc]
80009ac8:	58 0c       	cp.w	r12,0
80009aca:	c1 d0       	breq	80009b04 <_vfprintf_r+0x1228>
80009acc:	10 36       	cp.w	r6,r8
80009ace:	c0 64       	brge	80009ada <_vfprintf_r+0x11fe>
80009ad0:	fa cb f9 44 	sub	r11,sp,-1724
80009ad4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009ad8:	c1 f8       	rjmp	80009b16 <_vfprintf_r+0x123a>
80009ada:	fa c8 f9 50 	sub	r8,sp,-1712
80009ade:	1a d8       	st.w	--sp,r8
80009ae0:	fa c8 fa b8 	sub	r8,sp,-1352
80009ae4:	1a d8       	st.w	--sp,r8
80009ae6:	fa c8 fb b4 	sub	r8,sp,-1100
80009aea:	1a d8       	st.w	--sp,r8
80009aec:	fa c8 f9 40 	sub	r8,sp,-1728
80009af0:	fa c9 ff b4 	sub	r9,sp,-76
80009af4:	04 9a       	mov	r10,r2
80009af6:	0c 9b       	mov	r11,r6
80009af8:	08 9c       	mov	r12,r4
80009afa:	fe b0 f5 53 	rcall	800085a0 <get_arg>
80009afe:	2f dd       	sub	sp,-12
80009b00:	98 18       	ld.sh	r8,r12[0x2]
80009b02:	c2 68       	rjmp	80009b4e <_vfprintf_r+0x1272>
80009b04:	ee ca ff ff 	sub	r10,r7,-1
80009b08:	10 37       	cp.w	r7,r8
80009b0a:	c0 94       	brge	80009b1c <_vfprintf_r+0x1240>
80009b0c:	fa c9 f9 44 	sub	r9,sp,-1724
80009b10:	14 97       	mov	r7,r10
80009b12:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009b16:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009b1a:	c1 a8       	rjmp	80009b4e <_vfprintf_r+0x1272>
80009b1c:	41 09       	lddsp	r9,sp[0x40]
80009b1e:	59 f8       	cp.w	r8,31
80009b20:	e0 89 00 13 	brgt	80009b46 <_vfprintf_r+0x126a>
80009b24:	f2 cb ff fc 	sub	r11,r9,-4
80009b28:	51 0b       	stdsp	sp[0x40],r11
80009b2a:	72 09       	ld.w	r9,r9[0x0]
80009b2c:	fa c6 f9 44 	sub	r6,sp,-1724
80009b30:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009b34:	2f f8       	sub	r8,-1
80009b36:	f7 49 fd 88 	st.w	r11[-632],r9
80009b3a:	fb 48 06 b4 	st.w	sp[1716],r8
80009b3e:	14 97       	mov	r7,r10
80009b40:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009b44:	c0 58       	rjmp	80009b4e <_vfprintf_r+0x1272>
80009b46:	92 18       	ld.sh	r8,r9[0x2]
80009b48:	14 97       	mov	r7,r10
80009b4a:	2f c9       	sub	r9,-4
80009b4c:	51 09       	stdsp	sp[0x40],r9
80009b4e:	5c 78       	castu.h	r8
80009b50:	50 18       	stdsp	sp[0x4],r8
80009b52:	c4 68       	rjmp	80009bde <_vfprintf_r+0x1302>
80009b54:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009b58:	40 3c       	lddsp	r12,sp[0xc]
80009b5a:	58 0c       	cp.w	r12,0
80009b5c:	c1 d0       	breq	80009b96 <_vfprintf_r+0x12ba>
80009b5e:	10 36       	cp.w	r6,r8
80009b60:	c0 64       	brge	80009b6c <_vfprintf_r+0x1290>
80009b62:	fa cb f9 44 	sub	r11,sp,-1724
80009b66:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009b6a:	c1 f8       	rjmp	80009ba8 <_vfprintf_r+0x12cc>
80009b6c:	fa c8 f9 50 	sub	r8,sp,-1712
80009b70:	1a d8       	st.w	--sp,r8
80009b72:	fa c8 fa b8 	sub	r8,sp,-1352
80009b76:	0c 9b       	mov	r11,r6
80009b78:	1a d8       	st.w	--sp,r8
80009b7a:	fa c8 fb b4 	sub	r8,sp,-1100
80009b7e:	04 9a       	mov	r10,r2
80009b80:	1a d8       	st.w	--sp,r8
80009b82:	08 9c       	mov	r12,r4
80009b84:	fa c8 f9 40 	sub	r8,sp,-1728
80009b88:	fa c9 ff b4 	sub	r9,sp,-76
80009b8c:	fe b0 f5 0a 	rcall	800085a0 <get_arg>
80009b90:	2f dd       	sub	sp,-12
80009b92:	78 0b       	ld.w	r11,r12[0x0]
80009b94:	c2 48       	rjmp	80009bdc <_vfprintf_r+0x1300>
80009b96:	ee ca ff ff 	sub	r10,r7,-1
80009b9a:	10 37       	cp.w	r7,r8
80009b9c:	c0 94       	brge	80009bae <_vfprintf_r+0x12d2>
80009b9e:	fa c9 f9 44 	sub	r9,sp,-1724
80009ba2:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009ba6:	14 97       	mov	r7,r10
80009ba8:	ec fb fd 88 	ld.w	r11,r6[-632]
80009bac:	c1 88       	rjmp	80009bdc <_vfprintf_r+0x1300>
80009bae:	41 09       	lddsp	r9,sp[0x40]
80009bb0:	59 f8       	cp.w	r8,31
80009bb2:	e0 89 00 11 	brgt	80009bd4 <_vfprintf_r+0x12f8>
80009bb6:	f2 cb ff fc 	sub	r11,r9,-4
80009bba:	51 0b       	stdsp	sp[0x40],r11
80009bbc:	fa c6 f9 44 	sub	r6,sp,-1724
80009bc0:	72 0b       	ld.w	r11,r9[0x0]
80009bc2:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009bc6:	f3 4b fd 88 	st.w	r9[-632],r11
80009bca:	2f f8       	sub	r8,-1
80009bcc:	14 97       	mov	r7,r10
80009bce:	fb 48 06 b4 	st.w	sp[1716],r8
80009bd2:	c0 58       	rjmp	80009bdc <_vfprintf_r+0x1300>
80009bd4:	72 0b       	ld.w	r11,r9[0x0]
80009bd6:	14 97       	mov	r7,r10
80009bd8:	2f c9       	sub	r9,-4
80009bda:	51 09       	stdsp	sp[0x40],r9
80009bdc:	50 1b       	stdsp	sp[0x4],r11
80009bde:	30 0e       	mov	lr,0
80009be0:	30 18       	mov	r8,1
80009be2:	50 0e       	stdsp	sp[0x0],lr
80009be4:	c2 29       	rjmp	80009e28 <_vfprintf_r+0x154c>
80009be6:	50 a7       	stdsp	sp[0x28],r7
80009be8:	50 80       	stdsp	sp[0x20],r0
80009bea:	0c 97       	mov	r7,r6
80009bec:	04 94       	mov	r4,r2
80009bee:	06 96       	mov	r6,r3
80009bf0:	02 92       	mov	r2,r1
80009bf2:	4d 3c       	lddpc	r12,80009d3c <_vfprintf_r+0x1460>
80009bf4:	40 93       	lddsp	r3,sp[0x24]
80009bf6:	10 90       	mov	r0,r8
80009bf8:	40 41       	lddsp	r1,sp[0x10]
80009bfa:	50 dc       	stdsp	sp[0x34],r12
80009bfc:	ed b5 00 05 	bld	r5,0x5
80009c00:	c5 51       	brne	80009caa <_vfprintf_r+0x13ce>
80009c02:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009c06:	40 3b       	lddsp	r11,sp[0xc]
80009c08:	58 0b       	cp.w	r11,0
80009c0a:	c2 20       	breq	80009c4e <_vfprintf_r+0x1372>
80009c0c:	10 36       	cp.w	r6,r8
80009c0e:	c0 a4       	brge	80009c22 <_vfprintf_r+0x1346>
80009c10:	fa ca f9 44 	sub	r10,sp,-1724
80009c14:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009c18:	ec e8 fd 88 	ld.d	r8,r6[-632]
80009c1c:	fa e9 00 00 	st.d	sp[0],r8
80009c20:	cf 38       	rjmp	80009e06 <_vfprintf_r+0x152a>
80009c22:	fa c8 f9 50 	sub	r8,sp,-1712
80009c26:	1a d8       	st.w	--sp,r8
80009c28:	fa c8 fa b8 	sub	r8,sp,-1352
80009c2c:	04 9a       	mov	r10,r2
80009c2e:	1a d8       	st.w	--sp,r8
80009c30:	0c 9b       	mov	r11,r6
80009c32:	fa c8 fb b4 	sub	r8,sp,-1100
80009c36:	08 9c       	mov	r12,r4
80009c38:	1a d8       	st.w	--sp,r8
80009c3a:	fa c8 f9 40 	sub	r8,sp,-1728
80009c3e:	fa c9 ff b4 	sub	r9,sp,-76
80009c42:	fe b0 f4 af 	rcall	800085a0 <get_arg>
80009c46:	2f dd       	sub	sp,-12
80009c48:	f8 ea 00 00 	ld.d	r10,r12[0]
80009c4c:	c0 c8       	rjmp	80009c64 <_vfprintf_r+0x1388>
80009c4e:	ee ca ff ff 	sub	r10,r7,-1
80009c52:	10 37       	cp.w	r7,r8
80009c54:	c0 b4       	brge	80009c6a <_vfprintf_r+0x138e>
80009c56:	fa c9 f9 44 	sub	r9,sp,-1724
80009c5a:	14 97       	mov	r7,r10
80009c5c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009c60:	ec ea fd 88 	ld.d	r10,r6[-632]
80009c64:	fa eb 00 00 	st.d	sp[0],r10
80009c68:	cc f8       	rjmp	80009e06 <_vfprintf_r+0x152a>
80009c6a:	41 09       	lddsp	r9,sp[0x40]
80009c6c:	59 f8       	cp.w	r8,31
80009c6e:	e0 89 00 16 	brgt	80009c9a <_vfprintf_r+0x13be>
80009c72:	f2 e6 00 00 	ld.d	r6,r9[0]
80009c76:	f2 cb ff f8 	sub	r11,r9,-8
80009c7a:	fa e7 00 00 	st.d	sp[0],r6
80009c7e:	51 0b       	stdsp	sp[0x40],r11
80009c80:	fa c6 f9 44 	sub	r6,sp,-1724
80009c84:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009c88:	fa e6 00 00 	ld.d	r6,sp[0]
80009c8c:	f2 e7 fd 88 	st.d	r9[-632],r6
80009c90:	2f f8       	sub	r8,-1
80009c92:	14 97       	mov	r7,r10
80009c94:	fb 48 06 b4 	st.w	sp[1716],r8
80009c98:	cb 78       	rjmp	80009e06 <_vfprintf_r+0x152a>
80009c9a:	f2 e6 00 00 	ld.d	r6,r9[0]
80009c9e:	2f 89       	sub	r9,-8
80009ca0:	fa e7 00 00 	st.d	sp[0],r6
80009ca4:	51 09       	stdsp	sp[0x40],r9
80009ca6:	14 97       	mov	r7,r10
80009ca8:	ca f8       	rjmp	80009e06 <_vfprintf_r+0x152a>
80009caa:	ed b5 00 04 	bld	r5,0x4
80009cae:	c1 71       	brne	80009cdc <_vfprintf_r+0x1400>
80009cb0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009cb4:	40 3e       	lddsp	lr,sp[0xc]
80009cb6:	58 0e       	cp.w	lr,0
80009cb8:	c0 80       	breq	80009cc8 <_vfprintf_r+0x13ec>
80009cba:	10 36       	cp.w	r6,r8
80009cbc:	c6 a4       	brge	80009d90 <_vfprintf_r+0x14b4>
80009cbe:	fa cc f9 44 	sub	r12,sp,-1724
80009cc2:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009cc6:	c8 38       	rjmp	80009dcc <_vfprintf_r+0x14f0>
80009cc8:	ee ca ff ff 	sub	r10,r7,-1
80009ccc:	10 37       	cp.w	r7,r8
80009cce:	e0 84 00 82 	brge	80009dd2 <_vfprintf_r+0x14f6>
80009cd2:	fa cb f9 44 	sub	r11,sp,-1724
80009cd6:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009cda:	c7 88       	rjmp	80009dca <_vfprintf_r+0x14ee>
80009cdc:	ed b5 00 06 	bld	r5,0x6
80009ce0:	c4 c1       	brne	80009d78 <_vfprintf_r+0x149c>
80009ce2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009ce6:	40 3c       	lddsp	r12,sp[0xc]
80009ce8:	58 0c       	cp.w	r12,0
80009cea:	c1 d0       	breq	80009d24 <_vfprintf_r+0x1448>
80009cec:	10 36       	cp.w	r6,r8
80009cee:	c0 64       	brge	80009cfa <_vfprintf_r+0x141e>
80009cf0:	fa cb f9 44 	sub	r11,sp,-1724
80009cf4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009cf8:	c1 f8       	rjmp	80009d36 <_vfprintf_r+0x145a>
80009cfa:	fa c8 f9 50 	sub	r8,sp,-1712
80009cfe:	1a d8       	st.w	--sp,r8
80009d00:	fa c8 fa b8 	sub	r8,sp,-1352
80009d04:	1a d8       	st.w	--sp,r8
80009d06:	fa c8 fb b4 	sub	r8,sp,-1100
80009d0a:	1a d8       	st.w	--sp,r8
80009d0c:	fa c8 f9 40 	sub	r8,sp,-1728
80009d10:	fa c9 ff b4 	sub	r9,sp,-76
80009d14:	04 9a       	mov	r10,r2
80009d16:	0c 9b       	mov	r11,r6
80009d18:	08 9c       	mov	r12,r4
80009d1a:	fe b0 f4 43 	rcall	800085a0 <get_arg>
80009d1e:	2f dd       	sub	sp,-12
80009d20:	98 18       	ld.sh	r8,r12[0x2]
80009d22:	c2 88       	rjmp	80009d72 <_vfprintf_r+0x1496>
80009d24:	ee ca ff ff 	sub	r10,r7,-1
80009d28:	10 37       	cp.w	r7,r8
80009d2a:	c0 b4       	brge	80009d40 <_vfprintf_r+0x1464>
80009d2c:	fa c9 f9 44 	sub	r9,sp,-1724
80009d30:	14 97       	mov	r7,r10
80009d32:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009d36:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009d3a:	c1 c8       	rjmp	80009d72 <_vfprintf_r+0x1496>
80009d3c:	80 02       	ld.sh	r2,r0[0x0]
80009d3e:	f7 d8 41 09 	ldins.b	r8:b,r11[265]
80009d42:	59 f8       	cp.w	r8,31
80009d44:	e0 89 00 13 	brgt	80009d6a <_vfprintf_r+0x148e>
80009d48:	f2 cb ff fc 	sub	r11,r9,-4
80009d4c:	51 0b       	stdsp	sp[0x40],r11
80009d4e:	72 09       	ld.w	r9,r9[0x0]
80009d50:	fa c6 f9 44 	sub	r6,sp,-1724
80009d54:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009d58:	2f f8       	sub	r8,-1
80009d5a:	f7 49 fd 88 	st.w	r11[-632],r9
80009d5e:	fb 48 06 b4 	st.w	sp[1716],r8
80009d62:	14 97       	mov	r7,r10
80009d64:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009d68:	c0 58       	rjmp	80009d72 <_vfprintf_r+0x1496>
80009d6a:	92 18       	ld.sh	r8,r9[0x2]
80009d6c:	14 97       	mov	r7,r10
80009d6e:	2f c9       	sub	r9,-4
80009d70:	51 09       	stdsp	sp[0x40],r9
80009d72:	5c 78       	castu.h	r8
80009d74:	50 18       	stdsp	sp[0x4],r8
80009d76:	c4 68       	rjmp	80009e02 <_vfprintf_r+0x1526>
80009d78:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009d7c:	40 3c       	lddsp	r12,sp[0xc]
80009d7e:	58 0c       	cp.w	r12,0
80009d80:	c1 d0       	breq	80009dba <_vfprintf_r+0x14de>
80009d82:	10 36       	cp.w	r6,r8
80009d84:	c0 64       	brge	80009d90 <_vfprintf_r+0x14b4>
80009d86:	fa cb f9 44 	sub	r11,sp,-1724
80009d8a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009d8e:	c1 f8       	rjmp	80009dcc <_vfprintf_r+0x14f0>
80009d90:	fa c8 f9 50 	sub	r8,sp,-1712
80009d94:	1a d8       	st.w	--sp,r8
80009d96:	fa c8 fa b8 	sub	r8,sp,-1352
80009d9a:	0c 9b       	mov	r11,r6
80009d9c:	1a d8       	st.w	--sp,r8
80009d9e:	fa c8 fb b4 	sub	r8,sp,-1100
80009da2:	04 9a       	mov	r10,r2
80009da4:	1a d8       	st.w	--sp,r8
80009da6:	08 9c       	mov	r12,r4
80009da8:	fa c8 f9 40 	sub	r8,sp,-1728
80009dac:	fa c9 ff b4 	sub	r9,sp,-76
80009db0:	fe b0 f3 f8 	rcall	800085a0 <get_arg>
80009db4:	2f dd       	sub	sp,-12
80009db6:	78 0b       	ld.w	r11,r12[0x0]
80009db8:	c2 48       	rjmp	80009e00 <_vfprintf_r+0x1524>
80009dba:	ee ca ff ff 	sub	r10,r7,-1
80009dbe:	10 37       	cp.w	r7,r8
80009dc0:	c0 94       	brge	80009dd2 <_vfprintf_r+0x14f6>
80009dc2:	fa c9 f9 44 	sub	r9,sp,-1724
80009dc6:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009dca:	14 97       	mov	r7,r10
80009dcc:	ec fb fd 88 	ld.w	r11,r6[-632]
80009dd0:	c1 88       	rjmp	80009e00 <_vfprintf_r+0x1524>
80009dd2:	41 09       	lddsp	r9,sp[0x40]
80009dd4:	59 f8       	cp.w	r8,31
80009dd6:	e0 89 00 11 	brgt	80009df8 <_vfprintf_r+0x151c>
80009dda:	f2 cb ff fc 	sub	r11,r9,-4
80009dde:	51 0b       	stdsp	sp[0x40],r11
80009de0:	fa c6 f9 44 	sub	r6,sp,-1724
80009de4:	72 0b       	ld.w	r11,r9[0x0]
80009de6:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009dea:	f3 4b fd 88 	st.w	r9[-632],r11
80009dee:	2f f8       	sub	r8,-1
80009df0:	14 97       	mov	r7,r10
80009df2:	fb 48 06 b4 	st.w	sp[1716],r8
80009df6:	c0 58       	rjmp	80009e00 <_vfprintf_r+0x1524>
80009df8:	72 0b       	ld.w	r11,r9[0x0]
80009dfa:	14 97       	mov	r7,r10
80009dfc:	2f c9       	sub	r9,-4
80009dfe:	51 09       	stdsp	sp[0x40],r9
80009e00:	50 1b       	stdsp	sp[0x4],r11
80009e02:	30 0e       	mov	lr,0
80009e04:	50 0e       	stdsp	sp[0x0],lr
80009e06:	40 08       	lddsp	r8,sp[0x0]
80009e08:	40 1c       	lddsp	r12,sp[0x4]
80009e0a:	18 48       	or	r8,r12
80009e0c:	5f 19       	srne	r9
80009e0e:	0a 98       	mov	r8,r5
80009e10:	eb e9 00 09 	and	r9,r5,r9
80009e14:	a1 b8       	sbr	r8,0x1
80009e16:	58 09       	cp.w	r9,0
80009e18:	c0 70       	breq	80009e26 <_vfprintf_r+0x154a>
80009e1a:	10 95       	mov	r5,r8
80009e1c:	fb 60 06 b9 	st.b	sp[1721],r0
80009e20:	33 08       	mov	r8,48
80009e22:	fb 68 06 b8 	st.b	sp[1720],r8
80009e26:	30 28       	mov	r8,2
80009e28:	30 09       	mov	r9,0
80009e2a:	fb 69 06 bb 	st.b	sp[1723],r9
80009e2e:	0a 99       	mov	r9,r5
80009e30:	a7 d9       	cbr	r9,0x7
80009e32:	40 2b       	lddsp	r11,sp[0x8]
80009e34:	40 16       	lddsp	r6,sp[0x4]
80009e36:	58 0b       	cp.w	r11,0
80009e38:	5f 1a       	srne	r10
80009e3a:	f2 05 17 40 	movge	r5,r9
80009e3e:	fa c2 f9 78 	sub	r2,sp,-1672
80009e42:	40 09       	lddsp	r9,sp[0x0]
80009e44:	0c 49       	or	r9,r6
80009e46:	5f 19       	srne	r9
80009e48:	f5 e9 10 09 	or	r9,r10,r9
80009e4c:	c5 c0       	breq	80009f04 <_vfprintf_r+0x1628>
80009e4e:	30 19       	mov	r9,1
80009e50:	f2 08 18 00 	cp.b	r8,r9
80009e54:	c0 60       	breq	80009e60 <_vfprintf_r+0x1584>
80009e56:	30 29       	mov	r9,2
80009e58:	f2 08 18 00 	cp.b	r8,r9
80009e5c:	c0 41       	brne	80009e64 <_vfprintf_r+0x1588>
80009e5e:	c3 c8       	rjmp	80009ed6 <_vfprintf_r+0x15fa>
80009e60:	04 96       	mov	r6,r2
80009e62:	c3 08       	rjmp	80009ec2 <_vfprintf_r+0x15e6>
80009e64:	04 96       	mov	r6,r2
80009e66:	fa e8 00 00 	ld.d	r8,sp[0]
80009e6a:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80009e6e:	2d 0a       	sub	r10,-48
80009e70:	0c fa       	st.b	--r6,r10
80009e72:	f0 0b 16 03 	lsr	r11,r8,0x3
80009e76:	f2 0c 16 03 	lsr	r12,r9,0x3
80009e7a:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80009e7e:	18 99       	mov	r9,r12
80009e80:	16 98       	mov	r8,r11
80009e82:	58 08       	cp.w	r8,0
80009e84:	5c 29       	cpc	r9
80009e86:	cf 21       	brne	80009e6a <_vfprintf_r+0x158e>
80009e88:	fa e9 00 00 	st.d	sp[0],r8
80009e8c:	ed b5 00 00 	bld	r5,0x0
80009e90:	c4 51       	brne	80009f1a <_vfprintf_r+0x163e>
80009e92:	33 09       	mov	r9,48
80009e94:	f2 0a 18 00 	cp.b	r10,r9
80009e98:	c4 10       	breq	80009f1a <_vfprintf_r+0x163e>
80009e9a:	0c f9       	st.b	--r6,r9
80009e9c:	c3 f8       	rjmp	80009f1a <_vfprintf_r+0x163e>
80009e9e:	fa ea 00 00 	ld.d	r10,sp[0]
80009ea2:	30 a8       	mov	r8,10
80009ea4:	30 09       	mov	r9,0
80009ea6:	e0 a0 14 7b 	rcall	8000c79c <__avr32_umod64>
80009eaa:	30 a8       	mov	r8,10
80009eac:	2d 0a       	sub	r10,-48
80009eae:	30 09       	mov	r9,0
80009eb0:	ac 8a       	st.b	r6[0x0],r10
80009eb2:	fa ea 00 00 	ld.d	r10,sp[0]
80009eb6:	fe b0 ed 69 	rcall	80007988 <__avr32_udiv64>
80009eba:	16 99       	mov	r9,r11
80009ebc:	14 98       	mov	r8,r10
80009ebe:	fa e9 00 00 	st.d	sp[0],r8
80009ec2:	20 16       	sub	r6,1
80009ec4:	fa ea 00 00 	ld.d	r10,sp[0]
80009ec8:	58 9a       	cp.w	r10,9
80009eca:	5c 2b       	cpc	r11
80009ecc:	fe 9b ff e9 	brhi	80009e9e <_vfprintf_r+0x15c2>
80009ed0:	1b f8       	ld.ub	r8,sp[0x7]
80009ed2:	2d 08       	sub	r8,-48
80009ed4:	c2 08       	rjmp	80009f14 <_vfprintf_r+0x1638>
80009ed6:	04 96       	mov	r6,r2
80009ed8:	fa e8 00 00 	ld.d	r8,sp[0]
80009edc:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80009ee0:	40 de       	lddsp	lr,sp[0x34]
80009ee2:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80009ee6:	0c fa       	st.b	--r6,r10
80009ee8:	f2 0b 16 04 	lsr	r11,r9,0x4
80009eec:	f0 0a 16 04 	lsr	r10,r8,0x4
80009ef0:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80009ef4:	16 99       	mov	r9,r11
80009ef6:	14 98       	mov	r8,r10
80009ef8:	58 08       	cp.w	r8,0
80009efa:	5c 29       	cpc	r9
80009efc:	cf 01       	brne	80009edc <_vfprintf_r+0x1600>
80009efe:	fa e9 00 00 	st.d	sp[0],r8
80009f02:	c0 c8       	rjmp	80009f1a <_vfprintf_r+0x163e>
80009f04:	58 08       	cp.w	r8,0
80009f06:	c0 91       	brne	80009f18 <_vfprintf_r+0x163c>
80009f08:	ed b5 00 00 	bld	r5,0x0
80009f0c:	c0 61       	brne	80009f18 <_vfprintf_r+0x163c>
80009f0e:	fa c6 f9 79 	sub	r6,sp,-1671
80009f12:	33 08       	mov	r8,48
80009f14:	ac 88       	st.b	r6[0x0],r8
80009f16:	c0 28       	rjmp	80009f1a <_vfprintf_r+0x163e>
80009f18:	04 96       	mov	r6,r2
80009f1a:	0c 12       	sub	r2,r6
80009f1c:	c1 c8       	rjmp	80009f54 <_vfprintf_r+0x1678>
80009f1e:	50 a7       	stdsp	sp[0x28],r7
80009f20:	50 80       	stdsp	sp[0x20],r0
80009f22:	40 93       	lddsp	r3,sp[0x24]
80009f24:	0c 97       	mov	r7,r6
80009f26:	10 90       	mov	r0,r8
80009f28:	04 94       	mov	r4,r2
80009f2a:	40 41       	lddsp	r1,sp[0x10]
80009f2c:	58 08       	cp.w	r8,0
80009f2e:	e0 80 04 51 	breq	8000a7d0 <_vfprintf_r+0x1ef4>
80009f32:	fb 68 06 60 	st.b	sp[1632],r8
80009f36:	30 0c       	mov	r12,0
80009f38:	30 08       	mov	r8,0
80009f3a:	30 12       	mov	r2,1
80009f3c:	fb 68 06 bb 	st.b	sp[1723],r8
80009f40:	50 2c       	stdsp	sp[0x8],r12
80009f42:	fa c6 f9 a0 	sub	r6,sp,-1632
80009f46:	c0 78       	rjmp	80009f54 <_vfprintf_r+0x1678>
80009f48:	30 0b       	mov	r11,0
80009f4a:	50 2b       	stdsp	sp[0x8],r11
80009f4c:	c0 48       	rjmp	80009f54 <_vfprintf_r+0x1678>
80009f4e:	40 22       	lddsp	r2,sp[0x8]
80009f50:	30 0a       	mov	r10,0
80009f52:	50 2a       	stdsp	sp[0x8],r10
80009f54:	40 29       	lddsp	r9,sp[0x8]
80009f56:	e4 09 0c 49 	max	r9,r2,r9
80009f5a:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009f5e:	50 39       	stdsp	sp[0xc],r9
80009f60:	0a 9e       	mov	lr,r5
80009f62:	30 09       	mov	r9,0
80009f64:	e2 1e 00 02 	andl	lr,0x2,COH
80009f68:	f2 08 18 00 	cp.b	r8,r9
80009f6c:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80009f70:	f7 b8 01 ff 	subne	r8,-1
80009f74:	fb f8 1a 03 	st.wne	sp[0xc],r8
80009f78:	0a 9b       	mov	r11,r5
80009f7a:	58 0e       	cp.w	lr,0
80009f7c:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80009f80:	f7 bc 01 fe 	subne	r12,-2
80009f84:	fb fc 1a 03 	st.wne	sp[0xc],r12
80009f88:	e2 1b 00 84 	andl	r11,0x84,COH
80009f8c:	50 fe       	stdsp	sp[0x3c],lr
80009f8e:	50 9b       	stdsp	sp[0x24],r11
80009f90:	c4 51       	brne	8000a01a <_vfprintf_r+0x173e>
80009f92:	40 8a       	lddsp	r10,sp[0x20]
80009f94:	40 39       	lddsp	r9,sp[0xc]
80009f96:	12 1a       	sub	r10,r9
80009f98:	50 4a       	stdsp	sp[0x10],r10
80009f9a:	58 0a       	cp.w	r10,0
80009f9c:	e0 89 00 1f 	brgt	80009fda <_vfprintf_r+0x16fe>
80009fa0:	c3 d8       	rjmp	8000a01a <_vfprintf_r+0x173e>
80009fa2:	2f 09       	sub	r9,-16
80009fa4:	2f f8       	sub	r8,-1
80009fa6:	4c ee       	lddpc	lr,8000a0dc <_vfprintf_r+0x1800>
80009fa8:	31 0c       	mov	r12,16
80009faa:	fb 49 06 90 	st.w	sp[1680],r9
80009fae:	87 0e       	st.w	r3[0x0],lr
80009fb0:	87 1c       	st.w	r3[0x4],r12
80009fb2:	fb 48 06 8c 	st.w	sp[1676],r8
80009fb6:	58 78       	cp.w	r8,7
80009fb8:	e0 89 00 04 	brgt	80009fc0 <_vfprintf_r+0x16e4>
80009fbc:	2f 83       	sub	r3,-8
80009fbe:	c0 b8       	rjmp	80009fd4 <_vfprintf_r+0x16f8>
80009fc0:	fa ca f9 78 	sub	r10,sp,-1672
80009fc4:	02 9b       	mov	r11,r1
80009fc6:	08 9c       	mov	r12,r4
80009fc8:	fe b0 f4 7c 	rcall	800088c0 <__sprint_r>
80009fcc:	e0 81 04 13 	brne	8000a7f2 <_vfprintf_r+0x1f16>
80009fd0:	fa c3 f9 e0 	sub	r3,sp,-1568
80009fd4:	40 4b       	lddsp	r11,sp[0x10]
80009fd6:	21 0b       	sub	r11,16
80009fd8:	50 4b       	stdsp	sp[0x10],r11
80009fda:	fa f9 06 90 	ld.w	r9,sp[1680]
80009fde:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009fe2:	4b fa       	lddpc	r10,8000a0dc <_vfprintf_r+0x1800>
80009fe4:	40 4e       	lddsp	lr,sp[0x10]
80009fe6:	59 0e       	cp.w	lr,16
80009fe8:	fe 99 ff dd 	brgt	80009fa2 <_vfprintf_r+0x16c6>
80009fec:	1c 09       	add	r9,lr
80009fee:	2f f8       	sub	r8,-1
80009ff0:	87 0a       	st.w	r3[0x0],r10
80009ff2:	fb 49 06 90 	st.w	sp[1680],r9
80009ff6:	87 1e       	st.w	r3[0x4],lr
80009ff8:	fb 48 06 8c 	st.w	sp[1676],r8
80009ffc:	58 78       	cp.w	r8,7
80009ffe:	e0 89 00 04 	brgt	8000a006 <_vfprintf_r+0x172a>
8000a002:	2f 83       	sub	r3,-8
8000a004:	c0 b8       	rjmp	8000a01a <_vfprintf_r+0x173e>
8000a006:	fa ca f9 78 	sub	r10,sp,-1672
8000a00a:	02 9b       	mov	r11,r1
8000a00c:	08 9c       	mov	r12,r4
8000a00e:	fe b0 f4 59 	rcall	800088c0 <__sprint_r>
8000a012:	e0 81 03 f0 	brne	8000a7f2 <_vfprintf_r+0x1f16>
8000a016:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a01a:	30 09       	mov	r9,0
8000a01c:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000a020:	f2 08 18 00 	cp.b	r8,r9
8000a024:	c1 f0       	breq	8000a062 <_vfprintf_r+0x1786>
8000a026:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a02a:	fa c9 f9 45 	sub	r9,sp,-1723
8000a02e:	2f f8       	sub	r8,-1
8000a030:	87 09       	st.w	r3[0x0],r9
8000a032:	fb 48 06 90 	st.w	sp[1680],r8
8000a036:	30 19       	mov	r9,1
8000a038:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a03c:	87 19       	st.w	r3[0x4],r9
8000a03e:	2f f8       	sub	r8,-1
8000a040:	fb 48 06 8c 	st.w	sp[1676],r8
8000a044:	58 78       	cp.w	r8,7
8000a046:	e0 89 00 04 	brgt	8000a04e <_vfprintf_r+0x1772>
8000a04a:	2f 83       	sub	r3,-8
8000a04c:	c0 b8       	rjmp	8000a062 <_vfprintf_r+0x1786>
8000a04e:	fa ca f9 78 	sub	r10,sp,-1672
8000a052:	02 9b       	mov	r11,r1
8000a054:	08 9c       	mov	r12,r4
8000a056:	fe b0 f4 35 	rcall	800088c0 <__sprint_r>
8000a05a:	e0 81 03 cc 	brne	8000a7f2 <_vfprintf_r+0x1f16>
8000a05e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a062:	40 fc       	lddsp	r12,sp[0x3c]
8000a064:	58 0c       	cp.w	r12,0
8000a066:	c1 f0       	breq	8000a0a4 <_vfprintf_r+0x17c8>
8000a068:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a06c:	fa c9 f9 48 	sub	r9,sp,-1720
8000a070:	2f e8       	sub	r8,-2
8000a072:	87 09       	st.w	r3[0x0],r9
8000a074:	fb 48 06 90 	st.w	sp[1680],r8
8000a078:	30 29       	mov	r9,2
8000a07a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a07e:	87 19       	st.w	r3[0x4],r9
8000a080:	2f f8       	sub	r8,-1
8000a082:	fb 48 06 8c 	st.w	sp[1676],r8
8000a086:	58 78       	cp.w	r8,7
8000a088:	e0 89 00 04 	brgt	8000a090 <_vfprintf_r+0x17b4>
8000a08c:	2f 83       	sub	r3,-8
8000a08e:	c0 b8       	rjmp	8000a0a4 <_vfprintf_r+0x17c8>
8000a090:	fa ca f9 78 	sub	r10,sp,-1672
8000a094:	02 9b       	mov	r11,r1
8000a096:	08 9c       	mov	r12,r4
8000a098:	fe b0 f4 14 	rcall	800088c0 <__sprint_r>
8000a09c:	e0 81 03 ab 	brne	8000a7f2 <_vfprintf_r+0x1f16>
8000a0a0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a0a4:	40 9b       	lddsp	r11,sp[0x24]
8000a0a6:	e0 4b 00 80 	cp.w	r11,128
8000a0aa:	c4 a1       	brne	8000a13e <_vfprintf_r+0x1862>
8000a0ac:	40 8a       	lddsp	r10,sp[0x20]
8000a0ae:	40 39       	lddsp	r9,sp[0xc]
8000a0b0:	12 1a       	sub	r10,r9
8000a0b2:	50 4a       	stdsp	sp[0x10],r10
8000a0b4:	58 0a       	cp.w	r10,0
8000a0b6:	e0 89 00 24 	brgt	8000a0fe <_vfprintf_r+0x1822>
8000a0ba:	c4 28       	rjmp	8000a13e <_vfprintf_r+0x1862>
8000a0bc:	2f 09       	sub	r9,-16
8000a0be:	2f f8       	sub	r8,-1
8000a0c0:	48 8e       	lddpc	lr,8000a0e0 <_vfprintf_r+0x1804>
8000a0c2:	31 0c       	mov	r12,16
8000a0c4:	fb 49 06 90 	st.w	sp[1680],r9
8000a0c8:	87 0e       	st.w	r3[0x0],lr
8000a0ca:	87 1c       	st.w	r3[0x4],r12
8000a0cc:	fb 48 06 8c 	st.w	sp[1676],r8
8000a0d0:	58 78       	cp.w	r8,7
8000a0d2:	e0 89 00 09 	brgt	8000a0e4 <_vfprintf_r+0x1808>
8000a0d6:	2f 83       	sub	r3,-8
8000a0d8:	c1 08       	rjmp	8000a0f8 <_vfprintf_r+0x181c>
8000a0da:	d7 03       	nop
8000a0dc:	80 02       	ld.sh	r2,r0[0x0]
8000a0de:	f7 f0 80 02 	ld.wls	r0,r11[0x8]
8000a0e2:	f8 00       	*unknown*
8000a0e4:	fa ca f9 78 	sub	r10,sp,-1672
8000a0e8:	02 9b       	mov	r11,r1
8000a0ea:	08 9c       	mov	r12,r4
8000a0ec:	fe b0 f3 ea 	rcall	800088c0 <__sprint_r>
8000a0f0:	e0 81 03 81 	brne	8000a7f2 <_vfprintf_r+0x1f16>
8000a0f4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a0f8:	40 4b       	lddsp	r11,sp[0x10]
8000a0fa:	21 0b       	sub	r11,16
8000a0fc:	50 4b       	stdsp	sp[0x10],r11
8000a0fe:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a102:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a106:	4c 6a       	lddpc	r10,8000a21c <_vfprintf_r+0x1940>
8000a108:	40 4e       	lddsp	lr,sp[0x10]
8000a10a:	59 0e       	cp.w	lr,16
8000a10c:	fe 99 ff d8 	brgt	8000a0bc <_vfprintf_r+0x17e0>
8000a110:	1c 09       	add	r9,lr
8000a112:	2f f8       	sub	r8,-1
8000a114:	87 0a       	st.w	r3[0x0],r10
8000a116:	fb 49 06 90 	st.w	sp[1680],r9
8000a11a:	87 1e       	st.w	r3[0x4],lr
8000a11c:	fb 48 06 8c 	st.w	sp[1676],r8
8000a120:	58 78       	cp.w	r8,7
8000a122:	e0 89 00 04 	brgt	8000a12a <_vfprintf_r+0x184e>
8000a126:	2f 83       	sub	r3,-8
8000a128:	c0 b8       	rjmp	8000a13e <_vfprintf_r+0x1862>
8000a12a:	fa ca f9 78 	sub	r10,sp,-1672
8000a12e:	02 9b       	mov	r11,r1
8000a130:	08 9c       	mov	r12,r4
8000a132:	fe b0 f3 c7 	rcall	800088c0 <__sprint_r>
8000a136:	e0 81 03 5e 	brne	8000a7f2 <_vfprintf_r+0x1f16>
8000a13a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a13e:	40 2c       	lddsp	r12,sp[0x8]
8000a140:	04 1c       	sub	r12,r2
8000a142:	50 2c       	stdsp	sp[0x8],r12
8000a144:	58 0c       	cp.w	r12,0
8000a146:	e0 89 00 1f 	brgt	8000a184 <_vfprintf_r+0x18a8>
8000a14a:	c3 d8       	rjmp	8000a1c4 <_vfprintf_r+0x18e8>
8000a14c:	2f 09       	sub	r9,-16
8000a14e:	2f f8       	sub	r8,-1
8000a150:	4b 3b       	lddpc	r11,8000a21c <_vfprintf_r+0x1940>
8000a152:	31 0a       	mov	r10,16
8000a154:	fb 49 06 90 	st.w	sp[1680],r9
8000a158:	87 0b       	st.w	r3[0x0],r11
8000a15a:	87 1a       	st.w	r3[0x4],r10
8000a15c:	fb 48 06 8c 	st.w	sp[1676],r8
8000a160:	58 78       	cp.w	r8,7
8000a162:	e0 89 00 04 	brgt	8000a16a <_vfprintf_r+0x188e>
8000a166:	2f 83       	sub	r3,-8
8000a168:	c0 b8       	rjmp	8000a17e <_vfprintf_r+0x18a2>
8000a16a:	fa ca f9 78 	sub	r10,sp,-1672
8000a16e:	02 9b       	mov	r11,r1
8000a170:	08 9c       	mov	r12,r4
8000a172:	fe b0 f3 a7 	rcall	800088c0 <__sprint_r>
8000a176:	e0 81 03 3e 	brne	8000a7f2 <_vfprintf_r+0x1f16>
8000a17a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a17e:	40 29       	lddsp	r9,sp[0x8]
8000a180:	21 09       	sub	r9,16
8000a182:	50 29       	stdsp	sp[0x8],r9
8000a184:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a188:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a18c:	4a 4a       	lddpc	r10,8000a21c <_vfprintf_r+0x1940>
8000a18e:	40 2e       	lddsp	lr,sp[0x8]
8000a190:	59 0e       	cp.w	lr,16
8000a192:	fe 99 ff dd 	brgt	8000a14c <_vfprintf_r+0x1870>
8000a196:	1c 09       	add	r9,lr
8000a198:	2f f8       	sub	r8,-1
8000a19a:	87 0a       	st.w	r3[0x0],r10
8000a19c:	fb 49 06 90 	st.w	sp[1680],r9
8000a1a0:	87 1e       	st.w	r3[0x4],lr
8000a1a2:	fb 48 06 8c 	st.w	sp[1676],r8
8000a1a6:	58 78       	cp.w	r8,7
8000a1a8:	e0 89 00 04 	brgt	8000a1b0 <_vfprintf_r+0x18d4>
8000a1ac:	2f 83       	sub	r3,-8
8000a1ae:	c0 b8       	rjmp	8000a1c4 <_vfprintf_r+0x18e8>
8000a1b0:	fa ca f9 78 	sub	r10,sp,-1672
8000a1b4:	02 9b       	mov	r11,r1
8000a1b6:	08 9c       	mov	r12,r4
8000a1b8:	fe b0 f3 84 	rcall	800088c0 <__sprint_r>
8000a1bc:	e0 81 03 1b 	brne	8000a7f2 <_vfprintf_r+0x1f16>
8000a1c0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a1c4:	ed b5 00 08 	bld	r5,0x8
8000a1c8:	c0 b0       	breq	8000a1de <_vfprintf_r+0x1902>
8000a1ca:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a1ce:	87 12       	st.w	r3[0x4],r2
8000a1d0:	87 06       	st.w	r3[0x0],r6
8000a1d2:	f0 02 00 02 	add	r2,r8,r2
8000a1d6:	fb 42 06 90 	st.w	sp[1680],r2
8000a1da:	e0 8f 01 d5 	bral	8000a584 <_vfprintf_r+0x1ca8>
8000a1de:	e0 40 00 65 	cp.w	r0,101
8000a1e2:	e0 8a 01 d7 	brle	8000a590 <_vfprintf_r+0x1cb4>
8000a1e6:	30 08       	mov	r8,0
8000a1e8:	30 09       	mov	r9,0
8000a1ea:	40 5b       	lddsp	r11,sp[0x14]
8000a1ec:	40 7a       	lddsp	r10,sp[0x1c]
8000a1ee:	e0 a0 12 90 	rcall	8000c70e <__avr32_f64_cmp_eq>
8000a1f2:	c7 a0       	breq	8000a2e6 <_vfprintf_r+0x1a0a>
8000a1f4:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a1f8:	48 a9       	lddpc	r9,8000a220 <_vfprintf_r+0x1944>
8000a1fa:	2f f8       	sub	r8,-1
8000a1fc:	87 09       	st.w	r3[0x0],r9
8000a1fe:	fb 48 06 90 	st.w	sp[1680],r8
8000a202:	30 19       	mov	r9,1
8000a204:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a208:	87 19       	st.w	r3[0x4],r9
8000a20a:	2f f8       	sub	r8,-1
8000a20c:	fb 48 06 8c 	st.w	sp[1676],r8
8000a210:	58 78       	cp.w	r8,7
8000a212:	e0 89 00 09 	brgt	8000a224 <_vfprintf_r+0x1948>
8000a216:	2f 83       	sub	r3,-8
8000a218:	c1 08       	rjmp	8000a238 <_vfprintf_r+0x195c>
8000a21a:	d7 03       	nop
8000a21c:	80 02       	ld.sh	r2,r0[0x0]
8000a21e:	f8 00       	*unknown*
8000a220:	80 02       	ld.sh	r2,r0[0x0]
8000a222:	f7 ec fa ca 	sthh.w	r10[0x2b0],r11:t,r12:t
8000a226:	f9 78 02 9b 	stcond	r12[667],r8
8000a22a:	08 9c       	mov	r12,r4
8000a22c:	fe b0 f3 4a 	rcall	800088c0 <__sprint_r>
8000a230:	e0 81 02 e1 	brne	8000a7f2 <_vfprintf_r+0x1f16>
8000a234:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a238:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000a23c:	40 6c       	lddsp	r12,sp[0x18]
8000a23e:	18 38       	cp.w	r8,r12
8000a240:	c0 55       	brlt	8000a24a <_vfprintf_r+0x196e>
8000a242:	ed b5 00 00 	bld	r5,0x0
8000a246:	e0 81 02 69 	brne	8000a718 <_vfprintf_r+0x1e3c>
8000a24a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a24e:	2f f8       	sub	r8,-1
8000a250:	40 cb       	lddsp	r11,sp[0x30]
8000a252:	fb 48 06 90 	st.w	sp[1680],r8
8000a256:	30 19       	mov	r9,1
8000a258:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a25c:	87 0b       	st.w	r3[0x0],r11
8000a25e:	2f f8       	sub	r8,-1
8000a260:	87 19       	st.w	r3[0x4],r9
8000a262:	fb 48 06 8c 	st.w	sp[1676],r8
8000a266:	58 78       	cp.w	r8,7
8000a268:	e0 89 00 04 	brgt	8000a270 <_vfprintf_r+0x1994>
8000a26c:	2f 83       	sub	r3,-8
8000a26e:	c0 b8       	rjmp	8000a284 <_vfprintf_r+0x19a8>
8000a270:	fa ca f9 78 	sub	r10,sp,-1672
8000a274:	02 9b       	mov	r11,r1
8000a276:	08 9c       	mov	r12,r4
8000a278:	fe b0 f3 24 	rcall	800088c0 <__sprint_r>
8000a27c:	e0 81 02 bb 	brne	8000a7f2 <_vfprintf_r+0x1f16>
8000a280:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a284:	40 66       	lddsp	r6,sp[0x18]
8000a286:	20 16       	sub	r6,1
8000a288:	58 06       	cp.w	r6,0
8000a28a:	e0 89 00 1d 	brgt	8000a2c4 <_vfprintf_r+0x19e8>
8000a28e:	e0 8f 02 45 	bral	8000a718 <_vfprintf_r+0x1e3c>
8000a292:	2f 09       	sub	r9,-16
8000a294:	2f f8       	sub	r8,-1
8000a296:	fb 49 06 90 	st.w	sp[1680],r9
8000a29a:	87 02       	st.w	r3[0x0],r2
8000a29c:	87 10       	st.w	r3[0x4],r0
8000a29e:	fb 48 06 8c 	st.w	sp[1676],r8
8000a2a2:	58 78       	cp.w	r8,7
8000a2a4:	e0 89 00 04 	brgt	8000a2ac <_vfprintf_r+0x19d0>
8000a2a8:	2f 83       	sub	r3,-8
8000a2aa:	c0 b8       	rjmp	8000a2c0 <_vfprintf_r+0x19e4>
8000a2ac:	fa ca f9 78 	sub	r10,sp,-1672
8000a2b0:	02 9b       	mov	r11,r1
8000a2b2:	08 9c       	mov	r12,r4
8000a2b4:	fe b0 f3 06 	rcall	800088c0 <__sprint_r>
8000a2b8:	e0 81 02 9d 	brne	8000a7f2 <_vfprintf_r+0x1f16>
8000a2bc:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a2c0:	21 06       	sub	r6,16
8000a2c2:	c0 38       	rjmp	8000a2c8 <_vfprintf_r+0x19ec>
8000a2c4:	4d 22       	lddpc	r2,8000a40c <_vfprintf_r+0x1b30>
8000a2c6:	31 00       	mov	r0,16
8000a2c8:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a2cc:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a2d0:	4c fa       	lddpc	r10,8000a40c <_vfprintf_r+0x1b30>
8000a2d2:	59 06       	cp.w	r6,16
8000a2d4:	fe 99 ff df 	brgt	8000a292 <_vfprintf_r+0x19b6>
8000a2d8:	0c 09       	add	r9,r6
8000a2da:	87 0a       	st.w	r3[0x0],r10
8000a2dc:	fb 49 06 90 	st.w	sp[1680],r9
8000a2e0:	2f f8       	sub	r8,-1
8000a2e2:	87 16       	st.w	r3[0x4],r6
8000a2e4:	c5 39       	rjmp	8000a58a <_vfprintf_r+0x1cae>
8000a2e6:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000a2ea:	58 0a       	cp.w	r10,0
8000a2ec:	e0 89 00 94 	brgt	8000a414 <_vfprintf_r+0x1b38>
8000a2f0:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a2f4:	4c 79       	lddpc	r9,8000a410 <_vfprintf_r+0x1b34>
8000a2f6:	2f f8       	sub	r8,-1
8000a2f8:	87 09       	st.w	r3[0x0],r9
8000a2fa:	fb 48 06 90 	st.w	sp[1680],r8
8000a2fe:	30 19       	mov	r9,1
8000a300:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a304:	87 19       	st.w	r3[0x4],r9
8000a306:	2f f8       	sub	r8,-1
8000a308:	fb 48 06 8c 	st.w	sp[1676],r8
8000a30c:	58 78       	cp.w	r8,7
8000a30e:	e0 89 00 04 	brgt	8000a316 <_vfprintf_r+0x1a3a>
8000a312:	2f 83       	sub	r3,-8
8000a314:	c0 b8       	rjmp	8000a32a <_vfprintf_r+0x1a4e>
8000a316:	fa ca f9 78 	sub	r10,sp,-1672
8000a31a:	02 9b       	mov	r11,r1
8000a31c:	08 9c       	mov	r12,r4
8000a31e:	fe b0 f2 d1 	rcall	800088c0 <__sprint_r>
8000a322:	e0 81 02 68 	brne	8000a7f2 <_vfprintf_r+0x1f16>
8000a326:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a32a:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000a32e:	58 08       	cp.w	r8,0
8000a330:	c0 81       	brne	8000a340 <_vfprintf_r+0x1a64>
8000a332:	40 6a       	lddsp	r10,sp[0x18]
8000a334:	58 0a       	cp.w	r10,0
8000a336:	c0 51       	brne	8000a340 <_vfprintf_r+0x1a64>
8000a338:	ed b5 00 00 	bld	r5,0x0
8000a33c:	e0 81 01 ee 	brne	8000a718 <_vfprintf_r+0x1e3c>
8000a340:	40 c9       	lddsp	r9,sp[0x30]
8000a342:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a346:	2f f8       	sub	r8,-1
8000a348:	87 09       	st.w	r3[0x0],r9
8000a34a:	fb 48 06 90 	st.w	sp[1680],r8
8000a34e:	30 19       	mov	r9,1
8000a350:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a354:	87 19       	st.w	r3[0x4],r9
8000a356:	2f f8       	sub	r8,-1
8000a358:	fb 48 06 8c 	st.w	sp[1676],r8
8000a35c:	58 78       	cp.w	r8,7
8000a35e:	e0 89 00 04 	brgt	8000a366 <_vfprintf_r+0x1a8a>
8000a362:	2f 83       	sub	r3,-8
8000a364:	c0 b8       	rjmp	8000a37a <_vfprintf_r+0x1a9e>
8000a366:	fa ca f9 78 	sub	r10,sp,-1672
8000a36a:	02 9b       	mov	r11,r1
8000a36c:	08 9c       	mov	r12,r4
8000a36e:	fe b0 f2 a9 	rcall	800088c0 <__sprint_r>
8000a372:	e0 81 02 40 	brne	8000a7f2 <_vfprintf_r+0x1f16>
8000a376:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a37a:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000a37e:	5c 32       	neg	r2
8000a380:	58 02       	cp.w	r2,0
8000a382:	e0 89 00 1d 	brgt	8000a3bc <_vfprintf_r+0x1ae0>
8000a386:	c3 b8       	rjmp	8000a3fc <_vfprintf_r+0x1b20>
8000a388:	2f 09       	sub	r9,-16
8000a38a:	2f f8       	sub	r8,-1
8000a38c:	31 0e       	mov	lr,16
8000a38e:	fb 49 06 90 	st.w	sp[1680],r9
8000a392:	87 00       	st.w	r3[0x0],r0
8000a394:	87 1e       	st.w	r3[0x4],lr
8000a396:	fb 48 06 8c 	st.w	sp[1676],r8
8000a39a:	58 78       	cp.w	r8,7
8000a39c:	e0 89 00 04 	brgt	8000a3a4 <_vfprintf_r+0x1ac8>
8000a3a0:	2f 83       	sub	r3,-8
8000a3a2:	c0 b8       	rjmp	8000a3b8 <_vfprintf_r+0x1adc>
8000a3a4:	fa ca f9 78 	sub	r10,sp,-1672
8000a3a8:	02 9b       	mov	r11,r1
8000a3aa:	08 9c       	mov	r12,r4
8000a3ac:	fe b0 f2 8a 	rcall	800088c0 <__sprint_r>
8000a3b0:	e0 81 02 21 	brne	8000a7f2 <_vfprintf_r+0x1f16>
8000a3b4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a3b8:	21 02       	sub	r2,16
8000a3ba:	c0 28       	rjmp	8000a3be <_vfprintf_r+0x1ae2>
8000a3bc:	49 40       	lddpc	r0,8000a40c <_vfprintf_r+0x1b30>
8000a3be:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a3c2:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a3c6:	49 2a       	lddpc	r10,8000a40c <_vfprintf_r+0x1b30>
8000a3c8:	59 02       	cp.w	r2,16
8000a3ca:	fe 99 ff df 	brgt	8000a388 <_vfprintf_r+0x1aac>
8000a3ce:	04 09       	add	r9,r2
8000a3d0:	2f f8       	sub	r8,-1
8000a3d2:	87 0a       	st.w	r3[0x0],r10
8000a3d4:	fb 49 06 90 	st.w	sp[1680],r9
8000a3d8:	87 12       	st.w	r3[0x4],r2
8000a3da:	fb 48 06 8c 	st.w	sp[1676],r8
8000a3de:	58 78       	cp.w	r8,7
8000a3e0:	e0 89 00 04 	brgt	8000a3e8 <_vfprintf_r+0x1b0c>
8000a3e4:	2f 83       	sub	r3,-8
8000a3e6:	c0 b8       	rjmp	8000a3fc <_vfprintf_r+0x1b20>
8000a3e8:	fa ca f9 78 	sub	r10,sp,-1672
8000a3ec:	02 9b       	mov	r11,r1
8000a3ee:	08 9c       	mov	r12,r4
8000a3f0:	fe b0 f2 68 	rcall	800088c0 <__sprint_r>
8000a3f4:	e0 81 01 ff 	brne	8000a7f2 <_vfprintf_r+0x1f16>
8000a3f8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a3fc:	40 6c       	lddsp	r12,sp[0x18]
8000a3fe:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a402:	87 06       	st.w	r3[0x0],r6
8000a404:	87 1c       	st.w	r3[0x4],r12
8000a406:	18 08       	add	r8,r12
8000a408:	cb c8       	rjmp	8000a580 <_vfprintf_r+0x1ca4>
8000a40a:	d7 03       	nop
8000a40c:	80 02       	ld.sh	r2,r0[0x0]
8000a40e:	f8 00       	*unknown*
8000a410:	80 02       	ld.sh	r2,r0[0x0]
8000a412:	f7 ec fa f9 	sthh.w	r9[0x2bc],r11:t,r12:t
8000a416:	06 90       	mov	r0,r3
8000a418:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a41c:	40 6b       	lddsp	r11,sp[0x18]
8000a41e:	16 3a       	cp.w	r10,r11
8000a420:	c6 d5       	brlt	8000a4fa <_vfprintf_r+0x1c1e>
8000a422:	16 09       	add	r9,r11
8000a424:	2f f8       	sub	r8,-1
8000a426:	87 06       	st.w	r3[0x0],r6
8000a428:	fb 49 06 90 	st.w	sp[1680],r9
8000a42c:	87 1b       	st.w	r3[0x4],r11
8000a42e:	fb 48 06 8c 	st.w	sp[1676],r8
8000a432:	58 78       	cp.w	r8,7
8000a434:	e0 89 00 04 	brgt	8000a43c <_vfprintf_r+0x1b60>
8000a438:	2f 83       	sub	r3,-8
8000a43a:	c0 b8       	rjmp	8000a450 <_vfprintf_r+0x1b74>
8000a43c:	fa ca f9 78 	sub	r10,sp,-1672
8000a440:	02 9b       	mov	r11,r1
8000a442:	08 9c       	mov	r12,r4
8000a444:	fe b0 f2 3e 	rcall	800088c0 <__sprint_r>
8000a448:	e0 81 01 d5 	brne	8000a7f2 <_vfprintf_r+0x1f16>
8000a44c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a450:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000a454:	40 6a       	lddsp	r10,sp[0x18]
8000a456:	14 16       	sub	r6,r10
8000a458:	58 06       	cp.w	r6,0
8000a45a:	e0 89 00 1c 	brgt	8000a492 <_vfprintf_r+0x1bb6>
8000a45e:	c3 b8       	rjmp	8000a4d4 <_vfprintf_r+0x1bf8>
8000a460:	2f 09       	sub	r9,-16
8000a462:	2f f8       	sub	r8,-1
8000a464:	fb 49 06 90 	st.w	sp[1680],r9
8000a468:	87 02       	st.w	r3[0x0],r2
8000a46a:	87 10       	st.w	r3[0x4],r0
8000a46c:	fb 48 06 8c 	st.w	sp[1676],r8
8000a470:	58 78       	cp.w	r8,7
8000a472:	e0 89 00 04 	brgt	8000a47a <_vfprintf_r+0x1b9e>
8000a476:	2f 83       	sub	r3,-8
8000a478:	c0 b8       	rjmp	8000a48e <_vfprintf_r+0x1bb2>
8000a47a:	fa ca f9 78 	sub	r10,sp,-1672
8000a47e:	02 9b       	mov	r11,r1
8000a480:	08 9c       	mov	r12,r4
8000a482:	fe b0 f2 1f 	rcall	800088c0 <__sprint_r>
8000a486:	e0 81 01 b6 	brne	8000a7f2 <_vfprintf_r+0x1f16>
8000a48a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a48e:	21 06       	sub	r6,16
8000a490:	c0 38       	rjmp	8000a496 <_vfprintf_r+0x1bba>
8000a492:	4d c2       	lddpc	r2,8000a600 <_vfprintf_r+0x1d24>
8000a494:	31 00       	mov	r0,16
8000a496:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a49a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a49e:	4d 9a       	lddpc	r10,8000a600 <_vfprintf_r+0x1d24>
8000a4a0:	59 06       	cp.w	r6,16
8000a4a2:	fe 99 ff df 	brgt	8000a460 <_vfprintf_r+0x1b84>
8000a4a6:	0c 09       	add	r9,r6
8000a4a8:	2f f8       	sub	r8,-1
8000a4aa:	87 0a       	st.w	r3[0x0],r10
8000a4ac:	fb 49 06 90 	st.w	sp[1680],r9
8000a4b0:	87 16       	st.w	r3[0x4],r6
8000a4b2:	fb 48 06 8c 	st.w	sp[1676],r8
8000a4b6:	58 78       	cp.w	r8,7
8000a4b8:	e0 89 00 04 	brgt	8000a4c0 <_vfprintf_r+0x1be4>
8000a4bc:	2f 83       	sub	r3,-8
8000a4be:	c0 b8       	rjmp	8000a4d4 <_vfprintf_r+0x1bf8>
8000a4c0:	fa ca f9 78 	sub	r10,sp,-1672
8000a4c4:	02 9b       	mov	r11,r1
8000a4c6:	08 9c       	mov	r12,r4
8000a4c8:	fe b0 f1 fc 	rcall	800088c0 <__sprint_r>
8000a4cc:	e0 81 01 93 	brne	8000a7f2 <_vfprintf_r+0x1f16>
8000a4d0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a4d4:	ed b5 00 00 	bld	r5,0x0
8000a4d8:	e0 81 01 20 	brne	8000a718 <_vfprintf_r+0x1e3c>
8000a4dc:	40 c9       	lddsp	r9,sp[0x30]
8000a4de:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a4e2:	2f f8       	sub	r8,-1
8000a4e4:	87 09       	st.w	r3[0x0],r9
8000a4e6:	fb 48 06 90 	st.w	sp[1680],r8
8000a4ea:	30 19       	mov	r9,1
8000a4ec:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a4f0:	87 19       	st.w	r3[0x4],r9
8000a4f2:	2f f8       	sub	r8,-1
8000a4f4:	fb 48 06 8c 	st.w	sp[1676],r8
8000a4f8:	c0 29       	rjmp	8000a6fc <_vfprintf_r+0x1e20>
8000a4fa:	14 09       	add	r9,r10
8000a4fc:	2f f8       	sub	r8,-1
8000a4fe:	fb 49 06 90 	st.w	sp[1680],r9
8000a502:	87 06       	st.w	r3[0x0],r6
8000a504:	87 1a       	st.w	r3[0x4],r10
8000a506:	fb 48 06 8c 	st.w	sp[1676],r8
8000a50a:	58 78       	cp.w	r8,7
8000a50c:	e0 89 00 04 	brgt	8000a514 <_vfprintf_r+0x1c38>
8000a510:	2f 83       	sub	r3,-8
8000a512:	c0 b8       	rjmp	8000a528 <_vfprintf_r+0x1c4c>
8000a514:	fa ca f9 78 	sub	r10,sp,-1672
8000a518:	02 9b       	mov	r11,r1
8000a51a:	08 9c       	mov	r12,r4
8000a51c:	fe b0 f1 d2 	rcall	800088c0 <__sprint_r>
8000a520:	e0 81 01 69 	brne	8000a7f2 <_vfprintf_r+0x1f16>
8000a524:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a528:	40 c8       	lddsp	r8,sp[0x30]
8000a52a:	87 08       	st.w	r3[0x0],r8
8000a52c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a530:	2f f8       	sub	r8,-1
8000a532:	30 19       	mov	r9,1
8000a534:	fb 48 06 90 	st.w	sp[1680],r8
8000a538:	87 19       	st.w	r3[0x4],r9
8000a53a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a53e:	2f f8       	sub	r8,-1
8000a540:	fb 48 06 8c 	st.w	sp[1676],r8
8000a544:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000a548:	58 78       	cp.w	r8,7
8000a54a:	e0 89 00 04 	brgt	8000a552 <_vfprintf_r+0x1c76>
8000a54e:	2f 83       	sub	r3,-8
8000a550:	c0 b8       	rjmp	8000a566 <_vfprintf_r+0x1c8a>
8000a552:	fa ca f9 78 	sub	r10,sp,-1672
8000a556:	02 9b       	mov	r11,r1
8000a558:	08 9c       	mov	r12,r4
8000a55a:	fe b0 f1 b3 	rcall	800088c0 <__sprint_r>
8000a55e:	e0 81 01 4a 	brne	8000a7f2 <_vfprintf_r+0x1f16>
8000a562:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a566:	04 06       	add	r6,r2
8000a568:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000a56c:	87 06       	st.w	r3[0x0],r6
8000a56e:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a572:	40 66       	lddsp	r6,sp[0x18]
8000a574:	40 6e       	lddsp	lr,sp[0x18]
8000a576:	10 16       	sub	r6,r8
8000a578:	f2 08 01 08 	sub	r8,r9,r8
8000a57c:	87 16       	st.w	r3[0x4],r6
8000a57e:	1c 08       	add	r8,lr
8000a580:	fb 48 06 90 	st.w	sp[1680],r8
8000a584:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a588:	2f f8       	sub	r8,-1
8000a58a:	fb 48 06 8c 	st.w	sp[1676],r8
8000a58e:	cb 78       	rjmp	8000a6fc <_vfprintf_r+0x1e20>
8000a590:	40 6c       	lddsp	r12,sp[0x18]
8000a592:	58 1c       	cp.w	r12,1
8000a594:	e0 89 00 06 	brgt	8000a5a0 <_vfprintf_r+0x1cc4>
8000a598:	ed b5 00 00 	bld	r5,0x0
8000a59c:	e0 81 00 85 	brne	8000a6a6 <_vfprintf_r+0x1dca>
8000a5a0:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a5a4:	2f f8       	sub	r8,-1
8000a5a6:	30 19       	mov	r9,1
8000a5a8:	fb 48 06 90 	st.w	sp[1680],r8
8000a5ac:	87 06       	st.w	r3[0x0],r6
8000a5ae:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a5b2:	87 19       	st.w	r3[0x4],r9
8000a5b4:	2f f8       	sub	r8,-1
8000a5b6:	fb 48 06 8c 	st.w	sp[1676],r8
8000a5ba:	58 78       	cp.w	r8,7
8000a5bc:	e0 89 00 04 	brgt	8000a5c4 <_vfprintf_r+0x1ce8>
8000a5c0:	2f 83       	sub	r3,-8
8000a5c2:	c0 b8       	rjmp	8000a5d8 <_vfprintf_r+0x1cfc>
8000a5c4:	fa ca f9 78 	sub	r10,sp,-1672
8000a5c8:	02 9b       	mov	r11,r1
8000a5ca:	08 9c       	mov	r12,r4
8000a5cc:	fe b0 f1 7a 	rcall	800088c0 <__sprint_r>
8000a5d0:	e0 81 01 11 	brne	8000a7f2 <_vfprintf_r+0x1f16>
8000a5d4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a5d8:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a5dc:	2f f8       	sub	r8,-1
8000a5de:	40 cb       	lddsp	r11,sp[0x30]
8000a5e0:	fb 48 06 90 	st.w	sp[1680],r8
8000a5e4:	30 19       	mov	r9,1
8000a5e6:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a5ea:	87 0b       	st.w	r3[0x0],r11
8000a5ec:	2f f8       	sub	r8,-1
8000a5ee:	87 19       	st.w	r3[0x4],r9
8000a5f0:	fb 48 06 8c 	st.w	sp[1676],r8
8000a5f4:	58 78       	cp.w	r8,7
8000a5f6:	e0 89 00 07 	brgt	8000a604 <_vfprintf_r+0x1d28>
8000a5fa:	2f 83       	sub	r3,-8
8000a5fc:	c0 e8       	rjmp	8000a618 <_vfprintf_r+0x1d3c>
8000a5fe:	d7 03       	nop
8000a600:	80 02       	ld.sh	r2,r0[0x0]
8000a602:	f8 00       	*unknown*
8000a604:	fa ca f9 78 	sub	r10,sp,-1672
8000a608:	02 9b       	mov	r11,r1
8000a60a:	08 9c       	mov	r12,r4
8000a60c:	fe b0 f1 5a 	rcall	800088c0 <__sprint_r>
8000a610:	e0 81 00 f1 	brne	8000a7f2 <_vfprintf_r+0x1f16>
8000a614:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a618:	30 08       	mov	r8,0
8000a61a:	30 09       	mov	r9,0
8000a61c:	40 5b       	lddsp	r11,sp[0x14]
8000a61e:	40 7a       	lddsp	r10,sp[0x1c]
8000a620:	e0 a0 10 77 	rcall	8000c70e <__avr32_f64_cmp_eq>
8000a624:	40 68       	lddsp	r8,sp[0x18]
8000a626:	20 18       	sub	r8,1
8000a628:	58 0c       	cp.w	r12,0
8000a62a:	c0 d1       	brne	8000a644 <_vfprintf_r+0x1d68>
8000a62c:	2f f6       	sub	r6,-1
8000a62e:	87 18       	st.w	r3[0x4],r8
8000a630:	87 06       	st.w	r3[0x0],r6
8000a632:	fa f6 06 90 	ld.w	r6,sp[1680]
8000a636:	10 06       	add	r6,r8
8000a638:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a63c:	fb 46 06 90 	st.w	sp[1680],r6
8000a640:	2f f8       	sub	r8,-1
8000a642:	c2 f8       	rjmp	8000a6a0 <_vfprintf_r+0x1dc4>
8000a644:	10 96       	mov	r6,r8
8000a646:	58 08       	cp.w	r8,0
8000a648:	e0 89 00 1c 	brgt	8000a680 <_vfprintf_r+0x1da4>
8000a64c:	c4 98       	rjmp	8000a6de <_vfprintf_r+0x1e02>
8000a64e:	2f 09       	sub	r9,-16
8000a650:	2f f8       	sub	r8,-1
8000a652:	fb 49 06 90 	st.w	sp[1680],r9
8000a656:	87 02       	st.w	r3[0x0],r2
8000a658:	87 10       	st.w	r3[0x4],r0
8000a65a:	fb 48 06 8c 	st.w	sp[1676],r8
8000a65e:	58 78       	cp.w	r8,7
8000a660:	e0 89 00 04 	brgt	8000a668 <_vfprintf_r+0x1d8c>
8000a664:	2f 83       	sub	r3,-8
8000a666:	c0 b8       	rjmp	8000a67c <_vfprintf_r+0x1da0>
8000a668:	fa ca f9 78 	sub	r10,sp,-1672
8000a66c:	02 9b       	mov	r11,r1
8000a66e:	08 9c       	mov	r12,r4
8000a670:	fe b0 f1 28 	rcall	800088c0 <__sprint_r>
8000a674:	e0 81 00 bf 	brne	8000a7f2 <_vfprintf_r+0x1f16>
8000a678:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a67c:	21 06       	sub	r6,16
8000a67e:	c0 38       	rjmp	8000a684 <_vfprintf_r+0x1da8>
8000a680:	4d 22       	lddpc	r2,8000a7c8 <_vfprintf_r+0x1eec>
8000a682:	31 00       	mov	r0,16
8000a684:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a688:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a68c:	4c fa       	lddpc	r10,8000a7c8 <_vfprintf_r+0x1eec>
8000a68e:	59 06       	cp.w	r6,16
8000a690:	fe 99 ff df 	brgt	8000a64e <_vfprintf_r+0x1d72>
8000a694:	0c 09       	add	r9,r6
8000a696:	87 0a       	st.w	r3[0x0],r10
8000a698:	fb 49 06 90 	st.w	sp[1680],r9
8000a69c:	2f f8       	sub	r8,-1
8000a69e:	87 16       	st.w	r3[0x4],r6
8000a6a0:	fb 48 06 8c 	st.w	sp[1676],r8
8000a6a4:	c0 e8       	rjmp	8000a6c0 <_vfprintf_r+0x1de4>
8000a6a6:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a6aa:	2f f8       	sub	r8,-1
8000a6ac:	30 19       	mov	r9,1
8000a6ae:	fb 48 06 90 	st.w	sp[1680],r8
8000a6b2:	87 06       	st.w	r3[0x0],r6
8000a6b4:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a6b8:	87 19       	st.w	r3[0x4],r9
8000a6ba:	2f f8       	sub	r8,-1
8000a6bc:	fb 48 06 8c 	st.w	sp[1676],r8
8000a6c0:	58 78       	cp.w	r8,7
8000a6c2:	e0 89 00 04 	brgt	8000a6ca <_vfprintf_r+0x1dee>
8000a6c6:	2f 83       	sub	r3,-8
8000a6c8:	c0 b8       	rjmp	8000a6de <_vfprintf_r+0x1e02>
8000a6ca:	fa ca f9 78 	sub	r10,sp,-1672
8000a6ce:	02 9b       	mov	r11,r1
8000a6d0:	08 9c       	mov	r12,r4
8000a6d2:	fe b0 f0 f7 	rcall	800088c0 <__sprint_r>
8000a6d6:	e0 81 00 8e 	brne	8000a7f2 <_vfprintf_r+0x1f16>
8000a6da:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a6de:	40 ea       	lddsp	r10,sp[0x38]
8000a6e0:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a6e4:	14 08       	add	r8,r10
8000a6e6:	fa c9 f9 64 	sub	r9,sp,-1692
8000a6ea:	fb 48 06 90 	st.w	sp[1680],r8
8000a6ee:	87 1a       	st.w	r3[0x4],r10
8000a6f0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a6f4:	87 09       	st.w	r3[0x0],r9
8000a6f6:	2f f8       	sub	r8,-1
8000a6f8:	fb 48 06 8c 	st.w	sp[1676],r8
8000a6fc:	58 78       	cp.w	r8,7
8000a6fe:	e0 89 00 04 	brgt	8000a706 <_vfprintf_r+0x1e2a>
8000a702:	2f 83       	sub	r3,-8
8000a704:	c0 a8       	rjmp	8000a718 <_vfprintf_r+0x1e3c>
8000a706:	fa ca f9 78 	sub	r10,sp,-1672
8000a70a:	02 9b       	mov	r11,r1
8000a70c:	08 9c       	mov	r12,r4
8000a70e:	fe b0 f0 d9 	rcall	800088c0 <__sprint_r>
8000a712:	c7 01       	brne	8000a7f2 <_vfprintf_r+0x1f16>
8000a714:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a718:	e2 15 00 04 	andl	r5,0x4,COH
8000a71c:	c3 d0       	breq	8000a796 <_vfprintf_r+0x1eba>
8000a71e:	40 86       	lddsp	r6,sp[0x20]
8000a720:	40 39       	lddsp	r9,sp[0xc]
8000a722:	12 16       	sub	r6,r9
8000a724:	58 06       	cp.w	r6,0
8000a726:	e0 89 00 1a 	brgt	8000a75a <_vfprintf_r+0x1e7e>
8000a72a:	c3 68       	rjmp	8000a796 <_vfprintf_r+0x1eba>
8000a72c:	2f 09       	sub	r9,-16
8000a72e:	2f f8       	sub	r8,-1
8000a730:	fb 49 06 90 	st.w	sp[1680],r9
8000a734:	87 05       	st.w	r3[0x0],r5
8000a736:	87 12       	st.w	r3[0x4],r2
8000a738:	fb 48 06 8c 	st.w	sp[1676],r8
8000a73c:	58 78       	cp.w	r8,7
8000a73e:	e0 89 00 04 	brgt	8000a746 <_vfprintf_r+0x1e6a>
8000a742:	2f 83       	sub	r3,-8
8000a744:	c0 98       	rjmp	8000a756 <_vfprintf_r+0x1e7a>
8000a746:	00 9a       	mov	r10,r0
8000a748:	02 9b       	mov	r11,r1
8000a74a:	08 9c       	mov	r12,r4
8000a74c:	fe b0 f0 ba 	rcall	800088c0 <__sprint_r>
8000a750:	c5 11       	brne	8000a7f2 <_vfprintf_r+0x1f16>
8000a752:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a756:	21 06       	sub	r6,16
8000a758:	c0 58       	rjmp	8000a762 <_vfprintf_r+0x1e86>
8000a75a:	49 d5       	lddpc	r5,8000a7cc <_vfprintf_r+0x1ef0>
8000a75c:	31 02       	mov	r2,16
8000a75e:	fa c0 f9 78 	sub	r0,sp,-1672
8000a762:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a766:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a76a:	49 9a       	lddpc	r10,8000a7cc <_vfprintf_r+0x1ef0>
8000a76c:	59 06       	cp.w	r6,16
8000a76e:	fe 99 ff df 	brgt	8000a72c <_vfprintf_r+0x1e50>
8000a772:	0c 09       	add	r9,r6
8000a774:	2f f8       	sub	r8,-1
8000a776:	87 0a       	st.w	r3[0x0],r10
8000a778:	87 16       	st.w	r3[0x4],r6
8000a77a:	fb 49 06 90 	st.w	sp[1680],r9
8000a77e:	fb 48 06 8c 	st.w	sp[1676],r8
8000a782:	58 78       	cp.w	r8,7
8000a784:	e0 8a 00 09 	brle	8000a796 <_vfprintf_r+0x1eba>
8000a788:	fa ca f9 78 	sub	r10,sp,-1672
8000a78c:	02 9b       	mov	r11,r1
8000a78e:	08 9c       	mov	r12,r4
8000a790:	fe b0 f0 98 	rcall	800088c0 <__sprint_r>
8000a794:	c2 f1       	brne	8000a7f2 <_vfprintf_r+0x1f16>
8000a796:	40 bc       	lddsp	r12,sp[0x2c]
8000a798:	40 36       	lddsp	r6,sp[0xc]
8000a79a:	40 8e       	lddsp	lr,sp[0x20]
8000a79c:	ec 0e 0c 48 	max	r8,r6,lr
8000a7a0:	10 0c       	add	r12,r8
8000a7a2:	50 bc       	stdsp	sp[0x2c],r12
8000a7a4:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a7a8:	58 08       	cp.w	r8,0
8000a7aa:	c0 80       	breq	8000a7ba <_vfprintf_r+0x1ede>
8000a7ac:	fa ca f9 78 	sub	r10,sp,-1672
8000a7b0:	02 9b       	mov	r11,r1
8000a7b2:	08 9c       	mov	r12,r4
8000a7b4:	fe b0 f0 86 	rcall	800088c0 <__sprint_r>
8000a7b8:	c1 d1       	brne	8000a7f2 <_vfprintf_r+0x1f16>
8000a7ba:	30 0b       	mov	r11,0
8000a7bc:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a7c0:	fb 4b 06 8c 	st.w	sp[1676],r11
8000a7c4:	fe 9f f1 17 	bral	800089f2 <_vfprintf_r+0x116>
8000a7c8:	80 02       	ld.sh	r2,r0[0x0]
8000a7ca:	f8 00       	*unknown*
8000a7cc:	80 02       	ld.sh	r2,r0[0x0]
8000a7ce:	f7 f0 08 95 	ld.ubeq	r0,r11[0x95]
8000a7d2:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a7d6:	58 08       	cp.w	r8,0
8000a7d8:	c0 80       	breq	8000a7e8 <_vfprintf_r+0x1f0c>
8000a7da:	08 9c       	mov	r12,r4
8000a7dc:	fa ca f9 78 	sub	r10,sp,-1672
8000a7e0:	02 9b       	mov	r11,r1
8000a7e2:	fe b0 f0 6f 	rcall	800088c0 <__sprint_r>
8000a7e6:	c0 61       	brne	8000a7f2 <_vfprintf_r+0x1f16>
8000a7e8:	30 08       	mov	r8,0
8000a7ea:	fb 48 06 8c 	st.w	sp[1676],r8
8000a7ee:	c0 28       	rjmp	8000a7f2 <_vfprintf_r+0x1f16>
8000a7f0:	40 41       	lddsp	r1,sp[0x10]
8000a7f2:	82 68       	ld.sh	r8,r1[0xc]
8000a7f4:	ed b8 00 06 	bld	r8,0x6
8000a7f8:	c0 31       	brne	8000a7fe <_vfprintf_r+0x1f22>
8000a7fa:	3f fa       	mov	r10,-1
8000a7fc:	50 ba       	stdsp	sp[0x2c],r10
8000a7fe:	40 bc       	lddsp	r12,sp[0x2c]
8000a800:	fe 3d f9 44 	sub	sp,-1724
8000a804:	d8 32       	popm	r0-r7,pc
8000a806:	d7 03       	nop

8000a808 <__swsetup_r>:
8000a808:	d4 21       	pushm	r4-r7,lr
8000a80a:	e0 68 05 34 	mov	r8,1332
8000a80e:	18 96       	mov	r6,r12
8000a810:	16 97       	mov	r7,r11
8000a812:	70 0c       	ld.w	r12,r8[0x0]
8000a814:	58 0c       	cp.w	r12,0
8000a816:	c0 60       	breq	8000a822 <__swsetup_r+0x1a>
8000a818:	78 68       	ld.w	r8,r12[0x18]
8000a81a:	58 08       	cp.w	r8,0
8000a81c:	c0 31       	brne	8000a822 <__swsetup_r+0x1a>
8000a81e:	e0 a0 07 c7 	rcall	8000b7ac <__sinit>
8000a822:	4a f8       	lddpc	r8,8000a8dc <__swsetup_r+0xd4>
8000a824:	10 37       	cp.w	r7,r8
8000a826:	c0 61       	brne	8000a832 <__swsetup_r+0x2a>
8000a828:	e0 68 05 34 	mov	r8,1332
8000a82c:	70 08       	ld.w	r8,r8[0x0]
8000a82e:	70 07       	ld.w	r7,r8[0x0]
8000a830:	c1 08       	rjmp	8000a850 <__swsetup_r+0x48>
8000a832:	4a c8       	lddpc	r8,8000a8e0 <__swsetup_r+0xd8>
8000a834:	10 37       	cp.w	r7,r8
8000a836:	c0 61       	brne	8000a842 <__swsetup_r+0x3a>
8000a838:	e0 68 05 34 	mov	r8,1332
8000a83c:	70 08       	ld.w	r8,r8[0x0]
8000a83e:	70 17       	ld.w	r7,r8[0x4]
8000a840:	c0 88       	rjmp	8000a850 <__swsetup_r+0x48>
8000a842:	4a 98       	lddpc	r8,8000a8e4 <__swsetup_r+0xdc>
8000a844:	10 37       	cp.w	r7,r8
8000a846:	c0 51       	brne	8000a850 <__swsetup_r+0x48>
8000a848:	e0 68 05 34 	mov	r8,1332
8000a84c:	70 08       	ld.w	r8,r8[0x0]
8000a84e:	70 27       	ld.w	r7,r8[0x8]
8000a850:	8e 68       	ld.sh	r8,r7[0xc]
8000a852:	ed b8 00 03 	bld	r8,0x3
8000a856:	c1 e0       	breq	8000a892 <__swsetup_r+0x8a>
8000a858:	ed b8 00 04 	bld	r8,0x4
8000a85c:	c3 e1       	brne	8000a8d8 <__swsetup_r+0xd0>
8000a85e:	ed b8 00 02 	bld	r8,0x2
8000a862:	c1 51       	brne	8000a88c <__swsetup_r+0x84>
8000a864:	6e db       	ld.w	r11,r7[0x34]
8000a866:	58 0b       	cp.w	r11,0
8000a868:	c0 a0       	breq	8000a87c <__swsetup_r+0x74>
8000a86a:	ee c8 ff bc 	sub	r8,r7,-68
8000a86e:	10 3b       	cp.w	r11,r8
8000a870:	c0 40       	breq	8000a878 <__swsetup_r+0x70>
8000a872:	0c 9c       	mov	r12,r6
8000a874:	e0 a0 08 34 	rcall	8000b8dc <_free_r>
8000a878:	30 08       	mov	r8,0
8000a87a:	8f d8       	st.w	r7[0x34],r8
8000a87c:	8e 68       	ld.sh	r8,r7[0xc]
8000a87e:	e0 18 ff db 	andl	r8,0xffdb
8000a882:	ae 68       	st.h	r7[0xc],r8
8000a884:	30 08       	mov	r8,0
8000a886:	8f 18       	st.w	r7[0x4],r8
8000a888:	6e 48       	ld.w	r8,r7[0x10]
8000a88a:	8f 08       	st.w	r7[0x0],r8
8000a88c:	8e 68       	ld.sh	r8,r7[0xc]
8000a88e:	a3 b8       	sbr	r8,0x3
8000a890:	ae 68       	st.h	r7[0xc],r8
8000a892:	6e 48       	ld.w	r8,r7[0x10]
8000a894:	58 08       	cp.w	r8,0
8000a896:	c0 b1       	brne	8000a8ac <__swsetup_r+0xa4>
8000a898:	8e 68       	ld.sh	r8,r7[0xc]
8000a89a:	e2 18 02 80 	andl	r8,0x280,COH
8000a89e:	e0 48 02 00 	cp.w	r8,512
8000a8a2:	c0 50       	breq	8000a8ac <__swsetup_r+0xa4>
8000a8a4:	0c 9c       	mov	r12,r6
8000a8a6:	0e 9b       	mov	r11,r7
8000a8a8:	e0 a0 0a 52 	rcall	8000bd4c <__smakebuf_r>
8000a8ac:	8e 69       	ld.sh	r9,r7[0xc]
8000a8ae:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000a8b2:	c0 70       	breq	8000a8c0 <__swsetup_r+0xb8>
8000a8b4:	30 08       	mov	r8,0
8000a8b6:	8f 28       	st.w	r7[0x8],r8
8000a8b8:	6e 58       	ld.w	r8,r7[0x14]
8000a8ba:	5c 38       	neg	r8
8000a8bc:	8f 68       	st.w	r7[0x18],r8
8000a8be:	c0 68       	rjmp	8000a8ca <__swsetup_r+0xc2>
8000a8c0:	ed b9 00 01 	bld	r9,0x1
8000a8c4:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000a8c8:	8f 28       	st.w	r7[0x8],r8
8000a8ca:	6e 48       	ld.w	r8,r7[0x10]
8000a8cc:	58 08       	cp.w	r8,0
8000a8ce:	c0 61       	brne	8000a8da <__swsetup_r+0xd2>
8000a8d0:	8e 68       	ld.sh	r8,r7[0xc]
8000a8d2:	ed b8 00 07 	bld	r8,0x7
8000a8d6:	c0 21       	brne	8000a8da <__swsetup_r+0xd2>
8000a8d8:	dc 2a       	popm	r4-r7,pc,r12=-1
8000a8da:	d8 2a       	popm	r4-r7,pc,r12=0
8000a8dc:	80 02       	ld.sh	r2,r0[0x0]
8000a8de:	f9 20 80 02 	ld.sb	r0,r12[-32766]
8000a8e2:	f9 40 80 02 	st.w	r12[-32766],r0
8000a8e6:	f9 60 d4 31 	st.b	r12[-11215],r0

8000a8e8 <quorem>:
8000a8e8:	d4 31       	pushm	r0-r7,lr
8000a8ea:	20 2d       	sub	sp,8
8000a8ec:	18 97       	mov	r7,r12
8000a8ee:	78 48       	ld.w	r8,r12[0x10]
8000a8f0:	76 46       	ld.w	r6,r11[0x10]
8000a8f2:	0c 38       	cp.w	r8,r6
8000a8f4:	c0 34       	brge	8000a8fa <quorem+0x12>
8000a8f6:	30 0c       	mov	r12,0
8000a8f8:	c8 58       	rjmp	8000aa02 <quorem+0x11a>
8000a8fa:	ec c2 ff fc 	sub	r2,r6,-4
8000a8fe:	f6 c3 ff ec 	sub	r3,r11,-20
8000a902:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000a906:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000a90a:	2f f9       	sub	r9,-1
8000a90c:	20 16       	sub	r6,1
8000a90e:	f8 09 0d 08 	divu	r8,r12,r9
8000a912:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000a916:	ee c4 ff ec 	sub	r4,r7,-20
8000a91a:	10 95       	mov	r5,r8
8000a91c:	58 08       	cp.w	r8,0
8000a91e:	c4 10       	breq	8000a9a0 <quorem+0xb8>
8000a920:	30 09       	mov	r9,0
8000a922:	06 9a       	mov	r10,r3
8000a924:	08 98       	mov	r8,r4
8000a926:	12 91       	mov	r1,r9
8000a928:	50 0b       	stdsp	sp[0x0],r11
8000a92a:	70 0e       	ld.w	lr,r8[0x0]
8000a92c:	b1 8e       	lsr	lr,0x10
8000a92e:	50 1e       	stdsp	sp[0x4],lr
8000a930:	15 0e       	ld.w	lr,r10++
8000a932:	fc 00 16 10 	lsr	r0,lr,0x10
8000a936:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000a93a:	ea 0e 03 41 	mac	r1,r5,lr
8000a93e:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000a942:	b1 81       	lsr	r1,0x10
8000a944:	40 1b       	lddsp	r11,sp[0x4]
8000a946:	ea 00 02 40 	mul	r0,r5,r0
8000a94a:	e2 00 00 00 	add	r0,r1,r0
8000a94e:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000a952:	02 1b       	sub	r11,r1
8000a954:	50 1b       	stdsp	sp[0x4],r11
8000a956:	70 0b       	ld.w	r11,r8[0x0]
8000a958:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000a95c:	02 09       	add	r9,r1
8000a95e:	f2 0e 01 0e 	sub	lr,r9,lr
8000a962:	b0 1e       	st.h	r8[0x2],lr
8000a964:	fc 09 14 10 	asr	r9,lr,0x10
8000a968:	40 1e       	lddsp	lr,sp[0x4]
8000a96a:	fc 09 00 09 	add	r9,lr,r9
8000a96e:	b0 09       	st.h	r8[0x0],r9
8000a970:	e0 01 16 10 	lsr	r1,r0,0x10
8000a974:	2f c8       	sub	r8,-4
8000a976:	b1 49       	asr	r9,0x10
8000a978:	04 3a       	cp.w	r10,r2
8000a97a:	fe 98 ff d8 	brls	8000a92a <quorem+0x42>
8000a97e:	40 0b       	lddsp	r11,sp[0x0]
8000a980:	58 0c       	cp.w	r12,0
8000a982:	c0 f1       	brne	8000a9a0 <quorem+0xb8>
8000a984:	ec c8 ff fb 	sub	r8,r6,-5
8000a988:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a98c:	c0 28       	rjmp	8000a990 <quorem+0xa8>
8000a98e:	20 16       	sub	r6,1
8000a990:	20 48       	sub	r8,4
8000a992:	08 38       	cp.w	r8,r4
8000a994:	e0 88 00 05 	brls	8000a99e <quorem+0xb6>
8000a998:	70 09       	ld.w	r9,r8[0x0]
8000a99a:	58 09       	cp.w	r9,0
8000a99c:	cf 90       	breq	8000a98e <quorem+0xa6>
8000a99e:	8f 46       	st.w	r7[0x10],r6
8000a9a0:	0e 9c       	mov	r12,r7
8000a9a2:	e0 a0 0a d4 	rcall	8000bf4a <__mcmp>
8000a9a6:	c2 d5       	brlt	8000aa00 <quorem+0x118>
8000a9a8:	2f f5       	sub	r5,-1
8000a9aa:	08 98       	mov	r8,r4
8000a9ac:	30 09       	mov	r9,0
8000a9ae:	07 0b       	ld.w	r11,r3++
8000a9b0:	f6 0a 16 10 	lsr	r10,r11,0x10
8000a9b4:	70 0c       	ld.w	r12,r8[0x0]
8000a9b6:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a9ba:	f8 0e 16 10 	lsr	lr,r12,0x10
8000a9be:	14 1e       	sub	lr,r10
8000a9c0:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000a9c4:	16 1a       	sub	r10,r11
8000a9c6:	12 0a       	add	r10,r9
8000a9c8:	b0 1a       	st.h	r8[0x2],r10
8000a9ca:	b1 4a       	asr	r10,0x10
8000a9cc:	fc 0a 00 09 	add	r9,lr,r10
8000a9d0:	b0 09       	st.h	r8[0x0],r9
8000a9d2:	2f c8       	sub	r8,-4
8000a9d4:	b1 49       	asr	r9,0x10
8000a9d6:	04 33       	cp.w	r3,r2
8000a9d8:	fe 98 ff eb 	brls	8000a9ae <quorem+0xc6>
8000a9dc:	ec c8 ff fb 	sub	r8,r6,-5
8000a9e0:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000a9e4:	58 09       	cp.w	r9,0
8000a9e6:	c0 d1       	brne	8000aa00 <quorem+0x118>
8000a9e8:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a9ec:	c0 28       	rjmp	8000a9f0 <quorem+0x108>
8000a9ee:	20 16       	sub	r6,1
8000a9f0:	20 48       	sub	r8,4
8000a9f2:	08 38       	cp.w	r8,r4
8000a9f4:	e0 88 00 05 	brls	8000a9fe <quorem+0x116>
8000a9f8:	70 09       	ld.w	r9,r8[0x0]
8000a9fa:	58 09       	cp.w	r9,0
8000a9fc:	cf 90       	breq	8000a9ee <quorem+0x106>
8000a9fe:	8f 46       	st.w	r7[0x10],r6
8000aa00:	0a 9c       	mov	r12,r5
8000aa02:	2f ed       	sub	sp,-8
8000aa04:	d8 32       	popm	r0-r7,pc
8000aa06:	d7 03       	nop

8000aa08 <_dtoa_r>:
8000aa08:	d4 31       	pushm	r0-r7,lr
8000aa0a:	21 ad       	sub	sp,104
8000aa0c:	fa c4 ff 74 	sub	r4,sp,-140
8000aa10:	18 97       	mov	r7,r12
8000aa12:	16 95       	mov	r5,r11
8000aa14:	68 2c       	ld.w	r12,r4[0x8]
8000aa16:	50 c9       	stdsp	sp[0x30],r9
8000aa18:	68 16       	ld.w	r6,r4[0x4]
8000aa1a:	68 09       	ld.w	r9,r4[0x0]
8000aa1c:	50 e8       	stdsp	sp[0x38],r8
8000aa1e:	14 94       	mov	r4,r10
8000aa20:	51 2c       	stdsp	sp[0x48],r12
8000aa22:	fa e5 00 08 	st.d	sp[8],r4
8000aa26:	51 59       	stdsp	sp[0x54],r9
8000aa28:	6e 95       	ld.w	r5,r7[0x24]
8000aa2a:	58 05       	cp.w	r5,0
8000aa2c:	c0 91       	brne	8000aa3e <_dtoa_r+0x36>
8000aa2e:	31 0c       	mov	r12,16
8000aa30:	fe b0 e8 e6 	rcall	80007bfc <malloc>
8000aa34:	99 35       	st.w	r12[0xc],r5
8000aa36:	8f 9c       	st.w	r7[0x24],r12
8000aa38:	99 15       	st.w	r12[0x4],r5
8000aa3a:	99 25       	st.w	r12[0x8],r5
8000aa3c:	99 05       	st.w	r12[0x0],r5
8000aa3e:	6e 99       	ld.w	r9,r7[0x24]
8000aa40:	72 08       	ld.w	r8,r9[0x0]
8000aa42:	58 08       	cp.w	r8,0
8000aa44:	c0 f0       	breq	8000aa62 <_dtoa_r+0x5a>
8000aa46:	72 1a       	ld.w	r10,r9[0x4]
8000aa48:	91 1a       	st.w	r8[0x4],r10
8000aa4a:	30 1a       	mov	r10,1
8000aa4c:	72 19       	ld.w	r9,r9[0x4]
8000aa4e:	f4 09 09 49 	lsl	r9,r10,r9
8000aa52:	10 9b       	mov	r11,r8
8000aa54:	91 29       	st.w	r8[0x8],r9
8000aa56:	0e 9c       	mov	r12,r7
8000aa58:	e0 a0 0a 92 	rcall	8000bf7c <_Bfree>
8000aa5c:	6e 98       	ld.w	r8,r7[0x24]
8000aa5e:	30 09       	mov	r9,0
8000aa60:	91 09       	st.w	r8[0x0],r9
8000aa62:	40 28       	lddsp	r8,sp[0x8]
8000aa64:	10 94       	mov	r4,r8
8000aa66:	58 08       	cp.w	r8,0
8000aa68:	c0 64       	brge	8000aa74 <_dtoa_r+0x6c>
8000aa6a:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000aa6e:	50 28       	stdsp	sp[0x8],r8
8000aa70:	30 18       	mov	r8,1
8000aa72:	c0 28       	rjmp	8000aa76 <_dtoa_r+0x6e>
8000aa74:	30 08       	mov	r8,0
8000aa76:	8d 08       	st.w	r6[0x0],r8
8000aa78:	fc 1c 7f f0 	movh	r12,0x7ff0
8000aa7c:	40 26       	lddsp	r6,sp[0x8]
8000aa7e:	0c 98       	mov	r8,r6
8000aa80:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000aa84:	18 38       	cp.w	r8,r12
8000aa86:	c1 e1       	brne	8000aac2 <_dtoa_r+0xba>
8000aa88:	e0 68 27 0f 	mov	r8,9999
8000aa8c:	41 5b       	lddsp	r11,sp[0x54]
8000aa8e:	97 08       	st.w	r11[0x0],r8
8000aa90:	40 3a       	lddsp	r10,sp[0xc]
8000aa92:	58 0a       	cp.w	r10,0
8000aa94:	c0 61       	brne	8000aaa0 <_dtoa_r+0x98>
8000aa96:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000aa9a:	c0 31       	brne	8000aaa0 <_dtoa_r+0x98>
8000aa9c:	4a cc       	lddpc	r12,8000ab4c <_dtoa_r+0x144>
8000aa9e:	c0 28       	rjmp	8000aaa2 <_dtoa_r+0x9a>
8000aaa0:	4a cc       	lddpc	r12,8000ab50 <_dtoa_r+0x148>
8000aaa2:	41 29       	lddsp	r9,sp[0x48]
8000aaa4:	58 09       	cp.w	r9,0
8000aaa6:	e0 80 05 9e 	breq	8000b5e2 <_dtoa_r+0xbda>
8000aaaa:	f8 c8 ff fd 	sub	r8,r12,-3
8000aaae:	f8 c9 ff f8 	sub	r9,r12,-8
8000aab2:	11 8b       	ld.ub	r11,r8[0x0]
8000aab4:	30 0a       	mov	r10,0
8000aab6:	41 25       	lddsp	r5,sp[0x48]
8000aab8:	f4 0b 18 00 	cp.b	r11,r10
8000aabc:	f2 08 17 10 	movne	r8,r9
8000aac0:	c1 58       	rjmp	8000aaea <_dtoa_r+0xe2>
8000aac2:	fa ea 00 08 	ld.d	r10,sp[8]
8000aac6:	30 08       	mov	r8,0
8000aac8:	fa eb 00 3c 	st.d	sp[60],r10
8000aacc:	30 09       	mov	r9,0
8000aace:	e0 a0 0e 20 	rcall	8000c70e <__avr32_f64_cmp_eq>
8000aad2:	c0 f0       	breq	8000aaf0 <_dtoa_r+0xe8>
8000aad4:	30 18       	mov	r8,1
8000aad6:	41 5a       	lddsp	r10,sp[0x54]
8000aad8:	95 08       	st.w	r10[0x0],r8
8000aada:	49 fc       	lddpc	r12,8000ab54 <_dtoa_r+0x14c>
8000aadc:	41 29       	lddsp	r9,sp[0x48]
8000aade:	f8 08 00 08 	add	r8,r12,r8
8000aae2:	58 09       	cp.w	r9,0
8000aae4:	e0 80 05 7f 	breq	8000b5e2 <_dtoa_r+0xbda>
8000aae8:	12 95       	mov	r5,r9
8000aaea:	8b 08       	st.w	r5[0x0],r8
8000aaec:	e0 8f 05 7b 	bral	8000b5e2 <_dtoa_r+0xbda>
8000aaf0:	fa c8 ff 9c 	sub	r8,sp,-100
8000aaf4:	fa c9 ff a0 	sub	r9,sp,-96
8000aaf8:	fa ea 00 3c 	ld.d	r10,sp[60]
8000aafc:	0e 9c       	mov	r12,r7
8000aafe:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000ab02:	e0 a0 0a 8f 	rcall	8000c020 <__d2b>
8000ab06:	18 93       	mov	r3,r12
8000ab08:	58 05       	cp.w	r5,0
8000ab0a:	c0 d0       	breq	8000ab24 <_dtoa_r+0x11c>
8000ab0c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000ab10:	30 04       	mov	r4,0
8000ab12:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000ab16:	ea c5 03 ff 	sub	r5,r5,1023
8000ab1a:	10 9b       	mov	r11,r8
8000ab1c:	51 74       	stdsp	sp[0x5c],r4
8000ab1e:	ea 1b 3f f0 	orh	r11,0x3ff0
8000ab22:	c2 a8       	rjmp	8000ab76 <_dtoa_r+0x16e>
8000ab24:	41 88       	lddsp	r8,sp[0x60]
8000ab26:	41 9c       	lddsp	r12,sp[0x64]
8000ab28:	10 0c       	add	r12,r8
8000ab2a:	f8 c5 fb ce 	sub	r5,r12,-1074
8000ab2e:	e0 45 00 20 	cp.w	r5,32
8000ab32:	e0 8a 00 13 	brle	8000ab58 <_dtoa_r+0x150>
8000ab36:	f8 cc fb ee 	sub	r12,r12,-1042
8000ab3a:	40 3b       	lddsp	r11,sp[0xc]
8000ab3c:	ea 08 11 40 	rsub	r8,r5,64
8000ab40:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000ab44:	ec 08 09 46 	lsl	r6,r6,r8
8000ab48:	0c 4c       	or	r12,r6
8000ab4a:	c0 c8       	rjmp	8000ab62 <_dtoa_r+0x15a>
8000ab4c:	80 02       	ld.sh	r2,r0[0x0]
8000ab4e:	f9 10 80 02 	ld.uh	r0,r12[-32766]
8000ab52:	f9 1c 80 02 	ld.uh	r12,r12[-32766]
8000ab56:	f7 ec ea 0c 	sthh.w	r12[0x280],r11:t,r12:b
8000ab5a:	11 20       	ld.uh	r0,r8++
8000ab5c:	40 3a       	lddsp	r10,sp[0xc]
8000ab5e:	f4 0c 09 4c 	lsl	r12,r10,r12
8000ab62:	fe b0 e3 5d 	rcall	8000721c <__avr32_u32_to_f64>
8000ab66:	fc 18 fe 10 	movh	r8,0xfe10
8000ab6a:	30 19       	mov	r9,1
8000ab6c:	ea c5 04 33 	sub	r5,r5,1075
8000ab70:	f0 0b 00 0b 	add	r11,r8,r11
8000ab74:	51 79       	stdsp	sp[0x5c],r9
8000ab76:	30 08       	mov	r8,0
8000ab78:	fc 19 3f f8 	movh	r9,0x3ff8
8000ab7c:	fe b0 e1 fa 	rcall	80006f70 <__avr32_f64_sub>
8000ab80:	e0 68 43 61 	mov	r8,17249
8000ab84:	ea 18 63 6f 	orh	r8,0x636f
8000ab88:	e0 69 87 a7 	mov	r9,34727
8000ab8c:	ea 19 3f d2 	orh	r9,0x3fd2
8000ab90:	fe b0 e1 04 	rcall	80006d98 <__avr32_f64_mul>
8000ab94:	e0 68 c8 b3 	mov	r8,51379
8000ab98:	ea 18 8b 60 	orh	r8,0x8b60
8000ab9c:	e0 69 8a 28 	mov	r9,35368
8000aba0:	ea 19 3f c6 	orh	r9,0x3fc6
8000aba4:	fe b0 e2 b4 	rcall	8000710c <__avr32_f64_add>
8000aba8:	0a 9c       	mov	r12,r5
8000abaa:	14 90       	mov	r0,r10
8000abac:	16 91       	mov	r1,r11
8000abae:	fe b0 e3 3b 	rcall	80007224 <__avr32_s32_to_f64>
8000abb2:	e0 68 79 fb 	mov	r8,31227
8000abb6:	ea 18 50 9f 	orh	r8,0x509f
8000abba:	e0 69 44 13 	mov	r9,17427
8000abbe:	ea 19 3f d3 	orh	r9,0x3fd3
8000abc2:	fe b0 e0 eb 	rcall	80006d98 <__avr32_f64_mul>
8000abc6:	14 98       	mov	r8,r10
8000abc8:	16 99       	mov	r9,r11
8000abca:	00 9a       	mov	r10,r0
8000abcc:	02 9b       	mov	r11,r1
8000abce:	fe b0 e2 9f 	rcall	8000710c <__avr32_f64_add>
8000abd2:	14 90       	mov	r0,r10
8000abd4:	16 91       	mov	r1,r11
8000abd6:	e0 a0 0d 89 	rcall	8000c6e8 <__avr32_f64_to_s32>
8000abda:	30 08       	mov	r8,0
8000abdc:	18 96       	mov	r6,r12
8000abde:	30 09       	mov	r9,0
8000abe0:	00 9a       	mov	r10,r0
8000abe2:	02 9b       	mov	r11,r1
8000abe4:	fe b0 e3 90 	rcall	80007304 <__avr32_f64_cmp_lt>
8000abe8:	c0 c0       	breq	8000ac00 <_dtoa_r+0x1f8>
8000abea:	0c 9c       	mov	r12,r6
8000abec:	fe b0 e3 1c 	rcall	80007224 <__avr32_s32_to_f64>
8000abf0:	14 98       	mov	r8,r10
8000abf2:	16 99       	mov	r9,r11
8000abf4:	00 9a       	mov	r10,r0
8000abf6:	02 9b       	mov	r11,r1
8000abf8:	e0 a0 0d 8b 	rcall	8000c70e <__avr32_f64_cmp_eq>
8000abfc:	f7 b6 00 01 	subeq	r6,1
8000ac00:	59 66       	cp.w	r6,22
8000ac02:	e0 88 00 05 	brls	8000ac0c <_dtoa_r+0x204>
8000ac06:	30 18       	mov	r8,1
8000ac08:	51 48       	stdsp	sp[0x50],r8
8000ac0a:	c1 28       	rjmp	8000ac2e <_dtoa_r+0x226>
8000ac0c:	4c 08       	lddpc	r8,8000ad0c <_dtoa_r+0x304>
8000ac0e:	fa ea 00 3c 	ld.d	r10,sp[60]
8000ac12:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000ac16:	fe b0 e3 77 	rcall	80007304 <__avr32_f64_cmp_lt>
8000ac1a:	f9 b4 00 00 	moveq	r4,0
8000ac1e:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000ac22:	f7 b6 01 01 	subne	r6,1
8000ac26:	f9 bc 01 00 	movne	r12,0
8000ac2a:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000ac2e:	41 90       	lddsp	r0,sp[0x64]
8000ac30:	20 10       	sub	r0,1
8000ac32:	0a 10       	sub	r0,r5
8000ac34:	c0 46       	brmi	8000ac3c <_dtoa_r+0x234>
8000ac36:	50 40       	stdsp	sp[0x10],r0
8000ac38:	30 00       	mov	r0,0
8000ac3a:	c0 48       	rjmp	8000ac42 <_dtoa_r+0x23a>
8000ac3c:	30 0b       	mov	r11,0
8000ac3e:	5c 30       	neg	r0
8000ac40:	50 4b       	stdsp	sp[0x10],r11
8000ac42:	ec 02 11 00 	rsub	r2,r6,0
8000ac46:	58 06       	cp.w	r6,0
8000ac48:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000ac4c:	f5 d6 e4 0a 	addge	r10,r10,r6
8000ac50:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000ac54:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000ac58:	f9 b2 04 00 	movge	r2,0
8000ac5c:	e1 d6 e5 10 	sublt	r0,r0,r6
8000ac60:	f9 b9 05 00 	movlt	r9,0
8000ac64:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000ac68:	40 c8       	lddsp	r8,sp[0x30]
8000ac6a:	58 98       	cp.w	r8,9
8000ac6c:	e0 8b 00 20 	brhi	8000acac <_dtoa_r+0x2a4>
8000ac70:	58 58       	cp.w	r8,5
8000ac72:	f9 b4 0a 01 	movle	r4,1
8000ac76:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000ac7a:	f7 b5 09 04 	subgt	r5,4
8000ac7e:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000ac82:	f9 b4 09 00 	movgt	r4,0
8000ac86:	40 cc       	lddsp	r12,sp[0x30]
8000ac88:	58 3c       	cp.w	r12,3
8000ac8a:	c2 d0       	breq	8000ace4 <_dtoa_r+0x2dc>
8000ac8c:	e0 89 00 05 	brgt	8000ac96 <_dtoa_r+0x28e>
8000ac90:	58 2c       	cp.w	r12,2
8000ac92:	c1 01       	brne	8000acb2 <_dtoa_r+0x2aa>
8000ac94:	c1 88       	rjmp	8000acc4 <_dtoa_r+0x2bc>
8000ac96:	40 cb       	lddsp	r11,sp[0x30]
8000ac98:	58 4b       	cp.w	r11,4
8000ac9a:	c0 60       	breq	8000aca6 <_dtoa_r+0x29e>
8000ac9c:	58 5b       	cp.w	r11,5
8000ac9e:	c0 a1       	brne	8000acb2 <_dtoa_r+0x2aa>
8000aca0:	30 1a       	mov	r10,1
8000aca2:	50 da       	stdsp	sp[0x34],r10
8000aca4:	c2 28       	rjmp	8000ace8 <_dtoa_r+0x2e0>
8000aca6:	30 19       	mov	r9,1
8000aca8:	50 d9       	stdsp	sp[0x34],r9
8000acaa:	c0 f8       	rjmp	8000acc8 <_dtoa_r+0x2c0>
8000acac:	30 08       	mov	r8,0
8000acae:	30 14       	mov	r4,1
8000acb0:	50 c8       	stdsp	sp[0x30],r8
8000acb2:	3f f5       	mov	r5,-1
8000acb4:	30 1c       	mov	r12,1
8000acb6:	30 0b       	mov	r11,0
8000acb8:	50 95       	stdsp	sp[0x24],r5
8000acba:	50 dc       	stdsp	sp[0x34],r12
8000acbc:	0a 91       	mov	r1,r5
8000acbe:	31 28       	mov	r8,18
8000acc0:	50 eb       	stdsp	sp[0x38],r11
8000acc2:	c2 08       	rjmp	8000ad02 <_dtoa_r+0x2fa>
8000acc4:	30 0a       	mov	r10,0
8000acc6:	50 da       	stdsp	sp[0x34],r10
8000acc8:	40 e9       	lddsp	r9,sp[0x38]
8000acca:	58 09       	cp.w	r9,0
8000accc:	e0 89 00 07 	brgt	8000acda <_dtoa_r+0x2d2>
8000acd0:	30 18       	mov	r8,1
8000acd2:	50 98       	stdsp	sp[0x24],r8
8000acd4:	10 91       	mov	r1,r8
8000acd6:	50 e8       	stdsp	sp[0x38],r8
8000acd8:	c1 58       	rjmp	8000ad02 <_dtoa_r+0x2fa>
8000acda:	40 e5       	lddsp	r5,sp[0x38]
8000acdc:	50 95       	stdsp	sp[0x24],r5
8000acde:	0a 91       	mov	r1,r5
8000ace0:	0a 98       	mov	r8,r5
8000ace2:	c1 08       	rjmp	8000ad02 <_dtoa_r+0x2fa>
8000ace4:	30 0c       	mov	r12,0
8000ace6:	50 dc       	stdsp	sp[0x34],r12
8000ace8:	40 eb       	lddsp	r11,sp[0x38]
8000acea:	ec 0b 00 0b 	add	r11,r6,r11
8000acee:	50 9b       	stdsp	sp[0x24],r11
8000acf0:	16 98       	mov	r8,r11
8000acf2:	2f f8       	sub	r8,-1
8000acf4:	58 08       	cp.w	r8,0
8000acf6:	e0 89 00 05 	brgt	8000ad00 <_dtoa_r+0x2f8>
8000acfa:	10 91       	mov	r1,r8
8000acfc:	30 18       	mov	r8,1
8000acfe:	c0 28       	rjmp	8000ad02 <_dtoa_r+0x2fa>
8000ad00:	10 91       	mov	r1,r8
8000ad02:	30 09       	mov	r9,0
8000ad04:	6e 9a       	ld.w	r10,r7[0x24]
8000ad06:	95 19       	st.w	r10[0x4],r9
8000ad08:	30 49       	mov	r9,4
8000ad0a:	c0 78       	rjmp	8000ad18 <_dtoa_r+0x310>
8000ad0c:	80 02       	ld.sh	r2,r0[0x0]
8000ad0e:	f9 d4 6a 1a 	ldins.b	r4:u,r12[-1510]
8000ad12:	a1 79       	lsl	r9,0x1
8000ad14:	2f fa       	sub	r10,-1
8000ad16:	8b 1a       	st.w	r5[0x4],r10
8000ad18:	6e 95       	ld.w	r5,r7[0x24]
8000ad1a:	f2 ca ff ec 	sub	r10,r9,-20
8000ad1e:	10 3a       	cp.w	r10,r8
8000ad20:	fe 98 ff f8 	brls	8000ad10 <_dtoa_r+0x308>
8000ad24:	6a 1b       	ld.w	r11,r5[0x4]
8000ad26:	0e 9c       	mov	r12,r7
8000ad28:	e0 a0 09 44 	rcall	8000bfb0 <_Balloc>
8000ad2c:	58 e1       	cp.w	r1,14
8000ad2e:	5f 88       	srls	r8
8000ad30:	8b 0c       	st.w	r5[0x0],r12
8000ad32:	f1 e4 00 04 	and	r4,r8,r4
8000ad36:	6e 98       	ld.w	r8,r7[0x24]
8000ad38:	70 08       	ld.w	r8,r8[0x0]
8000ad3a:	50 88       	stdsp	sp[0x20],r8
8000ad3c:	e0 80 01 82 	breq	8000b040 <_dtoa_r+0x638>
8000ad40:	58 06       	cp.w	r6,0
8000ad42:	e0 8a 00 40 	brle	8000adc2 <_dtoa_r+0x3ba>
8000ad46:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000ad4a:	4c b8       	lddpc	r8,8000ae74 <_dtoa_r+0x46c>
8000ad4c:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000ad50:	fa e5 00 18 	st.d	sp[24],r4
8000ad54:	ec 04 14 04 	asr	r4,r6,0x4
8000ad58:	ed b4 00 04 	bld	r4,0x4
8000ad5c:	c0 30       	breq	8000ad62 <_dtoa_r+0x35a>
8000ad5e:	30 25       	mov	r5,2
8000ad60:	c0 f8       	rjmp	8000ad7e <_dtoa_r+0x376>
8000ad62:	4c 68       	lddpc	r8,8000ae78 <_dtoa_r+0x470>
8000ad64:	f0 e8 00 20 	ld.d	r8,r8[32]
8000ad68:	fa ea 00 3c 	ld.d	r10,sp[60]
8000ad6c:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000ad70:	fe b0 e3 18 	rcall	800073a0 <__avr32_f64_div>
8000ad74:	30 35       	mov	r5,3
8000ad76:	14 98       	mov	r8,r10
8000ad78:	16 99       	mov	r9,r11
8000ad7a:	fa e9 00 08 	st.d	sp[8],r8
8000ad7e:	4b fc       	lddpc	r12,8000ae78 <_dtoa_r+0x470>
8000ad80:	50 a3       	stdsp	sp[0x28],r3
8000ad82:	0c 93       	mov	r3,r6
8000ad84:	18 96       	mov	r6,r12
8000ad86:	c0 f8       	rjmp	8000ada4 <_dtoa_r+0x39c>
8000ad88:	fa ea 00 18 	ld.d	r10,sp[24]
8000ad8c:	ed b4 00 00 	bld	r4,0x0
8000ad90:	c0 81       	brne	8000ada0 <_dtoa_r+0x398>
8000ad92:	ec e8 00 00 	ld.d	r8,r6[0]
8000ad96:	2f f5       	sub	r5,-1
8000ad98:	fe b0 e0 00 	rcall	80006d98 <__avr32_f64_mul>
8000ad9c:	fa eb 00 18 	st.d	sp[24],r10
8000ada0:	a1 54       	asr	r4,0x1
8000ada2:	2f 86       	sub	r6,-8
8000ada4:	58 04       	cp.w	r4,0
8000ada6:	cf 11       	brne	8000ad88 <_dtoa_r+0x380>
8000ada8:	fa e8 00 18 	ld.d	r8,sp[24]
8000adac:	fa ea 00 08 	ld.d	r10,sp[8]
8000adb0:	06 96       	mov	r6,r3
8000adb2:	fe b0 e2 f7 	rcall	800073a0 <__avr32_f64_div>
8000adb6:	40 a3       	lddsp	r3,sp[0x28]
8000adb8:	14 98       	mov	r8,r10
8000adba:	16 99       	mov	r9,r11
8000adbc:	fa e9 00 08 	st.d	sp[8],r8
8000adc0:	c2 d8       	rjmp	8000ae1a <_dtoa_r+0x412>
8000adc2:	ec 08 11 00 	rsub	r8,r6,0
8000adc6:	c0 31       	brne	8000adcc <_dtoa_r+0x3c4>
8000adc8:	30 25       	mov	r5,2
8000adca:	c2 88       	rjmp	8000ae1a <_dtoa_r+0x412>
8000adcc:	4a bc       	lddpc	r12,8000ae78 <_dtoa_r+0x470>
8000adce:	f0 04 14 04 	asr	r4,r8,0x4
8000add2:	50 1c       	stdsp	sp[0x4],r12
8000add4:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000add8:	4a 79       	lddpc	r9,8000ae74 <_dtoa_r+0x46c>
8000adda:	fa ea 00 3c 	ld.d	r10,sp[60]
8000adde:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000ade2:	fe b0 df db 	rcall	80006d98 <__avr32_f64_mul>
8000ade6:	40 1c       	lddsp	r12,sp[0x4]
8000ade8:	50 63       	stdsp	sp[0x18],r3
8000adea:	30 25       	mov	r5,2
8000adec:	0c 93       	mov	r3,r6
8000adee:	fa eb 00 08 	st.d	sp[8],r10
8000adf2:	18 96       	mov	r6,r12
8000adf4:	c0 f8       	rjmp	8000ae12 <_dtoa_r+0x40a>
8000adf6:	fa ea 00 08 	ld.d	r10,sp[8]
8000adfa:	ed b4 00 00 	bld	r4,0x0
8000adfe:	c0 81       	brne	8000ae0e <_dtoa_r+0x406>
8000ae00:	ec e8 00 00 	ld.d	r8,r6[0]
8000ae04:	2f f5       	sub	r5,-1
8000ae06:	fe b0 df c9 	rcall	80006d98 <__avr32_f64_mul>
8000ae0a:	fa eb 00 08 	st.d	sp[8],r10
8000ae0e:	a1 54       	asr	r4,0x1
8000ae10:	2f 86       	sub	r6,-8
8000ae12:	58 04       	cp.w	r4,0
8000ae14:	cf 11       	brne	8000adf6 <_dtoa_r+0x3ee>
8000ae16:	06 96       	mov	r6,r3
8000ae18:	40 63       	lddsp	r3,sp[0x18]
8000ae1a:	41 4a       	lddsp	r10,sp[0x50]
8000ae1c:	58 0a       	cp.w	r10,0
8000ae1e:	c2 f0       	breq	8000ae7c <_dtoa_r+0x474>
8000ae20:	fa e8 00 08 	ld.d	r8,sp[8]
8000ae24:	58 01       	cp.w	r1,0
8000ae26:	5f 94       	srgt	r4
8000ae28:	fa e9 00 18 	st.d	sp[24],r8
8000ae2c:	30 08       	mov	r8,0
8000ae2e:	fc 19 3f f0 	movh	r9,0x3ff0
8000ae32:	fa ea 00 18 	ld.d	r10,sp[24]
8000ae36:	fe b0 e2 67 	rcall	80007304 <__avr32_f64_cmp_lt>
8000ae3a:	f9 bc 00 00 	moveq	r12,0
8000ae3e:	f9 bc 01 01 	movne	r12,1
8000ae42:	e9 ec 00 0c 	and	r12,r4,r12
8000ae46:	c1 b0       	breq	8000ae7c <_dtoa_r+0x474>
8000ae48:	40 98       	lddsp	r8,sp[0x24]
8000ae4a:	58 08       	cp.w	r8,0
8000ae4c:	e0 8a 00 f6 	brle	8000b038 <_dtoa_r+0x630>
8000ae50:	30 08       	mov	r8,0
8000ae52:	fc 19 40 24 	movh	r9,0x4024
8000ae56:	ec c4 00 01 	sub	r4,r6,1
8000ae5a:	fa ea 00 18 	ld.d	r10,sp[24]
8000ae5e:	2f f5       	sub	r5,-1
8000ae60:	50 64       	stdsp	sp[0x18],r4
8000ae62:	fe b0 df 9b 	rcall	80006d98 <__avr32_f64_mul>
8000ae66:	40 94       	lddsp	r4,sp[0x24]
8000ae68:	14 98       	mov	r8,r10
8000ae6a:	16 99       	mov	r9,r11
8000ae6c:	fa e9 00 08 	st.d	sp[8],r8
8000ae70:	c0 88       	rjmp	8000ae80 <_dtoa_r+0x478>
8000ae72:	d7 03       	nop
8000ae74:	80 02       	ld.sh	r2,r0[0x0]
8000ae76:	f9 d4 80 02 	ldswp.w	r4,r12[8]
8000ae7a:	fa 9c 50 66 	brvs	7ff74f46 <_estack+0x7ff64f46>
8000ae7e:	02 94       	mov	r4,r1
8000ae80:	0a 9c       	mov	r12,r5
8000ae82:	fe b0 e1 d1 	rcall	80007224 <__avr32_s32_to_f64>
8000ae86:	fa e8 00 08 	ld.d	r8,sp[8]
8000ae8a:	fe b0 df 87 	rcall	80006d98 <__avr32_f64_mul>
8000ae8e:	30 08       	mov	r8,0
8000ae90:	fc 19 40 1c 	movh	r9,0x401c
8000ae94:	fe b0 e1 3c 	rcall	8000710c <__avr32_f64_add>
8000ae98:	14 98       	mov	r8,r10
8000ae9a:	16 99       	mov	r9,r11
8000ae9c:	fa e9 00 28 	st.d	sp[40],r8
8000aea0:	fc 18 fc c0 	movh	r8,0xfcc0
8000aea4:	40 a5       	lddsp	r5,sp[0x28]
8000aea6:	10 05       	add	r5,r8
8000aea8:	50 a5       	stdsp	sp[0x28],r5
8000aeaa:	58 04       	cp.w	r4,0
8000aeac:	c2 11       	brne	8000aeee <_dtoa_r+0x4e6>
8000aeae:	fa ea 00 08 	ld.d	r10,sp[8]
8000aeb2:	30 08       	mov	r8,0
8000aeb4:	fc 19 40 14 	movh	r9,0x4014
8000aeb8:	fe b0 e0 5c 	rcall	80006f70 <__avr32_f64_sub>
8000aebc:	40 bc       	lddsp	r12,sp[0x2c]
8000aebe:	fa eb 00 08 	st.d	sp[8],r10
8000aec2:	14 98       	mov	r8,r10
8000aec4:	16 99       	mov	r9,r11
8000aec6:	18 9a       	mov	r10,r12
8000aec8:	0a 9b       	mov	r11,r5
8000aeca:	fe b0 e2 1d 	rcall	80007304 <__avr32_f64_cmp_lt>
8000aece:	e0 81 02 54 	brne	8000b376 <_dtoa_r+0x96e>
8000aed2:	0a 98       	mov	r8,r5
8000aed4:	40 b9       	lddsp	r9,sp[0x2c]
8000aed6:	ee 18 80 00 	eorh	r8,0x8000
8000aeda:	fa ea 00 08 	ld.d	r10,sp[8]
8000aede:	10 95       	mov	r5,r8
8000aee0:	12 98       	mov	r8,r9
8000aee2:	0a 99       	mov	r9,r5
8000aee4:	fe b0 e2 10 	rcall	80007304 <__avr32_f64_cmp_lt>
8000aee8:	e0 81 02 3e 	brne	8000b364 <_dtoa_r+0x95c>
8000aeec:	ca 68       	rjmp	8000b038 <_dtoa_r+0x630>
8000aeee:	4c e9       	lddpc	r9,8000b024 <_dtoa_r+0x61c>
8000aef0:	e8 c8 00 01 	sub	r8,r4,1
8000aef4:	40 d5       	lddsp	r5,sp[0x34]
8000aef6:	58 05       	cp.w	r5,0
8000aef8:	c4 f0       	breq	8000af96 <_dtoa_r+0x58e>
8000aefa:	30 0c       	mov	r12,0
8000aefc:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000af00:	51 3c       	stdsp	sp[0x4c],r12
8000af02:	30 0a       	mov	r10,0
8000af04:	fc 1b 3f e0 	movh	r11,0x3fe0
8000af08:	fe b0 e2 4c 	rcall	800073a0 <__avr32_f64_div>
8000af0c:	fa e8 00 28 	ld.d	r8,sp[40]
8000af10:	40 85       	lddsp	r5,sp[0x20]
8000af12:	fe b0 e0 2f 	rcall	80006f70 <__avr32_f64_sub>
8000af16:	fa eb 00 28 	st.d	sp[40],r10
8000af1a:	fa ea 00 08 	ld.d	r10,sp[8]
8000af1e:	e0 a0 0b e5 	rcall	8000c6e8 <__avr32_f64_to_s32>
8000af22:	51 6c       	stdsp	sp[0x58],r12
8000af24:	fe b0 e1 80 	rcall	80007224 <__avr32_s32_to_f64>
8000af28:	14 98       	mov	r8,r10
8000af2a:	16 99       	mov	r9,r11
8000af2c:	fa ea 00 08 	ld.d	r10,sp[8]
8000af30:	fe b0 e0 20 	rcall	80006f70 <__avr32_f64_sub>
8000af34:	fa eb 00 08 	st.d	sp[8],r10
8000af38:	41 68       	lddsp	r8,sp[0x58]
8000af3a:	2d 08       	sub	r8,-48
8000af3c:	0a c8       	st.b	r5++,r8
8000af3e:	41 39       	lddsp	r9,sp[0x4c]
8000af40:	2f f9       	sub	r9,-1
8000af42:	51 39       	stdsp	sp[0x4c],r9
8000af44:	fa e8 00 28 	ld.d	r8,sp[40]
8000af48:	fe b0 e1 de 	rcall	80007304 <__avr32_f64_cmp_lt>
8000af4c:	e0 81 03 3a 	brne	8000b5c0 <_dtoa_r+0xbb8>
8000af50:	fa e8 00 08 	ld.d	r8,sp[8]
8000af54:	30 0a       	mov	r10,0
8000af56:	fc 1b 3f f0 	movh	r11,0x3ff0
8000af5a:	fe b0 e0 0b 	rcall	80006f70 <__avr32_f64_sub>
8000af5e:	fa e8 00 28 	ld.d	r8,sp[40]
8000af62:	fe b0 e1 d1 	rcall	80007304 <__avr32_f64_cmp_lt>
8000af66:	fa ea 00 28 	ld.d	r10,sp[40]
8000af6a:	30 08       	mov	r8,0
8000af6c:	fc 19 40 24 	movh	r9,0x4024
8000af70:	e0 81 00 da 	brne	8000b124 <_dtoa_r+0x71c>
8000af74:	41 3c       	lddsp	r12,sp[0x4c]
8000af76:	08 3c       	cp.w	r12,r4
8000af78:	c6 04       	brge	8000b038 <_dtoa_r+0x630>
8000af7a:	fe b0 df 0f 	rcall	80006d98 <__avr32_f64_mul>
8000af7e:	30 08       	mov	r8,0
8000af80:	fa eb 00 28 	st.d	sp[40],r10
8000af84:	fc 19 40 24 	movh	r9,0x4024
8000af88:	fa ea 00 08 	ld.d	r10,sp[8]
8000af8c:	fe b0 df 06 	rcall	80006d98 <__avr32_f64_mul>
8000af90:	fa eb 00 08 	st.d	sp[8],r10
8000af94:	cc 3b       	rjmp	8000af1a <_dtoa_r+0x512>
8000af96:	40 85       	lddsp	r5,sp[0x20]
8000af98:	08 05       	add	r5,r4
8000af9a:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000af9e:	51 35       	stdsp	sp[0x4c],r5
8000afa0:	fa e8 00 28 	ld.d	r8,sp[40]
8000afa4:	40 85       	lddsp	r5,sp[0x20]
8000afa6:	fe b0 de f9 	rcall	80006d98 <__avr32_f64_mul>
8000afaa:	fa eb 00 28 	st.d	sp[40],r10
8000afae:	fa ea 00 08 	ld.d	r10,sp[8]
8000afb2:	e0 a0 0b 9b 	rcall	8000c6e8 <__avr32_f64_to_s32>
8000afb6:	51 6c       	stdsp	sp[0x58],r12
8000afb8:	fe b0 e1 36 	rcall	80007224 <__avr32_s32_to_f64>
8000afbc:	14 98       	mov	r8,r10
8000afbe:	16 99       	mov	r9,r11
8000afc0:	fa ea 00 08 	ld.d	r10,sp[8]
8000afc4:	fe b0 df d6 	rcall	80006f70 <__avr32_f64_sub>
8000afc8:	fa eb 00 08 	st.d	sp[8],r10
8000afcc:	41 68       	lddsp	r8,sp[0x58]
8000afce:	2d 08       	sub	r8,-48
8000afd0:	0a c8       	st.b	r5++,r8
8000afd2:	41 3c       	lddsp	r12,sp[0x4c]
8000afd4:	18 35       	cp.w	r5,r12
8000afd6:	c2 91       	brne	8000b028 <_dtoa_r+0x620>
8000afd8:	30 08       	mov	r8,0
8000afda:	fc 19 3f e0 	movh	r9,0x3fe0
8000afde:	fa ea 00 28 	ld.d	r10,sp[40]
8000afe2:	fe b0 e0 95 	rcall	8000710c <__avr32_f64_add>
8000afe6:	40 85       	lddsp	r5,sp[0x20]
8000afe8:	fa e8 00 08 	ld.d	r8,sp[8]
8000afec:	08 05       	add	r5,r4
8000afee:	fe b0 e1 8b 	rcall	80007304 <__avr32_f64_cmp_lt>
8000aff2:	e0 81 00 99 	brne	8000b124 <_dtoa_r+0x71c>
8000aff6:	fa e8 00 28 	ld.d	r8,sp[40]
8000affa:	30 0a       	mov	r10,0
8000affc:	fc 1b 3f e0 	movh	r11,0x3fe0
8000b000:	fe b0 df b8 	rcall	80006f70 <__avr32_f64_sub>
8000b004:	14 98       	mov	r8,r10
8000b006:	16 99       	mov	r9,r11
8000b008:	fa ea 00 08 	ld.d	r10,sp[8]
8000b00c:	fe b0 e1 7c 	rcall	80007304 <__avr32_f64_cmp_lt>
8000b010:	c1 40       	breq	8000b038 <_dtoa_r+0x630>
8000b012:	33 09       	mov	r9,48
8000b014:	0a 98       	mov	r8,r5
8000b016:	11 7a       	ld.ub	r10,--r8
8000b018:	f2 0a 18 00 	cp.b	r10,r9
8000b01c:	e0 81 02 d2 	brne	8000b5c0 <_dtoa_r+0xbb8>
8000b020:	10 95       	mov	r5,r8
8000b022:	cf 9b       	rjmp	8000b014 <_dtoa_r+0x60c>
8000b024:	80 02       	ld.sh	r2,r0[0x0]
8000b026:	f9 d4 30 08 	ldswp.uh	r4,r12[16]
8000b02a:	fc 19 40 24 	movh	r9,0x4024
8000b02e:	fe b0 de b5 	rcall	80006d98 <__avr32_f64_mul>
8000b032:	fa eb 00 08 	st.d	sp[8],r10
8000b036:	cb cb       	rjmp	8000afae <_dtoa_r+0x5a6>
8000b038:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b03c:	fa eb 00 08 	st.d	sp[8],r10
8000b040:	58 e6       	cp.w	r6,14
8000b042:	5f ab       	srle	r11
8000b044:	41 8a       	lddsp	r10,sp[0x60]
8000b046:	30 08       	mov	r8,0
8000b048:	f4 09 11 ff 	rsub	r9,r10,-1
8000b04c:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000b050:	f0 09 18 00 	cp.b	r9,r8
8000b054:	e0 80 00 81 	breq	8000b156 <_dtoa_r+0x74e>
8000b058:	40 ea       	lddsp	r10,sp[0x38]
8000b05a:	58 01       	cp.w	r1,0
8000b05c:	5f a9       	srle	r9
8000b05e:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000b062:	4c 9a       	lddpc	r10,8000b184 <_dtoa_r+0x77c>
8000b064:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000b068:	fa e5 00 10 	st.d	sp[16],r4
8000b06c:	f0 09 18 00 	cp.b	r9,r8
8000b070:	c1 40       	breq	8000b098 <_dtoa_r+0x690>
8000b072:	58 01       	cp.w	r1,0
8000b074:	e0 81 01 78 	brne	8000b364 <_dtoa_r+0x95c>
8000b078:	30 08       	mov	r8,0
8000b07a:	fc 19 40 14 	movh	r9,0x4014
8000b07e:	08 9a       	mov	r10,r4
8000b080:	0a 9b       	mov	r11,r5
8000b082:	fe b0 de 8b 	rcall	80006d98 <__avr32_f64_mul>
8000b086:	fa e8 00 08 	ld.d	r8,sp[8]
8000b08a:	e0 a0 0b 55 	rcall	8000c734 <__avr32_f64_cmp_ge>
8000b08e:	e0 81 01 6b 	brne	8000b364 <_dtoa_r+0x95c>
8000b092:	02 92       	mov	r2,r1
8000b094:	e0 8f 01 73 	bral	8000b37a <_dtoa_r+0x972>
8000b098:	40 85       	lddsp	r5,sp[0x20]
8000b09a:	30 14       	mov	r4,1
8000b09c:	fa e8 00 10 	ld.d	r8,sp[16]
8000b0a0:	fa ea 00 08 	ld.d	r10,sp[8]
8000b0a4:	fe b0 e1 7e 	rcall	800073a0 <__avr32_f64_div>
8000b0a8:	e0 a0 0b 20 	rcall	8000c6e8 <__avr32_f64_to_s32>
8000b0ac:	18 92       	mov	r2,r12
8000b0ae:	fe b0 e0 bb 	rcall	80007224 <__avr32_s32_to_f64>
8000b0b2:	fa e8 00 10 	ld.d	r8,sp[16]
8000b0b6:	fe b0 de 71 	rcall	80006d98 <__avr32_f64_mul>
8000b0ba:	14 98       	mov	r8,r10
8000b0bc:	16 99       	mov	r9,r11
8000b0be:	fa ea 00 08 	ld.d	r10,sp[8]
8000b0c2:	fe b0 df 57 	rcall	80006f70 <__avr32_f64_sub>
8000b0c6:	fa eb 00 08 	st.d	sp[8],r10
8000b0ca:	e4 c8 ff d0 	sub	r8,r2,-48
8000b0ce:	0a c8       	st.b	r5++,r8
8000b0d0:	fc 19 40 24 	movh	r9,0x4024
8000b0d4:	30 08       	mov	r8,0
8000b0d6:	02 34       	cp.w	r4,r1
8000b0d8:	c3 31       	brne	8000b13e <_dtoa_r+0x736>
8000b0da:	fa e8 00 08 	ld.d	r8,sp[8]
8000b0de:	fe b0 e0 17 	rcall	8000710c <__avr32_f64_add>
8000b0e2:	16 91       	mov	r1,r11
8000b0e4:	14 90       	mov	r0,r10
8000b0e6:	14 98       	mov	r8,r10
8000b0e8:	02 99       	mov	r9,r1
8000b0ea:	fa ea 00 10 	ld.d	r10,sp[16]
8000b0ee:	fe b0 e1 0b 	rcall	80007304 <__avr32_f64_cmp_lt>
8000b0f2:	c1 a1       	brne	8000b126 <_dtoa_r+0x71e>
8000b0f4:	fa e8 00 10 	ld.d	r8,sp[16]
8000b0f8:	00 9a       	mov	r10,r0
8000b0fa:	02 9b       	mov	r11,r1
8000b0fc:	e0 a0 0b 09 	rcall	8000c70e <__avr32_f64_cmp_eq>
8000b100:	e0 80 02 5f 	breq	8000b5be <_dtoa_r+0xbb6>
8000b104:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000b108:	c0 f1       	brne	8000b126 <_dtoa_r+0x71e>
8000b10a:	e0 8f 02 5a 	bral	8000b5be <_dtoa_r+0xbb6>
8000b10e:	40 8a       	lddsp	r10,sp[0x20]
8000b110:	14 38       	cp.w	r8,r10
8000b112:	c0 30       	breq	8000b118 <_dtoa_r+0x710>
8000b114:	10 95       	mov	r5,r8
8000b116:	c0 98       	rjmp	8000b128 <_dtoa_r+0x720>
8000b118:	33 08       	mov	r8,48
8000b11a:	40 89       	lddsp	r9,sp[0x20]
8000b11c:	2f f6       	sub	r6,-1
8000b11e:	b2 88       	st.b	r9[0x0],r8
8000b120:	40 88       	lddsp	r8,sp[0x20]
8000b122:	c0 88       	rjmp	8000b132 <_dtoa_r+0x72a>
8000b124:	40 66       	lddsp	r6,sp[0x18]
8000b126:	33 99       	mov	r9,57
8000b128:	0a 98       	mov	r8,r5
8000b12a:	11 7a       	ld.ub	r10,--r8
8000b12c:	f2 0a 18 00 	cp.b	r10,r9
8000b130:	ce f0       	breq	8000b10e <_dtoa_r+0x706>
8000b132:	50 66       	stdsp	sp[0x18],r6
8000b134:	11 89       	ld.ub	r9,r8[0x0]
8000b136:	2f f9       	sub	r9,-1
8000b138:	b0 89       	st.b	r8[0x0],r9
8000b13a:	e0 8f 02 43 	bral	8000b5c0 <_dtoa_r+0xbb8>
8000b13e:	fe b0 de 2d 	rcall	80006d98 <__avr32_f64_mul>
8000b142:	2f f4       	sub	r4,-1
8000b144:	fa eb 00 08 	st.d	sp[8],r10
8000b148:	30 08       	mov	r8,0
8000b14a:	30 09       	mov	r9,0
8000b14c:	e0 a0 0a e1 	rcall	8000c70e <__avr32_f64_cmp_eq>
8000b150:	ca 60       	breq	8000b09c <_dtoa_r+0x694>
8000b152:	e0 8f 02 36 	bral	8000b5be <_dtoa_r+0xbb6>
8000b156:	40 d8       	lddsp	r8,sp[0x34]
8000b158:	58 08       	cp.w	r8,0
8000b15a:	c0 51       	brne	8000b164 <_dtoa_r+0x75c>
8000b15c:	04 98       	mov	r8,r2
8000b15e:	00 95       	mov	r5,r0
8000b160:	40 d4       	lddsp	r4,sp[0x34]
8000b162:	c3 88       	rjmp	8000b1d2 <_dtoa_r+0x7ca>
8000b164:	40 c5       	lddsp	r5,sp[0x30]
8000b166:	58 15       	cp.w	r5,1
8000b168:	e0 89 00 10 	brgt	8000b188 <_dtoa_r+0x780>
8000b16c:	41 74       	lddsp	r4,sp[0x5c]
8000b16e:	58 04       	cp.w	r4,0
8000b170:	c0 40       	breq	8000b178 <_dtoa_r+0x770>
8000b172:	f4 c9 fb cd 	sub	r9,r10,-1075
8000b176:	c0 48       	rjmp	8000b17e <_dtoa_r+0x776>
8000b178:	41 99       	lddsp	r9,sp[0x64]
8000b17a:	f2 09 11 36 	rsub	r9,r9,54
8000b17e:	04 98       	mov	r8,r2
8000b180:	00 95       	mov	r5,r0
8000b182:	c1 d8       	rjmp	8000b1bc <_dtoa_r+0x7b4>
8000b184:	80 02       	ld.sh	r2,r0[0x0]
8000b186:	f9 d4       	*unknown*
8000b188:	e2 c8 00 01 	sub	r8,r1,1
8000b18c:	58 01       	cp.w	r1,0
8000b18e:	e0 05 17 40 	movge	r5,r0
8000b192:	e2 09 17 40 	movge	r9,r1
8000b196:	e1 d1 e5 15 	sublt	r5,r0,r1
8000b19a:	f9 b9 05 00 	movlt	r9,0
8000b19e:	10 32       	cp.w	r2,r8
8000b1a0:	e5 d8 e4 18 	subge	r8,r2,r8
8000b1a4:	f1 d2 e5 18 	sublt	r8,r8,r2
8000b1a8:	e5 d8 e5 02 	addlt	r2,r2,r8
8000b1ac:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000b1b0:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000b1b4:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000b1b8:	f9 b8 05 00 	movlt	r8,0
8000b1bc:	40 4b       	lddsp	r11,sp[0x10]
8000b1be:	12 0b       	add	r11,r9
8000b1c0:	50 08       	stdsp	sp[0x0],r8
8000b1c2:	50 4b       	stdsp	sp[0x10],r11
8000b1c4:	12 00       	add	r0,r9
8000b1c6:	30 1b       	mov	r11,1
8000b1c8:	0e 9c       	mov	r12,r7
8000b1ca:	e0 a0 08 a7 	rcall	8000c318 <__i2b>
8000b1ce:	40 08       	lddsp	r8,sp[0x0]
8000b1d0:	18 94       	mov	r4,r12
8000b1d2:	40 4a       	lddsp	r10,sp[0x10]
8000b1d4:	58 05       	cp.w	r5,0
8000b1d6:	5f 99       	srgt	r9
8000b1d8:	58 0a       	cp.w	r10,0
8000b1da:	5f 9a       	srgt	r10
8000b1dc:	f5 e9 00 09 	and	r9,r10,r9
8000b1e0:	c0 80       	breq	8000b1f0 <_dtoa_r+0x7e8>
8000b1e2:	40 4c       	lddsp	r12,sp[0x10]
8000b1e4:	f8 05 0d 49 	min	r9,r12,r5
8000b1e8:	12 1c       	sub	r12,r9
8000b1ea:	12 10       	sub	r0,r9
8000b1ec:	50 4c       	stdsp	sp[0x10],r12
8000b1ee:	12 15       	sub	r5,r9
8000b1f0:	58 02       	cp.w	r2,0
8000b1f2:	e0 8a 00 27 	brle	8000b240 <_dtoa_r+0x838>
8000b1f6:	40 db       	lddsp	r11,sp[0x34]
8000b1f8:	58 0b       	cp.w	r11,0
8000b1fa:	c1 d0       	breq	8000b234 <_dtoa_r+0x82c>
8000b1fc:	58 08       	cp.w	r8,0
8000b1fe:	e0 8a 00 17 	brle	8000b22c <_dtoa_r+0x824>
8000b202:	10 9a       	mov	r10,r8
8000b204:	50 08       	stdsp	sp[0x0],r8
8000b206:	08 9b       	mov	r11,r4
8000b208:	0e 9c       	mov	r12,r7
8000b20a:	e0 a0 08 cd 	rcall	8000c3a4 <__pow5mult>
8000b20e:	06 9a       	mov	r10,r3
8000b210:	18 9b       	mov	r11,r12
8000b212:	18 94       	mov	r4,r12
8000b214:	0e 9c       	mov	r12,r7
8000b216:	e0 a0 08 01 	rcall	8000c218 <__multiply>
8000b21a:	18 99       	mov	r9,r12
8000b21c:	06 9b       	mov	r11,r3
8000b21e:	50 19       	stdsp	sp[0x4],r9
8000b220:	0e 9c       	mov	r12,r7
8000b222:	e0 a0 06 ad 	rcall	8000bf7c <_Bfree>
8000b226:	40 19       	lddsp	r9,sp[0x4]
8000b228:	40 08       	lddsp	r8,sp[0x0]
8000b22a:	12 93       	mov	r3,r9
8000b22c:	e4 08 01 0a 	sub	r10,r2,r8
8000b230:	c0 80       	breq	8000b240 <_dtoa_r+0x838>
8000b232:	c0 28       	rjmp	8000b236 <_dtoa_r+0x82e>
8000b234:	04 9a       	mov	r10,r2
8000b236:	06 9b       	mov	r11,r3
8000b238:	0e 9c       	mov	r12,r7
8000b23a:	e0 a0 08 b5 	rcall	8000c3a4 <__pow5mult>
8000b23e:	18 93       	mov	r3,r12
8000b240:	30 1b       	mov	r11,1
8000b242:	0e 9c       	mov	r12,r7
8000b244:	e0 a0 08 6a 	rcall	8000c318 <__i2b>
8000b248:	41 1a       	lddsp	r10,sp[0x44]
8000b24a:	18 92       	mov	r2,r12
8000b24c:	58 0a       	cp.w	r10,0
8000b24e:	e0 8a 00 07 	brle	8000b25c <_dtoa_r+0x854>
8000b252:	18 9b       	mov	r11,r12
8000b254:	0e 9c       	mov	r12,r7
8000b256:	e0 a0 08 a7 	rcall	8000c3a4 <__pow5mult>
8000b25a:	18 92       	mov	r2,r12
8000b25c:	40 c9       	lddsp	r9,sp[0x30]
8000b25e:	58 19       	cp.w	r9,1
8000b260:	e0 89 00 14 	brgt	8000b288 <_dtoa_r+0x880>
8000b264:	40 38       	lddsp	r8,sp[0xc]
8000b266:	58 08       	cp.w	r8,0
8000b268:	c1 01       	brne	8000b288 <_dtoa_r+0x880>
8000b26a:	40 29       	lddsp	r9,sp[0x8]
8000b26c:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000b270:	c0 c1       	brne	8000b288 <_dtoa_r+0x880>
8000b272:	12 98       	mov	r8,r9
8000b274:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000b278:	c0 80       	breq	8000b288 <_dtoa_r+0x880>
8000b27a:	40 4c       	lddsp	r12,sp[0x10]
8000b27c:	30 1b       	mov	r11,1
8000b27e:	2f fc       	sub	r12,-1
8000b280:	2f f0       	sub	r0,-1
8000b282:	50 4c       	stdsp	sp[0x10],r12
8000b284:	50 6b       	stdsp	sp[0x18],r11
8000b286:	c0 38       	rjmp	8000b28c <_dtoa_r+0x884>
8000b288:	30 0a       	mov	r10,0
8000b28a:	50 6a       	stdsp	sp[0x18],r10
8000b28c:	41 19       	lddsp	r9,sp[0x44]
8000b28e:	58 09       	cp.w	r9,0
8000b290:	c0 31       	brne	8000b296 <_dtoa_r+0x88e>
8000b292:	30 1c       	mov	r12,1
8000b294:	c0 98       	rjmp	8000b2a6 <_dtoa_r+0x89e>
8000b296:	64 48       	ld.w	r8,r2[0x10]
8000b298:	2f c8       	sub	r8,-4
8000b29a:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000b29e:	e0 a0 05 df 	rcall	8000be5c <__hi0bits>
8000b2a2:	f8 0c 11 20 	rsub	r12,r12,32
8000b2a6:	40 4b       	lddsp	r11,sp[0x10]
8000b2a8:	f8 0b 00 08 	add	r8,r12,r11
8000b2ac:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000b2b0:	c0 c0       	breq	8000b2c8 <_dtoa_r+0x8c0>
8000b2b2:	f0 08 11 20 	rsub	r8,r8,32
8000b2b6:	58 48       	cp.w	r8,4
8000b2b8:	e0 8a 00 06 	brle	8000b2c4 <_dtoa_r+0x8bc>
8000b2bc:	20 48       	sub	r8,4
8000b2be:	10 0b       	add	r11,r8
8000b2c0:	50 4b       	stdsp	sp[0x10],r11
8000b2c2:	c0 78       	rjmp	8000b2d0 <_dtoa_r+0x8c8>
8000b2c4:	58 48       	cp.w	r8,4
8000b2c6:	c0 70       	breq	8000b2d4 <_dtoa_r+0x8cc>
8000b2c8:	40 4a       	lddsp	r10,sp[0x10]
8000b2ca:	2e 48       	sub	r8,-28
8000b2cc:	10 0a       	add	r10,r8
8000b2ce:	50 4a       	stdsp	sp[0x10],r10
8000b2d0:	10 00       	add	r0,r8
8000b2d2:	10 05       	add	r5,r8
8000b2d4:	58 00       	cp.w	r0,0
8000b2d6:	e0 8a 00 08 	brle	8000b2e6 <_dtoa_r+0x8de>
8000b2da:	06 9b       	mov	r11,r3
8000b2dc:	00 9a       	mov	r10,r0
8000b2de:	0e 9c       	mov	r12,r7
8000b2e0:	e0 a0 07 58 	rcall	8000c190 <__lshift>
8000b2e4:	18 93       	mov	r3,r12
8000b2e6:	40 49       	lddsp	r9,sp[0x10]
8000b2e8:	58 09       	cp.w	r9,0
8000b2ea:	e0 8a 00 08 	brle	8000b2fa <_dtoa_r+0x8f2>
8000b2ee:	04 9b       	mov	r11,r2
8000b2f0:	12 9a       	mov	r10,r9
8000b2f2:	0e 9c       	mov	r12,r7
8000b2f4:	e0 a0 07 4e 	rcall	8000c190 <__lshift>
8000b2f8:	18 92       	mov	r2,r12
8000b2fa:	41 48       	lddsp	r8,sp[0x50]
8000b2fc:	58 08       	cp.w	r8,0
8000b2fe:	c1 b0       	breq	8000b334 <_dtoa_r+0x92c>
8000b300:	04 9b       	mov	r11,r2
8000b302:	06 9c       	mov	r12,r3
8000b304:	e0 a0 06 23 	rcall	8000bf4a <__mcmp>
8000b308:	c1 64       	brge	8000b334 <_dtoa_r+0x92c>
8000b30a:	06 9b       	mov	r11,r3
8000b30c:	30 09       	mov	r9,0
8000b30e:	30 aa       	mov	r10,10
8000b310:	0e 9c       	mov	r12,r7
8000b312:	e0 a0 08 0b 	rcall	8000c328 <__multadd>
8000b316:	20 16       	sub	r6,1
8000b318:	18 93       	mov	r3,r12
8000b31a:	40 dc       	lddsp	r12,sp[0x34]
8000b31c:	58 0c       	cp.w	r12,0
8000b31e:	c0 31       	brne	8000b324 <_dtoa_r+0x91c>
8000b320:	40 91       	lddsp	r1,sp[0x24]
8000b322:	c0 98       	rjmp	8000b334 <_dtoa_r+0x92c>
8000b324:	08 9b       	mov	r11,r4
8000b326:	40 91       	lddsp	r1,sp[0x24]
8000b328:	30 09       	mov	r9,0
8000b32a:	30 aa       	mov	r10,10
8000b32c:	0e 9c       	mov	r12,r7
8000b32e:	e0 a0 07 fd 	rcall	8000c328 <__multadd>
8000b332:	18 94       	mov	r4,r12
8000b334:	58 01       	cp.w	r1,0
8000b336:	5f a9       	srle	r9
8000b338:	40 cb       	lddsp	r11,sp[0x30]
8000b33a:	58 2b       	cp.w	r11,2
8000b33c:	5f 98       	srgt	r8
8000b33e:	f3 e8 00 08 	and	r8,r9,r8
8000b342:	c2 50       	breq	8000b38c <_dtoa_r+0x984>
8000b344:	58 01       	cp.w	r1,0
8000b346:	c1 11       	brne	8000b368 <_dtoa_r+0x960>
8000b348:	04 9b       	mov	r11,r2
8000b34a:	02 99       	mov	r9,r1
8000b34c:	30 5a       	mov	r10,5
8000b34e:	0e 9c       	mov	r12,r7
8000b350:	e0 a0 07 ec 	rcall	8000c328 <__multadd>
8000b354:	18 92       	mov	r2,r12
8000b356:	18 9b       	mov	r11,r12
8000b358:	06 9c       	mov	r12,r3
8000b35a:	e0 a0 05 f8 	rcall	8000bf4a <__mcmp>
8000b35e:	e0 89 00 0f 	brgt	8000b37c <_dtoa_r+0x974>
8000b362:	c0 38       	rjmp	8000b368 <_dtoa_r+0x960>
8000b364:	30 02       	mov	r2,0
8000b366:	04 94       	mov	r4,r2
8000b368:	40 ea       	lddsp	r10,sp[0x38]
8000b36a:	30 09       	mov	r9,0
8000b36c:	5c da       	com	r10
8000b36e:	40 85       	lddsp	r5,sp[0x20]
8000b370:	50 6a       	stdsp	sp[0x18],r10
8000b372:	50 49       	stdsp	sp[0x10],r9
8000b374:	c0 f9       	rjmp	8000b592 <_dtoa_r+0xb8a>
8000b376:	08 92       	mov	r2,r4
8000b378:	40 66       	lddsp	r6,sp[0x18]
8000b37a:	04 94       	mov	r4,r2
8000b37c:	2f f6       	sub	r6,-1
8000b37e:	50 66       	stdsp	sp[0x18],r6
8000b380:	33 18       	mov	r8,49
8000b382:	40 85       	lddsp	r5,sp[0x20]
8000b384:	0a c8       	st.b	r5++,r8
8000b386:	30 08       	mov	r8,0
8000b388:	50 48       	stdsp	sp[0x10],r8
8000b38a:	c0 49       	rjmp	8000b592 <_dtoa_r+0xb8a>
8000b38c:	40 dc       	lddsp	r12,sp[0x34]
8000b38e:	58 0c       	cp.w	r12,0
8000b390:	e0 80 00 b5 	breq	8000b4fa <_dtoa_r+0xaf2>
8000b394:	58 05       	cp.w	r5,0
8000b396:	e0 8a 00 08 	brle	8000b3a6 <_dtoa_r+0x99e>
8000b39a:	08 9b       	mov	r11,r4
8000b39c:	0a 9a       	mov	r10,r5
8000b39e:	0e 9c       	mov	r12,r7
8000b3a0:	e0 a0 06 f8 	rcall	8000c190 <__lshift>
8000b3a4:	18 94       	mov	r4,r12
8000b3a6:	40 6b       	lddsp	r11,sp[0x18]
8000b3a8:	58 0b       	cp.w	r11,0
8000b3aa:	c0 31       	brne	8000b3b0 <_dtoa_r+0x9a8>
8000b3ac:	08 9c       	mov	r12,r4
8000b3ae:	c1 38       	rjmp	8000b3d4 <_dtoa_r+0x9cc>
8000b3b0:	68 1b       	ld.w	r11,r4[0x4]
8000b3b2:	0e 9c       	mov	r12,r7
8000b3b4:	e0 a0 05 fe 	rcall	8000bfb0 <_Balloc>
8000b3b8:	68 4a       	ld.w	r10,r4[0x10]
8000b3ba:	18 95       	mov	r5,r12
8000b3bc:	e8 cb ff f4 	sub	r11,r4,-12
8000b3c0:	2f ea       	sub	r10,-2
8000b3c2:	2f 4c       	sub	r12,-12
8000b3c4:	a3 6a       	lsl	r10,0x2
8000b3c6:	fe b0 e6 39 	rcall	80008038 <memcpy>
8000b3ca:	0a 9b       	mov	r11,r5
8000b3cc:	30 1a       	mov	r10,1
8000b3ce:	0e 9c       	mov	r12,r7
8000b3d0:	e0 a0 06 e0 	rcall	8000c190 <__lshift>
8000b3d4:	50 44       	stdsp	sp[0x10],r4
8000b3d6:	40 3a       	lddsp	r10,sp[0xc]
8000b3d8:	30 19       	mov	r9,1
8000b3da:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000b3de:	18 94       	mov	r4,r12
8000b3e0:	50 da       	stdsp	sp[0x34],r10
8000b3e2:	40 85       	lddsp	r5,sp[0x20]
8000b3e4:	50 99       	stdsp	sp[0x24],r9
8000b3e6:	50 26       	stdsp	sp[0x8],r6
8000b3e8:	50 e1       	stdsp	sp[0x38],r1
8000b3ea:	04 9b       	mov	r11,r2
8000b3ec:	06 9c       	mov	r12,r3
8000b3ee:	fe b0 fa 7d 	rcall	8000a8e8 <quorem>
8000b3f2:	40 4b       	lddsp	r11,sp[0x10]
8000b3f4:	f8 c0 ff d0 	sub	r0,r12,-48
8000b3f8:	06 9c       	mov	r12,r3
8000b3fa:	e0 a0 05 a8 	rcall	8000bf4a <__mcmp>
8000b3fe:	08 9a       	mov	r10,r4
8000b400:	50 6c       	stdsp	sp[0x18],r12
8000b402:	04 9b       	mov	r11,r2
8000b404:	0e 9c       	mov	r12,r7
8000b406:	e0 a0 06 5d 	rcall	8000c0c0 <__mdiff>
8000b40a:	18 91       	mov	r1,r12
8000b40c:	78 38       	ld.w	r8,r12[0xc]
8000b40e:	58 08       	cp.w	r8,0
8000b410:	c0 30       	breq	8000b416 <_dtoa_r+0xa0e>
8000b412:	30 16       	mov	r6,1
8000b414:	c0 68       	rjmp	8000b420 <_dtoa_r+0xa18>
8000b416:	18 9b       	mov	r11,r12
8000b418:	06 9c       	mov	r12,r3
8000b41a:	e0 a0 05 98 	rcall	8000bf4a <__mcmp>
8000b41e:	18 96       	mov	r6,r12
8000b420:	0e 9c       	mov	r12,r7
8000b422:	02 9b       	mov	r11,r1
8000b424:	e0 a0 05 ac 	rcall	8000bf7c <_Bfree>
8000b428:	40 cc       	lddsp	r12,sp[0x30]
8000b42a:	ed ec 10 08 	or	r8,r6,r12
8000b42e:	c0 d1       	brne	8000b448 <_dtoa_r+0xa40>
8000b430:	40 db       	lddsp	r11,sp[0x34]
8000b432:	58 0b       	cp.w	r11,0
8000b434:	c0 a1       	brne	8000b448 <_dtoa_r+0xa40>
8000b436:	40 26       	lddsp	r6,sp[0x8]
8000b438:	e0 40 00 39 	cp.w	r0,57
8000b43c:	c3 00       	breq	8000b49c <_dtoa_r+0xa94>
8000b43e:	40 6a       	lddsp	r10,sp[0x18]
8000b440:	58 0a       	cp.w	r10,0
8000b442:	e0 89 00 24 	brgt	8000b48a <_dtoa_r+0xa82>
8000b446:	c2 f8       	rjmp	8000b4a4 <_dtoa_r+0xa9c>
8000b448:	40 69       	lddsp	r9,sp[0x18]
8000b44a:	58 09       	cp.w	r9,0
8000b44c:	c0 85       	brlt	8000b45c <_dtoa_r+0xa54>
8000b44e:	12 98       	mov	r8,r9
8000b450:	40 cc       	lddsp	r12,sp[0x30]
8000b452:	18 48       	or	r8,r12
8000b454:	c1 d1       	brne	8000b48e <_dtoa_r+0xa86>
8000b456:	40 db       	lddsp	r11,sp[0x34]
8000b458:	58 0b       	cp.w	r11,0
8000b45a:	c1 a1       	brne	8000b48e <_dtoa_r+0xa86>
8000b45c:	0c 99       	mov	r9,r6
8000b45e:	40 26       	lddsp	r6,sp[0x8]
8000b460:	58 09       	cp.w	r9,0
8000b462:	e0 8a 00 21 	brle	8000b4a4 <_dtoa_r+0xa9c>
8000b466:	06 9b       	mov	r11,r3
8000b468:	30 1a       	mov	r10,1
8000b46a:	0e 9c       	mov	r12,r7
8000b46c:	e0 a0 06 92 	rcall	8000c190 <__lshift>
8000b470:	04 9b       	mov	r11,r2
8000b472:	18 93       	mov	r3,r12
8000b474:	e0 a0 05 6b 	rcall	8000bf4a <__mcmp>
8000b478:	e0 89 00 06 	brgt	8000b484 <_dtoa_r+0xa7c>
8000b47c:	c1 41       	brne	8000b4a4 <_dtoa_r+0xa9c>
8000b47e:	ed b0 00 00 	bld	r0,0x0
8000b482:	c1 11       	brne	8000b4a4 <_dtoa_r+0xa9c>
8000b484:	e0 40 00 39 	cp.w	r0,57
8000b488:	c0 a0       	breq	8000b49c <_dtoa_r+0xa94>
8000b48a:	2f f0       	sub	r0,-1
8000b48c:	c0 c8       	rjmp	8000b4a4 <_dtoa_r+0xa9c>
8000b48e:	58 06       	cp.w	r6,0
8000b490:	e0 8a 00 0c 	brle	8000b4a8 <_dtoa_r+0xaa0>
8000b494:	40 26       	lddsp	r6,sp[0x8]
8000b496:	e0 40 00 39 	cp.w	r0,57
8000b49a:	c0 41       	brne	8000b4a2 <_dtoa_r+0xa9a>
8000b49c:	33 98       	mov	r8,57
8000b49e:	0a c8       	st.b	r5++,r8
8000b4a0:	c6 78       	rjmp	8000b56e <_dtoa_r+0xb66>
8000b4a2:	2f f0       	sub	r0,-1
8000b4a4:	0a c0       	st.b	r5++,r0
8000b4a6:	c7 58       	rjmp	8000b590 <_dtoa_r+0xb88>
8000b4a8:	0a c0       	st.b	r5++,r0
8000b4aa:	40 9a       	lddsp	r10,sp[0x24]
8000b4ac:	40 e9       	lddsp	r9,sp[0x38]
8000b4ae:	12 3a       	cp.w	r10,r9
8000b4b0:	c4 30       	breq	8000b536 <_dtoa_r+0xb2e>
8000b4b2:	06 9b       	mov	r11,r3
8000b4b4:	30 09       	mov	r9,0
8000b4b6:	30 aa       	mov	r10,10
8000b4b8:	0e 9c       	mov	r12,r7
8000b4ba:	e0 a0 07 37 	rcall	8000c328 <__multadd>
8000b4be:	40 48       	lddsp	r8,sp[0x10]
8000b4c0:	18 93       	mov	r3,r12
8000b4c2:	08 38       	cp.w	r8,r4
8000b4c4:	c0 91       	brne	8000b4d6 <_dtoa_r+0xace>
8000b4c6:	10 9b       	mov	r11,r8
8000b4c8:	30 09       	mov	r9,0
8000b4ca:	30 aa       	mov	r10,10
8000b4cc:	0e 9c       	mov	r12,r7
8000b4ce:	e0 a0 07 2d 	rcall	8000c328 <__multadd>
8000b4d2:	50 4c       	stdsp	sp[0x10],r12
8000b4d4:	c0 e8       	rjmp	8000b4f0 <_dtoa_r+0xae8>
8000b4d6:	40 4b       	lddsp	r11,sp[0x10]
8000b4d8:	30 09       	mov	r9,0
8000b4da:	30 aa       	mov	r10,10
8000b4dc:	0e 9c       	mov	r12,r7
8000b4de:	e0 a0 07 25 	rcall	8000c328 <__multadd>
8000b4e2:	08 9b       	mov	r11,r4
8000b4e4:	50 4c       	stdsp	sp[0x10],r12
8000b4e6:	30 09       	mov	r9,0
8000b4e8:	30 aa       	mov	r10,10
8000b4ea:	0e 9c       	mov	r12,r7
8000b4ec:	e0 a0 07 1e 	rcall	8000c328 <__multadd>
8000b4f0:	18 94       	mov	r4,r12
8000b4f2:	40 9c       	lddsp	r12,sp[0x24]
8000b4f4:	2f fc       	sub	r12,-1
8000b4f6:	50 9c       	stdsp	sp[0x24],r12
8000b4f8:	c7 9b       	rjmp	8000b3ea <_dtoa_r+0x9e2>
8000b4fa:	30 18       	mov	r8,1
8000b4fc:	06 90       	mov	r0,r3
8000b4fe:	40 85       	lddsp	r5,sp[0x20]
8000b500:	08 93       	mov	r3,r4
8000b502:	0c 94       	mov	r4,r6
8000b504:	10 96       	mov	r6,r8
8000b506:	04 9b       	mov	r11,r2
8000b508:	00 9c       	mov	r12,r0
8000b50a:	fe b0 f9 ef 	rcall	8000a8e8 <quorem>
8000b50e:	2d 0c       	sub	r12,-48
8000b510:	0a cc       	st.b	r5++,r12
8000b512:	02 36       	cp.w	r6,r1
8000b514:	c0 a4       	brge	8000b528 <_dtoa_r+0xb20>
8000b516:	00 9b       	mov	r11,r0
8000b518:	30 09       	mov	r9,0
8000b51a:	30 aa       	mov	r10,10
8000b51c:	0e 9c       	mov	r12,r7
8000b51e:	2f f6       	sub	r6,-1
8000b520:	e0 a0 07 04 	rcall	8000c328 <__multadd>
8000b524:	18 90       	mov	r0,r12
8000b526:	cf 0b       	rjmp	8000b506 <_dtoa_r+0xafe>
8000b528:	08 96       	mov	r6,r4
8000b52a:	30 0b       	mov	r11,0
8000b52c:	06 94       	mov	r4,r3
8000b52e:	50 4b       	stdsp	sp[0x10],r11
8000b530:	00 93       	mov	r3,r0
8000b532:	18 90       	mov	r0,r12
8000b534:	c0 28       	rjmp	8000b538 <_dtoa_r+0xb30>
8000b536:	40 26       	lddsp	r6,sp[0x8]
8000b538:	06 9b       	mov	r11,r3
8000b53a:	30 1a       	mov	r10,1
8000b53c:	0e 9c       	mov	r12,r7
8000b53e:	e0 a0 06 29 	rcall	8000c190 <__lshift>
8000b542:	04 9b       	mov	r11,r2
8000b544:	18 93       	mov	r3,r12
8000b546:	e0 a0 05 02 	rcall	8000bf4a <__mcmp>
8000b54a:	e0 89 00 12 	brgt	8000b56e <_dtoa_r+0xb66>
8000b54e:	c1 b1       	brne	8000b584 <_dtoa_r+0xb7c>
8000b550:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000b554:	c0 d1       	brne	8000b56e <_dtoa_r+0xb66>
8000b556:	c1 78       	rjmp	8000b584 <_dtoa_r+0xb7c>
8000b558:	40 89       	lddsp	r9,sp[0x20]
8000b55a:	12 38       	cp.w	r8,r9
8000b55c:	c0 30       	breq	8000b562 <_dtoa_r+0xb5a>
8000b55e:	10 95       	mov	r5,r8
8000b560:	c0 88       	rjmp	8000b570 <_dtoa_r+0xb68>
8000b562:	2f f6       	sub	r6,-1
8000b564:	50 66       	stdsp	sp[0x18],r6
8000b566:	33 18       	mov	r8,49
8000b568:	40 8c       	lddsp	r12,sp[0x20]
8000b56a:	b8 88       	st.b	r12[0x0],r8
8000b56c:	c1 38       	rjmp	8000b592 <_dtoa_r+0xb8a>
8000b56e:	33 9a       	mov	r10,57
8000b570:	0a 98       	mov	r8,r5
8000b572:	11 79       	ld.ub	r9,--r8
8000b574:	f4 09 18 00 	cp.b	r9,r10
8000b578:	cf 00       	breq	8000b558 <_dtoa_r+0xb50>
8000b57a:	2f f9       	sub	r9,-1
8000b57c:	b0 89       	st.b	r8[0x0],r9
8000b57e:	c0 98       	rjmp	8000b590 <_dtoa_r+0xb88>
8000b580:	10 95       	mov	r5,r8
8000b582:	c0 28       	rjmp	8000b586 <_dtoa_r+0xb7e>
8000b584:	33 09       	mov	r9,48
8000b586:	0a 98       	mov	r8,r5
8000b588:	11 7a       	ld.ub	r10,--r8
8000b58a:	f2 0a 18 00 	cp.b	r10,r9
8000b58e:	cf 90       	breq	8000b580 <_dtoa_r+0xb78>
8000b590:	50 66       	stdsp	sp[0x18],r6
8000b592:	04 9b       	mov	r11,r2
8000b594:	0e 9c       	mov	r12,r7
8000b596:	e0 a0 04 f3 	rcall	8000bf7c <_Bfree>
8000b59a:	58 04       	cp.w	r4,0
8000b59c:	c1 20       	breq	8000b5c0 <_dtoa_r+0xbb8>
8000b59e:	40 4b       	lddsp	r11,sp[0x10]
8000b5a0:	08 3b       	cp.w	r11,r4
8000b5a2:	5f 19       	srne	r9
8000b5a4:	58 0b       	cp.w	r11,0
8000b5a6:	5f 18       	srne	r8
8000b5a8:	f3 e8 00 08 	and	r8,r9,r8
8000b5ac:	c0 40       	breq	8000b5b4 <_dtoa_r+0xbac>
8000b5ae:	0e 9c       	mov	r12,r7
8000b5b0:	e0 a0 04 e6 	rcall	8000bf7c <_Bfree>
8000b5b4:	08 9b       	mov	r11,r4
8000b5b6:	0e 9c       	mov	r12,r7
8000b5b8:	e0 a0 04 e2 	rcall	8000bf7c <_Bfree>
8000b5bc:	c0 28       	rjmp	8000b5c0 <_dtoa_r+0xbb8>
8000b5be:	50 66       	stdsp	sp[0x18],r6
8000b5c0:	0e 9c       	mov	r12,r7
8000b5c2:	06 9b       	mov	r11,r3
8000b5c4:	e0 a0 04 dc 	rcall	8000bf7c <_Bfree>
8000b5c8:	30 08       	mov	r8,0
8000b5ca:	aa 88       	st.b	r5[0x0],r8
8000b5cc:	40 68       	lddsp	r8,sp[0x18]
8000b5ce:	41 5a       	lddsp	r10,sp[0x54]
8000b5d0:	2f f8       	sub	r8,-1
8000b5d2:	41 29       	lddsp	r9,sp[0x48]
8000b5d4:	95 08       	st.w	r10[0x0],r8
8000b5d6:	40 8c       	lddsp	r12,sp[0x20]
8000b5d8:	58 09       	cp.w	r9,0
8000b5da:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000b5de:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000b5e2:	2e 6d       	sub	sp,-104
8000b5e4:	d8 32       	popm	r0-r7,pc
8000b5e6:	d7 03       	nop

8000b5e8 <__errno>:
8000b5e8:	e0 68 05 34 	mov	r8,1332
8000b5ec:	70 0c       	ld.w	r12,r8[0x0]
8000b5ee:	2f 4c       	sub	r12,-12
8000b5f0:	5e fc       	retal	r12
8000b5f2:	d7 03       	nop

8000b5f4 <_fflush_r>:
8000b5f4:	d4 21       	pushm	r4-r7,lr
8000b5f6:	16 97       	mov	r7,r11
8000b5f8:	18 96       	mov	r6,r12
8000b5fa:	76 48       	ld.w	r8,r11[0x10]
8000b5fc:	58 08       	cp.w	r8,0
8000b5fe:	c7 c0       	breq	8000b6f6 <_fflush_r+0x102>
8000b600:	58 0c       	cp.w	r12,0
8000b602:	c0 50       	breq	8000b60c <_fflush_r+0x18>
8000b604:	78 68       	ld.w	r8,r12[0x18]
8000b606:	58 08       	cp.w	r8,0
8000b608:	c0 21       	brne	8000b60c <_fflush_r+0x18>
8000b60a:	cd 1c       	rcall	8000b7ac <__sinit>
8000b60c:	4b b8       	lddpc	r8,8000b6f8 <_fflush_r+0x104>
8000b60e:	10 37       	cp.w	r7,r8
8000b610:	c0 31       	brne	8000b616 <_fflush_r+0x22>
8000b612:	6c 07       	ld.w	r7,r6[0x0]
8000b614:	c0 a8       	rjmp	8000b628 <_fflush_r+0x34>
8000b616:	4b a8       	lddpc	r8,8000b6fc <_fflush_r+0x108>
8000b618:	10 37       	cp.w	r7,r8
8000b61a:	c0 31       	brne	8000b620 <_fflush_r+0x2c>
8000b61c:	6c 17       	ld.w	r7,r6[0x4]
8000b61e:	c0 58       	rjmp	8000b628 <_fflush_r+0x34>
8000b620:	4b 88       	lddpc	r8,8000b700 <_fflush_r+0x10c>
8000b622:	10 37       	cp.w	r7,r8
8000b624:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000b628:	8e 6a       	ld.sh	r10,r7[0xc]
8000b62a:	14 98       	mov	r8,r10
8000b62c:	ed ba 00 03 	bld	r10,0x3
8000b630:	c4 20       	breq	8000b6b4 <_fflush_r+0xc0>
8000b632:	ab ba       	sbr	r10,0xb
8000b634:	ae 6a       	st.h	r7[0xc],r10
8000b636:	6e 18       	ld.w	r8,r7[0x4]
8000b638:	58 08       	cp.w	r8,0
8000b63a:	e0 89 00 06 	brgt	8000b646 <_fflush_r+0x52>
8000b63e:	6f 08       	ld.w	r8,r7[0x40]
8000b640:	58 08       	cp.w	r8,0
8000b642:	e0 8a 00 5a 	brle	8000b6f6 <_fflush_r+0x102>
8000b646:	6e b8       	ld.w	r8,r7[0x2c]
8000b648:	58 08       	cp.w	r8,0
8000b64a:	c5 60       	breq	8000b6f6 <_fflush_r+0x102>
8000b64c:	e2 1a 10 00 	andl	r10,0x1000,COH
8000b650:	c0 30       	breq	8000b656 <_fflush_r+0x62>
8000b652:	6f 55       	ld.w	r5,r7[0x54]
8000b654:	c0 f8       	rjmp	8000b672 <_fflush_r+0x7e>
8000b656:	30 19       	mov	r9,1
8000b658:	6e 8b       	ld.w	r11,r7[0x20]
8000b65a:	0c 9c       	mov	r12,r6
8000b65c:	5d 18       	icall	r8
8000b65e:	18 95       	mov	r5,r12
8000b660:	5b fc       	cp.w	r12,-1
8000b662:	c0 81       	brne	8000b672 <_fflush_r+0x7e>
8000b664:	6c 38       	ld.w	r8,r6[0xc]
8000b666:	59 d8       	cp.w	r8,29
8000b668:	c4 70       	breq	8000b6f6 <_fflush_r+0x102>
8000b66a:	8e 68       	ld.sh	r8,r7[0xc]
8000b66c:	a7 a8       	sbr	r8,0x6
8000b66e:	ae 68       	st.h	r7[0xc],r8
8000b670:	d8 22       	popm	r4-r7,pc
8000b672:	8e 68       	ld.sh	r8,r7[0xc]
8000b674:	ed b8 00 02 	bld	r8,0x2
8000b678:	c0 91       	brne	8000b68a <_fflush_r+0x96>
8000b67a:	6e 18       	ld.w	r8,r7[0x4]
8000b67c:	10 15       	sub	r5,r8
8000b67e:	6e d8       	ld.w	r8,r7[0x34]
8000b680:	58 08       	cp.w	r8,0
8000b682:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000b686:	eb d8 e1 15 	subne	r5,r5,r8
8000b68a:	6e b8       	ld.w	r8,r7[0x2c]
8000b68c:	0c 9c       	mov	r12,r6
8000b68e:	30 09       	mov	r9,0
8000b690:	0a 9a       	mov	r10,r5
8000b692:	6e 8b       	ld.w	r11,r7[0x20]
8000b694:	5d 18       	icall	r8
8000b696:	8e 68       	ld.sh	r8,r7[0xc]
8000b698:	0a 3c       	cp.w	r12,r5
8000b69a:	c2 61       	brne	8000b6e6 <_fflush_r+0xf2>
8000b69c:	ab d8       	cbr	r8,0xb
8000b69e:	30 0c       	mov	r12,0
8000b6a0:	6e 49       	ld.w	r9,r7[0x10]
8000b6a2:	ae 68       	st.h	r7[0xc],r8
8000b6a4:	8f 1c       	st.w	r7[0x4],r12
8000b6a6:	8f 09       	st.w	r7[0x0],r9
8000b6a8:	ed b8 00 0c 	bld	r8,0xc
8000b6ac:	c2 51       	brne	8000b6f6 <_fflush_r+0x102>
8000b6ae:	ef 45 00 54 	st.w	r7[84],r5
8000b6b2:	d8 22       	popm	r4-r7,pc
8000b6b4:	6e 45       	ld.w	r5,r7[0x10]
8000b6b6:	58 05       	cp.w	r5,0
8000b6b8:	c1 f0       	breq	8000b6f6 <_fflush_r+0x102>
8000b6ba:	6e 04       	ld.w	r4,r7[0x0]
8000b6bc:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000b6c0:	8f 05       	st.w	r7[0x0],r5
8000b6c2:	f9 b8 01 00 	movne	r8,0
8000b6c6:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000b6ca:	0a 14       	sub	r4,r5
8000b6cc:	8f 28       	st.w	r7[0x8],r8
8000b6ce:	c1 18       	rjmp	8000b6f0 <_fflush_r+0xfc>
8000b6d0:	08 99       	mov	r9,r4
8000b6d2:	0a 9a       	mov	r10,r5
8000b6d4:	6e a8       	ld.w	r8,r7[0x28]
8000b6d6:	6e 8b       	ld.w	r11,r7[0x20]
8000b6d8:	0c 9c       	mov	r12,r6
8000b6da:	5d 18       	icall	r8
8000b6dc:	18 14       	sub	r4,r12
8000b6de:	58 0c       	cp.w	r12,0
8000b6e0:	e0 89 00 07 	brgt	8000b6ee <_fflush_r+0xfa>
8000b6e4:	8e 68       	ld.sh	r8,r7[0xc]
8000b6e6:	a7 a8       	sbr	r8,0x6
8000b6e8:	3f fc       	mov	r12,-1
8000b6ea:	ae 68       	st.h	r7[0xc],r8
8000b6ec:	d8 22       	popm	r4-r7,pc
8000b6ee:	18 05       	add	r5,r12
8000b6f0:	58 04       	cp.w	r4,0
8000b6f2:	fe 99 ff ef 	brgt	8000b6d0 <_fflush_r+0xdc>
8000b6f6:	d8 2a       	popm	r4-r7,pc,r12=0
8000b6f8:	80 02       	ld.sh	r2,r0[0x0]
8000b6fa:	f9 20 80 02 	ld.sb	r0,r12[-32766]
8000b6fe:	f9 40 80 02 	st.w	r12[-32766],r0
8000b702:	f9 60 5e fc 	st.b	r12[24316],r0

8000b704 <__sfp_lock_acquire>:
8000b704:	5e fc       	retal	r12

8000b706 <__sfp_lock_release>:
8000b706:	5e fc       	retal	r12

8000b708 <_cleanup_r>:
8000b708:	d4 01       	pushm	lr
8000b70a:	fe cb f0 aa 	sub	r11,pc,-3926
8000b70e:	e0 a0 02 f5 	rcall	8000bcf8 <_fwalk>
8000b712:	d8 02       	popm	pc

8000b714 <__sfmoreglue>:
8000b714:	d4 21       	pushm	r4-r7,lr
8000b716:	16 95       	mov	r5,r11
8000b718:	f6 06 10 5c 	mul	r6,r11,92
8000b71c:	ec cb ff f4 	sub	r11,r6,-12
8000b720:	fe b0 e2 76 	rcall	80007c0c <_malloc_r>
8000b724:	18 97       	mov	r7,r12
8000b726:	c0 90       	breq	8000b738 <__sfmoreglue+0x24>
8000b728:	99 15       	st.w	r12[0x4],r5
8000b72a:	30 0b       	mov	r11,0
8000b72c:	2f 4c       	sub	r12,-12
8000b72e:	0c 9a       	mov	r10,r6
8000b730:	8f 2c       	st.w	r7[0x8],r12
8000b732:	8f 0b       	st.w	r7[0x0],r11
8000b734:	fe b0 e5 26 	rcall	80008180 <memset>
8000b738:	0e 9c       	mov	r12,r7
8000b73a:	d8 22       	popm	r4-r7,pc

8000b73c <__sfp>:
8000b73c:	d4 21       	pushm	r4-r7,lr
8000b73e:	49 b8       	lddpc	r8,8000b7a8 <__sfp+0x6c>
8000b740:	18 96       	mov	r6,r12
8000b742:	70 07       	ld.w	r7,r8[0x0]
8000b744:	6e 68       	ld.w	r8,r7[0x18]
8000b746:	58 08       	cp.w	r8,0
8000b748:	c0 31       	brne	8000b74e <__sfp+0x12>
8000b74a:	0e 9c       	mov	r12,r7
8000b74c:	c3 0c       	rcall	8000b7ac <__sinit>
8000b74e:	ee c7 ff 28 	sub	r7,r7,-216
8000b752:	30 05       	mov	r5,0
8000b754:	6e 2c       	ld.w	r12,r7[0x8]
8000b756:	6e 18       	ld.w	r8,r7[0x4]
8000b758:	c0 68       	rjmp	8000b764 <__sfp+0x28>
8000b75a:	98 69       	ld.sh	r9,r12[0xc]
8000b75c:	ea 09 19 00 	cp.h	r9,r5
8000b760:	c1 10       	breq	8000b782 <__sfp+0x46>
8000b762:	2a 4c       	sub	r12,-92
8000b764:	20 18       	sub	r8,1
8000b766:	cf a7       	brpl	8000b75a <__sfp+0x1e>
8000b768:	6e 08       	ld.w	r8,r7[0x0]
8000b76a:	58 08       	cp.w	r8,0
8000b76c:	c0 61       	brne	8000b778 <__sfp+0x3c>
8000b76e:	30 4b       	mov	r11,4
8000b770:	0c 9c       	mov	r12,r6
8000b772:	cd 1f       	rcall	8000b714 <__sfmoreglue>
8000b774:	8f 0c       	st.w	r7[0x0],r12
8000b776:	c0 30       	breq	8000b77c <__sfp+0x40>
8000b778:	6e 07       	ld.w	r7,r7[0x0]
8000b77a:	ce db       	rjmp	8000b754 <__sfp+0x18>
8000b77c:	30 c8       	mov	r8,12
8000b77e:	8d 38       	st.w	r6[0xc],r8
8000b780:	d8 22       	popm	r4-r7,pc
8000b782:	30 08       	mov	r8,0
8000b784:	f9 48 00 4c 	st.w	r12[76],r8
8000b788:	99 08       	st.w	r12[0x0],r8
8000b78a:	99 28       	st.w	r12[0x8],r8
8000b78c:	99 18       	st.w	r12[0x4],r8
8000b78e:	99 48       	st.w	r12[0x10],r8
8000b790:	99 58       	st.w	r12[0x14],r8
8000b792:	99 68       	st.w	r12[0x18],r8
8000b794:	99 d8       	st.w	r12[0x34],r8
8000b796:	99 e8       	st.w	r12[0x38],r8
8000b798:	f9 48 00 48 	st.w	r12[72],r8
8000b79c:	3f f8       	mov	r8,-1
8000b79e:	b8 78       	st.h	r12[0xe],r8
8000b7a0:	30 18       	mov	r8,1
8000b7a2:	b8 68       	st.h	r12[0xc],r8
8000b7a4:	d8 22       	popm	r4-r7,pc
8000b7a6:	d7 03       	nop
8000b7a8:	80 02       	ld.sh	r2,r0[0x0]
8000b7aa:	f9 84       	*unknown*

8000b7ac <__sinit>:
8000b7ac:	d4 21       	pushm	r4-r7,lr
8000b7ae:	18 96       	mov	r6,r12
8000b7b0:	78 67       	ld.w	r7,r12[0x18]
8000b7b2:	58 07       	cp.w	r7,0
8000b7b4:	c4 91       	brne	8000b846 <__sinit+0x9a>
8000b7b6:	fe c8 00 ae 	sub	r8,pc,174
8000b7ba:	30 15       	mov	r5,1
8000b7bc:	99 a8       	st.w	r12[0x28],r8
8000b7be:	f9 47 00 d8 	st.w	r12[216],r7
8000b7c2:	f9 47 00 dc 	st.w	r12[220],r7
8000b7c6:	f9 47 00 e0 	st.w	r12[224],r7
8000b7ca:	99 65       	st.w	r12[0x18],r5
8000b7cc:	cb 8f       	rcall	8000b73c <__sfp>
8000b7ce:	8d 0c       	st.w	r6[0x0],r12
8000b7d0:	0c 9c       	mov	r12,r6
8000b7d2:	cb 5f       	rcall	8000b73c <__sfp>
8000b7d4:	8d 1c       	st.w	r6[0x4],r12
8000b7d6:	0c 9c       	mov	r12,r6
8000b7d8:	cb 2f       	rcall	8000b73c <__sfp>
8000b7da:	6c 09       	ld.w	r9,r6[0x0]
8000b7dc:	30 48       	mov	r8,4
8000b7de:	93 07       	st.w	r9[0x0],r7
8000b7e0:	b2 68       	st.h	r9[0xc],r8
8000b7e2:	93 17       	st.w	r9[0x4],r7
8000b7e4:	93 27       	st.w	r9[0x8],r7
8000b7e6:	6c 18       	ld.w	r8,r6[0x4]
8000b7e8:	b2 77       	st.h	r9[0xe],r7
8000b7ea:	93 47       	st.w	r9[0x10],r7
8000b7ec:	93 57       	st.w	r9[0x14],r7
8000b7ee:	93 67       	st.w	r9[0x18],r7
8000b7f0:	93 89       	st.w	r9[0x20],r9
8000b7f2:	91 07       	st.w	r8[0x0],r7
8000b7f4:	91 17       	st.w	r8[0x4],r7
8000b7f6:	91 27       	st.w	r8[0x8],r7
8000b7f8:	fe ce f3 28 	sub	lr,pc,-3288
8000b7fc:	fe cb f3 58 	sub	r11,pc,-3240
8000b800:	93 9e       	st.w	r9[0x24],lr
8000b802:	93 ab       	st.w	r9[0x28],r11
8000b804:	fe ca f3 80 	sub	r10,pc,-3200
8000b808:	fe c4 f3 8c 	sub	r4,pc,-3188
8000b80c:	93 ba       	st.w	r9[0x2c],r10
8000b80e:	93 c4       	st.w	r9[0x30],r4
8000b810:	30 99       	mov	r9,9
8000b812:	b0 69       	st.h	r8[0xc],r9
8000b814:	b0 75       	st.h	r8[0xe],r5
8000b816:	91 c4       	st.w	r8[0x30],r4
8000b818:	91 47       	st.w	r8[0x10],r7
8000b81a:	91 57       	st.w	r8[0x14],r7
8000b81c:	91 67       	st.w	r8[0x18],r7
8000b81e:	91 88       	st.w	r8[0x20],r8
8000b820:	91 9e       	st.w	r8[0x24],lr
8000b822:	91 ab       	st.w	r8[0x28],r11
8000b824:	91 ba       	st.w	r8[0x2c],r10
8000b826:	8d 2c       	st.w	r6[0x8],r12
8000b828:	31 28       	mov	r8,18
8000b82a:	99 07       	st.w	r12[0x0],r7
8000b82c:	b8 68       	st.h	r12[0xc],r8
8000b82e:	99 17       	st.w	r12[0x4],r7
8000b830:	99 27       	st.w	r12[0x8],r7
8000b832:	30 28       	mov	r8,2
8000b834:	b8 78       	st.h	r12[0xe],r8
8000b836:	99 c4       	st.w	r12[0x30],r4
8000b838:	99 67       	st.w	r12[0x18],r7
8000b83a:	99 9e       	st.w	r12[0x24],lr
8000b83c:	99 ab       	st.w	r12[0x28],r11
8000b83e:	99 ba       	st.w	r12[0x2c],r10
8000b840:	99 47       	st.w	r12[0x10],r7
8000b842:	99 57       	st.w	r12[0x14],r7
8000b844:	99 8c       	st.w	r12[0x20],r12
8000b846:	d8 22       	popm	r4-r7,pc

8000b848 <_malloc_trim_r>:
8000b848:	d4 21       	pushm	r4-r7,lr
8000b84a:	16 95       	mov	r5,r11
8000b84c:	18 97       	mov	r7,r12
8000b84e:	fe b0 d3 53 	rcall	80005ef4 <__malloc_lock>
8000b852:	33 44       	mov	r4,52
8000b854:	68 28       	ld.w	r8,r4[0x8]
8000b856:	70 16       	ld.w	r6,r8[0x4]
8000b858:	e0 16 ff fc 	andl	r6,0xfffc
8000b85c:	ec c8 ff 91 	sub	r8,r6,-111
8000b860:	f0 05 01 05 	sub	r5,r8,r5
8000b864:	e0 15 ff 80 	andl	r5,0xff80
8000b868:	ea c5 00 80 	sub	r5,r5,128
8000b86c:	e0 45 00 7f 	cp.w	r5,127
8000b870:	e0 8a 00 25 	brle	8000b8ba <_malloc_trim_r+0x72>
8000b874:	30 0b       	mov	r11,0
8000b876:	0e 9c       	mov	r12,r7
8000b878:	fe b0 e5 ec 	rcall	80008450 <_sbrk_r>
8000b87c:	68 28       	ld.w	r8,r4[0x8]
8000b87e:	0c 08       	add	r8,r6
8000b880:	10 3c       	cp.w	r12,r8
8000b882:	c1 c1       	brne	8000b8ba <_malloc_trim_r+0x72>
8000b884:	ea 0b 11 00 	rsub	r11,r5,0
8000b888:	0e 9c       	mov	r12,r7
8000b88a:	fe b0 e5 e3 	rcall	80008450 <_sbrk_r>
8000b88e:	5b fc       	cp.w	r12,-1
8000b890:	c1 91       	brne	8000b8c2 <_malloc_trim_r+0x7a>
8000b892:	30 0b       	mov	r11,0
8000b894:	0e 9c       	mov	r12,r7
8000b896:	fe b0 e5 dd 	rcall	80008450 <_sbrk_r>
8000b89a:	68 28       	ld.w	r8,r4[0x8]
8000b89c:	f8 08 01 09 	sub	r9,r12,r8
8000b8a0:	58 f9       	cp.w	r9,15
8000b8a2:	e0 8a 00 0c 	brle	8000b8ba <_malloc_trim_r+0x72>
8000b8a6:	a1 a9       	sbr	r9,0x0
8000b8a8:	91 19       	st.w	r8[0x4],r9
8000b8aa:	e0 68 04 40 	mov	r8,1088
8000b8ae:	70 09       	ld.w	r9,r8[0x0]
8000b8b0:	e0 68 07 e0 	mov	r8,2016
8000b8b4:	f8 09 01 09 	sub	r9,r12,r9
8000b8b8:	91 09       	st.w	r8[0x0],r9
8000b8ba:	0e 9c       	mov	r12,r7
8000b8bc:	fe b0 d3 22 	rcall	80005f00 <__malloc_unlock>
8000b8c0:	d8 2a       	popm	r4-r7,pc,r12=0
8000b8c2:	68 28       	ld.w	r8,r4[0x8]
8000b8c4:	0a 16       	sub	r6,r5
8000b8c6:	a1 a6       	sbr	r6,0x0
8000b8c8:	91 16       	st.w	r8[0x4],r6
8000b8ca:	e0 68 07 e0 	mov	r8,2016
8000b8ce:	70 09       	ld.w	r9,r8[0x0]
8000b8d0:	0a 19       	sub	r9,r5
8000b8d2:	0e 9c       	mov	r12,r7
8000b8d4:	91 09       	st.w	r8[0x0],r9
8000b8d6:	fe b0 d3 15 	rcall	80005f00 <__malloc_unlock>
8000b8da:	da 2a       	popm	r4-r7,pc,r12=1

8000b8dc <_free_r>:
8000b8dc:	d4 21       	pushm	r4-r7,lr
8000b8de:	16 96       	mov	r6,r11
8000b8e0:	18 97       	mov	r7,r12
8000b8e2:	58 0b       	cp.w	r11,0
8000b8e4:	e0 80 00 be 	breq	8000ba60 <_free_r+0x184>
8000b8e8:	fe b0 d3 06 	rcall	80005ef4 <__malloc_lock>
8000b8ec:	20 86       	sub	r6,8
8000b8ee:	33 4a       	mov	r10,52
8000b8f0:	6c 18       	ld.w	r8,r6[0x4]
8000b8f2:	74 2e       	ld.w	lr,r10[0x8]
8000b8f4:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000b8f8:	a1 c8       	cbr	r8,0x0
8000b8fa:	ec 08 00 09 	add	r9,r6,r8
8000b8fe:	72 1b       	ld.w	r11,r9[0x4]
8000b900:	e0 1b ff fc 	andl	r11,0xfffc
8000b904:	1c 39       	cp.w	r9,lr
8000b906:	c1 e1       	brne	8000b942 <_free_r+0x66>
8000b908:	f6 08 00 08 	add	r8,r11,r8
8000b90c:	58 0c       	cp.w	r12,0
8000b90e:	c0 81       	brne	8000b91e <_free_r+0x42>
8000b910:	6c 09       	ld.w	r9,r6[0x0]
8000b912:	12 16       	sub	r6,r9
8000b914:	12 08       	add	r8,r9
8000b916:	6c 3b       	ld.w	r11,r6[0xc]
8000b918:	6c 29       	ld.w	r9,r6[0x8]
8000b91a:	97 29       	st.w	r11[0x8],r9
8000b91c:	93 3b       	st.w	r9[0xc],r11
8000b91e:	10 99       	mov	r9,r8
8000b920:	95 26       	st.w	r10[0x8],r6
8000b922:	a1 a9       	sbr	r9,0x0
8000b924:	8d 19       	st.w	r6[0x4],r9
8000b926:	e0 69 04 3c 	mov	r9,1084
8000b92a:	72 09       	ld.w	r9,r9[0x0]
8000b92c:	12 38       	cp.w	r8,r9
8000b92e:	c0 63       	brcs	8000b93a <_free_r+0x5e>
8000b930:	e0 68 07 dc 	mov	r8,2012
8000b934:	0e 9c       	mov	r12,r7
8000b936:	70 0b       	ld.w	r11,r8[0x0]
8000b938:	c8 8f       	rcall	8000b848 <_malloc_trim_r>
8000b93a:	0e 9c       	mov	r12,r7
8000b93c:	fe b0 d2 e2 	rcall	80005f00 <__malloc_unlock>
8000b940:	d8 22       	popm	r4-r7,pc
8000b942:	93 1b       	st.w	r9[0x4],r11
8000b944:	58 0c       	cp.w	r12,0
8000b946:	c0 30       	breq	8000b94c <_free_r+0x70>
8000b948:	30 0c       	mov	r12,0
8000b94a:	c1 08       	rjmp	8000b96a <_free_r+0x8e>
8000b94c:	6c 0e       	ld.w	lr,r6[0x0]
8000b94e:	f4 c5 ff f8 	sub	r5,r10,-8
8000b952:	1c 16       	sub	r6,lr
8000b954:	1c 08       	add	r8,lr
8000b956:	6c 2e       	ld.w	lr,r6[0x8]
8000b958:	0a 3e       	cp.w	lr,r5
8000b95a:	f9 bc 00 01 	moveq	r12,1
8000b95e:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000b962:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000b966:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000b96a:	f2 0b 00 0e 	add	lr,r9,r11
8000b96e:	7c 1e       	ld.w	lr,lr[0x4]
8000b970:	ed be 00 00 	bld	lr,0x0
8000b974:	c1 30       	breq	8000b99a <_free_r+0xbe>
8000b976:	16 08       	add	r8,r11
8000b978:	58 0c       	cp.w	r12,0
8000b97a:	c0 c1       	brne	8000b992 <_free_r+0xb6>
8000b97c:	33 4e       	mov	lr,52
8000b97e:	72 2b       	ld.w	r11,r9[0x8]
8000b980:	2f 8e       	sub	lr,-8
8000b982:	1c 3b       	cp.w	r11,lr
8000b984:	c0 71       	brne	8000b992 <_free_r+0xb6>
8000b986:	97 36       	st.w	r11[0xc],r6
8000b988:	97 26       	st.w	r11[0x8],r6
8000b98a:	8d 2b       	st.w	r6[0x8],r11
8000b98c:	8d 3b       	st.w	r6[0xc],r11
8000b98e:	30 1c       	mov	r12,1
8000b990:	c0 58       	rjmp	8000b99a <_free_r+0xbe>
8000b992:	72 2b       	ld.w	r11,r9[0x8]
8000b994:	72 39       	ld.w	r9,r9[0xc]
8000b996:	93 2b       	st.w	r9[0x8],r11
8000b998:	97 39       	st.w	r11[0xc],r9
8000b99a:	10 99       	mov	r9,r8
8000b99c:	ec 08 09 08 	st.w	r6[r8],r8
8000b9a0:	a1 a9       	sbr	r9,0x0
8000b9a2:	8d 19       	st.w	r6[0x4],r9
8000b9a4:	58 0c       	cp.w	r12,0
8000b9a6:	c5 a1       	brne	8000ba5a <_free_r+0x17e>
8000b9a8:	e0 48 01 ff 	cp.w	r8,511
8000b9ac:	e0 8b 00 13 	brhi	8000b9d2 <_free_r+0xf6>
8000b9b0:	a3 98       	lsr	r8,0x3
8000b9b2:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000b9b6:	72 2b       	ld.w	r11,r9[0x8]
8000b9b8:	8d 39       	st.w	r6[0xc],r9
8000b9ba:	8d 2b       	st.w	r6[0x8],r11
8000b9bc:	97 36       	st.w	r11[0xc],r6
8000b9be:	93 26       	st.w	r9[0x8],r6
8000b9c0:	a3 48       	asr	r8,0x2
8000b9c2:	74 19       	ld.w	r9,r10[0x4]
8000b9c4:	30 1b       	mov	r11,1
8000b9c6:	f6 08 09 48 	lsl	r8,r11,r8
8000b9ca:	f3 e8 10 08 	or	r8,r9,r8
8000b9ce:	95 18       	st.w	r10[0x4],r8
8000b9d0:	c4 58       	rjmp	8000ba5a <_free_r+0x17e>
8000b9d2:	f0 0b 16 09 	lsr	r11,r8,0x9
8000b9d6:	58 4b       	cp.w	r11,4
8000b9d8:	e0 8b 00 06 	brhi	8000b9e4 <_free_r+0x108>
8000b9dc:	f0 0b 16 06 	lsr	r11,r8,0x6
8000b9e0:	2c 8b       	sub	r11,-56
8000b9e2:	c2 08       	rjmp	8000ba22 <_free_r+0x146>
8000b9e4:	59 4b       	cp.w	r11,20
8000b9e6:	e0 8b 00 04 	brhi	8000b9ee <_free_r+0x112>
8000b9ea:	2a 5b       	sub	r11,-91
8000b9ec:	c1 b8       	rjmp	8000ba22 <_free_r+0x146>
8000b9ee:	e0 4b 00 54 	cp.w	r11,84
8000b9f2:	e0 8b 00 06 	brhi	8000b9fe <_free_r+0x122>
8000b9f6:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000b9fa:	29 2b       	sub	r11,-110
8000b9fc:	c1 38       	rjmp	8000ba22 <_free_r+0x146>
8000b9fe:	e0 4b 01 54 	cp.w	r11,340
8000ba02:	e0 8b 00 06 	brhi	8000ba0e <_free_r+0x132>
8000ba06:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000ba0a:	28 9b       	sub	r11,-119
8000ba0c:	c0 b8       	rjmp	8000ba22 <_free_r+0x146>
8000ba0e:	e0 4b 05 54 	cp.w	r11,1364
8000ba12:	e0 88 00 05 	brls	8000ba1c <_free_r+0x140>
8000ba16:	37 eb       	mov	r11,126
8000ba18:	c0 58       	rjmp	8000ba22 <_free_r+0x146>
8000ba1a:	d7 03       	nop
8000ba1c:	f0 0b 16 12 	lsr	r11,r8,0x12
8000ba20:	28 4b       	sub	r11,-124
8000ba22:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000ba26:	78 29       	ld.w	r9,r12[0x8]
8000ba28:	18 39       	cp.w	r9,r12
8000ba2a:	c0 e1       	brne	8000ba46 <_free_r+0x16a>
8000ba2c:	74 18       	ld.w	r8,r10[0x4]
8000ba2e:	a3 4b       	asr	r11,0x2
8000ba30:	30 1c       	mov	r12,1
8000ba32:	f8 0b 09 4b 	lsl	r11,r12,r11
8000ba36:	f1 eb 10 0b 	or	r11,r8,r11
8000ba3a:	12 98       	mov	r8,r9
8000ba3c:	95 1b       	st.w	r10[0x4],r11
8000ba3e:	c0 a8       	rjmp	8000ba52 <_free_r+0x176>
8000ba40:	72 29       	ld.w	r9,r9[0x8]
8000ba42:	18 39       	cp.w	r9,r12
8000ba44:	c0 60       	breq	8000ba50 <_free_r+0x174>
8000ba46:	72 1a       	ld.w	r10,r9[0x4]
8000ba48:	e0 1a ff fc 	andl	r10,0xfffc
8000ba4c:	14 38       	cp.w	r8,r10
8000ba4e:	cf 93       	brcs	8000ba40 <_free_r+0x164>
8000ba50:	72 38       	ld.w	r8,r9[0xc]
8000ba52:	8d 38       	st.w	r6[0xc],r8
8000ba54:	8d 29       	st.w	r6[0x8],r9
8000ba56:	93 36       	st.w	r9[0xc],r6
8000ba58:	91 26       	st.w	r8[0x8],r6
8000ba5a:	0e 9c       	mov	r12,r7
8000ba5c:	fe b0 d2 52 	rcall	80005f00 <__malloc_unlock>
8000ba60:	d8 22       	popm	r4-r7,pc
8000ba62:	d7 03       	nop

8000ba64 <__sfvwrite_r>:
8000ba64:	d4 31       	pushm	r0-r7,lr
8000ba66:	20 3d       	sub	sp,12
8000ba68:	14 94       	mov	r4,r10
8000ba6a:	18 95       	mov	r5,r12
8000ba6c:	16 97       	mov	r7,r11
8000ba6e:	74 28       	ld.w	r8,r10[0x8]
8000ba70:	58 08       	cp.w	r8,0
8000ba72:	e0 80 01 40 	breq	8000bcf2 <__sfvwrite_r+0x28e>
8000ba76:	96 68       	ld.sh	r8,r11[0xc]
8000ba78:	ed b8 00 03 	bld	r8,0x3
8000ba7c:	c0 41       	brne	8000ba84 <__sfvwrite_r+0x20>
8000ba7e:	76 48       	ld.w	r8,r11[0x10]
8000ba80:	58 08       	cp.w	r8,0
8000ba82:	c0 c1       	brne	8000ba9a <__sfvwrite_r+0x36>
8000ba84:	0e 9b       	mov	r11,r7
8000ba86:	0a 9c       	mov	r12,r5
8000ba88:	fe b0 f6 c0 	rcall	8000a808 <__swsetup_r>
8000ba8c:	c0 70       	breq	8000ba9a <__sfvwrite_r+0x36>
8000ba8e:	8e 68       	ld.sh	r8,r7[0xc]
8000ba90:	a7 a8       	sbr	r8,0x6
8000ba92:	ae 68       	st.h	r7[0xc],r8
8000ba94:	30 98       	mov	r8,9
8000ba96:	8b 38       	st.w	r5[0xc],r8
8000ba98:	c2 b9       	rjmp	8000bcee <__sfvwrite_r+0x28a>
8000ba9a:	8e 63       	ld.sh	r3,r7[0xc]
8000ba9c:	68 00       	ld.w	r0,r4[0x0]
8000ba9e:	06 96       	mov	r6,r3
8000baa0:	e2 16 00 02 	andl	r6,0x2,COH
8000baa4:	c2 10       	breq	8000bae6 <__sfvwrite_r+0x82>
8000baa6:	30 03       	mov	r3,0
8000baa8:	e0 62 04 00 	mov	r2,1024
8000baac:	06 96       	mov	r6,r3
8000baae:	c0 48       	rjmp	8000bab6 <__sfvwrite_r+0x52>
8000bab0:	60 03       	ld.w	r3,r0[0x0]
8000bab2:	60 16       	ld.w	r6,r0[0x4]
8000bab4:	2f 80       	sub	r0,-8
8000bab6:	58 06       	cp.w	r6,0
8000bab8:	cf c0       	breq	8000bab0 <__sfvwrite_r+0x4c>
8000baba:	e0 46 04 00 	cp.w	r6,1024
8000babe:	ec 09 17 80 	movls	r9,r6
8000bac2:	e4 09 17 b0 	movhi	r9,r2
8000bac6:	06 9a       	mov	r10,r3
8000bac8:	6e a8       	ld.w	r8,r7[0x28]
8000baca:	6e 8b       	ld.w	r11,r7[0x20]
8000bacc:	0a 9c       	mov	r12,r5
8000bace:	5d 18       	icall	r8
8000bad0:	18 16       	sub	r6,r12
8000bad2:	58 0c       	cp.w	r12,0
8000bad4:	e0 8a 01 0a 	brle	8000bce8 <__sfvwrite_r+0x284>
8000bad8:	68 28       	ld.w	r8,r4[0x8]
8000bada:	18 18       	sub	r8,r12
8000badc:	89 28       	st.w	r4[0x8],r8
8000bade:	e0 80 01 0a 	breq	8000bcf2 <__sfvwrite_r+0x28e>
8000bae2:	18 03       	add	r3,r12
8000bae4:	ce 9b       	rjmp	8000bab6 <__sfvwrite_r+0x52>
8000bae6:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000baea:	c0 70       	breq	8000baf8 <__sfvwrite_r+0x94>
8000baec:	50 06       	stdsp	sp[0x0],r6
8000baee:	0c 93       	mov	r3,r6
8000baf0:	0c 91       	mov	r1,r6
8000baf2:	50 15       	stdsp	sp[0x4],r5
8000baf4:	08 92       	mov	r2,r4
8000baf6:	c9 c8       	rjmp	8000bc2e <__sfvwrite_r+0x1ca>
8000baf8:	06 96       	mov	r6,r3
8000bafa:	08 91       	mov	r1,r4
8000bafc:	c0 48       	rjmp	8000bb04 <__sfvwrite_r+0xa0>
8000bafe:	60 03       	ld.w	r3,r0[0x0]
8000bb00:	60 16       	ld.w	r6,r0[0x4]
8000bb02:	2f 80       	sub	r0,-8
8000bb04:	58 06       	cp.w	r6,0
8000bb06:	cf c0       	breq	8000bafe <__sfvwrite_r+0x9a>
8000bb08:	8e 68       	ld.sh	r8,r7[0xc]
8000bb0a:	6e 24       	ld.w	r4,r7[0x8]
8000bb0c:	10 99       	mov	r9,r8
8000bb0e:	e2 19 02 00 	andl	r9,0x200,COH
8000bb12:	c5 50       	breq	8000bbbc <__sfvwrite_r+0x158>
8000bb14:	08 36       	cp.w	r6,r4
8000bb16:	c4 43       	brcs	8000bb9e <__sfvwrite_r+0x13a>
8000bb18:	10 99       	mov	r9,r8
8000bb1a:	e2 19 04 80 	andl	r9,0x480,COH
8000bb1e:	c4 00       	breq	8000bb9e <__sfvwrite_r+0x13a>
8000bb20:	6e 4b       	ld.w	r11,r7[0x10]
8000bb22:	6e 09       	ld.w	r9,r7[0x0]
8000bb24:	16 19       	sub	r9,r11
8000bb26:	50 09       	stdsp	sp[0x0],r9
8000bb28:	6e 59       	ld.w	r9,r7[0x14]
8000bb2a:	10 9c       	mov	r12,r8
8000bb2c:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000bb30:	30 28       	mov	r8,2
8000bb32:	f4 08 0c 08 	divs	r8,r10,r8
8000bb36:	fa e9 00 04 	st.d	sp[4],r8
8000bb3a:	10 94       	mov	r4,r8
8000bb3c:	40 09       	lddsp	r9,sp[0x0]
8000bb3e:	e2 1c 04 00 	andl	r12,0x400,COH
8000bb42:	2f f9       	sub	r9,-1
8000bb44:	0c 09       	add	r9,r6
8000bb46:	12 38       	cp.w	r8,r9
8000bb48:	f2 04 17 30 	movlo	r4,r9
8000bb4c:	58 0c       	cp.w	r12,0
8000bb4e:	c1 10       	breq	8000bb70 <__sfvwrite_r+0x10c>
8000bb50:	08 9b       	mov	r11,r4
8000bb52:	0a 9c       	mov	r12,r5
8000bb54:	fe b0 e0 5c 	rcall	80007c0c <_malloc_r>
8000bb58:	18 92       	mov	r2,r12
8000bb5a:	c1 40       	breq	8000bb82 <__sfvwrite_r+0x11e>
8000bb5c:	40 0a       	lddsp	r10,sp[0x0]
8000bb5e:	6e 4b       	ld.w	r11,r7[0x10]
8000bb60:	fe b0 e2 6c 	rcall	80008038 <memcpy>
8000bb64:	8e 68       	ld.sh	r8,r7[0xc]
8000bb66:	e0 18 fb 7f 	andl	r8,0xfb7f
8000bb6a:	a7 b8       	sbr	r8,0x7
8000bb6c:	ae 68       	st.h	r7[0xc],r8
8000bb6e:	c0 d8       	rjmp	8000bb88 <__sfvwrite_r+0x124>
8000bb70:	08 9a       	mov	r10,r4
8000bb72:	0a 9c       	mov	r12,r5
8000bb74:	fe b0 e3 0e 	rcall	80008190 <_realloc_r>
8000bb78:	18 92       	mov	r2,r12
8000bb7a:	c0 71       	brne	8000bb88 <__sfvwrite_r+0x124>
8000bb7c:	6e 4b       	ld.w	r11,r7[0x10]
8000bb7e:	0a 9c       	mov	r12,r5
8000bb80:	ca ee       	rcall	8000b8dc <_free_r>
8000bb82:	30 c8       	mov	r8,12
8000bb84:	8b 38       	st.w	r5[0xc],r8
8000bb86:	cb 18       	rjmp	8000bce8 <__sfvwrite_r+0x284>
8000bb88:	40 0a       	lddsp	r10,sp[0x0]
8000bb8a:	40 09       	lddsp	r9,sp[0x0]
8000bb8c:	e8 0a 01 0a 	sub	r10,r4,r10
8000bb90:	e4 09 00 08 	add	r8,r2,r9
8000bb94:	8f 54       	st.w	r7[0x14],r4
8000bb96:	8f 2a       	st.w	r7[0x8],r10
8000bb98:	8f 08       	st.w	r7[0x0],r8
8000bb9a:	8f 42       	st.w	r7[0x10],r2
8000bb9c:	0c 94       	mov	r4,r6
8000bb9e:	08 36       	cp.w	r6,r4
8000bba0:	ec 04 17 30 	movlo	r4,r6
8000bba4:	06 9b       	mov	r11,r3
8000bba6:	08 9a       	mov	r10,r4
8000bba8:	6e 0c       	ld.w	r12,r7[0x0]
8000bbaa:	c3 ad       	rcall	8000be1e <memmove>
8000bbac:	6e 08       	ld.w	r8,r7[0x0]
8000bbae:	08 08       	add	r8,r4
8000bbb0:	8f 08       	st.w	r7[0x0],r8
8000bbb2:	6e 28       	ld.w	r8,r7[0x8]
8000bbb4:	08 18       	sub	r8,r4
8000bbb6:	0c 94       	mov	r4,r6
8000bbb8:	8f 28       	st.w	r7[0x8],r8
8000bbba:	c2 e8       	rjmp	8000bc16 <__sfvwrite_r+0x1b2>
8000bbbc:	08 36       	cp.w	r6,r4
8000bbbe:	5f ba       	srhi	r10
8000bbc0:	6e 0c       	ld.w	r12,r7[0x0]
8000bbc2:	6e 48       	ld.w	r8,r7[0x10]
8000bbc4:	10 3c       	cp.w	r12,r8
8000bbc6:	5f b8       	srhi	r8
8000bbc8:	f5 e8 00 08 	and	r8,r10,r8
8000bbcc:	f2 08 18 00 	cp.b	r8,r9
8000bbd0:	c0 d0       	breq	8000bbea <__sfvwrite_r+0x186>
8000bbd2:	06 9b       	mov	r11,r3
8000bbd4:	08 9a       	mov	r10,r4
8000bbd6:	c2 4d       	rcall	8000be1e <memmove>
8000bbd8:	6e 08       	ld.w	r8,r7[0x0]
8000bbda:	08 08       	add	r8,r4
8000bbdc:	0e 9b       	mov	r11,r7
8000bbde:	8f 08       	st.w	r7[0x0],r8
8000bbe0:	0a 9c       	mov	r12,r5
8000bbe2:	fe b0 fd 09 	rcall	8000b5f4 <_fflush_r>
8000bbe6:	c1 80       	breq	8000bc16 <__sfvwrite_r+0x1b2>
8000bbe8:	c8 08       	rjmp	8000bce8 <__sfvwrite_r+0x284>
8000bbea:	6e 59       	ld.w	r9,r7[0x14]
8000bbec:	12 36       	cp.w	r6,r9
8000bbee:	c0 a3       	brcs	8000bc02 <__sfvwrite_r+0x19e>
8000bbf0:	6e a8       	ld.w	r8,r7[0x28]
8000bbf2:	06 9a       	mov	r10,r3
8000bbf4:	6e 8b       	ld.w	r11,r7[0x20]
8000bbf6:	0a 9c       	mov	r12,r5
8000bbf8:	5d 18       	icall	r8
8000bbfa:	18 94       	mov	r4,r12
8000bbfc:	e0 89 00 0d 	brgt	8000bc16 <__sfvwrite_r+0x1b2>
8000bc00:	c7 48       	rjmp	8000bce8 <__sfvwrite_r+0x284>
8000bc02:	0c 9a       	mov	r10,r6
8000bc04:	06 9b       	mov	r11,r3
8000bc06:	c0 cd       	rcall	8000be1e <memmove>
8000bc08:	6e 08       	ld.w	r8,r7[0x0]
8000bc0a:	0c 08       	add	r8,r6
8000bc0c:	0c 94       	mov	r4,r6
8000bc0e:	8f 08       	st.w	r7[0x0],r8
8000bc10:	6e 28       	ld.w	r8,r7[0x8]
8000bc12:	0c 18       	sub	r8,r6
8000bc14:	8f 28       	st.w	r7[0x8],r8
8000bc16:	62 28       	ld.w	r8,r1[0x8]
8000bc18:	08 18       	sub	r8,r4
8000bc1a:	83 28       	st.w	r1[0x8],r8
8000bc1c:	c6 b0       	breq	8000bcf2 <__sfvwrite_r+0x28e>
8000bc1e:	08 16       	sub	r6,r4
8000bc20:	08 03       	add	r3,r4
8000bc22:	c7 1b       	rjmp	8000bb04 <__sfvwrite_r+0xa0>
8000bc24:	60 03       	ld.w	r3,r0[0x0]
8000bc26:	60 11       	ld.w	r1,r0[0x4]
8000bc28:	30 08       	mov	r8,0
8000bc2a:	2f 80       	sub	r0,-8
8000bc2c:	50 08       	stdsp	sp[0x0],r8
8000bc2e:	58 01       	cp.w	r1,0
8000bc30:	cf a0       	breq	8000bc24 <__sfvwrite_r+0x1c0>
8000bc32:	40 0a       	lddsp	r10,sp[0x0]
8000bc34:	58 0a       	cp.w	r10,0
8000bc36:	c1 41       	brne	8000bc5e <__sfvwrite_r+0x1fa>
8000bc38:	e2 c6 ff ff 	sub	r6,r1,-1
8000bc3c:	02 9a       	mov	r10,r1
8000bc3e:	30 ab       	mov	r11,10
8000bc40:	06 9c       	mov	r12,r3
8000bc42:	ce 3c       	rcall	8000be08 <memchr>
8000bc44:	f8 c8 ff ff 	sub	r8,r12,-1
8000bc48:	58 0c       	cp.w	r12,0
8000bc4a:	f1 d3 e1 16 	subne	r6,r8,r3
8000bc4e:	f9 b9 01 01 	movne	r9,1
8000bc52:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000bc56:	f9 b8 00 01 	moveq	r8,1
8000bc5a:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000bc5e:	02 36       	cp.w	r6,r1
8000bc60:	ec 04 17 80 	movls	r4,r6
8000bc64:	e2 04 17 b0 	movhi	r4,r1
8000bc68:	6e 59       	ld.w	r9,r7[0x14]
8000bc6a:	6e 25       	ld.w	r5,r7[0x8]
8000bc6c:	f2 05 00 05 	add	r5,r9,r5
8000bc70:	0a 34       	cp.w	r4,r5
8000bc72:	5f 9a       	srgt	r10
8000bc74:	6e 0c       	ld.w	r12,r7[0x0]
8000bc76:	6e 48       	ld.w	r8,r7[0x10]
8000bc78:	10 3c       	cp.w	r12,r8
8000bc7a:	5f b8       	srhi	r8
8000bc7c:	f5 e8 00 08 	and	r8,r10,r8
8000bc80:	30 0a       	mov	r10,0
8000bc82:	f4 08 18 00 	cp.b	r8,r10
8000bc86:	c0 d0       	breq	8000bca0 <__sfvwrite_r+0x23c>
8000bc88:	06 9b       	mov	r11,r3
8000bc8a:	0a 9a       	mov	r10,r5
8000bc8c:	cc 9c       	rcall	8000be1e <memmove>
8000bc8e:	6e 08       	ld.w	r8,r7[0x0]
8000bc90:	0a 08       	add	r8,r5
8000bc92:	0e 9b       	mov	r11,r7
8000bc94:	8f 08       	st.w	r7[0x0],r8
8000bc96:	40 1c       	lddsp	r12,sp[0x4]
8000bc98:	fe b0 fc ae 	rcall	8000b5f4 <_fflush_r>
8000bc9c:	c1 70       	breq	8000bcca <__sfvwrite_r+0x266>
8000bc9e:	c2 58       	rjmp	8000bce8 <__sfvwrite_r+0x284>
8000bca0:	12 34       	cp.w	r4,r9
8000bca2:	c0 a5       	brlt	8000bcb6 <__sfvwrite_r+0x252>
8000bca4:	6e a8       	ld.w	r8,r7[0x28]
8000bca6:	06 9a       	mov	r10,r3
8000bca8:	6e 8b       	ld.w	r11,r7[0x20]
8000bcaa:	40 1c       	lddsp	r12,sp[0x4]
8000bcac:	5d 18       	icall	r8
8000bcae:	18 95       	mov	r5,r12
8000bcb0:	e0 89 00 0d 	brgt	8000bcca <__sfvwrite_r+0x266>
8000bcb4:	c1 a8       	rjmp	8000bce8 <__sfvwrite_r+0x284>
8000bcb6:	08 9a       	mov	r10,r4
8000bcb8:	06 9b       	mov	r11,r3
8000bcba:	cb 2c       	rcall	8000be1e <memmove>
8000bcbc:	6e 08       	ld.w	r8,r7[0x0]
8000bcbe:	08 08       	add	r8,r4
8000bcc0:	08 95       	mov	r5,r4
8000bcc2:	8f 08       	st.w	r7[0x0],r8
8000bcc4:	6e 28       	ld.w	r8,r7[0x8]
8000bcc6:	08 18       	sub	r8,r4
8000bcc8:	8f 28       	st.w	r7[0x8],r8
8000bcca:	0a 16       	sub	r6,r5
8000bccc:	c0 71       	brne	8000bcda <__sfvwrite_r+0x276>
8000bcce:	0e 9b       	mov	r11,r7
8000bcd0:	40 1c       	lddsp	r12,sp[0x4]
8000bcd2:	fe b0 fc 91 	rcall	8000b5f4 <_fflush_r>
8000bcd6:	c0 91       	brne	8000bce8 <__sfvwrite_r+0x284>
8000bcd8:	50 06       	stdsp	sp[0x0],r6
8000bcda:	64 28       	ld.w	r8,r2[0x8]
8000bcdc:	0a 18       	sub	r8,r5
8000bcde:	85 28       	st.w	r2[0x8],r8
8000bce0:	c0 90       	breq	8000bcf2 <__sfvwrite_r+0x28e>
8000bce2:	0a 11       	sub	r1,r5
8000bce4:	0a 03       	add	r3,r5
8000bce6:	ca 4b       	rjmp	8000bc2e <__sfvwrite_r+0x1ca>
8000bce8:	8e 68       	ld.sh	r8,r7[0xc]
8000bcea:	a7 a8       	sbr	r8,0x6
8000bcec:	ae 68       	st.h	r7[0xc],r8
8000bcee:	3f fc       	mov	r12,-1
8000bcf0:	c0 28       	rjmp	8000bcf4 <__sfvwrite_r+0x290>
8000bcf2:	30 0c       	mov	r12,0
8000bcf4:	2f dd       	sub	sp,-12
8000bcf6:	d8 32       	popm	r0-r7,pc

8000bcf8 <_fwalk>:
8000bcf8:	d4 31       	pushm	r0-r7,lr
8000bcfa:	30 05       	mov	r5,0
8000bcfc:	16 91       	mov	r1,r11
8000bcfe:	f8 c7 ff 28 	sub	r7,r12,-216
8000bd02:	0a 92       	mov	r2,r5
8000bd04:	fe b0 fd 00 	rcall	8000b704 <__sfp_lock_acquire>
8000bd08:	3f f3       	mov	r3,-1
8000bd0a:	c1 68       	rjmp	8000bd36 <_fwalk+0x3e>
8000bd0c:	6e 26       	ld.w	r6,r7[0x8]
8000bd0e:	6e 14       	ld.w	r4,r7[0x4]
8000bd10:	2f 46       	sub	r6,-12
8000bd12:	c0 c8       	rjmp	8000bd2a <_fwalk+0x32>
8000bd14:	8c 08       	ld.sh	r8,r6[0x0]
8000bd16:	e4 08 19 00 	cp.h	r8,r2
8000bd1a:	c0 70       	breq	8000bd28 <_fwalk+0x30>
8000bd1c:	8c 18       	ld.sh	r8,r6[0x2]
8000bd1e:	e6 08 19 00 	cp.h	r8,r3
8000bd22:	c0 30       	breq	8000bd28 <_fwalk+0x30>
8000bd24:	5d 11       	icall	r1
8000bd26:	18 45       	or	r5,r12
8000bd28:	2a 46       	sub	r6,-92
8000bd2a:	20 14       	sub	r4,1
8000bd2c:	ec cc 00 0c 	sub	r12,r6,12
8000bd30:	58 04       	cp.w	r4,0
8000bd32:	cf 14       	brge	8000bd14 <_fwalk+0x1c>
8000bd34:	6e 07       	ld.w	r7,r7[0x0]
8000bd36:	58 07       	cp.w	r7,0
8000bd38:	ce a1       	brne	8000bd0c <_fwalk+0x14>
8000bd3a:	fe b0 fc e6 	rcall	8000b706 <__sfp_lock_release>
8000bd3e:	0a 9c       	mov	r12,r5
8000bd40:	d8 32       	popm	r0-r7,pc
8000bd42:	d7 03       	nop

8000bd44 <_localeconv_r>:
8000bd44:	48 1c       	lddpc	r12,8000bd48 <_localeconv_r+0x4>
8000bd46:	5e fc       	retal	r12
8000bd48:	80 02       	ld.sh	r2,r0[0x0]
8000bd4a:	f9 88       	*unknown*

8000bd4c <__smakebuf_r>:
8000bd4c:	d4 21       	pushm	r4-r7,lr
8000bd4e:	20 fd       	sub	sp,60
8000bd50:	96 68       	ld.sh	r8,r11[0xc]
8000bd52:	16 97       	mov	r7,r11
8000bd54:	18 96       	mov	r6,r12
8000bd56:	e2 18 00 02 	andl	r8,0x2,COH
8000bd5a:	c3 d1       	brne	8000bdd4 <__smakebuf_r+0x88>
8000bd5c:	96 7b       	ld.sh	r11,r11[0xe]
8000bd5e:	f0 0b 19 00 	cp.h	r11,r8
8000bd62:	c0 55       	brlt	8000bd6c <__smakebuf_r+0x20>
8000bd64:	1a 9a       	mov	r10,sp
8000bd66:	e0 a0 04 85 	rcall	8000c670 <_fstat_r>
8000bd6a:	c0 f4       	brge	8000bd88 <__smakebuf_r+0x3c>
8000bd6c:	8e 65       	ld.sh	r5,r7[0xc]
8000bd6e:	0a 98       	mov	r8,r5
8000bd70:	ab b8       	sbr	r8,0xb
8000bd72:	e2 15 00 80 	andl	r5,0x80,COH
8000bd76:	ae 68       	st.h	r7[0xc],r8
8000bd78:	30 04       	mov	r4,0
8000bd7a:	e0 68 04 00 	mov	r8,1024
8000bd7e:	f9 b5 01 40 	movne	r5,64
8000bd82:	f0 05 17 00 	moveq	r5,r8
8000bd86:	c1 c8       	rjmp	8000bdbe <__smakebuf_r+0x72>
8000bd88:	40 18       	lddsp	r8,sp[0x4]
8000bd8a:	e2 18 f0 00 	andl	r8,0xf000,COH
8000bd8e:	e0 48 20 00 	cp.w	r8,8192
8000bd92:	5f 04       	sreq	r4
8000bd94:	e0 48 80 00 	cp.w	r8,32768
8000bd98:	c0 e1       	brne	8000bdb4 <__smakebuf_r+0x68>
8000bd9a:	6e b9       	ld.w	r9,r7[0x2c]
8000bd9c:	fe c8 f9 18 	sub	r8,pc,-1768
8000bda0:	10 39       	cp.w	r9,r8
8000bda2:	c0 91       	brne	8000bdb4 <__smakebuf_r+0x68>
8000bda4:	8e 68       	ld.sh	r8,r7[0xc]
8000bda6:	e0 65 04 00 	mov	r5,1024
8000bdaa:	ab a8       	sbr	r8,0xa
8000bdac:	ef 45 00 50 	st.w	r7[80],r5
8000bdb0:	ae 68       	st.h	r7[0xc],r8
8000bdb2:	c0 68       	rjmp	8000bdbe <__smakebuf_r+0x72>
8000bdb4:	8e 68       	ld.sh	r8,r7[0xc]
8000bdb6:	e0 65 04 00 	mov	r5,1024
8000bdba:	ab b8       	sbr	r8,0xb
8000bdbc:	ae 68       	st.h	r7[0xc],r8
8000bdbe:	0a 9b       	mov	r11,r5
8000bdc0:	0c 9c       	mov	r12,r6
8000bdc2:	fe b0 df 25 	rcall	80007c0c <_malloc_r>
8000bdc6:	8e 68       	ld.sh	r8,r7[0xc]
8000bdc8:	c0 d1       	brne	8000bde2 <__smakebuf_r+0x96>
8000bdca:	ed b8 00 09 	bld	r8,0x9
8000bdce:	c1 b0       	breq	8000be04 <__smakebuf_r+0xb8>
8000bdd0:	a1 b8       	sbr	r8,0x1
8000bdd2:	ae 68       	st.h	r7[0xc],r8
8000bdd4:	ee c8 ff b9 	sub	r8,r7,-71
8000bdd8:	8f 48       	st.w	r7[0x10],r8
8000bdda:	8f 08       	st.w	r7[0x0],r8
8000bddc:	30 18       	mov	r8,1
8000bdde:	8f 58       	st.w	r7[0x14],r8
8000bde0:	c1 28       	rjmp	8000be04 <__smakebuf_r+0xb8>
8000bde2:	a7 b8       	sbr	r8,0x7
8000bde4:	8f 4c       	st.w	r7[0x10],r12
8000bde6:	ae 68       	st.h	r7[0xc],r8
8000bde8:	8f 55       	st.w	r7[0x14],r5
8000bdea:	fe c8 06 e2 	sub	r8,pc,1762
8000bdee:	8f 0c       	st.w	r7[0x0],r12
8000bdf0:	8d a8       	st.w	r6[0x28],r8
8000bdf2:	58 04       	cp.w	r4,0
8000bdf4:	c0 80       	breq	8000be04 <__smakebuf_r+0xb8>
8000bdf6:	8e 7c       	ld.sh	r12,r7[0xe]
8000bdf8:	fe b0 e3 7e 	rcall	800084f4 <isatty>
8000bdfc:	c0 40       	breq	8000be04 <__smakebuf_r+0xb8>
8000bdfe:	8e 68       	ld.sh	r8,r7[0xc]
8000be00:	a1 a8       	sbr	r8,0x0
8000be02:	ae 68       	st.h	r7[0xc],r8
8000be04:	2f 1d       	sub	sp,-60
8000be06:	d8 22       	popm	r4-r7,pc

8000be08 <memchr>:
8000be08:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000be0c:	c0 68       	rjmp	8000be18 <memchr+0x10>
8000be0e:	20 1a       	sub	r10,1
8000be10:	19 88       	ld.ub	r8,r12[0x0]
8000be12:	16 38       	cp.w	r8,r11
8000be14:	5e 0c       	reteq	r12
8000be16:	2f fc       	sub	r12,-1
8000be18:	58 0a       	cp.w	r10,0
8000be1a:	cf a1       	brne	8000be0e <memchr+0x6>
8000be1c:	5e fa       	retal	r10

8000be1e <memmove>:
8000be1e:	d4 01       	pushm	lr
8000be20:	18 3b       	cp.w	r11,r12
8000be22:	c1 92       	brcc	8000be54 <memmove+0x36>
8000be24:	f6 0a 00 09 	add	r9,r11,r10
8000be28:	12 3c       	cp.w	r12,r9
8000be2a:	c1 52       	brcc	8000be54 <memmove+0x36>
8000be2c:	f8 0a 00 0b 	add	r11,r12,r10
8000be30:	30 08       	mov	r8,0
8000be32:	c0 68       	rjmp	8000be3e <memmove+0x20>
8000be34:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000be38:	20 1a       	sub	r10,1
8000be3a:	f6 08 0b 0e 	st.b	r11[r8],lr
8000be3e:	20 18       	sub	r8,1
8000be40:	58 0a       	cp.w	r10,0
8000be42:	cf 91       	brne	8000be34 <memmove+0x16>
8000be44:	d8 02       	popm	pc
8000be46:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000be4a:	20 1a       	sub	r10,1
8000be4c:	f8 08 0b 09 	st.b	r12[r8],r9
8000be50:	2f f8       	sub	r8,-1
8000be52:	c0 28       	rjmp	8000be56 <memmove+0x38>
8000be54:	30 08       	mov	r8,0
8000be56:	58 0a       	cp.w	r10,0
8000be58:	cf 71       	brne	8000be46 <memmove+0x28>
8000be5a:	d8 02       	popm	pc

8000be5c <__hi0bits>:
8000be5c:	18 98       	mov	r8,r12
8000be5e:	e0 1c 00 00 	andl	r12,0x0
8000be62:	f0 09 15 10 	lsl	r9,r8,0x10
8000be66:	58 0c       	cp.w	r12,0
8000be68:	f2 08 17 00 	moveq	r8,r9
8000be6c:	f9 bc 00 10 	moveq	r12,16
8000be70:	f9 bc 01 00 	movne	r12,0
8000be74:	10 9a       	mov	r10,r8
8000be76:	f0 09 15 08 	lsl	r9,r8,0x8
8000be7a:	e6 1a ff 00 	andh	r10,0xff00,COH
8000be7e:	f7 bc 00 f8 	subeq	r12,-8
8000be82:	f2 08 17 00 	moveq	r8,r9
8000be86:	10 9a       	mov	r10,r8
8000be88:	f0 09 15 04 	lsl	r9,r8,0x4
8000be8c:	e6 1a f0 00 	andh	r10,0xf000,COH
8000be90:	f7 bc 00 fc 	subeq	r12,-4
8000be94:	f2 08 17 00 	moveq	r8,r9
8000be98:	10 9a       	mov	r10,r8
8000be9a:	f0 09 15 02 	lsl	r9,r8,0x2
8000be9e:	e6 1a c0 00 	andh	r10,0xc000,COH
8000bea2:	f7 bc 00 fe 	subeq	r12,-2
8000bea6:	f2 08 17 00 	moveq	r8,r9
8000beaa:	58 08       	cp.w	r8,0
8000beac:	5e 5c       	retlt	r12
8000beae:	ed b8 00 1e 	bld	r8,0x1e
8000beb2:	f9 bc 01 20 	movne	r12,32
8000beb6:	f7 bc 00 ff 	subeq	r12,-1
8000beba:	5e fc       	retal	r12

8000bebc <__lo0bits>:
8000bebc:	18 99       	mov	r9,r12
8000bebe:	78 08       	ld.w	r8,r12[0x0]
8000bec0:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000bec4:	c1 50       	breq	8000beee <__lo0bits+0x32>
8000bec6:	ed b8 00 00 	bld	r8,0x0
8000beca:	c0 21       	brne	8000bece <__lo0bits+0x12>
8000becc:	5e fd       	retal	0
8000bece:	10 9b       	mov	r11,r8
8000bed0:	f0 0a 16 01 	lsr	r10,r8,0x1
8000bed4:	e2 1b 00 02 	andl	r11,0x2,COH
8000bed8:	a3 88       	lsr	r8,0x2
8000beda:	58 0b       	cp.w	r11,0
8000bedc:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000bee0:	f9 bc 01 01 	movne	r12,1
8000bee4:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000bee8:	f9 bc 00 02 	moveq	r12,2
8000beec:	5e fc       	retal	r12
8000beee:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000bef2:	f0 0b 16 10 	lsr	r11,r8,0x10
8000bef6:	58 0a       	cp.w	r10,0
8000bef8:	f6 08 17 00 	moveq	r8,r11
8000befc:	f9 bc 00 10 	moveq	r12,16
8000bf00:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000bf04:	f0 0a 16 08 	lsr	r10,r8,0x8
8000bf08:	58 0b       	cp.w	r11,0
8000bf0a:	f7 bc 00 f8 	subeq	r12,-8
8000bf0e:	f4 08 17 00 	moveq	r8,r10
8000bf12:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000bf16:	f0 0a 16 04 	lsr	r10,r8,0x4
8000bf1a:	58 0b       	cp.w	r11,0
8000bf1c:	f7 bc 00 fc 	subeq	r12,-4
8000bf20:	f4 08 17 00 	moveq	r8,r10
8000bf24:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000bf28:	f0 0a 16 02 	lsr	r10,r8,0x2
8000bf2c:	58 0b       	cp.w	r11,0
8000bf2e:	f7 bc 00 fe 	subeq	r12,-2
8000bf32:	f4 08 17 00 	moveq	r8,r10
8000bf36:	ed b8 00 00 	bld	r8,0x0
8000bf3a:	c0 60       	breq	8000bf46 <__lo0bits+0x8a>
8000bf3c:	a1 98       	lsr	r8,0x1
8000bf3e:	c0 31       	brne	8000bf44 <__lo0bits+0x88>
8000bf40:	32 0c       	mov	r12,32
8000bf42:	5e fc       	retal	r12
8000bf44:	2f fc       	sub	r12,-1
8000bf46:	93 08       	st.w	r9[0x0],r8
8000bf48:	5e fc       	retal	r12

8000bf4a <__mcmp>:
8000bf4a:	d4 01       	pushm	lr
8000bf4c:	18 98       	mov	r8,r12
8000bf4e:	76 49       	ld.w	r9,r11[0x10]
8000bf50:	78 4c       	ld.w	r12,r12[0x10]
8000bf52:	12 1c       	sub	r12,r9
8000bf54:	c1 31       	brne	8000bf7a <__mcmp+0x30>
8000bf56:	2f b9       	sub	r9,-5
8000bf58:	a3 69       	lsl	r9,0x2
8000bf5a:	12 0b       	add	r11,r9
8000bf5c:	f0 09 00 09 	add	r9,r8,r9
8000bf60:	2e c8       	sub	r8,-20
8000bf62:	13 4e       	ld.w	lr,--r9
8000bf64:	17 4a       	ld.w	r10,--r11
8000bf66:	14 3e       	cp.w	lr,r10
8000bf68:	c0 60       	breq	8000bf74 <__mcmp+0x2a>
8000bf6a:	f9 bc 03 ff 	movlo	r12,-1
8000bf6e:	f9 bc 02 01 	movhs	r12,1
8000bf72:	d8 02       	popm	pc
8000bf74:	10 39       	cp.w	r9,r8
8000bf76:	fe 9b ff f6 	brhi	8000bf62 <__mcmp+0x18>
8000bf7a:	d8 02       	popm	pc

8000bf7c <_Bfree>:
8000bf7c:	d4 21       	pushm	r4-r7,lr
8000bf7e:	18 97       	mov	r7,r12
8000bf80:	16 95       	mov	r5,r11
8000bf82:	78 96       	ld.w	r6,r12[0x24]
8000bf84:	58 06       	cp.w	r6,0
8000bf86:	c0 91       	brne	8000bf98 <_Bfree+0x1c>
8000bf88:	31 0c       	mov	r12,16
8000bf8a:	fe b0 de 39 	rcall	80007bfc <malloc>
8000bf8e:	99 36       	st.w	r12[0xc],r6
8000bf90:	8f 9c       	st.w	r7[0x24],r12
8000bf92:	99 16       	st.w	r12[0x4],r6
8000bf94:	99 26       	st.w	r12[0x8],r6
8000bf96:	99 06       	st.w	r12[0x0],r6
8000bf98:	58 05       	cp.w	r5,0
8000bf9a:	c0 90       	breq	8000bfac <_Bfree+0x30>
8000bf9c:	6a 19       	ld.w	r9,r5[0x4]
8000bf9e:	6e 98       	ld.w	r8,r7[0x24]
8000bfa0:	70 38       	ld.w	r8,r8[0xc]
8000bfa2:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000bfa6:	8b 0a       	st.w	r5[0x0],r10
8000bfa8:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000bfac:	d8 22       	popm	r4-r7,pc
8000bfae:	d7 03       	nop

8000bfb0 <_Balloc>:
8000bfb0:	d4 21       	pushm	r4-r7,lr
8000bfb2:	18 97       	mov	r7,r12
8000bfb4:	16 96       	mov	r6,r11
8000bfb6:	78 95       	ld.w	r5,r12[0x24]
8000bfb8:	58 05       	cp.w	r5,0
8000bfba:	c0 91       	brne	8000bfcc <_Balloc+0x1c>
8000bfbc:	31 0c       	mov	r12,16
8000bfbe:	fe b0 de 1f 	rcall	80007bfc <malloc>
8000bfc2:	99 35       	st.w	r12[0xc],r5
8000bfc4:	8f 9c       	st.w	r7[0x24],r12
8000bfc6:	99 15       	st.w	r12[0x4],r5
8000bfc8:	99 25       	st.w	r12[0x8],r5
8000bfca:	99 05       	st.w	r12[0x0],r5
8000bfcc:	6e 95       	ld.w	r5,r7[0x24]
8000bfce:	6a 38       	ld.w	r8,r5[0xc]
8000bfd0:	58 08       	cp.w	r8,0
8000bfd2:	c0 b1       	brne	8000bfe8 <_Balloc+0x38>
8000bfd4:	31 0a       	mov	r10,16
8000bfd6:	30 4b       	mov	r11,4
8000bfd8:	0e 9c       	mov	r12,r7
8000bfda:	e0 a0 02 a9 	rcall	8000c52c <_calloc_r>
8000bfde:	8b 3c       	st.w	r5[0xc],r12
8000bfe0:	6e 98       	ld.w	r8,r7[0x24]
8000bfe2:	70 3c       	ld.w	r12,r8[0xc]
8000bfe4:	58 0c       	cp.w	r12,0
8000bfe6:	c1 b0       	breq	8000c01c <_Balloc+0x6c>
8000bfe8:	6e 98       	ld.w	r8,r7[0x24]
8000bfea:	70 38       	ld.w	r8,r8[0xc]
8000bfec:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000bff0:	70 0c       	ld.w	r12,r8[0x0]
8000bff2:	58 0c       	cp.w	r12,0
8000bff4:	c0 40       	breq	8000bffc <_Balloc+0x4c>
8000bff6:	78 09       	ld.w	r9,r12[0x0]
8000bff8:	91 09       	st.w	r8[0x0],r9
8000bffa:	c0 e8       	rjmp	8000c016 <_Balloc+0x66>
8000bffc:	0e 9c       	mov	r12,r7
8000bffe:	30 17       	mov	r7,1
8000c000:	0e 9b       	mov	r11,r7
8000c002:	ee 06 09 47 	lsl	r7,r7,r6
8000c006:	ee ca ff fb 	sub	r10,r7,-5
8000c00a:	a3 6a       	lsl	r10,0x2
8000c00c:	e0 a0 02 90 	rcall	8000c52c <_calloc_r>
8000c010:	c0 60       	breq	8000c01c <_Balloc+0x6c>
8000c012:	99 16       	st.w	r12[0x4],r6
8000c014:	99 27       	st.w	r12[0x8],r7
8000c016:	30 08       	mov	r8,0
8000c018:	99 38       	st.w	r12[0xc],r8
8000c01a:	99 48       	st.w	r12[0x10],r8
8000c01c:	d8 22       	popm	r4-r7,pc
8000c01e:	d7 03       	nop

8000c020 <__d2b>:
8000c020:	d4 31       	pushm	r0-r7,lr
8000c022:	20 2d       	sub	sp,8
8000c024:	16 93       	mov	r3,r11
8000c026:	12 96       	mov	r6,r9
8000c028:	10 95       	mov	r5,r8
8000c02a:	14 92       	mov	r2,r10
8000c02c:	30 1b       	mov	r11,1
8000c02e:	cc 1f       	rcall	8000bfb0 <_Balloc>
8000c030:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000c034:	50 09       	stdsp	sp[0x0],r9
8000c036:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000c03a:	b5 a9       	sbr	r9,0x14
8000c03c:	f0 01 16 14 	lsr	r1,r8,0x14
8000c040:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000c044:	18 94       	mov	r4,r12
8000c046:	58 02       	cp.w	r2,0
8000c048:	c1 d0       	breq	8000c082 <__d2b+0x62>
8000c04a:	fa cc ff f8 	sub	r12,sp,-8
8000c04e:	18 d2       	st.w	--r12,r2
8000c050:	c3 6f       	rcall	8000bebc <__lo0bits>
8000c052:	40 18       	lddsp	r8,sp[0x4]
8000c054:	c0 d0       	breq	8000c06e <__d2b+0x4e>
8000c056:	40 09       	lddsp	r9,sp[0x0]
8000c058:	f8 0a 11 20 	rsub	r10,r12,32
8000c05c:	f2 0a 09 4a 	lsl	r10,r9,r10
8000c060:	f5 e8 10 08 	or	r8,r10,r8
8000c064:	89 58       	st.w	r4[0x14],r8
8000c066:	f2 0c 0a 49 	lsr	r9,r9,r12
8000c06a:	50 09       	stdsp	sp[0x0],r9
8000c06c:	c0 28       	rjmp	8000c070 <__d2b+0x50>
8000c06e:	89 58       	st.w	r4[0x14],r8
8000c070:	40 08       	lddsp	r8,sp[0x0]
8000c072:	58 08       	cp.w	r8,0
8000c074:	f9 b3 01 02 	movne	r3,2
8000c078:	f9 b3 00 01 	moveq	r3,1
8000c07c:	89 68       	st.w	r4[0x18],r8
8000c07e:	89 43       	st.w	r4[0x10],r3
8000c080:	c0 88       	rjmp	8000c090 <__d2b+0x70>
8000c082:	1a 9c       	mov	r12,sp
8000c084:	c1 cf       	rcall	8000bebc <__lo0bits>
8000c086:	30 13       	mov	r3,1
8000c088:	40 08       	lddsp	r8,sp[0x0]
8000c08a:	2e 0c       	sub	r12,-32
8000c08c:	89 43       	st.w	r4[0x10],r3
8000c08e:	89 58       	st.w	r4[0x14],r8
8000c090:	58 01       	cp.w	r1,0
8000c092:	c0 90       	breq	8000c0a4 <__d2b+0x84>
8000c094:	e2 c1 04 33 	sub	r1,r1,1075
8000c098:	18 01       	add	r1,r12
8000c09a:	8d 01       	st.w	r6[0x0],r1
8000c09c:	f8 0c 11 35 	rsub	r12,r12,53
8000c0a0:	8b 0c       	st.w	r5[0x0],r12
8000c0a2:	c0 c8       	rjmp	8000c0ba <__d2b+0x9a>
8000c0a4:	e6 c8 ff fc 	sub	r8,r3,-4
8000c0a8:	f8 cc 04 32 	sub	r12,r12,1074
8000c0ac:	a5 73       	lsl	r3,0x5
8000c0ae:	8d 0c       	st.w	r6[0x0],r12
8000c0b0:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000c0b4:	cd 4e       	rcall	8000be5c <__hi0bits>
8000c0b6:	18 13       	sub	r3,r12
8000c0b8:	8b 03       	st.w	r5[0x0],r3
8000c0ba:	08 9c       	mov	r12,r4
8000c0bc:	2f ed       	sub	sp,-8
8000c0be:	d8 32       	popm	r0-r7,pc

8000c0c0 <__mdiff>:
8000c0c0:	d4 31       	pushm	r0-r7,lr
8000c0c2:	74 48       	ld.w	r8,r10[0x10]
8000c0c4:	76 45       	ld.w	r5,r11[0x10]
8000c0c6:	16 97       	mov	r7,r11
8000c0c8:	14 96       	mov	r6,r10
8000c0ca:	10 15       	sub	r5,r8
8000c0cc:	c1 31       	brne	8000c0f2 <__mdiff+0x32>
8000c0ce:	2f b8       	sub	r8,-5
8000c0d0:	ee ce ff ec 	sub	lr,r7,-20
8000c0d4:	a3 68       	lsl	r8,0x2
8000c0d6:	f4 08 00 0b 	add	r11,r10,r8
8000c0da:	ee 08 00 08 	add	r8,r7,r8
8000c0de:	11 4a       	ld.w	r10,--r8
8000c0e0:	17 49       	ld.w	r9,--r11
8000c0e2:	12 3a       	cp.w	r10,r9
8000c0e4:	c0 30       	breq	8000c0ea <__mdiff+0x2a>
8000c0e6:	c0 e2       	brcc	8000c102 <__mdiff+0x42>
8000c0e8:	c0 78       	rjmp	8000c0f6 <__mdiff+0x36>
8000c0ea:	1c 38       	cp.w	r8,lr
8000c0ec:	fe 9b ff f9 	brhi	8000c0de <__mdiff+0x1e>
8000c0f0:	c4 98       	rjmp	8000c182 <__mdiff+0xc2>
8000c0f2:	58 05       	cp.w	r5,0
8000c0f4:	c0 64       	brge	8000c100 <__mdiff+0x40>
8000c0f6:	0e 98       	mov	r8,r7
8000c0f8:	30 15       	mov	r5,1
8000c0fa:	0c 97       	mov	r7,r6
8000c0fc:	10 96       	mov	r6,r8
8000c0fe:	c0 28       	rjmp	8000c102 <__mdiff+0x42>
8000c100:	30 05       	mov	r5,0
8000c102:	6e 1b       	ld.w	r11,r7[0x4]
8000c104:	c5 6f       	rcall	8000bfb0 <_Balloc>
8000c106:	6e 49       	ld.w	r9,r7[0x10]
8000c108:	6c 44       	ld.w	r4,r6[0x10]
8000c10a:	99 35       	st.w	r12[0xc],r5
8000c10c:	2f b4       	sub	r4,-5
8000c10e:	f2 c5 ff fb 	sub	r5,r9,-5
8000c112:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000c116:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000c11a:	2e c6       	sub	r6,-20
8000c11c:	2e c7       	sub	r7,-20
8000c11e:	f8 c8 ff ec 	sub	r8,r12,-20
8000c122:	30 0a       	mov	r10,0
8000c124:	0f 0e       	ld.w	lr,r7++
8000c126:	0d 0b       	ld.w	r11,r6++
8000c128:	fc 02 16 10 	lsr	r2,lr,0x10
8000c12c:	f6 03 16 10 	lsr	r3,r11,0x10
8000c130:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c134:	e4 03 01 03 	sub	r3,r2,r3
8000c138:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000c13c:	fc 0b 01 0b 	sub	r11,lr,r11
8000c140:	f6 0a 00 0a 	add	r10,r11,r10
8000c144:	b0 1a       	st.h	r8[0x2],r10
8000c146:	b1 4a       	asr	r10,0x10
8000c148:	e6 0a 00 0a 	add	r10,r3,r10
8000c14c:	b0 0a       	st.h	r8[0x0],r10
8000c14e:	2f c8       	sub	r8,-4
8000c150:	b1 4a       	asr	r10,0x10
8000c152:	08 36       	cp.w	r6,r4
8000c154:	ce 83       	brcs	8000c124 <__mdiff+0x64>
8000c156:	c0 d8       	rjmp	8000c170 <__mdiff+0xb0>
8000c158:	0f 0b       	ld.w	r11,r7++
8000c15a:	f6 0e 16 10 	lsr	lr,r11,0x10
8000c15e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000c162:	16 0a       	add	r10,r11
8000c164:	b0 1a       	st.h	r8[0x2],r10
8000c166:	b1 4a       	asr	r10,0x10
8000c168:	1c 0a       	add	r10,lr
8000c16a:	b0 0a       	st.h	r8[0x0],r10
8000c16c:	2f c8       	sub	r8,-4
8000c16e:	b1 4a       	asr	r10,0x10
8000c170:	0a 37       	cp.w	r7,r5
8000c172:	cf 33       	brcs	8000c158 <__mdiff+0x98>
8000c174:	c0 28       	rjmp	8000c178 <__mdiff+0xb8>
8000c176:	20 19       	sub	r9,1
8000c178:	11 4a       	ld.w	r10,--r8
8000c17a:	58 0a       	cp.w	r10,0
8000c17c:	cf d0       	breq	8000c176 <__mdiff+0xb6>
8000c17e:	99 49       	st.w	r12[0x10],r9
8000c180:	d8 32       	popm	r0-r7,pc
8000c182:	30 0b       	mov	r11,0
8000c184:	c1 6f       	rcall	8000bfb0 <_Balloc>
8000c186:	30 18       	mov	r8,1
8000c188:	99 48       	st.w	r12[0x10],r8
8000c18a:	30 08       	mov	r8,0
8000c18c:	99 58       	st.w	r12[0x14],r8
8000c18e:	d8 32       	popm	r0-r7,pc

8000c190 <__lshift>:
8000c190:	d4 31       	pushm	r0-r7,lr
8000c192:	16 97       	mov	r7,r11
8000c194:	76 46       	ld.w	r6,r11[0x10]
8000c196:	f4 02 14 05 	asr	r2,r10,0x5
8000c19a:	2f f6       	sub	r6,-1
8000c19c:	14 93       	mov	r3,r10
8000c19e:	18 94       	mov	r4,r12
8000c1a0:	04 06       	add	r6,r2
8000c1a2:	76 1b       	ld.w	r11,r11[0x4]
8000c1a4:	6e 28       	ld.w	r8,r7[0x8]
8000c1a6:	c0 38       	rjmp	8000c1ac <__lshift+0x1c>
8000c1a8:	2f fb       	sub	r11,-1
8000c1aa:	a1 78       	lsl	r8,0x1
8000c1ac:	10 36       	cp.w	r6,r8
8000c1ae:	fe 99 ff fd 	brgt	8000c1a8 <__lshift+0x18>
8000c1b2:	08 9c       	mov	r12,r4
8000c1b4:	cf ee       	rcall	8000bfb0 <_Balloc>
8000c1b6:	30 09       	mov	r9,0
8000c1b8:	18 95       	mov	r5,r12
8000c1ba:	f8 c8 ff ec 	sub	r8,r12,-20
8000c1be:	12 9a       	mov	r10,r9
8000c1c0:	c0 38       	rjmp	8000c1c6 <__lshift+0x36>
8000c1c2:	10 aa       	st.w	r8++,r10
8000c1c4:	2f f9       	sub	r9,-1
8000c1c6:	04 39       	cp.w	r9,r2
8000c1c8:	cf d5       	brlt	8000c1c2 <__lshift+0x32>
8000c1ca:	6e 4b       	ld.w	r11,r7[0x10]
8000c1cc:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000c1d0:	2f bb       	sub	r11,-5
8000c1d2:	ee c9 ff ec 	sub	r9,r7,-20
8000c1d6:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000c1da:	58 03       	cp.w	r3,0
8000c1dc:	c1 30       	breq	8000c202 <__lshift+0x72>
8000c1de:	e6 0c 11 20 	rsub	r12,r3,32
8000c1e2:	30 0a       	mov	r10,0
8000c1e4:	72 02       	ld.w	r2,r9[0x0]
8000c1e6:	e4 03 09 42 	lsl	r2,r2,r3
8000c1ea:	04 4a       	or	r10,r2
8000c1ec:	10 aa       	st.w	r8++,r10
8000c1ee:	13 0a       	ld.w	r10,r9++
8000c1f0:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c1f4:	16 39       	cp.w	r9,r11
8000c1f6:	cf 73       	brcs	8000c1e4 <__lshift+0x54>
8000c1f8:	91 0a       	st.w	r8[0x0],r10
8000c1fa:	58 0a       	cp.w	r10,0
8000c1fc:	c0 70       	breq	8000c20a <__lshift+0x7a>
8000c1fe:	2f f6       	sub	r6,-1
8000c200:	c0 58       	rjmp	8000c20a <__lshift+0x7a>
8000c202:	13 0a       	ld.w	r10,r9++
8000c204:	10 aa       	st.w	r8++,r10
8000c206:	16 39       	cp.w	r9,r11
8000c208:	cf d3       	brcs	8000c202 <__lshift+0x72>
8000c20a:	08 9c       	mov	r12,r4
8000c20c:	20 16       	sub	r6,1
8000c20e:	0e 9b       	mov	r11,r7
8000c210:	8b 46       	st.w	r5[0x10],r6
8000c212:	cb 5e       	rcall	8000bf7c <_Bfree>
8000c214:	0a 9c       	mov	r12,r5
8000c216:	d8 32       	popm	r0-r7,pc

8000c218 <__multiply>:
8000c218:	d4 31       	pushm	r0-r7,lr
8000c21a:	20 2d       	sub	sp,8
8000c21c:	76 49       	ld.w	r9,r11[0x10]
8000c21e:	74 48       	ld.w	r8,r10[0x10]
8000c220:	16 96       	mov	r6,r11
8000c222:	14 95       	mov	r5,r10
8000c224:	10 39       	cp.w	r9,r8
8000c226:	ec 08 17 50 	movlt	r8,r6
8000c22a:	ea 06 17 50 	movlt	r6,r5
8000c22e:	f0 05 17 50 	movlt	r5,r8
8000c232:	6c 28       	ld.w	r8,r6[0x8]
8000c234:	76 43       	ld.w	r3,r11[0x10]
8000c236:	74 42       	ld.w	r2,r10[0x10]
8000c238:	76 1b       	ld.w	r11,r11[0x4]
8000c23a:	e4 03 00 07 	add	r7,r2,r3
8000c23e:	10 37       	cp.w	r7,r8
8000c240:	f7 bb 09 ff 	subgt	r11,-1
8000c244:	cb 6e       	rcall	8000bfb0 <_Balloc>
8000c246:	ee c4 ff fb 	sub	r4,r7,-5
8000c24a:	f8 c9 ff ec 	sub	r9,r12,-20
8000c24e:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000c252:	30 0a       	mov	r10,0
8000c254:	12 98       	mov	r8,r9
8000c256:	c0 28       	rjmp	8000c25a <__multiply+0x42>
8000c258:	10 aa       	st.w	r8++,r10
8000c25a:	08 38       	cp.w	r8,r4
8000c25c:	cf e3       	brcs	8000c258 <__multiply+0x40>
8000c25e:	2f b3       	sub	r3,-5
8000c260:	2f b2       	sub	r2,-5
8000c262:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000c266:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000c26a:	ec cb ff ec 	sub	r11,r6,-20
8000c26e:	50 12       	stdsp	sp[0x4],r2
8000c270:	ea ca ff ec 	sub	r10,r5,-20
8000c274:	c4 48       	rjmp	8000c2fc <__multiply+0xe4>
8000c276:	94 95       	ld.uh	r5,r10[0x2]
8000c278:	58 05       	cp.w	r5,0
8000c27a:	c2 00       	breq	8000c2ba <__multiply+0xa2>
8000c27c:	12 98       	mov	r8,r9
8000c27e:	16 96       	mov	r6,r11
8000c280:	30 0e       	mov	lr,0
8000c282:	50 09       	stdsp	sp[0x0],r9
8000c284:	0d 02       	ld.w	r2,r6++
8000c286:	e4 00 16 10 	lsr	r0,r2,0x10
8000c28a:	70 01       	ld.w	r1,r8[0x0]
8000c28c:	70 09       	ld.w	r9,r8[0x0]
8000c28e:	b1 81       	lsr	r1,0x10
8000c290:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000c294:	e0 05 03 41 	mac	r1,r0,r5
8000c298:	ab 32       	mul	r2,r5
8000c29a:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000c29e:	00 02       	add	r2,r0
8000c2a0:	e4 0e 00 0e 	add	lr,r2,lr
8000c2a4:	b0 1e       	st.h	r8[0x2],lr
8000c2a6:	b1 8e       	lsr	lr,0x10
8000c2a8:	1c 01       	add	r1,lr
8000c2aa:	b0 01       	st.h	r8[0x0],r1
8000c2ac:	e2 0e 16 10 	lsr	lr,r1,0x10
8000c2b0:	2f c8       	sub	r8,-4
8000c2b2:	06 36       	cp.w	r6,r3
8000c2b4:	ce 83       	brcs	8000c284 <__multiply+0x6c>
8000c2b6:	40 09       	lddsp	r9,sp[0x0]
8000c2b8:	91 0e       	st.w	r8[0x0],lr
8000c2ba:	94 86       	ld.uh	r6,r10[0x0]
8000c2bc:	58 06       	cp.w	r6,0
8000c2be:	c1 d0       	breq	8000c2f8 <__multiply+0xe0>
8000c2c0:	72 02       	ld.w	r2,r9[0x0]
8000c2c2:	12 98       	mov	r8,r9
8000c2c4:	16 9e       	mov	lr,r11
8000c2c6:	30 05       	mov	r5,0
8000c2c8:	b0 12       	st.h	r8[0x2],r2
8000c2ca:	1d 01       	ld.w	r1,lr++
8000c2cc:	90 82       	ld.uh	r2,r8[0x0]
8000c2ce:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000c2d2:	ad 30       	mul	r0,r6
8000c2d4:	e0 02 00 02 	add	r2,r0,r2
8000c2d8:	e4 05 00 05 	add	r5,r2,r5
8000c2dc:	b0 05       	st.h	r8[0x0],r5
8000c2de:	b1 85       	lsr	r5,0x10
8000c2e0:	b1 81       	lsr	r1,0x10
8000c2e2:	2f c8       	sub	r8,-4
8000c2e4:	ad 31       	mul	r1,r6
8000c2e6:	90 92       	ld.uh	r2,r8[0x2]
8000c2e8:	e2 02 00 02 	add	r2,r1,r2
8000c2ec:	0a 02       	add	r2,r5
8000c2ee:	e4 05 16 10 	lsr	r5,r2,0x10
8000c2f2:	06 3e       	cp.w	lr,r3
8000c2f4:	ce a3       	brcs	8000c2c8 <__multiply+0xb0>
8000c2f6:	91 02       	st.w	r8[0x0],r2
8000c2f8:	2f ca       	sub	r10,-4
8000c2fa:	2f c9       	sub	r9,-4
8000c2fc:	40 18       	lddsp	r8,sp[0x4]
8000c2fe:	10 3a       	cp.w	r10,r8
8000c300:	cb b3       	brcs	8000c276 <__multiply+0x5e>
8000c302:	c0 28       	rjmp	8000c306 <__multiply+0xee>
8000c304:	20 17       	sub	r7,1
8000c306:	58 07       	cp.w	r7,0
8000c308:	e0 8a 00 05 	brle	8000c312 <__multiply+0xfa>
8000c30c:	09 48       	ld.w	r8,--r4
8000c30e:	58 08       	cp.w	r8,0
8000c310:	cf a0       	breq	8000c304 <__multiply+0xec>
8000c312:	99 47       	st.w	r12[0x10],r7
8000c314:	2f ed       	sub	sp,-8
8000c316:	d8 32       	popm	r0-r7,pc

8000c318 <__i2b>:
8000c318:	d4 21       	pushm	r4-r7,lr
8000c31a:	16 97       	mov	r7,r11
8000c31c:	30 1b       	mov	r11,1
8000c31e:	c4 9e       	rcall	8000bfb0 <_Balloc>
8000c320:	30 19       	mov	r9,1
8000c322:	99 57       	st.w	r12[0x14],r7
8000c324:	99 49       	st.w	r12[0x10],r9
8000c326:	d8 22       	popm	r4-r7,pc

8000c328 <__multadd>:
8000c328:	d4 31       	pushm	r0-r7,lr
8000c32a:	30 08       	mov	r8,0
8000c32c:	12 95       	mov	r5,r9
8000c32e:	16 97       	mov	r7,r11
8000c330:	18 96       	mov	r6,r12
8000c332:	76 44       	ld.w	r4,r11[0x10]
8000c334:	f6 c9 ff ec 	sub	r9,r11,-20
8000c338:	72 0b       	ld.w	r11,r9[0x0]
8000c33a:	f6 0c 16 10 	lsr	r12,r11,0x10
8000c33e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000c342:	f4 0c 02 4c 	mul	r12,r10,r12
8000c346:	f4 0b 03 45 	mac	r5,r10,r11
8000c34a:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000c34e:	b1 85       	lsr	r5,0x10
8000c350:	18 05       	add	r5,r12
8000c352:	ea 0c 15 10 	lsl	r12,r5,0x10
8000c356:	f8 0b 00 0b 	add	r11,r12,r11
8000c35a:	12 ab       	st.w	r9++,r11
8000c35c:	2f f8       	sub	r8,-1
8000c35e:	b1 85       	lsr	r5,0x10
8000c360:	08 38       	cp.w	r8,r4
8000c362:	ce b5       	brlt	8000c338 <__multadd+0x10>
8000c364:	58 05       	cp.w	r5,0
8000c366:	c1 c0       	breq	8000c39e <__multadd+0x76>
8000c368:	6e 28       	ld.w	r8,r7[0x8]
8000c36a:	10 34       	cp.w	r4,r8
8000c36c:	c1 35       	brlt	8000c392 <__multadd+0x6a>
8000c36e:	6e 1b       	ld.w	r11,r7[0x4]
8000c370:	0c 9c       	mov	r12,r6
8000c372:	2f fb       	sub	r11,-1
8000c374:	c1 ee       	rcall	8000bfb0 <_Balloc>
8000c376:	6e 4a       	ld.w	r10,r7[0x10]
8000c378:	ee cb ff f4 	sub	r11,r7,-12
8000c37c:	18 93       	mov	r3,r12
8000c37e:	2f ea       	sub	r10,-2
8000c380:	2f 4c       	sub	r12,-12
8000c382:	a3 6a       	lsl	r10,0x2
8000c384:	fe b0 de 5a 	rcall	80008038 <memcpy>
8000c388:	0e 9b       	mov	r11,r7
8000c38a:	0c 9c       	mov	r12,r6
8000c38c:	fe b0 fd f8 	rcall	8000bf7c <_Bfree>
8000c390:	06 97       	mov	r7,r3
8000c392:	e8 c8 ff ff 	sub	r8,r4,-1
8000c396:	2f b4       	sub	r4,-5
8000c398:	8f 48       	st.w	r7[0x10],r8
8000c39a:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000c39e:	0e 9c       	mov	r12,r7
8000c3a0:	d8 32       	popm	r0-r7,pc
8000c3a2:	d7 03       	nop

8000c3a4 <__pow5mult>:
8000c3a4:	d4 31       	pushm	r0-r7,lr
8000c3a6:	14 96       	mov	r6,r10
8000c3a8:	18 97       	mov	r7,r12
8000c3aa:	16 94       	mov	r4,r11
8000c3ac:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000c3b0:	c0 80       	breq	8000c3c0 <__pow5mult+0x1c>
8000c3b2:	20 18       	sub	r8,1
8000c3b4:	49 f9       	lddpc	r9,8000c430 <__pow5mult+0x8c>
8000c3b6:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000c3ba:	30 09       	mov	r9,0
8000c3bc:	cb 6f       	rcall	8000c328 <__multadd>
8000c3be:	18 94       	mov	r4,r12
8000c3c0:	a3 46       	asr	r6,0x2
8000c3c2:	c3 40       	breq	8000c42a <__pow5mult+0x86>
8000c3c4:	6e 95       	ld.w	r5,r7[0x24]
8000c3c6:	58 05       	cp.w	r5,0
8000c3c8:	c0 91       	brne	8000c3da <__pow5mult+0x36>
8000c3ca:	31 0c       	mov	r12,16
8000c3cc:	fe b0 dc 18 	rcall	80007bfc <malloc>
8000c3d0:	99 35       	st.w	r12[0xc],r5
8000c3d2:	8f 9c       	st.w	r7[0x24],r12
8000c3d4:	99 15       	st.w	r12[0x4],r5
8000c3d6:	99 25       	st.w	r12[0x8],r5
8000c3d8:	99 05       	st.w	r12[0x0],r5
8000c3da:	6e 93       	ld.w	r3,r7[0x24]
8000c3dc:	66 25       	ld.w	r5,r3[0x8]
8000c3de:	58 05       	cp.w	r5,0
8000c3e0:	c0 c1       	brne	8000c3f8 <__pow5mult+0x54>
8000c3e2:	e0 6b 02 71 	mov	r11,625
8000c3e6:	0e 9c       	mov	r12,r7
8000c3e8:	c9 8f       	rcall	8000c318 <__i2b>
8000c3ea:	87 2c       	st.w	r3[0x8],r12
8000c3ec:	30 08       	mov	r8,0
8000c3ee:	18 95       	mov	r5,r12
8000c3f0:	99 08       	st.w	r12[0x0],r8
8000c3f2:	c0 38       	rjmp	8000c3f8 <__pow5mult+0x54>
8000c3f4:	06 9c       	mov	r12,r3
8000c3f6:	18 95       	mov	r5,r12
8000c3f8:	ed b6 00 00 	bld	r6,0x0
8000c3fc:	c0 b1       	brne	8000c412 <__pow5mult+0x6e>
8000c3fe:	08 9b       	mov	r11,r4
8000c400:	0a 9a       	mov	r10,r5
8000c402:	0e 9c       	mov	r12,r7
8000c404:	c0 af       	rcall	8000c218 <__multiply>
8000c406:	08 9b       	mov	r11,r4
8000c408:	18 93       	mov	r3,r12
8000c40a:	0e 9c       	mov	r12,r7
8000c40c:	06 94       	mov	r4,r3
8000c40e:	fe b0 fd b7 	rcall	8000bf7c <_Bfree>
8000c412:	a1 56       	asr	r6,0x1
8000c414:	c0 b0       	breq	8000c42a <__pow5mult+0x86>
8000c416:	6a 03       	ld.w	r3,r5[0x0]
8000c418:	58 03       	cp.w	r3,0
8000c41a:	ce d1       	brne	8000c3f4 <__pow5mult+0x50>
8000c41c:	0a 9a       	mov	r10,r5
8000c41e:	0a 9b       	mov	r11,r5
8000c420:	0e 9c       	mov	r12,r7
8000c422:	cf be       	rcall	8000c218 <__multiply>
8000c424:	8b 0c       	st.w	r5[0x0],r12
8000c426:	99 03       	st.w	r12[0x0],r3
8000c428:	ce 7b       	rjmp	8000c3f6 <__pow5mult+0x52>
8000c42a:	08 9c       	mov	r12,r4
8000c42c:	d8 32       	popm	r0-r7,pc
8000c42e:	d7 03       	nop
8000c430:	80 02       	ld.sh	r2,r0[0x0]
8000c432:	f9 c8       	*unknown*

8000c434 <__isinfd>:
8000c434:	14 98       	mov	r8,r10
8000c436:	fc 19 7f f0 	movh	r9,0x7ff0
8000c43a:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000c43e:	f0 0b 11 00 	rsub	r11,r8,0
8000c442:	f7 e8 10 08 	or	r8,r11,r8
8000c446:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000c44a:	f2 08 01 08 	sub	r8,r9,r8
8000c44e:	f0 0c 11 00 	rsub	r12,r8,0
8000c452:	f9 e8 10 08 	or	r8,r12,r8
8000c456:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000c45a:	2f fc       	sub	r12,-1
8000c45c:	5e fc       	retal	r12

8000c45e <__isnand>:
8000c45e:	14 98       	mov	r8,r10
8000c460:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000c464:	f0 0c 11 00 	rsub	r12,r8,0
8000c468:	10 4c       	or	r12,r8
8000c46a:	fc 18 7f f0 	movh	r8,0x7ff0
8000c46e:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000c472:	f0 0c 01 0c 	sub	r12,r8,r12
8000c476:	bf 9c       	lsr	r12,0x1f
8000c478:	5e fc       	retal	r12
8000c47a:	d7 03       	nop

8000c47c <__sclose>:
8000c47c:	d4 01       	pushm	lr
8000c47e:	96 7b       	ld.sh	r11,r11[0xe]
8000c480:	c8 2c       	rcall	8000c584 <_close_r>
8000c482:	d8 02       	popm	pc

8000c484 <__sseek>:
8000c484:	d4 21       	pushm	r4-r7,lr
8000c486:	16 97       	mov	r7,r11
8000c488:	96 7b       	ld.sh	r11,r11[0xe]
8000c48a:	c0 5d       	rcall	8000c694 <_lseek_r>
8000c48c:	8e 68       	ld.sh	r8,r7[0xc]
8000c48e:	10 99       	mov	r9,r8
8000c490:	ad c8       	cbr	r8,0xc
8000c492:	ad a9       	sbr	r9,0xc
8000c494:	5b fc       	cp.w	r12,-1
8000c496:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000c49a:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000c49e:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000c4a2:	d8 22       	popm	r4-r7,pc

8000c4a4 <__swrite>:
8000c4a4:	d4 21       	pushm	r4-r7,lr
8000c4a6:	96 68       	ld.sh	r8,r11[0xc]
8000c4a8:	16 97       	mov	r7,r11
8000c4aa:	14 95       	mov	r5,r10
8000c4ac:	12 94       	mov	r4,r9
8000c4ae:	e2 18 01 00 	andl	r8,0x100,COH
8000c4b2:	18 96       	mov	r6,r12
8000c4b4:	c0 50       	breq	8000c4be <__swrite+0x1a>
8000c4b6:	30 29       	mov	r9,2
8000c4b8:	30 0a       	mov	r10,0
8000c4ba:	96 7b       	ld.sh	r11,r11[0xe]
8000c4bc:	ce cc       	rcall	8000c694 <_lseek_r>
8000c4be:	8e 68       	ld.sh	r8,r7[0xc]
8000c4c0:	ad c8       	cbr	r8,0xc
8000c4c2:	08 99       	mov	r9,r4
8000c4c4:	0a 9a       	mov	r10,r5
8000c4c6:	8e 7b       	ld.sh	r11,r7[0xe]
8000c4c8:	0c 9c       	mov	r12,r6
8000c4ca:	ae 68       	st.h	r7[0xc],r8
8000c4cc:	c1 cc       	rcall	8000c504 <_write_r>
8000c4ce:	d8 22       	popm	r4-r7,pc

8000c4d0 <__sread>:
8000c4d0:	d4 21       	pushm	r4-r7,lr
8000c4d2:	16 97       	mov	r7,r11
8000c4d4:	96 7b       	ld.sh	r11,r11[0xe]
8000c4d6:	cf 3c       	rcall	8000c6bc <_read_r>
8000c4d8:	c0 65       	brlt	8000c4e4 <__sread+0x14>
8000c4da:	6f 58       	ld.w	r8,r7[0x54]
8000c4dc:	18 08       	add	r8,r12
8000c4de:	ef 48 00 54 	st.w	r7[84],r8
8000c4e2:	d8 22       	popm	r4-r7,pc
8000c4e4:	8e 68       	ld.sh	r8,r7[0xc]
8000c4e6:	ad c8       	cbr	r8,0xc
8000c4e8:	ae 68       	st.h	r7[0xc],r8
8000c4ea:	d8 22       	popm	r4-r7,pc

8000c4ec <strlen>:
8000c4ec:	30 09       	mov	r9,0
8000c4ee:	18 98       	mov	r8,r12
8000c4f0:	c0 28       	rjmp	8000c4f4 <strlen+0x8>
8000c4f2:	2f f8       	sub	r8,-1
8000c4f4:	11 8a       	ld.ub	r10,r8[0x0]
8000c4f6:	f2 0a 18 00 	cp.b	r10,r9
8000c4fa:	cf c1       	brne	8000c4f2 <strlen+0x6>
8000c4fc:	f0 0c 01 0c 	sub	r12,r8,r12
8000c500:	5e fc       	retal	r12
8000c502:	d7 03       	nop

8000c504 <_write_r>:
8000c504:	d4 21       	pushm	r4-r7,lr
8000c506:	16 98       	mov	r8,r11
8000c508:	18 97       	mov	r7,r12
8000c50a:	10 9c       	mov	r12,r8
8000c50c:	30 08       	mov	r8,0
8000c50e:	14 9b       	mov	r11,r10
8000c510:	e0 66 10 5c 	mov	r6,4188
8000c514:	12 9a       	mov	r10,r9
8000c516:	8d 08       	st.w	r6[0x0],r8
8000c518:	fe b0 cd 1a 	rcall	80005f4c <_write>
8000c51c:	5b fc       	cp.w	r12,-1
8000c51e:	c0 51       	brne	8000c528 <_write_r+0x24>
8000c520:	6c 08       	ld.w	r8,r6[0x0]
8000c522:	58 08       	cp.w	r8,0
8000c524:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c528:	d8 22       	popm	r4-r7,pc
8000c52a:	d7 03       	nop

8000c52c <_calloc_r>:
8000c52c:	d4 21       	pushm	r4-r7,lr
8000c52e:	f4 0b 02 4b 	mul	r11,r10,r11
8000c532:	fe b0 db 6d 	rcall	80007c0c <_malloc_r>
8000c536:	18 97       	mov	r7,r12
8000c538:	c2 30       	breq	8000c57e <_calloc_r+0x52>
8000c53a:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000c53e:	e0 1a ff fc 	andl	r10,0xfffc
8000c542:	20 4a       	sub	r10,4
8000c544:	e0 4a 00 24 	cp.w	r10,36
8000c548:	e0 8b 00 18 	brhi	8000c578 <_calloc_r+0x4c>
8000c54c:	18 98       	mov	r8,r12
8000c54e:	59 3a       	cp.w	r10,19
8000c550:	e0 88 00 0f 	brls	8000c56e <_calloc_r+0x42>
8000c554:	30 09       	mov	r9,0
8000c556:	10 a9       	st.w	r8++,r9
8000c558:	10 a9       	st.w	r8++,r9
8000c55a:	59 ba       	cp.w	r10,27
8000c55c:	e0 88 00 09 	brls	8000c56e <_calloc_r+0x42>
8000c560:	10 a9       	st.w	r8++,r9
8000c562:	10 a9       	st.w	r8++,r9
8000c564:	e0 4a 00 24 	cp.w	r10,36
8000c568:	c0 31       	brne	8000c56e <_calloc_r+0x42>
8000c56a:	10 a9       	st.w	r8++,r9
8000c56c:	10 a9       	st.w	r8++,r9
8000c56e:	30 09       	mov	r9,0
8000c570:	10 a9       	st.w	r8++,r9
8000c572:	91 19       	st.w	r8[0x4],r9
8000c574:	91 09       	st.w	r8[0x0],r9
8000c576:	c0 48       	rjmp	8000c57e <_calloc_r+0x52>
8000c578:	30 0b       	mov	r11,0
8000c57a:	fe b0 de 03 	rcall	80008180 <memset>
8000c57e:	0e 9c       	mov	r12,r7
8000c580:	d8 22       	popm	r4-r7,pc
8000c582:	d7 03       	nop

8000c584 <_close_r>:
8000c584:	d4 21       	pushm	r4-r7,lr
8000c586:	30 08       	mov	r8,0
8000c588:	18 97       	mov	r7,r12
8000c58a:	e0 66 10 5c 	mov	r6,4188
8000c58e:	16 9c       	mov	r12,r11
8000c590:	8d 08       	st.w	r6[0x0],r8
8000c592:	fe b0 df 9d 	rcall	800084cc <_close>
8000c596:	5b fc       	cp.w	r12,-1
8000c598:	c0 51       	brne	8000c5a2 <_close_r+0x1e>
8000c59a:	6c 08       	ld.w	r8,r6[0x0]
8000c59c:	58 08       	cp.w	r8,0
8000c59e:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c5a2:	d8 22       	popm	r4-r7,pc

8000c5a4 <_fclose_r>:
8000c5a4:	d4 21       	pushm	r4-r7,lr
8000c5a6:	18 96       	mov	r6,r12
8000c5a8:	16 97       	mov	r7,r11
8000c5aa:	58 0b       	cp.w	r11,0
8000c5ac:	c0 31       	brne	8000c5b2 <_fclose_r+0xe>
8000c5ae:	16 95       	mov	r5,r11
8000c5b0:	c5 08       	rjmp	8000c650 <_fclose_r+0xac>
8000c5b2:	fe b0 f8 a9 	rcall	8000b704 <__sfp_lock_acquire>
8000c5b6:	58 06       	cp.w	r6,0
8000c5b8:	c0 70       	breq	8000c5c6 <_fclose_r+0x22>
8000c5ba:	6c 68       	ld.w	r8,r6[0x18]
8000c5bc:	58 08       	cp.w	r8,0
8000c5be:	c0 41       	brne	8000c5c6 <_fclose_r+0x22>
8000c5c0:	0c 9c       	mov	r12,r6
8000c5c2:	fe b0 f8 f5 	rcall	8000b7ac <__sinit>
8000c5c6:	4a 48       	lddpc	r8,8000c654 <_fclose_r+0xb0>
8000c5c8:	10 37       	cp.w	r7,r8
8000c5ca:	c0 31       	brne	8000c5d0 <_fclose_r+0x2c>
8000c5cc:	6c 07       	ld.w	r7,r6[0x0]
8000c5ce:	c0 a8       	rjmp	8000c5e2 <_fclose_r+0x3e>
8000c5d0:	4a 28       	lddpc	r8,8000c658 <_fclose_r+0xb4>
8000c5d2:	10 37       	cp.w	r7,r8
8000c5d4:	c0 31       	brne	8000c5da <_fclose_r+0x36>
8000c5d6:	6c 17       	ld.w	r7,r6[0x4]
8000c5d8:	c0 58       	rjmp	8000c5e2 <_fclose_r+0x3e>
8000c5da:	4a 18       	lddpc	r8,8000c65c <_fclose_r+0xb8>
8000c5dc:	10 37       	cp.w	r7,r8
8000c5de:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000c5e2:	8e 69       	ld.sh	r9,r7[0xc]
8000c5e4:	30 08       	mov	r8,0
8000c5e6:	f0 09 19 00 	cp.h	r9,r8
8000c5ea:	c0 51       	brne	8000c5f4 <_fclose_r+0x50>
8000c5ec:	fe b0 f8 8d 	rcall	8000b706 <__sfp_lock_release>
8000c5f0:	30 05       	mov	r5,0
8000c5f2:	c2 f8       	rjmp	8000c650 <_fclose_r+0xac>
8000c5f4:	0e 9b       	mov	r11,r7
8000c5f6:	0c 9c       	mov	r12,r6
8000c5f8:	fe b0 f7 fe 	rcall	8000b5f4 <_fflush_r>
8000c5fc:	6e c8       	ld.w	r8,r7[0x30]
8000c5fe:	18 95       	mov	r5,r12
8000c600:	58 08       	cp.w	r8,0
8000c602:	c0 60       	breq	8000c60e <_fclose_r+0x6a>
8000c604:	6e 8b       	ld.w	r11,r7[0x20]
8000c606:	0c 9c       	mov	r12,r6
8000c608:	5d 18       	icall	r8
8000c60a:	f9 b5 05 ff 	movlt	r5,-1
8000c60e:	8e 68       	ld.sh	r8,r7[0xc]
8000c610:	ed b8 00 07 	bld	r8,0x7
8000c614:	c0 51       	brne	8000c61e <_fclose_r+0x7a>
8000c616:	6e 4b       	ld.w	r11,r7[0x10]
8000c618:	0c 9c       	mov	r12,r6
8000c61a:	fe b0 f9 61 	rcall	8000b8dc <_free_r>
8000c61e:	6e db       	ld.w	r11,r7[0x34]
8000c620:	58 0b       	cp.w	r11,0
8000c622:	c0 a0       	breq	8000c636 <_fclose_r+0x92>
8000c624:	ee c8 ff bc 	sub	r8,r7,-68
8000c628:	10 3b       	cp.w	r11,r8
8000c62a:	c0 40       	breq	8000c632 <_fclose_r+0x8e>
8000c62c:	0c 9c       	mov	r12,r6
8000c62e:	fe b0 f9 57 	rcall	8000b8dc <_free_r>
8000c632:	30 08       	mov	r8,0
8000c634:	8f d8       	st.w	r7[0x34],r8
8000c636:	6f 2b       	ld.w	r11,r7[0x48]
8000c638:	58 0b       	cp.w	r11,0
8000c63a:	c0 70       	breq	8000c648 <_fclose_r+0xa4>
8000c63c:	0c 9c       	mov	r12,r6
8000c63e:	fe b0 f9 4f 	rcall	8000b8dc <_free_r>
8000c642:	30 08       	mov	r8,0
8000c644:	ef 48 00 48 	st.w	r7[72],r8
8000c648:	30 08       	mov	r8,0
8000c64a:	ae 68       	st.h	r7[0xc],r8
8000c64c:	fe b0 f8 5d 	rcall	8000b706 <__sfp_lock_release>
8000c650:	0a 9c       	mov	r12,r5
8000c652:	d8 22       	popm	r4-r7,pc
8000c654:	80 02       	ld.sh	r2,r0[0x0]
8000c656:	f9 20 80 02 	ld.sb	r0,r12[-32766]
8000c65a:	f9 40 80 02 	st.w	r12[-32766],r0
8000c65e:	f9 60 d4 01 	st.b	r12[-11263],r0

8000c660 <fclose>:
8000c660:	d4 01       	pushm	lr
8000c662:	e0 68 05 34 	mov	r8,1332
8000c666:	18 9b       	mov	r11,r12
8000c668:	70 0c       	ld.w	r12,r8[0x0]
8000c66a:	c9 df       	rcall	8000c5a4 <_fclose_r>
8000c66c:	d8 02       	popm	pc
8000c66e:	d7 03       	nop

8000c670 <_fstat_r>:
8000c670:	d4 21       	pushm	r4-r7,lr
8000c672:	16 98       	mov	r8,r11
8000c674:	18 97       	mov	r7,r12
8000c676:	10 9c       	mov	r12,r8
8000c678:	30 08       	mov	r8,0
8000c67a:	e0 66 10 5c 	mov	r6,4188
8000c67e:	14 9b       	mov	r11,r10
8000c680:	8d 08       	st.w	r6[0x0],r8
8000c682:	fe b0 df 4d 	rcall	8000851c <_fstat>
8000c686:	5b fc       	cp.w	r12,-1
8000c688:	c0 51       	brne	8000c692 <_fstat_r+0x22>
8000c68a:	6c 08       	ld.w	r8,r6[0x0]
8000c68c:	58 08       	cp.w	r8,0
8000c68e:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c692:	d8 22       	popm	r4-r7,pc

8000c694 <_lseek_r>:
8000c694:	d4 21       	pushm	r4-r7,lr
8000c696:	16 98       	mov	r8,r11
8000c698:	18 97       	mov	r7,r12
8000c69a:	10 9c       	mov	r12,r8
8000c69c:	30 08       	mov	r8,0
8000c69e:	14 9b       	mov	r11,r10
8000c6a0:	e0 66 10 5c 	mov	r6,4188
8000c6a4:	12 9a       	mov	r10,r9
8000c6a6:	8d 08       	st.w	r6[0x0],r8
8000c6a8:	fe b0 df 1c 	rcall	800084e0 <_lseek>
8000c6ac:	5b fc       	cp.w	r12,-1
8000c6ae:	c0 51       	brne	8000c6b8 <_lseek_r+0x24>
8000c6b0:	6c 08       	ld.w	r8,r6[0x0]
8000c6b2:	58 08       	cp.w	r8,0
8000c6b4:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c6b8:	d8 22       	popm	r4-r7,pc
8000c6ba:	d7 03       	nop

8000c6bc <_read_r>:
8000c6bc:	d4 21       	pushm	r4-r7,lr
8000c6be:	16 98       	mov	r8,r11
8000c6c0:	18 97       	mov	r7,r12
8000c6c2:	10 9c       	mov	r12,r8
8000c6c4:	30 08       	mov	r8,0
8000c6c6:	14 9b       	mov	r11,r10
8000c6c8:	e0 66 10 5c 	mov	r6,4188
8000c6cc:	12 9a       	mov	r10,r9
8000c6ce:	8d 08       	st.w	r6[0x0],r8
8000c6d0:	fe b0 cc 1e 	rcall	80005f0c <_read>
8000c6d4:	5b fc       	cp.w	r12,-1
8000c6d6:	c0 51       	brne	8000c6e0 <_read_r+0x24>
8000c6d8:	6c 08       	ld.w	r8,r6[0x0]
8000c6da:	58 08       	cp.w	r8,0
8000c6dc:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c6e0:	d8 22       	popm	r4-r7,pc
8000c6e2:	d7 03       	nop

8000c6e4 <__avr32_f64_to_u32>:
8000c6e4:	58 0b       	cp.w	r11,0
8000c6e6:	5e 6d       	retmi	0

8000c6e8 <__avr32_f64_to_s32>:
8000c6e8:	f6 0c 15 01 	lsl	r12,r11,0x1
8000c6ec:	b5 9c       	lsr	r12,0x15
8000c6ee:	e0 2c 03 ff 	sub	r12,1023
8000c6f2:	5e 3d       	retlo	0
8000c6f4:	f8 0c 11 1f 	rsub	r12,r12,31
8000c6f8:	16 99       	mov	r9,r11
8000c6fa:	ab 7b       	lsl	r11,0xb
8000c6fc:	bf bb       	sbr	r11,0x1f
8000c6fe:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c702:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c706:	a1 79       	lsl	r9,0x1
8000c708:	5e 2b       	reths	r11
8000c70a:	5c 3b       	neg	r11
8000c70c:	5e fb       	retal	r11

8000c70e <__avr32_f64_cmp_eq>:
8000c70e:	10 3a       	cp.w	r10,r8
8000c710:	f2 0b 13 00 	cpc	r11,r9
8000c714:	c0 80       	breq	8000c724 <__avr32_f64_cmp_eq+0x16>
8000c716:	a1 7b       	lsl	r11,0x1
8000c718:	a1 79       	lsl	r9,0x1
8000c71a:	14 4b       	or	r11,r10
8000c71c:	12 4b       	or	r11,r9
8000c71e:	10 4b       	or	r11,r8
8000c720:	5e 0f       	reteq	1
8000c722:	5e fd       	retal	0
8000c724:	a1 7b       	lsl	r11,0x1
8000c726:	fc 1c ff e0 	movh	r12,0xffe0
8000c72a:	58 0a       	cp.w	r10,0
8000c72c:	f8 0b 13 00 	cpc	r11,r12
8000c730:	5e 8f       	retls	1
8000c732:	5e fd       	retal	0

8000c734 <__avr32_f64_cmp_ge>:
8000c734:	1a de       	st.w	--sp,lr
8000c736:	1a d7       	st.w	--sp,r7
8000c738:	a1 7b       	lsl	r11,0x1
8000c73a:	5f 3c       	srlo	r12
8000c73c:	a1 79       	lsl	r9,0x1
8000c73e:	5f 37       	srlo	r7
8000c740:	5c fc       	rol	r12
8000c742:	fc 1e ff e0 	movh	lr,0xffe0
8000c746:	58 0a       	cp.w	r10,0
8000c748:	fc 0b 13 00 	cpc	r11,lr
8000c74c:	e0 8b 00 1d 	brhi	8000c786 <__avr32_f64_cmp_ge+0x52>
8000c750:	58 08       	cp.w	r8,0
8000c752:	fc 09 13 00 	cpc	r9,lr
8000c756:	e0 8b 00 18 	brhi	8000c786 <__avr32_f64_cmp_ge+0x52>
8000c75a:	58 0b       	cp.w	r11,0
8000c75c:	f5 ba 00 00 	subfeq	r10,0
8000c760:	c1 50       	breq	8000c78a <__avr32_f64_cmp_ge+0x56>
8000c762:	1b 07       	ld.w	r7,sp++
8000c764:	1b 0e       	ld.w	lr,sp++
8000c766:	58 3c       	cp.w	r12,3
8000c768:	c0 a0       	breq	8000c77c <__avr32_f64_cmp_ge+0x48>
8000c76a:	58 1c       	cp.w	r12,1
8000c76c:	c0 33       	brcs	8000c772 <__avr32_f64_cmp_ge+0x3e>
8000c76e:	5e 0f       	reteq	1
8000c770:	5e 1d       	retne	0
8000c772:	10 3a       	cp.w	r10,r8
8000c774:	f2 0b 13 00 	cpc	r11,r9
8000c778:	5e 2f       	reths	1
8000c77a:	5e 3d       	retlo	0
8000c77c:	14 38       	cp.w	r8,r10
8000c77e:	f6 09 13 00 	cpc	r9,r11
8000c782:	5e 2f       	reths	1
8000c784:	5e 3d       	retlo	0
8000c786:	1b 07       	ld.w	r7,sp++
8000c788:	d8 0a       	popm	pc,r12=0
8000c78a:	58 17       	cp.w	r7,1
8000c78c:	5f 0c       	sreq	r12
8000c78e:	58 09       	cp.w	r9,0
8000c790:	f5 b8 00 00 	subfeq	r8,0
8000c794:	1b 07       	ld.w	r7,sp++
8000c796:	1b 0e       	ld.w	lr,sp++
8000c798:	5e 0f       	reteq	1
8000c79a:	5e fc       	retal	r12

8000c79c <__avr32_umod64>:
8000c79c:	d4 31       	pushm	r0-r7,lr
8000c79e:	1a 97       	mov	r7,sp
8000c7a0:	20 3d       	sub	sp,12
8000c7a2:	10 9c       	mov	r12,r8
8000c7a4:	12 95       	mov	r5,r9
8000c7a6:	14 9e       	mov	lr,r10
8000c7a8:	16 91       	mov	r1,r11
8000c7aa:	16 96       	mov	r6,r11
8000c7ac:	58 09       	cp.w	r9,0
8000c7ae:	e0 81 00 81 	brne	8000c8b0 <__avr32_umod64+0x114>
8000c7b2:	16 38       	cp.w	r8,r11
8000c7b4:	e0 88 00 12 	brls	8000c7d8 <__avr32_umod64+0x3c>
8000c7b8:	f0 08 12 00 	clz	r8,r8
8000c7bc:	c4 e0       	breq	8000c858 <__avr32_umod64+0xbc>
8000c7be:	f6 08 09 46 	lsl	r6,r11,r8
8000c7c2:	f8 08 09 4c 	lsl	r12,r12,r8
8000c7c6:	f0 0b 11 20 	rsub	r11,r8,32
8000c7ca:	f4 08 09 4e 	lsl	lr,r10,r8
8000c7ce:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000c7d2:	f7 e6 10 06 	or	r6,r11,r6
8000c7d6:	c4 18       	rjmp	8000c858 <__avr32_umod64+0xbc>
8000c7d8:	58 08       	cp.w	r8,0
8000c7da:	c0 51       	brne	8000c7e4 <__avr32_umod64+0x48>
8000c7dc:	30 19       	mov	r9,1
8000c7de:	f2 08 0d 08 	divu	r8,r9,r8
8000c7e2:	10 9c       	mov	r12,r8
8000c7e4:	f8 08 12 00 	clz	r8,r12
8000c7e8:	c0 31       	brne	8000c7ee <__avr32_umod64+0x52>
8000c7ea:	18 16       	sub	r6,r12
8000c7ec:	c3 68       	rjmp	8000c858 <__avr32_umod64+0xbc>
8000c7ee:	f0 03 11 20 	rsub	r3,r8,32
8000c7f2:	f4 03 0a 4b 	lsr	r11,r10,r3
8000c7f6:	f8 08 09 4c 	lsl	r12,r12,r8
8000c7fa:	ec 08 09 49 	lsl	r9,r6,r8
8000c7fe:	ec 03 0a 43 	lsr	r3,r6,r3
8000c802:	f7 e9 10 09 	or	r9,r11,r9
8000c806:	f8 05 16 10 	lsr	r5,r12,0x10
8000c80a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c80e:	e6 05 0d 02 	divu	r2,r3,r5
8000c812:	f2 0e 16 10 	lsr	lr,r9,0x10
8000c816:	ec 02 02 4b 	mul	r11,r6,r2
8000c81a:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000c81e:	16 3e       	cp.w	lr,r11
8000c820:	c0 72       	brcc	8000c82e <__avr32_umod64+0x92>
8000c822:	18 0e       	add	lr,r12
8000c824:	18 3e       	cp.w	lr,r12
8000c826:	c0 43       	brcs	8000c82e <__avr32_umod64+0x92>
8000c828:	16 3e       	cp.w	lr,r11
8000c82a:	fd dc e3 0e 	addcs	lr,lr,r12
8000c82e:	fc 0b 01 03 	sub	r3,lr,r11
8000c832:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000c836:	e6 05 0d 02 	divu	r2,r3,r5
8000c83a:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c83e:	a5 36       	mul	r6,r2
8000c840:	0c 39       	cp.w	r9,r6
8000c842:	c0 72       	brcc	8000c850 <__avr32_umod64+0xb4>
8000c844:	18 09       	add	r9,r12
8000c846:	18 39       	cp.w	r9,r12
8000c848:	c0 43       	brcs	8000c850 <__avr32_umod64+0xb4>
8000c84a:	0c 39       	cp.w	r9,r6
8000c84c:	f3 dc e3 09 	addcs	r9,r9,r12
8000c850:	f2 06 01 06 	sub	r6,r9,r6
8000c854:	f4 08 09 4e 	lsl	lr,r10,r8
8000c858:	f8 0a 16 10 	lsr	r10,r12,0x10
8000c85c:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c860:	ec 0a 0d 02 	divu	r2,r6,r10
8000c864:	fc 09 16 10 	lsr	r9,lr,0x10
8000c868:	ea 02 02 4b 	mul	r11,r5,r2
8000c86c:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c870:	16 39       	cp.w	r9,r11
8000c872:	c0 72       	brcc	8000c880 <__avr32_umod64+0xe4>
8000c874:	18 09       	add	r9,r12
8000c876:	18 39       	cp.w	r9,r12
8000c878:	c0 43       	brcs	8000c880 <__avr32_umod64+0xe4>
8000c87a:	16 39       	cp.w	r9,r11
8000c87c:	f3 dc e3 09 	addcs	r9,r9,r12
8000c880:	f2 0b 01 0b 	sub	r11,r9,r11
8000c884:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c888:	f6 0a 0d 0a 	divu	r10,r11,r10
8000c88c:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000c890:	ea 0a 02 4a 	mul	r10,r5,r10
8000c894:	14 3e       	cp.w	lr,r10
8000c896:	c0 72       	brcc	8000c8a4 <__avr32_umod64+0x108>
8000c898:	18 0e       	add	lr,r12
8000c89a:	18 3e       	cp.w	lr,r12
8000c89c:	c0 43       	brcs	8000c8a4 <__avr32_umod64+0x108>
8000c89e:	14 3e       	cp.w	lr,r10
8000c8a0:	fd dc e3 0e 	addcs	lr,lr,r12
8000c8a4:	fc 0a 01 0a 	sub	r10,lr,r10
8000c8a8:	30 0b       	mov	r11,0
8000c8aa:	f4 08 0a 4a 	lsr	r10,r10,r8
8000c8ae:	c7 b8       	rjmp	8000c9a4 <__avr32_umod64+0x208>
8000c8b0:	16 39       	cp.w	r9,r11
8000c8b2:	e0 8b 00 79 	brhi	8000c9a4 <__avr32_umod64+0x208>
8000c8b6:	f2 09 12 00 	clz	r9,r9
8000c8ba:	c1 21       	brne	8000c8de <__avr32_umod64+0x142>
8000c8bc:	10 3a       	cp.w	r10,r8
8000c8be:	5f 2b       	srhs	r11
8000c8c0:	0a 31       	cp.w	r1,r5
8000c8c2:	5f ba       	srhi	r10
8000c8c4:	f7 ea 10 0a 	or	r10,r11,r10
8000c8c8:	f2 0a 18 00 	cp.b	r10,r9
8000c8cc:	c0 60       	breq	8000c8d8 <__avr32_umod64+0x13c>
8000c8ce:	fc 08 01 0c 	sub	r12,lr,r8
8000c8d2:	e2 05 01 46 	sbc	r6,r1,r5
8000c8d6:	18 9e       	mov	lr,r12
8000c8d8:	0c 9b       	mov	r11,r6
8000c8da:	1c 9a       	mov	r10,lr
8000c8dc:	c6 48       	rjmp	8000c9a4 <__avr32_umod64+0x208>
8000c8de:	ea 09 09 4c 	lsl	r12,r5,r9
8000c8e2:	f2 06 11 20 	rsub	r6,r9,32
8000c8e6:	f6 09 09 4b 	lsl	r11,r11,r9
8000c8ea:	f0 09 09 42 	lsl	r2,r8,r9
8000c8ee:	ef 46 ff f4 	st.w	r7[-12],r6
8000c8f2:	f0 06 0a 48 	lsr	r8,r8,r6
8000c8f6:	18 48       	or	r8,r12
8000c8f8:	e2 06 0a 4c 	lsr	r12,r1,r6
8000c8fc:	f4 09 09 43 	lsl	r3,r10,r9
8000c900:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000c904:	f4 06 0a 4a 	lsr	r10,r10,r6
8000c908:	16 4a       	or	r10,r11
8000c90a:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c90e:	f8 0b 0d 04 	divu	r4,r12,r11
8000c912:	f4 0c 16 10 	lsr	r12,r10,0x10
8000c916:	08 91       	mov	r1,r4
8000c918:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000c91c:	e8 0e 02 46 	mul	r6,r4,lr
8000c920:	0c 3c       	cp.w	r12,r6
8000c922:	c0 a2       	brcc	8000c936 <__avr32_umod64+0x19a>
8000c924:	20 11       	sub	r1,1
8000c926:	10 0c       	add	r12,r8
8000c928:	10 3c       	cp.w	r12,r8
8000c92a:	c0 63       	brcs	8000c936 <__avr32_umod64+0x19a>
8000c92c:	0c 3c       	cp.w	r12,r6
8000c92e:	f7 b1 03 01 	sublo	r1,1
8000c932:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000c936:	0c 1c       	sub	r12,r6
8000c938:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000c93c:	f8 0b 0d 04 	divu	r4,r12,r11
8000c940:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000c944:	08 96       	mov	r6,r4
8000c946:	e8 0e 02 4e 	mul	lr,r4,lr
8000c94a:	1c 3b       	cp.w	r11,lr
8000c94c:	c0 a2       	brcc	8000c960 <__avr32_umod64+0x1c4>
8000c94e:	20 16       	sub	r6,1
8000c950:	10 0b       	add	r11,r8
8000c952:	10 3b       	cp.w	r11,r8
8000c954:	c0 63       	brcs	8000c960 <__avr32_umod64+0x1c4>
8000c956:	1c 3b       	cp.w	r11,lr
8000c958:	f7 b6 03 01 	sublo	r6,1
8000c95c:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000c960:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000c964:	1c 1b       	sub	r11,lr
8000c966:	e2 02 06 40 	mulu.d	r0,r1,r2
8000c96a:	00 9e       	mov	lr,r0
8000c96c:	02 9c       	mov	r12,r1
8000c96e:	16 3c       	cp.w	r12,r11
8000c970:	e0 8b 00 08 	brhi	8000c980 <__avr32_umod64+0x1e4>
8000c974:	5f 06       	sreq	r6
8000c976:	06 30       	cp.w	r0,r3
8000c978:	5f ba       	srhi	r10
8000c97a:	ed ea 00 0a 	and	r10,r6,r10
8000c97e:	c0 60       	breq	8000c98a <__avr32_umod64+0x1ee>
8000c980:	fc 02 01 04 	sub	r4,lr,r2
8000c984:	f8 08 01 4c 	sbc	r12,r12,r8
8000c988:	08 9e       	mov	lr,r4
8000c98a:	e6 0e 01 0a 	sub	r10,r3,lr
8000c98e:	f6 0c 01 4c 	sbc	r12,r11,r12
8000c992:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000c996:	f8 09 0a 4b 	lsr	r11,r12,r9
8000c99a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c99e:	f8 01 09 4c 	lsl	r12,r12,r1
8000c9a2:	18 4a       	or	r10,r12
8000c9a4:	2f dd       	sub	sp,-12
8000c9a6:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000ca00 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
8000ca00:	c0 08       	rjmp	8000ca00 <_evba>
	...

8000ca04 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
8000ca04:	c0 08       	rjmp	8000ca04 <_handle_TLB_Multiple_Hit>
	...

8000ca08 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
8000ca08:	c0 08       	rjmp	8000ca08 <_handle_Bus_Error_Data_Fetch>
	...

8000ca0c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
8000ca0c:	c0 08       	rjmp	8000ca0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000ca10 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
8000ca10:	c0 08       	rjmp	8000ca10 <_handle_NMI>
	...

8000ca14 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
8000ca14:	c0 08       	rjmp	8000ca14 <_handle_Instruction_Address>
	...

8000ca18 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
8000ca18:	c0 08       	rjmp	8000ca18 <_handle_ITLB_Protection>
	...

8000ca1c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
8000ca1c:	c0 08       	rjmp	8000ca1c <_handle_Breakpoint>
	...

8000ca20 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
8000ca20:	c0 08       	rjmp	8000ca20 <_handle_Illegal_Opcode>
	...

8000ca24 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
8000ca24:	c0 08       	rjmp	8000ca24 <_handle_Unimplemented_Instruction>
	...

8000ca28 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
8000ca28:	c0 08       	rjmp	8000ca28 <_handle_Privilege_Violation>
	...

8000ca2c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR UC3.
_handle_Floating_Point:
	rjmp $
8000ca2c:	c0 08       	rjmp	8000ca2c <_handle_Floating_Point>
	...

8000ca30 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR UC3.
_handle_Coprocessor_Absent:
	rjmp $
8000ca30:	c0 08       	rjmp	8000ca30 <_handle_Coprocessor_Absent>
	...

8000ca34 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
8000ca34:	c0 08       	rjmp	8000ca34 <_handle_Data_Address_Read>
	...

8000ca38 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
8000ca38:	c0 08       	rjmp	8000ca38 <_handle_Data_Address_Write>
	...

8000ca3c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
8000ca3c:	c0 08       	rjmp	8000ca3c <_handle_DTLB_Protection_Read>
	...

8000ca40 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
8000ca40:	c0 08       	rjmp	8000ca40 <_handle_DTLB_Protection_Write>
	...

8000ca44 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
8000ca44:	c0 08       	rjmp	8000ca44 <_handle_DTLB_Modified>
	...

8000ca50 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
8000ca50:	c0 08       	rjmp	8000ca50 <_handle_ITLB_Miss>
	...

8000ca60 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
8000ca60:	c0 08       	rjmp	8000ca60 <_handle_DTLB_Miss_Read>
	...

8000ca70 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
8000ca70:	c0 08       	rjmp	8000ca70 <_handle_DTLB_Miss_Write>
	...

8000cb00 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000cb00:	fe cf 6d 54 	sub	pc,pc,27988

8000cb04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000cb04:	30 0c       	mov	r12,0
8000cb06:	fe b0 bb 73 	rcall	800041ec <_get_interrupt_handler>
8000cb0a:	58 0c       	cp.w	r12,0
8000cb0c:	f8 0f 17 10 	movne	pc,r12
8000cb10:	d6 03       	rete

8000cb12 <_int1>:
8000cb12:	30 1c       	mov	r12,1
8000cb14:	fe b0 bb 6c 	rcall	800041ec <_get_interrupt_handler>
8000cb18:	58 0c       	cp.w	r12,0
8000cb1a:	f8 0f 17 10 	movne	pc,r12
8000cb1e:	d6 03       	rete

8000cb20 <_int2>:
8000cb20:	30 2c       	mov	r12,2
8000cb22:	fe b0 bb 65 	rcall	800041ec <_get_interrupt_handler>
8000cb26:	58 0c       	cp.w	r12,0
8000cb28:	f8 0f 17 10 	movne	pc,r12
8000cb2c:	d6 03       	rete

8000cb2e <_int3>:
8000cb2e:	30 3c       	mov	r12,3
8000cb30:	fe b0 bb 5e 	rcall	800041ec <_get_interrupt_handler>
8000cb34:	58 0c       	cp.w	r12,0
8000cb36:	f8 0f 17 10 	movne	pc,r12
8000cb3a:	d6 03       	rete
8000cb3c:	d7 03       	nop
8000cb3e:	d7 03       	nop
8000cb40:	d7 03       	nop
8000cb42:	d7 03       	nop
8000cb44:	d7 03       	nop
8000cb46:	d7 03       	nop
8000cb48:	d7 03       	nop
8000cb4a:	d7 03       	nop
8000cb4c:	d7 03       	nop
8000cb4e:	d7 03       	nop
8000cb50:	d7 03       	nop
8000cb52:	d7 03       	nop
8000cb54:	d7 03       	nop
8000cb56:	d7 03       	nop
8000cb58:	d7 03       	nop
8000cb5a:	d7 03       	nop
8000cb5c:	d7 03       	nop
8000cb5e:	d7 03       	nop
8000cb60:	d7 03       	nop
8000cb62:	d7 03       	nop
8000cb64:	d7 03       	nop
8000cb66:	d7 03       	nop
8000cb68:	d7 03       	nop
8000cb6a:	d7 03       	nop
8000cb6c:	d7 03       	nop
8000cb6e:	d7 03       	nop
8000cb70:	d7 03       	nop
8000cb72:	d7 03       	nop
8000cb74:	d7 03       	nop
8000cb76:	d7 03       	nop
8000cb78:	d7 03       	nop
8000cb7a:	d7 03       	nop
8000cb7c:	d7 03       	nop
8000cb7e:	d7 03       	nop
8000cb80:	d7 03       	nop
8000cb82:	d7 03       	nop
8000cb84:	d7 03       	nop
8000cb86:	d7 03       	nop
8000cb88:	d7 03       	nop
8000cb8a:	d7 03       	nop
8000cb8c:	d7 03       	nop
8000cb8e:	d7 03       	nop
8000cb90:	d7 03       	nop
8000cb92:	d7 03       	nop
8000cb94:	d7 03       	nop
8000cb96:	d7 03       	nop
8000cb98:	d7 03       	nop
8000cb9a:	d7 03       	nop
8000cb9c:	d7 03       	nop
8000cb9e:	d7 03       	nop
8000cba0:	d7 03       	nop
8000cba2:	d7 03       	nop
8000cba4:	d7 03       	nop
8000cba6:	d7 03       	nop
8000cba8:	d7 03       	nop
8000cbaa:	d7 03       	nop
8000cbac:	d7 03       	nop
8000cbae:	d7 03       	nop
8000cbb0:	d7 03       	nop
8000cbb2:	d7 03       	nop
8000cbb4:	d7 03       	nop
8000cbb6:	d7 03       	nop
8000cbb8:	d7 03       	nop
8000cbba:	d7 03       	nop
8000cbbc:	d7 03       	nop
8000cbbe:	d7 03       	nop
8000cbc0:	d7 03       	nop
8000cbc2:	d7 03       	nop
8000cbc4:	d7 03       	nop
8000cbc6:	d7 03       	nop
8000cbc8:	d7 03       	nop
8000cbca:	d7 03       	nop
8000cbcc:	d7 03       	nop
8000cbce:	d7 03       	nop
8000cbd0:	d7 03       	nop
8000cbd2:	d7 03       	nop
8000cbd4:	d7 03       	nop
8000cbd6:	d7 03       	nop
8000cbd8:	d7 03       	nop
8000cbda:	d7 03       	nop
8000cbdc:	d7 03       	nop
8000cbde:	d7 03       	nop
8000cbe0:	d7 03       	nop
8000cbe2:	d7 03       	nop
8000cbe4:	d7 03       	nop
8000cbe6:	d7 03       	nop
8000cbe8:	d7 03       	nop
8000cbea:	d7 03       	nop
8000cbec:	d7 03       	nop
8000cbee:	d7 03       	nop
8000cbf0:	d7 03       	nop
8000cbf2:	d7 03       	nop
8000cbf4:	d7 03       	nop
8000cbf6:	d7 03       	nop
8000cbf8:	d7 03       	nop
8000cbfa:	d7 03       	nop
8000cbfc:	d7 03       	nop
8000cbfe:	d7 03       	nop
